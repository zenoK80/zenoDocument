---
title: "캐시 히트, 미스 및 성능 분석"
description: "캐시 히트율, 미스율의 개념과 계산 방법, 평균 메모리 접근 시간 산출을 상세히 학습합니다."
slug: "cache-hit-miss-performance"
sidebar_position: 2
---

# 캐시 히트, 미스 및 성능 분석

## 캐시 히트 (Cache Hit)

### 개념

**캐시 히트**는 CPU가 요청한 데이터가 **캐시에 이미 존재하는 경우**를 말합니다.

```
CPU: "주소 0x1000의 데이터 주세요!"
     ↓
캐시: "네, 여기 있습니다!" ✅
     ↓ (즉시)
CPU: "감사합니다!" (빠르게 작업 진행)
```

### 히트의 장점

```javascript
// 캐시 히트 시나리오
시간: 0ns   - CPU 요청
      1ns   - 캐시 검색
      2ns   - 데이터 발견!
      3ns   - CPU로 전달
      4ns   - 완료

총 소요 시간: 4~5ns
```

**왜 빠를까요?**

1. **물리적 거리**: CPU 내부에 있어 신호 이동 거리가 짧음
2. **SRAM 속도**: 고속 메모리 기술 사용
3. **버스 불필요**: 외부 버스를 거치지 않음

### 히트 발생 조건

캐시 히트가 발생하려면:

```javascript
// 조건 1: 데이터가 이미 캐시에 로드되어 있어야 함
cache.contains(address) === true

// 조건 2: 캐시 라인이 유효해야 함 (Valid bit = 1)
cache.isValid(address) === true

// 조건 3: 태그가 일치해야 함
cache.getTag(address) === requestedTag
```

**예시:**

```c
// C 프로그램
int array[100];

// 첫 번째 접근
int x = array[0];  // 캐시 미스 (처음 접근)
                   // 블록 단위로 array[0]~array[7] 로드

// 두 번째 접근
int y = array[1];  // 캐시 히트! (이미 로드됨)

// 세 번째 접근
int z = array[2];  // 캐시 히트! (같은 블록)
```

## 캐시 미스 (Cache Miss)

### 개념

**캐시 미스**는 CPU가 요청한 데이터가 **캐시에 없는 경우**를 말합니다.

```
CPU: "주소 0x5000의 데이터 주세요!"
     ↓
캐시: "여기에 없네요... 메모리에서 가져올게요" ❌
     ↓ (메모리 접근)
메모리: "여기 있습니다" (블록 전달)
     ↓ (캐시 저장)
캐시: "이제 있습니다!"
     ↓
CPU: "감사합니다" (늦게 작업 시작)
```

### 미스의 단점

```javascript
// 캐시 미스 시나리오
시간: 0ns   - CPU 요청
      1ns   - 캐시 검색
      2ns   - 데이터 없음 발견
      3ns   - 메인 메모리 접근 시작
      ...   - 대기... (긴 시간)
      53ns  - 메모리에서 블록 도착
      54ns  - 캐시에 저장
      55ns  - CPU로 전달
      56ns  - 완료

총 소요 시간: 50~100ns (히트보다 10~20배 느림!)
```

### 미스의 종류

캐시 미스는 원인에 따라 세 가지로 분류됩니다:

#### 1. Cold Miss (강제 미스, Compulsory Miss)

**원인**: 프로그램 시작 시 또는 처음 접근하는 데이터

```javascript
// 프로그램 시작
int main() {
    int x = array[0];  // Cold Miss!
    // 캐시가 비어있으므로 무조건 미스
}
```

**특징:**
- 피할 수 없는 미스
- 캐시 크기와 무관
- 모든 프로그램에서 발생

**발생 횟수 줄이는 방법:**
```c
// 방법 1: 데이터 재사용
for (int i = 0; i < 1000; i++) {
    sum += array[0];  // array[0]은 첫 번째만 Cold Miss
}

// 방법 2: Prefetching
// 미리 데이터를 로드하는 기법 (고급 기술)
```

#### 2. Capacity Miss (용량 미스)

**원인**: 캐시 용량이 부족하여 필요한 모든 데이터를 담을 수 없음

```javascript
// 캐시 크기: 64KB
// 작업 데이터: 128KB

// 전반부 접근
for (int i = 0; i < 16384; i++) {
    sum += data1[i];  // 64KB 사용
}

// 후반부 접근
for (int i = 0; i < 16384; i++) {
    sum += data2[i];  // 또 64KB 필요
    // data1이 밀려나감 (Capacity Miss)
}

// data1 다시 접근
for (int i = 0; i < 16384; i++) {
    sum += data1[i];  // 다시 미스! (Capacity Miss)
}
```

**특징:**
- 캐시 크기에 의존
- 큰 데이터셋 처리 시 발생
- 캐시를 늘리면 감소

**발생 횟수 줄이는 방법:**
```c
// 방법 1: 타일링 (Tiling) - 데이터를 작은 조각으로 나눔
for (int tile = 0; tile < N; tile += TILE_SIZE) {
    // 작은 타일 단위로 처리
    for (int i = tile; i < tile + TILE_SIZE; i++) {
        // 캐시에 들어갈 만큼만 처리
    }
}

// 방법 2: 데이터 압축
// 더 적은 메모리 사용
```

#### 3. Conflict Miss (충돌 미스)

**원인**: 캐시 매핑 방식으로 인해 같은 캐시 라인을 여러 주소가 공유할 때 발생

```javascript
// Direct Mapped Cache 예시
// 캐시 라인: 4개

주소 0x0000 → 캐시 라인 0
주소 0x0100 → 캐시 라인 0 (충돌!)
주소 0x0200 → 캐시 라인 0 (충돌!)

// 접근 순서: 0x0000, 0x0100, 0x0000
access(0x0000);  // 미스, 라인 0에 저장
access(0x0100);  // 미스, 라인 0에 저장 (0x0000 제거)
access(0x0000);  // 미스! (Conflict Miss)
                 // 공간은 있지만 같은 라인 사용
```

**특징:**
- 매핑 방식에 의존
- Set Associative 방식으로 완화 가능
- 캐시 크기와 무관

**발생 횟수 줄이는 방법:**
```c
// 방법 1: 데이터 배치 조정
// 충돌하는 주소들을 다른 위치로

// 방법 2: 더 높은 Associativity 사용
// Direct Mapped → 2-way → 4-way
```

### 미스 종류 비교

| 미스 종류 | 원인 | 해결 방법 |
|----------|------|----------|
| **Cold Miss** | 처음 접근 | 피할 수 없음, Prefetching |
| **Capacity Miss** | 캐시 용량 부족 | 캐시 크기 증가, 타일링 |
| **Conflict Miss** | 매핑 충돌 | Associativity 증가 |

## 히트율 (Hit Rate)

### 정의

**히트율**은 전체 메모리 접근 중에서 **캐시 히트가 발생한 비율**입니다.

```
히트율 (h) = 캐시 히트 횟수 / 전체 메모리 접근 횟수
```

### 계산 예시

```javascript
// 프로그램 실행 통계
전체 메모리 접근: 1000회
캐시 히트: 850회
캐시 미스: 150회

// 히트율 계산
히트율 = 850 / 1000 = 0.85 = 85%
```

### 히트율의 중요성

**히트율과 성능의 관계:**

```javascript
// 캐시 시간: 5ns
// 메모리 시간: 50ns

히트율 100%:
평균 시간 = 5ns × 1.0 = 5ns

히트율 90%:
평균 시간 = 5ns × 0.9 + 50ns × 0.1 = 9.5ns

히트율 50%:
평균 시간 = 5ns × 0.5 + 50ns × 0.5 = 27.5ns

히트율 0% (캐시 없음):
평균 시간 = 50ns × 1.0 = 50ns
```

**그래프로 보는 히트율과 성능:**

```
평균 접근 시간 (ns)
  ↑
50┤                         ●
  │                       ╱
40┤                     ╱
  │                   ╱
30┤                 ╱
  │               ╱
20┤             ╱
  │           ╱
10┤         ╱
  │    ╱╱╱
 5┤●───────────────────────
  └────────────────────────→ 히트율
  0%   25%   50%   75%  100%

히트율이 높을수록 성능 급상승!
```

### 실제 시스템의 히트율

**전형적인 히트율:**

```
L1 캐시: 95~99%
L2 캐시: 80~95%
L3 캐시: 70~90%

// 계층적으로 갈수록 히트율 감소
// 하지만 여전히 높은 수치 유지
```

**히트율에 영향을 주는 요소:**

1. **프로그램 특성**
   ```c
   // 높은 히트율
   for (int i = 0; i < 1000; i++) {
       sum += array[i];  // 순차 접근
   }
   
   // 낮은 히트율
   for (int i = 0; i < 1000; i++) {
       sum += array[rand()];  // 랜덤 접근
   }
   ```

2. **캐시 크기**
   ```
   작은 캐시 → 낮은 히트율
   큰 캐시   → 높은 히트율
   ```

3. **데이터 접근 패턴**
   ```
   순차 접근   → 높은 히트율
   랜덤 접근   → 낮은 히트율
   반복 접근   → 높은 히트율
   ```

## 미스율 (Miss Rate)

### 정의

**미스율**은 히트율의 여집합으로, **캐시 미스가 발생한 비율**입니다.

```
미스율 = 1 - 히트율
미스율 = 캐시 미스 횟수 / 전체 메모리 접근 횟수
```

### 계산 예시

```javascript
// 히트율이 85%인 경우
미스율 = 1 - 0.85 = 0.15 = 15%

// 또는 직접 계산
미스율 = 150 / 1000 = 0.15 = 15%
```

### 미스율의 영향

```javascript
// 미스율 1% 증가의 영향

원래:
히트율 90%, 미스율 10%
평균 시간 = 5 × 0.9 + 50 × 0.1 = 9.5ns

미스율 1% 증가 후:
히트율 89%, 미스율 11%
평균 시간 = 5 × 0.89 + 50 × 0.11 = 9.95ns

// 약 5% 성능 저하!
// 미스는 비용이 크므로 작은 증가도 큰 영향
```

## 평균 메모리 접근 시간 (Average Memory Access Time)

### 기본 공식

평균 메모리 접근 시간은 **히트와 미스를 모두 고려한 평균 시간**입니다.

```
Ta = Tc × h + Tm × (1 - h)

여기서:
Ta = 평균 메모리 접근 시간 (Average Access Time)
Tc = 캐시 접근 시간 (Cache Access Time)
Tm = 메인 메모리 접근 시간 (Memory Access Time)
h  = 히트율 (Hit Rate)
```

**공식의 의미:**

```javascript
평균 시간 = (히트 시 시간 × 히트 확률) + (미스 시 시간 × 미스 확률)

// 예시:
// 100번 접근 중 90번 히트, 10번 미스
평균 = (5ns × 90번 + 50ns × 10번) / 100
     = (450ns + 500ns) / 100
     = 950ns / 100
     = 9.5ns
```

### 간소화된 공식

캐시 접근 시간이 메모리 접근 시간보다 **매우 짧으므로** 종종 무시합니다:

```
Ta ≈ Tc + Tm × (1 - h)

또는

Ta ≈ Tm × (1 - h)  (Tc를 완전히 무시)
```

**왜 무시할 수 있나요?**

```javascript
// 예시
Tc = 5ns
Tm = 50ns
h = 0.9

정확한 계산:
Ta = 5 × 0.9 + 50 × 0.1
   = 4.5 + 5
   = 9.5ns

간소화 (Tc 무시):
Ta ≈ 50 × 0.1 = 5ns

// 오차: 9.5ns - 5ns = 4.5ns
// 하지만 Tm >> Tc 이므로 근사치로 사용 가능
```

### 계산 예제

#### 예제 1: 기본 계산

**조건:**
```
캐시 접근 시간: 5ns
메모리 접근 시간: 50ns
히트율: 90%
```

**풀이:**

```javascript
// 방법 1: 완전한 공식
Ta = Tc × h + Tm × (1 - h)
   = 5 × 0.9 + 50 × 0.1
   = 4.5 + 5
   = 9.5ns

// 방법 2: 미스율 사용
Ta = Tc × h + Tm × 미스율
   = 5 × 0.9 + 50 × 0.1
   = 9.5ns

// 해석: 평균적으로 9.5ns에 데이터 접근
```

#### 예제 2: 성능 비교

**캐시 없는 시스템 vs 캐시 있는 시스템**

```javascript
// 캐시 없는 시스템
Ta = Tm = 50ns

// 캐시 있는 시스템 (히트율 90%)
Ta = 5 × 0.9 + 50 × 0.1 = 9.5ns

// 성능 향상
향상율 = 50ns / 9.5ns ≈ 5.26배 빠름!
```

#### 예제 3: 히트율의 영향

**같은 시스템, 다른 히트율**

```javascript
// 조건: Tc=5ns, Tm=50ns

히트율 99%:
Ta = 5 × 0.99 + 50 × 0.01 = 5.45ns

히트율 95%:
Ta = 5 × 0.95 + 50 × 0.05 = 7.25ns

히트율 90%:
Ta = 5 × 0.90 + 50 × 0.10 = 9.5ns

히트율 80%:
Ta = 5 × 0.80 + 50 × 0.20 = 14ns

히트율 50%:
Ta = 5 × 0.50 + 50 × 0.50 = 27.5ns

// 히트율이 조금만 떨어져도 성능 큰 영향!
```

**표로 정리:**

| 히트율 | 평균 시간 | 캐시 없을 때 대비 |
|--------|----------|-----------------|
| 99% | 5.45ns | 9.2배 빠름 |
| 95% | 7.25ns | 6.9배 빠름 |
| 90% | 9.5ns | 5.3배 빠름 |
| 80% | 14ns | 3.6배 빠름 |
| 50% | 27.5ns | 1.8배 빠름 |

#### 예제 4: 실제 시스템 분석

**조건:**
```
L1 캐시 시간: 2ns, 히트율: 95%
메모리 시간: 100ns
```

**풀이:**

```javascript
// 1단계: 평균 시간 계산
Ta = 2 × 0.95 + 100 × 0.05
   = 1.9 + 5
   = 6.9ns

// 2단계: 1초에 몇 번 접근 가능?
접근 횟수 = 1초 / 6.9ns
          = 1,000,000,000ns / 6.9ns
          ≈ 145,000,000번
          ≈ 1억 4천 5백만 번!

// 3단계: 캐시 없었다면?
접근 횟수 = 1,000,000,000ns / 100ns
          = 10,000,000번
          = 천만 번

// 캐시 덕분에 14.5배 더 많은 접근!
```

### 평균 시간과 히트율 관계 그래프

```
평균 시간 (ns)
  ↑
100┤●
   │ ╲
 80┤  ╲
   │   ╲
 60┤    ╲
   │     ╲
 40┤      ╲
   │       ╲___
 20┤           ╲___
   │               ╲___
  5┤                   ●─────●
  0└─────────────────────────────→ 히트율
   0%  20%  40%  60%  80%  100%

관찰:
- 히트율 80% 이하: 급격한 성능 저하
- 히트율 90% 이상: 안정적인 성능
- 히트율 95% 이상: 최적 성능
```

## 성능 최적화 전략

### 1. 히트율 향상 방법

```c
// 방법 1: 순차 접근 패턴 사용
// ❌ 나쁜 예
for (int i = 0; i < N; i++) {
    sum += matrix[rand() % N][rand() % N];  // 랜덤 접근
}

// ✅ 좋은 예
for (int i = 0; i < N; i++) {
    for (int j = 0; j < N; j++) {
        sum += matrix[i][j];  // 순차 접근
    }
}
```

```c
// 방법 2: 데이터 재사용
// ❌ 나쁜 예
for (int i = 0; i < N; i++) {
    compute(data[i]);
}
for (int i = 0; i < N; i++) {
    process(data[i]);  // 다시 로드 필요
}

// ✅ 좋은 예
for (int i = 0; i < N; i++) {
    compute(data[i]);
    process(data[i]);  // 캐시에 있을 때 바로 사용
}
```

```c
// 방법 3: 작은 작업 단위 (타일링)
// ❌ 나쁜 예
for (int i = 0; i < 10000; i++) {
    for (int j = 0; j < 10000; j++) {
        C[i][j] += A[i][j] * B[i][j];
        // 배열이 너무 커서 캐시에 안 들어감
    }
}

// ✅ 좋은 예
const int TILE = 64;  // 캐시에 들어갈 크기
for (int ii = 0; ii < 10000; ii += TILE) {
    for (int jj = 0; jj < 10000; jj += TILE) {
        for (int i = ii; i < ii + TILE; i++) {
            for (int j = jj; j < jj + TILE; j++) {
                C[i][j] += A[i][j] * B[i][j];
                // 타일 단위로 캐시에 들어감
            }
        }
    }
}
```

### 2. 미스 페널티 감소 방법

```c
// 방법 1: Prefetching (미리 가져오기)
for (int i = 0; i < N; i++) {
    __builtin_prefetch(&data[i + 10]);  // 미리 로드
    process(data[i]);
}
```

```c
// 방법 2: 데이터 압축
// 더 많은 데이터를 캐시에 저장
struct Packed {
    int x : 10;  // 10비트만 사용
    int y : 10;
    int z : 10;
} __attribute__((packed));
```

## 실전 예제: 프로그램 성능 분석

### 예제 프로그램

```c
#include <stdio.h>

#define SIZE 1000

int main() {
    int array[SIZE];
    int sum = 0;
    
    // 배열 초기화
    for (int i = 0; i < SIZE; i++) {
        array[i] = i;
    }
    
    // 합계 계산
    for (int i = 0; i < SIZE; i++) {
        sum += array[i];
    }
    
    printf("Sum: %d\n", sum);
    return 0;
}
```

### 성능 분석

**가정:**
- 캐시 라인 크기: 64바이트 (16개 int)
- 캐시 접근 시간: 5ns
- 메모리 접근 시간: 50ns

**분석:**

```javascript
// 1. 초기화 루프
for (int i = 0; i < 1000; i++) {
    array[i] = i;
}

총 접근: 1000번
캐시 미스: 1000 / 16 = 63번 (블록 단위 로드)
캐시 히트: 1000 - 63 = 937번

시간 = 63 × 50ns + 937 × 5ns
     = 3,150ns + 4,685ns
     = 7,835ns

// 2. 합계 루프
for (int i = 0; i < 1000; i++) {
    sum += array[i];
}

// array는 이미 캐시에 있음!
총 접근: 1000번
캐시 미스: 0번 (모두 히트)
캐시 히트: 1000번

시간 = 1000 × 5ns = 5,000ns

// 전체 시간
총 시간 = 7,835ns + 5,000ns = 12,835ns

// 캐시 없었다면?
시간 = 2000 × 50ns = 100,000ns

// 성능 향상: 100,000 / 12,835 ≈ 7.8배!
```

## 정리

### 핵심 개념

1. **캐시 히트**
   - 데이터가 캐시에 있음
   - 빠른 접근 (수 나노초)
   - 히트율이 높을수록 성능 향상

2. **캐시 미스**
   - 데이터가 캐시에 없음
   - 느린 접근 (수십 나노초)
   - 세 종류: Cold, Capacity, Conflict

3. **성능 지표**
   ```
   히트율 = 히트 횟수 / 전체 접근
   미스율 = 1 - 히트율
   평균 시간 = Tc × h + Tm × (1-h)
   ```

4. **최적화**
   - 순차 접근 패턴
   - 데이터 재사용
   - 작은 작업 단위 (타일링)

### 다음 단계

다음 문서에서는 **참조의 지역성**을 배웁니다:
- 공간적 지역성
- 시간적 지역성
- 캐시 효율을 높이는 핵심 원리

:::tip 성능 향상의 핵심
히트율 10% 향상 = 전체 성능 2배 향상 가능!
프로그램을 작성할 때 캐시 친화적인 패턴을 사용하세요.
:::