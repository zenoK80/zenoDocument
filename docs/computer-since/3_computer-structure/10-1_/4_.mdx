---
title: "참조의 지역성 (Locality of Reference)"
description: "캐시가 효과적으로 동작하는 핵심 원리인 공간적 지역성과 시간적 지역성을 실전 예제와 함께 상세히 학습합니다."
slug: "locality-of-reference"
sidebar_position: 3
---

# 참조의 지역성 (Locality of Reference)

## 참조의 지역성이란?

**참조의 지역성(Locality of Reference)**은 프로그램이 메모리에 접근할 때 나타나는 **특정 패턴**을 말합니다.

프로그램은 무작위로 메모리를 접근하는 것이 아니라, **특정 영역을 집중적으로**, **반복적으로** 접근하는 경향이 있습니다.

```
메모리 전체: [━━━━━━━━━━━━━━━━━━━━━━━]
              ↑
실제 접근:    [●●●●] ← 이 부분만 집중 접근!
```

이 원리 덕분에 **작은 캐시로도 큰 효과**를 볼 수 있습니다.

## 지역성의 두 가지 유형

참조의 지역성은 크게 **두 가지**로 나뉩니다:

1. **공간적 지역성 (Spatial Locality)**
2. **시간적 지역성 (Temporal Locality)**

```
┌────────────────────┐
│  참조의 지역성      │
├──────────┬─────────┤
│ 공간적   │ 시간적  │
│ (Space)  │ (Time) │
└──────────┴─────────┘
```

## 공간적 지역성 (Spatial Locality)

### 개념

**공간적 지역성**은 "방금 접근한 메모리 주소의 **근처**를 곧 접근할 가능성이 높다"는 원리입니다.

```
메모리 주소:  [1000] [1004] [1008] [1012] [1016] ...
접근 순서:      ①      ②      ③      ④      ⑤
              ↑ 이쪽 접근하면 → → → 이쪽도 곧 접근
```

### 일상 생활 비유

#### 비유 1: 편의점 선택

```
🏠 우리 집
   ↓ 100m
🏪 A 편의점 (가까움)
   ↓ 500m
🏪 B 편의점 (멀음)

Q: 어느 편의점에 갈 확률이 높을까요?
A: 당연히 A 편의점! (공간적으로 가까움)
```

#### 비유 2: 책장에서 책 찾기

```
📚 [소설] [소설] [소설] [시집] [시집] [에세이] [에세이]
          ↑ 여기서 책을 꺼냈다면
            옆의 책들도 관심 있을 가능성 높음
```

### 프로그래밍에서의 공간적 지역성

#### 예제 1: 배열 순회

```c
int array[100];
int sum = 0;

// 순차적으로 접근
for (int i = 0; i < 100; i++) {
    sum += array[i];  // array[0], array[1], array[2], ...
}
```

**메모리 접근 패턴:**

```
메모리 레이아웃:
주소: [1000][1004][1008][1012][1016][1020]...
값:   arr[0] arr[1] arr[2] arr[3] arr[4] arr[5]...

접근 순서:
1차: 1000 (arr[0]) → 미스, 블록 로드 [1000~1031]
2차: 1004 (arr[1]) → 히트! (같은 블록에 있음)
3차: 1008 (arr[2]) → 히트!
4차: 1012 (arr[3]) → 히트!
...
```

**성능 분석:**

```javascript
// 캐시 블록 크기: 32바이트 (8개 int)
// 배열 크기: 100개 int

캐시 미스: 100 / 8 = 13번 (블록 단위로만 미스)
캐시 히트: 100 - 13 = 87번

히트율 = 87 / 100 = 87%

// 공간적 지역성 덕분에 높은 히트율!
```

#### 예제 2: 행렬 연산

**좋은 예 (행 우선 접근):**

```c
#define N 100
int matrix[N][N];
int sum = 0;

// ✅ 행 우선 순회 (Row-major order)
for (int i = 0; i < N; i++) {
    for (int j = 0; j < N; j++) {
        sum += matrix[i][j];  // 연속된 메모리 접근
    }
}
```

**메모리 레이아웃 (C 언어는 Row-major):**

```
메모리:
[0,0][0,1][0,2]...[0,99]  ← 1행 (연속)
[1,0][1,1][1,2]...[1,99]  ← 2행 (연속)
...

접근 순서:
[0,0] → [0,1] → [0,2] → ... → [0,99] → [1,0] → ...
  ↑연속적 접근 → 공간적 지역성 활용!
```

**나쁜 예 (열 우선 접근):**

```c
// ❌ 열 우선 순회 (Column-major order)
for (int j = 0; j < N; j++) {
    for (int i = 0; i < N; i++) {
        sum += matrix[i][j];  // 건너뛰며 접근
    }
}
```

**메모리 접근 패턴:**

```
메모리:
[0,0][0,1][0,2]...[1,0][1,1]...

접근 순서:
[0,0] → [1,0] → [2,0] → ...
  ↓ N×4바이트 떨어짐 (100×4 = 400바이트)
  ↓ 블록 크기(64바이트)를 넘어감
  ↓ 매번 새 블록 로드 필요

캐시 미스 급증! 🚨
```

**성능 비교:**

```javascript
// 행 우선 (좋음)
캐시 미스: (N × N) / (블록크기/4) 
         = 10,000 / 16 
         = 625번

// 열 우선 (나쁨)
캐시 미스: N × N 
         = 10,000번
         
// 약 16배 차이! 😱
```

#### 예제 3: 구조체 배열

```c
// 구조체 정의
struct Point {
    int x;
    int y;
    int z;
};

struct Point points[100];

// ✅ 좋은 접근
for (int i = 0; i < 100; i++) {
    int sum = points[i].x + points[i].y + points[i].z;
    // x, y, z가 메모리상 인접 → 한 번에 로드
}
```

**메모리 레이아웃:**

```
메모리:
[x0][y0][z0][x1][y1][z1][x2][y2][z2]...
 ↑   ↑   ↑
 같은 블록에 함께 로드됨!
```

#### 예제 4: 문자열 처리

```c
char str[1000] = "Hello, World!...";

// ✅ 순차적 접근
for (int i = 0; str[i] != '\0'; i++) {
    printf("%c", str[i]);
    // 문자들이 연속으로 배치 → 공간적 지역성
}
```

### 공간적 지역성 활용 팁

```c
// Tip 1: 데이터를 연속으로 배치
// ❌ 나쁨: 포인터 배열
int* ptrs[100];
for (int i = 0; i < 100; i++) {
    ptrs[i] = malloc(sizeof(int));  // 흩어진 메모리
}

// ✅ 좋음: 연속 배열
int array[100];  // 연속된 메모리
```

```c
// Tip 2: 구조체 멤버 순서 최적화
// ❌ 나쁨
struct Bad {
    char a;      // 1바이트
    int b;       // 4바이트 (패딩으로 3바이트 낭비)
    char c;      // 1바이트
    int d;       // 4바이트 (패딩으로 3바이트 낭비)
};  // 총 16바이트

// ✅ 좋음
struct Good {
    int b;       // 4바이트
    int d;       // 4바이트
    char a;      // 1바이트
    char c;      // 1바이트
};  // 총 12바이트 (25% 절약!)
```

## 시간적 지역성 (Temporal Locality)

### 개념

**시간적 지역성**은 "방금 접근한 데이터를 **가까운 미래에** 다시 접근할 가능성이 높다"는 원리입니다.

```
시간 →
[데이터A 접근] ... [데이터A 다시 접근] ... [데이터A 또 접근]
      ↑                  ↑                      ↑
      같은 데이터를 반복적으로 사용!
```

### 일상 생활 비유

#### 비유 1: 자주 쓰는 물건

```
🖊️ 자주 쓰는 펜
   → 책상 위에 둠 (가까운 곳)
   
📐 가끔 쓰는 자
   → 서랍 안에 둠
   
🔨 거의 안 쓰는 망치
   → 창고에 보관
```

#### 비유 2: 최근 연락한 사람

```
📱 스마트폰 "최근 연락처"
   → 자주 연락하는 사람이 계속 상위에 표시
   → 다시 연락할 확률 높음
```

### 프로그래밍에서의 시간적 지역성

#### 예제 1: 루프 변수

```c
int sum = 0;

for (int i = 0; i < 1000; i++) {
    sum += i;  // sum을 1000번 반복 사용
}
```

**메모리 접근 분석:**

```javascript
// sum 변수 접근 패턴
시간: 0ms   - sum 초기화 (메모리 로드)
      1ms   - sum 읽기 (캐시 히트)
      2ms   - sum 쓰기 (캐시 히트)
      3ms   - sum 읽기 (캐시 히트)
      ...
      999ms - sum 쓰기 (캐시 히트)

// 첫 접근만 미스, 나머지 999번 모두 히트!
히트율 = 999 / 1000 = 99.9%
```

#### 예제 2: 루프 카운터

```c
for (int i = 0; i < 100; i++) {
    for (int j = 0; j < 100; j++) {
        matrix[i][j] = i + j;
    }
}
```

**변수 접근 분석:**

```javascript
// i 변수
외부 루프 100번 반복
→ i 접근 횟수: 100번
→ 첫 1번만 미스, 나머지 히트

// j 변수
내부 루프 100번 × 외부 루프 100번
→ j 접근 횟수: 10,000번
→ 각 외부 루프마다 첫 1번씩만 미스
→ 미스: 100번, 히트: 9,900번
→ 히트율: 99%
```

#### 예제 3: 반복 계산

```c
double result = 0.0;
double coefficient = 3.14159;  // 상수

for (int i = 0; i < 1000; i++) {
    result += data[i] * coefficient;
    // coefficient를 1000번 반복 사용
}
```

**성능 분석:**

```javascript
// coefficient 접근
1차: 메모리에서 로드 (미스)
2~1000차: 캐시에서 읽기 (히트)

// coefficient가 계속 캐시에 있으므로
// 매번 빠른 접근 가능!
```

#### 예제 4: 함수 반복 호출

```c
int calculate(int x) {
    return x * x + 2 * x + 1;
}

int main() {
    for (int i = 0; i < 1000; i++) {
        int result = calculate(i);
        // calculate 함수 코드를 1000번 반복 실행
    }
}
```

**코드 캐싱:**

```javascript
// calculate 함수의 명령어들
첫 호출: 메모리에서 명령어 로드 (미스)
이후 호출: 명령어 캐시에서 실행 (히트)

// 명령어 캐시 (I-Cache) 히트율 ≈ 99.9%
```

#### 예제 5: 전역 변수

```c
int global_counter = 0;  // 전역 변수

void increment() {
    global_counter++;  // 반복 접근
}

int main() {
    for (int i = 0; i < 1000; i++) {
        increment();
    }
}
```

**접근 패턴:**

```
시간 →
[counter++] [counter++] [counter++] ... (1000번)
    ↑          ↑          ↑
    같은 변수 반복 사용 → 시간적 지역성
```

### 시간적 지역성 활용 팁

```c
// Tip 1: 자주 쓰는 값은 변수에 저장
// ❌ 나쁨
for (int i = 0; i < 1000; i++) {
    int value = array[0];  // array[0]을 1000번 읽음
    process(value);
}

// ✅ 좋음
int value = array[0];  // 한 번만 읽음
for (int i = 0; i < 1000; i++) {
    process(value);  // 캐시에서 읽음
}
```

```c
// Tip 2: 계산 결과 재사용
// ❌ 나쁨
for (int i = 0; i < 1000; i++) {
    double result = sqrt(x);  // sqrt 1000번 계산
    use(result);
}

// ✅ 좋음
double result = sqrt(x);  // 한 번만 계산
for (int i = 0; i < 1000; i++) {
    use(result);  // 결과 재사용
}
```

```c
// Tip 3: 루프 내 불변값 제거
// ❌ 나쁨
for (int i = 0; i < 1000; i++) {
    int limit = getLimit();  // 매번 호출
    if (i < limit) {
        process(i);
    }
}

// ✅ 좋음
int limit = getLimit();  // 한 번만 호출
for (int i = 0; i < 1000; i++) {
    if (i < limit) {
        process(i);
    }
}
```

## 공간적 + 시간적 지역성 조합

### 예제: 최적화된 행렬 곱셈

```c
// 행렬 곱셈: C = A × B
#define N 100

void matrix_multiply(int A[N][N], int B[N][N], int C[N][N]) {
    // ❌ 나쁜 방법
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            C[i][j] = 0;
            for (int k = 0; k < N; k++) {
                C[i][j] += A[i][k] * B[k][j];
                // B[k][j]: 열 우선 접근 (공간적 지역성 나쁨)
            }
        }
    }
}
```

**개선 버전 1: 타일링**

```c
void matrix_multiply_tiled(int A[N][N], int B[N][N], int C[N][N]) {
    #define TILE 32  // 캐시에 들어갈 크기
    
    // ✅ 타일 단위로 처리
    for (int ii = 0; ii < N; ii += TILE) {
        for (int jj = 0; jj < N; jj += TILE) {
            for (int kk = 0; kk < N; kk += TILE) {
                
                // 타일 내부 계산
                for (int i = ii; i < ii + TILE && i < N; i++) {
                    for (int j = jj; j < jj + TILE && j < N; j++) {
                        
                        int sum = 0;  // 시간적 지역성
                        for (int k = kk; k < kk + TILE && k < N; k++) {
                            sum += A[i][k] * B[k][j];
                            // 타일이 캐시에 들어감 (공간적 지역성)
                        }
                        C[i][j] += sum;
                        
                    }
                }
            }
        }
    }
}
```

**성능 비교:**

```javascript
// 원본 (나쁨)
캐시 미스율: ~40%
실행 시간: 1000ms

// 타일링 (좋음)
캐시 미스율: ~5%
실행 시간: 150ms

// 약 6.7배 빠름! 🚀
```

### 예제: 이미지 필터링

```c
// 3x3 블러 필터
void blur_image(int input[H][W], int output[H][W]) {
    // ✅ 공간적 + 시간적 지역성 활용
    for (int i = 1; i < H-1; i++) {
        for (int j = 1; j < W-1; j++) {
            
            // 주변 픽셀 합계 (공간적 지역성)
            int sum = 
                input[i-1][j-1] + input[i-1][j] + input[i-1][j+1] +
                input[i][j-1]   + input[i][j]   + input[i][j+1]   +
                input[i+1][j-1] + input[i+1][j] + input[i+1][j+1];
            
            output[i][j] = sum / 9;
            
            // 다음 픽셀 처리 시 input[i][j+1], input[i+1][j+1] 등은
            // 이미 캐시에 있음! (시간적 지역성)
        }
    }
}
```

## 지역성 위반 사례

### 안티패턴 1: 포인터 체이싱

```c
// ❌ 연결 리스트 순회
struct Node {
    int data;
    struct Node* next;  // 다음 노드 포인터
};

int sum = 0;
struct Node* current = head;
while (current != NULL) {
    sum += current->data;
    current = current->next;  // 메모리 여기저기 점프
}

// 노드들이 메모리에 흩어져 있음
// 공간적 지역성 없음
// 캐시 미스 많이 발생 😱
```

**개선:**

```c
// ✅ 배열로 변경
int data[N];
int sum = 0;

for (int i = 0; i < N; i++) {
    sum += data[i];  // 연속된 메모리 접근
}

// 공간적 지역성 활용
// 높은 캐시 히트율 ✨
```

### 안티패턴 2: 랜덤 접근

```c
// ❌ 랜덤 인덱스 접근
int array[10000];
for (int i = 0; i < 10000; i++) {
    int index = rand() % 10000;
    sum += array[index];  // 무작위 위치 접근
}

// 지역성 없음
// 캐시 효과 거의 없음
```

### 안티패턴 3: 큰 스트라이드

```c
// ❌ 큰 간격으로 접근
#define STRIDE 1000
int array[100000];

for (int i = 0; i < 100; i++) {
    sum += array[i * STRIDE];
    // 1000칸씩 건너뛰며 접근
    // 매번 새 블록 로드 필요
}

// 공간적 지역성 나쁨
```

## 지역성 측정 및 분석

### 지역성 점수 계산

```c
// 의사 코드: 지역성 분석
int analyze_locality(int accesses[], int count) {
    int spatial_score = 0;
    int temporal_score = 0;
    
    // 공간적 지역성 측정
    for (int i = 1; i < count; i++) {
        int distance = abs(accesses[i] - accesses[i-1]);
        if (distance <= CACHE_LINE_SIZE) {
            spatial_score++;  // 가까운 접근
        }
    }
    
    // 시간적 지역성 측정
    for (int i = 0; i < count; i++) {
        for (int j = i+1; j < count && j < i+100; j++) {
            if (accesses[i] == accesses[j]) {
                temporal_score++;  // 재접근
            }
        }
    }
    
    printf("공간적 지역성: %.2f%%\n", 
           spatial_score * 100.0 / count);
    printf("시간적 지역성: %.2f%%\n", 
           temporal_score * 100.0 / count);
}
```

### 실제 프로그램 분석 도구

```bash
# Linux perf 도구 사용
perf stat -e cache-references,cache-misses ./program

# 출력 예시:
# cache-references: 1,000,000
# cache-misses:       50,000
# 캐시 미스율: 5%
```

## 정리

### 핵심 개념

1. **공간적 지역성**
   ```
   가까운 주소 접근 → 블록 단위 로드 활용
   예: 배열 순회, 구조체 멤버 접근
   ```

2. **시간적 지역성**
   ```
   같은 데이터 반복 접근 → 캐시 유지
   예: 루프 변수, 반복 계산
   ```

3. **최적화 원칙**
   ```
   ✅ 순차 접근
   ✅ 데이터 재사용
   ✅ 작은 작업 단위
   ❌ 랜덤 접근
   ❌ 포인터 체이싱
   ❌ 큰 스트라이드
   ```

### 실전 체크리스트

```c
// 코드 작성 시 확인사항
□ 배열을 순차적으로 접근하는가?
□ 루프 변수를 재사용하는가?
□ 자주 쓰는 값을 변수에 저장했는가?
□ 행렬은 행 우선으로 접근하는가?
□ 데이터가 연속으로 배치되어 있는가?
□ 불필요한 함수 호출이 없는가?
```

### 다음 단계

다음 문서에서는 **캐시 교체 알고리즘**을 배웁니다:
- LRU, FIFO, LFU, Random
- 각 알고리즘의 장단점
- 실제 구현 예제

:::tip 성능의 핵심
지역성을 잘 활용하면 캐시 히트율 20% 향상 = 전체 성능 2~3배 향상!  
"가까운 것끼리, 자주 쓰는 것을 가까이"가 핵심입니다.
:::