---
title: 세그멘테이션의 주소 변환 실전
description: 세그멘테이션을 이용한 주소 변환 과정을 단계별로 계산하고, Limit 검증과 오류 처리를 실습합니다.
slug: "segmentation-address-translation"
sidebar_position: 2
date: 2024-01-15
---

## 🎯 이번 강의의 목표

- 세그멘테이션에서 주소 변환 과정 상세 학습
- Limit 검증의 중요성 이해하기
- 실제 계산 예제를 통한 완전한 이해
- 오류 처리 상황 대처하기

---

## 📋 주소 변환의 기본 공식

### 세그멘테이션에서의 주소 표현

```
가상 주소 = [세그먼트 번호] [오프셋]
```

### 물리 주소 계산

```
물리 주소 = Address + Offset

단, 조건:
- 세그먼트가 Valid해야 함
- Offset < Limit이어야 함
```

---

## 🔍 주소 변환의 상세 단계

### Step 1: 가상 주소 분석

```
가상 주소를 받으면 먼저 분해합니다:
- 세그먼트 번호 추출
- 오프셋 추출
```

### Step 2: 세그멘테이션 테이블 조회

```
해당 세그먼트 번호를 테이블에서 찾음:
├─ Limit 값 확인
├─ Address 값 확인
└─ 상태(Valid/Invalid) 확인
```

### Step 3: 유효성 검사

```
다음 두 가지 검사 수행:

검사 1: 범위 검사 (Bound Checking)
        Offset < Limit?
        
검사 2: 상태 검사 (Status Check)
        Address가 Invalid(I)가 아닌가?
```

### Step 4: 물리 주소 계산

```
모든 검사 통과하면:
물리 주소 = Address + Offset
```

### Step 5: 메모리 접근

```
계산된 물리 주소로 메모리 접근
데이터 읽거나 쓰기 수행
```

---

## 📊 세그멘테이션 테이블 예제

### 테이블 설정

```
프로그램의 4개 세그먼트:

┌─────────┬─────────┬──────────┐
│ Segment │ Limit   │ Address  │
├─────────┼─────────┼──────────┤
│    0    │  280    │   120    │
│    1    │  128    │   450    │
│    2    │  170    │   630    │
│    3    │  100    │    I     │
└─────────┴─────────┴──────────┘

메모리 레이아웃:

    메모리주소
       ↓
    [0~119]      OS 영역
    [120~399]    Segment 0 (280B)
    [400~449]    빈 공간
    [450~577]    Segment 1 (128B)
    [578~629]    빈 공간
    [630~799]    Segment 2 (170B)
```

---

## 🔢 예제 1: 정상적인 접근

### 상황: 가상 주소 "세그먼트 0의 오프셋 32" 접근

```
가상 주소: S=0, D=32 (S=Segment, D=Distance/Offset)

┌────────────────────────────────────┐
│ Step 1: 가상 주소 분석              │
└────────────────────────────────────┘

  세그먼트 번호: 0
  오프셋: 32

┌────────────────────────────────────┐
│ Step 2: 테이블 조회                │
└────────────────────────────────────┘

  세그먼트 0 찾음:
  ├─ Limit: 280
  ├─ Address: 120
  └─ Status: Valid (I 아님)

┌────────────────────────────────────┐
│ Step 3: 유효성 검사 (Range Check)  │
└────────────────────────────────────┘

  검사 1: Offset < Limit?
          32 < 280?
          YES ✓ (범위 내)
  
  검사 2: Status 확인
          Invalid이 아닌가?
          아니다 ✓ (Valid 상태)

┌────────────────────────────────────┐
│ Step 4: 물리 주소 계산              │
└────────────────────────────────────┘

  물리 주소 = Address + Offset
           = 120 + 32
           = 152

┌────────────────────────────────────┐
│ Step 5: 메모리 접근                │
└────────────────────────────────────┘

  물리 주소 152번지에서 데이터 접근
  ✅ 성공적으로 읽기/쓰기 수행
```

### 메모리 위치 시각화

```
메모리에서의 위치:

    [120~399]    Segment 0 (280B)
     ↑
    120번지 (Address)
     +32
     ↓
    152번지 (물리 주소)
     ← 여기서 데이터를 읽음
```

---

## 🔢 예제 2: Offset 오류 (범위 초과)

### 상황: 가상 주소 "세그먼트 0의 오프셋 300" 접근

```
가상 주소: S=0, D=300

┌────────────────────────────────────┐
│ Step 1: 가상 주소 분석              │
└────────────────────────────────────┘

  세그먼트 번호: 0
  오프셋: 300

┌────────────────────────────────────┐
│ Step 2: 테이블 조회                │
└────────────────────────────────────┘

  세그먼트 0 찾음:
  ├─ Limit: 280
  ├─ Address: 120
  └─ Status: Valid

┌────────────────────────────────────┐
│ Step 3: 유효성 검사 (Range Check)  │
└────────────────────────────────────┘

  검사 1: Offset < Limit?
          300 < 280?
          NO ✗ (범위를 초과함!)

┌────────────────────────────────────┐
│ Step 4: 오류 처리                  │
└────────────────────────────────────┘

  ⚠️ Segmentation Fault 발생!
  
  오류 메시지:
  "Segment 0에 대한 불법 접근"
  "Offset 300이 Limit 280을 초과"
  
  결과: 프로세스 강제 종료

┌────────────────────────────────────┐
│ Step 5: 프로세스 상태              │
└────────────────────────────────────┘

  ❌ 메모리 접근 불가
  ❌ 프로그램 종료
```

### 오류 분석

```
왜 이런 오류가 생기나?

1. 프로그래머 실수
   - 배열 경계 초과
   - 잘못된 포인터 접근

2. 버그
   - 초기화 오류
   - 계산 오류

3. 메모리 보호
   - OS가 의도적으로 접근 막음
   - 보안 또는 안정성 이유

"Segmentation Fault" 또는 "SIGSEGV" 오류
→ 이런 상황에서 발생하는 전형적인 오류
```

---

## 🔢 예제 3: Invalid 상태 (스왑 영역)

### 상황: 가상 주소 "세그먼트 3의 오프셋 50" 접근

```
가상 주소: S=3, D=50

┌────────────────────────────────────┐
│ Step 1: 가상 주소 분석              │
└────────────────────────────────────┘

  세그먼트 번호: 3
  오프셋: 50

┌────────────────────────────────────┐
│ Step 2: 테이블 조회                │
└────────────────────────────────────┘

  세그먼트 3 찾음:
  ├─ Limit: 100
  ├─ Address: I (Invalid)
  └─ Status: Invalid

┌────────────────────────────────────┐
│ Step 3: 유효성 검사 (Status Check)│
└────────────────────────────────────┘

  검사 1: Offset < Limit?
          50 < 100?
          YES ✓ (범위 내)
  
  검사 2: Address가 Invalid인가?
          Address = I (Invalid)
          YES ✗ (메모리에 없음!)

┌────────────────────────────────────┐
│ Step 4: 오류 처리 (Page Fault)     │
└────────────────────────────────────┘

  ⚠️ Segment Fault 발생!
  
  원인: 세그먼트가 스왑 영역에 있음
  
  처리 흐름:
  1. 운영체제 개입
  2. 스왑 영역에서 세그먼트 3 찾기
  3. 메모리 공간 확보 (필요시 다른 세그먼트 swap out)
  4. 세그먼트 3을 메모리로 로드
  5. 세그멘테이션 테이블 업데이트
     └─ Address: I → 새로운 주소 (예: 1000)
  6. 요청 재시도

┌────────────────────────────────────┐
│ Step 5: 재시도 (Retry)             │
└────────────────────────────────────┘

  테이블이 이제:
  ├─ Address: 1000 (업데이트됨)
  
  물리 주소 = 1000 + 50 = 1050
  
  ✅ 메모리 접근 성공
```

### 성능 영향

```
메모리 접근: ~1나노초
스왑에서 로드: ~10,000,000나노초 (10ms)

성능 차: 약 1000만배 느림!

따라서 스왑 접근이 많으면 성능 저하
```

---

## 🔢 예제 4: 다양한 접근들

### 세그먼트 1의 오프셋 100 접근

```
가상 주소: S=1, D=100

테이블에서 세그먼트 1:
├─ Limit: 128
├─ Address: 450
└─ Status: Valid

검사:
  100 < 128? → YES ✓
  Valid? → YES ✓

물리 주소: 450 + 100 = 550
✅ 성공
```

### 세그먼트 2의 오프셋 150 접근

```
가상 주소: S=2, D=150

테이블에서 세그먼트 2:
├─ Limit: 170
├─ Address: 630
└─ Status: Valid

검사:
  150 < 170? → YES ✓
  Valid? → YES ✓

물리 주소: 630 + 150 = 780
✅ 성공
```

### 세그먼트 1의 오프셋 200 접근 (범위 초과)

```
가상 주소: S=1, D=200

테이블에서 세그먼트 1:
├─ Limit: 128
├─ Address: 450
└─ Status: Valid

검사:
  200 < 128? → NO ✗

⚠️ Segmentation Fault 발생!
❌ 접근 불가
```

---

## 📊 Limit의 보호 효과

### 메모리 보호 메커니즘

```
세그먼트 0: 120~399
세그먼트 1: 450~577

중간 400~449는 빈 공간

문제: 세그먼트 0이 침범하지 않을까?

해결: Limit!

세그먼트 0의 Limit = 280
→ Address 120 + 280 = 400 (정확한 경계)

세그먼트 0에서 오프셋 281 이상 접근?
→ 즉시 Segmentation Fault!
→ 침범 불가능!
```

---

## 📝 실전 문제

### 문제 1: 기본 계산

```
세그멘테이션 테이블:

┌─────────┬─────────┬──────────┐
│ Segment │ Limit   │ Address  │
├─────────┼─────────┼──────────┤
│    0    │  200    │   100    │
│    1    │  150    │   400    │
│    2    │  100    │    I     │
└─────────┴─────────┴──────────┘

Q1: S=0, D=50에 접근하면?

A1:
  Offset: 50 < Limit: 200? → YES ✓
  Address: 100 (Valid) → YES ✓
  물리 주소 = 100 + 50 = 150
  ✅ 성공

Q2: S=1, D=200에 접근하면?

A2:
  Offset: 200 < Limit: 150? → NO ✗
  ❌ Segmentation Fault
  
Q3: S=2, D=50에 접근하면?

A3:
  Offset: 50 < Limit: 100? → YES ✓
  Address: I (Invalid) → Invalid ✗
  ⚠️ Page Fault (스왑에서 로드 필요)
```

---

## 🎓 핵심 정리

### 주소 변환 알고리즘

```
함수 SegmentationAddressTranslation(S, D):
  
  // Step 1: 테이블 조회
  segment = SegmentationTable[S]
  
  // Step 2: 유효성 검사
  if D >= segment.Limit then
    Trap("Segmentation Fault")
    return ERROR
  
  if segment.Address == INVALID then
    Trap("Page Fault")
    // 스왑에서 로드 (OS 처리)
    // 테이블 업데이트
    segment.Address = newAddress
  
  // Step 3: 주소 변환
  physicalAddress = segment.Address + D
  
  // Step 4: 메모리 접근
  return memory[physicalAddress]
```

### 주요 오류 종류

| 오류 | 원인 | 처리 |
|------|------|------|
| **Segmentation Fault** | Offset ≥ Limit | 프로세스 종료 |
| **Invalid Address** | Address = I | 페이지 폴트 처리 |
| **Out of Bounds** | 세그먼트 번호 오류 | 프로세스 종료 |

---

## 💡 Limit의 역할

### 1️⃣ 범위 제한

```
각 세그먼트가 사용할 수 있는 최대 크기 명확화
```

### 2️⃣ 메모리 보호

```
한 세그먼트가 다른 세그먼트 영역 침범 방지
```

### 3️⃣ 오류 감지

```
범위 초과 접근을 즉시 감지하고 보고
```

### 4️⃣ 버그 방지

```
포인터 오류, 배열 오버플로우 등을 조기에 발견
```

---

## ❓ 자주 묻는 질문(FAQ)

**Q: Offset은 어떻게 결정되나요?**

A: 프로그래머가 프로그램에서 사용하는 주소입니다. CPU가 변수에 접근할 때 자동으로 전달됩니다.

**Q: Limit을 초과하면 복구될 수 없나요?**

A: 일반적으로는 아닙니다. Limit을 초과하면 버그이므로 프로그램을 종료합니다.

**Q: Invalid 세그먼트는 얼마나 자주 발생하나요?**

A: 메모리가 부족한 상황에서만 발생합니다. 요즘은 메모리가 충분해 거의 발생하지 않습니다.

**Q: Address가 꼭 정렬되어야 하나요?**

A: 일반적으로는 아니지만, 성능을 위해 특정 경계(예: 4KB)로 정렬하기도 합니다.

---