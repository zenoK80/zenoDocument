---
title: 혼용 매핑과 메모리 접근 권한
description: 페이징과 세그멘테이션을 결합한 혼용 기법과 메모리 접근 권한 관리를 학습합니다. 현대 운영체제의 메모리 관리 방식을 이해합니다.
slug: "hybrid-mapping-and-access-control"
sidebar_position: 3
date: 2024-01-15
---

## 🎯 이번 강의의 목표

- 페이징과 세그멘테이션의 혼용 기법 이해하기
- 메모리 접근 권한의 개념 학습하기
- 권한 비트의 역할 이해하기
- 프로세스 제어 블록(PCB) 구조 배우기

---

## 🔀 혼용 매핑(Hybrid/Combined Mapping)이란?

### 개념

```
페이징과 세그멘테이션의 장점을 모두 활용하는 기법

세그멘테이션 + 페이징의 조합
```

### 왜 혼용하는가?

```
페이징의 장점:
✓ 메모리 관리 간단
✓ 외부 단편화 없음
✓ 페이지 테이블이 효율적

페이징의 단점:
✗ 논리적 의미 부여 어려움
✗ 내부 단편화 발생

세그멘테이션의 장점:
✓ 논리적 의미 있음
✓ 메모리 보호 우수
✓ 내부 단편화 없음

세그멘테이션의 단점:
✗ 외부 단편화
✗ 테이블 관리 복잡

→ 두 기법을 합치자!
```

---

## 📊 혼용 매핑의 구조

### 3단계 주소 변환

혼용 매핑은 세 가지 정보를 사용합니다:

```
가상 주소 = [세그먼트 번호] [페이지 번호] [오프셋]
              ↑              ↑            ↑
             S             P            D
          (Segment)      (Page)    (Displacement)
```

### 예: 32비트 주소 체계

```
32비트 주소를 이렇게 나눔:

┌─────────────────────────────────────────┐
│ S (6비트) │ P (10비트) │ D (10비트)      │
├───────────┼──────────┬───────────────┤
│ 세그먼트  │ 페이지   │ 오프셋        │
│ 0~63      │ 0~1023   │ 0~1023        │
└───────────┴──────────┴───────────────┘

→ 최대 64개 세그먼트
→ 각 세그먼트에 최대 1024개 페이지
→ 각 페이지는 1KB
```

---

## 🔄 혼용 매핑의 주소 변환 과정

### 단계별 변환

```
┌─────────────────────────────────┐
│ Step 1: 세그먼트 번호 추출      │
└─────────────────────────────────┘

가상 주소의 상위 비트 확인
→ 세그먼트 번호 결정

예) S=2 (세그먼트 2)

┌─────────────────────────────────┐
│ Step 2: 세그멘테이션 테이블 조회│
└─────────────────────────────────┘

세그먼트 2의 정보:
├─ Base Address: 180000 (페이지 테이블 시작)
├─ Limit: 5 (최대 5개 페이지)
└─ 권한: Read-Write-Execute

유효성 검사:
- 세그먼트 유효한가?
- 접근 권한 있는가?

┌─────────────────────────────────┐
│ Step 3: 페이지 번호 추출        │
└─────────────────────────────────┘

가상 주소의 중간 비트 확인
→ 페이지 번호 결정

예) P=3 (페이지 3)

┌─────────────────────────────────┐
│ Step 4: 페이지 테이블 조회      │
└─────────────────────────────────┘

세그먼트 2의 페이지 테이블:
│ 페이지 │ 프레임 │ 권한
├─────────┼────────┼─────────────
│    0    │   2    │ R-W-E
│    1    │   5    │ R-W-
│    2    │   1    │ R---
│    3    │   7    │ R-W-E ← 찾음
│    4    │   X    │ Invalid
└─────────┴────────┴─────────────

페이지 3: 프레임 7, 권한 R-W-E

┌─────────────────────────────────┐
│ Step 5: 오프셋 추출             │
└─────────────────────────────────┘

가상 주소의 하위 비트
→ 오프셋 결정

예) D=512 (1024바이트 페이지 내 512번 위치)

┌─────────────────────────────────┐
│ Step 6: 물리 주소 계산          │
└─────────────────────────────────┘

물리 주소 = (프레임 × 페이지 크기) + 오프셋
         = (7 × 1024) + 512
         = 7168 + 512
         = 7680

┌─────────────────────────────────┐
│ Step 7: 권한 검증               │
└─────────────────────────────────┘

요청 작업과 권한 비교:
- 읽기(R) 요청? → 권한 R 확인
- 쓰기(W) 요청? → 권한 W 확인
- 실행(E) 요청? → 권한 E 확인

모두 허용 → 계속 진행

┌─────────────────────────────────┐
│ Step 8: 메모리 접근             │
└─────────────────────────────────┘

물리 주소 7680에서 데이터 접근
✅ 모든 검증 완료 후 접근 가능
```

---

## 🔐 메모리 접근 권한(Access Control)

### 권한의 종류

메모리에 접근할 때 다음 4가지 권한을 정의합니다:

#### 1️⃣ Read (R)

```
메모리에서 데이터를 읽기만 할 수 있는 권한

예) 상수 데이터, 프로그램 코드 읽기
```

#### 2️⃣ Write (W)

```
메모리에 데이터를 쓸 수 있는 권한

예) 전역 변수 수정, 배열 값 변경

특징: Write 권한이 있으면 일반적으로 Read도 가능
```

#### 3️⃣ Execute (E)

```
메모리의 코드를 실행할 수 있는 권한

예) 함수 실행, 명령어 실행

특징: 코드 영역에만 필요
```

#### 4️⃣ Append (A)

```
메모리에 데이터를 추가할 수 있는 권한

특징: Write 권한과 함께 사용되는 경우가 많음
```

### 권한의 조합

```
모든 조합: 2⁴ = 16가지 가능

하지만 Append는 일반적으로 Write와 함께만 사용되므로:
실제 사용 조합: 8가지

예시:

Mode 0: --- (아무 권한 없음)
        → 접근 불가능

Mode 1: R-- (읽기만 가능)
        → Read-Only 파일

Mode 2: RW- (읽고 쓰기 가능)
        → 일반 데이터 영역

Mode 3: R-E (읽고 실행 가능)
        → 코드 영역

Mode 4: RWE (읽고, 쓰고, 실행 가능)
        → 제한 없음 (모든 권한)
```

---

## 📂 메모리 영역별 권한

### 프로세스의 메모리 구조

```
┌──────────────────────────────┐
│ 1. Code 영역                 │ R-E (읽고 실행)
│    - 프로그램의 명령어      │ 쓰기 금지
├──────────────────────────────┤
│ 2. Data 영역                 │ R-W (읽고 쓰기)
│    - 초기화된 데이터        │ 실행 금지
├──────────────────────────────┤
│ 3. BSS 영역                  │ R-W (읽고 쓰기)
│    - 초기화되지 않은 데이터 │ 실행 금지
├──────────────────────────────┤
│ 4. Heap 영역                 │ R-W (읽고 쓰기)
│    - 동적 할당 메모리       │ 실행 금지
├──────────────────────────────┤
│                              │
│ (빈 공간)                   │
│                              │
├──────────────────────────────┤
│ 5. Stack 영역                │ R-W (읽고 쓰기)
│    - 함수 호출, 로컬 변수   │ 실행 금지
└──────────────────────────────┘

```

### 권한이 필요한 이유

```
1. 보안
   → 중요한 코드 영역을 수정 불가능하게

2. 안정성
   → 실수로 잘못된 접근 방지

3. 격리
   → 프로세스 간 메모리 보호

4. 오류 감지
   → 버그를 조기에 발견
```

---

## 🛡️ 권한 위반 시 처리

### Read-Only 영역에 Write 시도

```
상황: Code 영역(R-E)에 쓰기 시도

권한:
  - Code 영역: R-E (Read, Execute만)
  - 요청: Write

검증:
  쓰기 권한(W) 있는가?
  NO ✗

처리:
  ⚠️ Trap/Exception 발생!
  
  오류 메시지: "Segmentation Fault" 또는
              "Protection Violation"
  
  결과: 프로세스 강제 종료
```

### Execute 권한 없는 영역에서 실행 시도

```
상황: Data 영역(R-W)에서 코드 실행 시도

이것은 보안 공격의 전형적인 패턴
(Buffer overflow, Return-oriented programming 등)

권한:
  - Data 영역: R-W (Write 가능)
  - 악의적으로 코드 주입
  - 실행 시도

검증:
  실행 권한(E) 있는가?
  NO ✗

처리:
  ⚠️ Execute Protection 발생!
  
  오류: "Illegal operation"
  
  결과: 공격 차단, 프로세스 종료
```

---

## 📋 프로세스 제어 블록(PCB)

### PCB의 역할

```
프로세스가 실행될 때 필요한 모든 정보를 저장하는 구조
```

### PCB에 포함되는 정보

```
PCB 구조:

┌─────────────────────────────┐
│ Process Information         │
├─────────────────────────────┤
│ Process ID (PID)            │ 프로세스 고유 번호
│ Process State               │ Running, Waiting, Ready 등
│ Program Counter (PC)        │ 다음 실행할 명령어 주소
│ Register Values             │ CPU 레지스터 값
├─────────────────────────────┤
│ Memory Information          │
├─────────────────────────────┤
│ Segment Table Address       │ 세그멘테이션 테이블 위치
│ Page Table Address          │ 페이지 테이블 위치
│ Memory Limits               │ 메모리 사용량 제한
│ Base Register               │ 기본 주소
├─────────────────────────────┤
│ Code Segment Base/Limit     │ 코드 영역 위치/크기
│ Data Segment Base/Limit     │ 데이터 영역 위치/크기
│ Stack Segment Base/Limit    │ 스택 영역 위치/크기
├─────────────────────────────┤
│ File Information            │
├─────────────────────────────┤
│ Open Files                  │ 열린 파일 목록
│ Working Directory           │ 현재 디렉토리
├─────────────────────────────┤
│ Priority Information        │
├─────────────────────────────┤
│ Priority                    │ 스케줄링 우선순위
│ CPU Time                    │ 사용한 CPU 시간
│ IO Pending                  │ 입출력 대기 상태
└─────────────────────────────┘
```

---

## 🔗 페이징과 세그멘테이션의 혼용 예제

### 시나리오 설정

```
32비트 시스템:

주소 분할:
┌────────┬────────────┬────────────┐
│  6비트 │   10비트   │   10비트   │
│ Segment│   Page     │  Offset    │
│(0-63)  │  (0-1023)  │  (0-1023)  │
└────────┴────────────┴────────────┘

페이지 크기: 1024바이트
세그먼트 0: 프로그램 코드
세그먼트 1: 프로그램 데이터
```

### 세그멘테이션 테이블

```
┌─────┬────────────┬──────────┬─────────┐
│ Seg │ Limit(pg) │ Base Addr│ 권한    │
├─────┼────────────┼──────────┼─────────┤
│  0  │     5     │  2000    │ R-E     │
│  1  │     3     │  3500    │ R-W     │
└─────┴────────────┴──────────┴─────────┘

의미:
- 세그먼트 0 (Code):
  * 최대 5개 페이지 (5KB)
  * 페이지 테이블 시작: 주소 2000
  * 권한: 읽기, 실행 (쓰기 금지)

- 세그먼트 1 (Data):
  * 최대 3개 페이지 (3KB)
  * 페이지 테이블 시작: 주소 3500
  * 권한: 읽기, 쓰기 (실행 금지)
```

### 세그먼트 0의 페이지 테이블

```
페이지 테이블 위치: 2000부터 시작

┌──────┬────────┬─────┐
│ Page │ Frame  │권한 │
├──────┼────────┼─────┤
│  0   │   10   │ R-E │
│  1   │   15   │ R-E │
│  2   │   8    │ R-E │
│  3   │   20   │ R-E │
│  4   │   12   │ R-E │
└──────┴────────┴─────┘

각 페이지의 프레임이 결정됨
```

### 가상 주소 변환 예시

```
상황: 세그먼트 0, 페이지 2, 오프셋 500 접근

가상 주소: S=0, P=2, D=500

┌──────────────────────────────────┐
│ Step 1: 세그멘테이션 테이블 조회 │
└──────────────────────────────────┘

세그먼트 0:
├─ Limit: 5 (최대 5개 페이지)
├─ Base Addr: 2000
└─ 권한: R-E

┌──────────────────────────────────┐
│ Step 2: 페이지 범위 확인         │
└──────────────────────────────────┘

페이지 2 < Limit 5?
2 < 5 → YES ✓

┌──────────────────────────────────┐
│ Step 3: 권한 확인                │
└──────────────────────────────────┘

코드 영역이므로 쓰기 요청?
아니, 읽기 또는 실행 요청
권한: R-E → 가능 ✓

┌──────────────────────────────────┐
│ Step 4: 페이지 테이블 조회       │
└──────────────────────────────────┘

세그먼트 0의 페이지 테이블 (주소 2000)에서
페이지 2 찾음:
├─ Frame: 8
└─ 권한: R-E

┌──────────────────────────────────┐
│ Step 5: 물리 주소 계산           │
└──────────────────────────────────┘

물리 주소 = (Frame × Page Size) + Offset
         = (8 × 1024) + 500
         = 8192 + 500
         = 8692

┌──────────────────────────────────┐
│ Step 6: 메모리 접근              │
└──────────────────────────────────┘

물리 주소 8692에서 데이터 접근
✅ 성공!
```

---

## 📊 페이징 vs 세그멘테이션 vs 혼용

| 특징 | 페이징 | 세그멘테이션 | 혼용 |
|------|---------|----------|------|
| **분할 방식** | 고정 크기 | 가변 크기 | 가변+고정 |
| **외부 단편화** | 없음 | 있음 | 없음 ⭐ |
| **내부 단편화** | 있음 | 없음 | 있음(적음) |
| **메모리 보호** | 보통 | 우수 | 우수 ⭐ |
| **테이블 크기** | 큼 | 작음 | 중간 ⭐ |
| **관리 복잡도** | 간단 | 복잡 | 중간 |
| **권한 관리** | 페이지별 | 세그먼트별 | 둘 다 ⭐ |
| **현대 OS 사용** | ✓ | ✗ | ✓ |

---

## 🎯 혼용 기법의 장점

### 1️⃣ 외부 단편화 해결

```
페이징의 고정 크기 덕분에
세그멘테이션의 외부 단편화 제거
```

### 2️⃣ 효율적인 테이블 관리

```
세그먼트 수가 적어서
전체 테이블 크기 감소

OS 메모리 절약
→ 사용자 메모리 증가
```

### 3️⃣ 논리적 의미 보존

```
세그멘테이션의 논리적 의미 유지
- 코드, 데이터 분리
- 스택, 힙 분리
```

### 4️⃣ 유연한 메모리 보호

```
세그먼트 단위: 영역별 권한
페이지 단위: 세밀한 제어
```

---

## 💾 실제 시스템에서의 구현

### Intel x86-64 아키텍처

```
세그멘테이션 + 페이징 혼용
(실제로는 세그멘테이션을 최소화하고 페이징 주로 사용)
```

### 리눅스/유닉스

```
세그멘테이션 테이블 (간소화):
- 코드 세그먼트
- 데이터 세그먼트

페이지 테이블 (주요):
- 모든 메모리 관리 담당
```

### Windows

```
세그먼트와 페이징 모두 사용
보안과 성능을 위한 다층 보호
```

---

## 🎓 핵심 정리

### 혼용 매핑 주소 변환

```
Step 1: 세그먼트 테이블에서 페이지 테이블 주소 찾기
Step 2: 페이지 테이블에서 프레임 번호 찾기
Step 3: 권한 확인
Step 4: 물리 주소 = (Frame × Page Size) + Offset
```

### 메모리 접근 권한

```
Read (R): 읽기만 가능
Write (W): 쓰기 가능
Execute (E): 코드 실행 가능
Append (A): 추가 가능 (거의 미사용)
```

### 프로세스 메모리 영역

```
Code (R-E) → Data (R-W) → Heap (R-W) → Stack (R-W)
```

---

## ❓ 자주 묻는 질문(FAQ)

**Q: 권한 검사가 매번 일어나나요?**

A: 네, 가상 메모리에 접근할 때마다 권한을 검사합니다. TLB(캐시)로 최적화됩니다.

**Q: 권한 없음(---)으로 설정하는 영역이 있나요?**

A: 네, 사용되지 않는 메모리 영역이나 보호된 영역입니다.

**Q: Code 영역에 데이터를 저장할 수 없나요?**

A: 불가능합니다. 쓰기 권한(W)이 없어서 Segmentation Fault가 발생합니다.

**Q: 실행 권한(E)이 없어도 데이터는 읽을 수 있나요?**

A: 네, R 권한이 있으면 데이터를 읽을 수 있습니다. E는 실행만 관련됩니다.

---

## 🎬 정리: 가상 메모리 전체 구조

```
프로그램 실행 흐름:

1. CPU: "가상 주소 접근"
         ↓
2. 세그멘테이션: "어느 세그먼트인가?"
                 "페이지 테이블은 어디?"
         ↓
3. 페이징: "어느 페이지인가?"
          "어느 프레임인가?"
         ↓
4. 권한 확인: "이 작업 허락된가?"
         ↓
5. 물리 주소: "최종 메모리 위치 결정"
         ↓
6. 메모리 접근: "실제 데이터 읽기/쓰기"
```

---

## 🏁 전체 강좌 완료

### 배운 내용

```
1강 - 가상 메모리 개념
2강 - 주소 매핑
3강 - 페이징 기본
4강 - 페이징 주소 변환
5강 - 메모리 할당과 교체
6강 - 세그멘테이션 개념
7강 - 세그멘테이션 주소 변환
8강 - 혼용 매핑과 권한 관리 (현재)
```