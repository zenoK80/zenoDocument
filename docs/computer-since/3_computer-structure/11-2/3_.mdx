---
title: 페이징(Paging) - 메모리 관리의 기본
description: 페이징 기법의 개념과 원리를 초보자 눈높이에서 설명합니다. 메모리를 고정 크기로 나누어 관리하는 방법을 배워봅시다.
slug: paging-basics
sidebar_position: 3
date: 2024-01-15
---

## 🎯 이번 시간의 목표

- 페이징이란 무엇인지 이해하기
- 페이지와 프레임의 개념 배우기
- 페이지 테이블이 어떻게 작동하는지 학습하기
- 페이징을 통한 주소 변환 과정 이해하기

---

## 🧩 페이징(Paging)의 기본 개념

### 페이징이란?

```
메모리를 일정한 크기(보통 4KB)로 나누어 관리하는 기법
```

### 비유: 책을 페이지로 나누기

```
📖 책 전체 = 메모리 전체
📄 각 페이지 = 고정된 크기 (예: 200자씩)

책을 읽을 때 페이지 단위로 나누면:
- 전체 구조를 이해하기 쉬움
- 찾는 내용을 빠르게 위치시킬 수 있음
- 손상된 페이지만 교체 가능
```

---

## 📐 페이징의 두 가지 주요 개념

### 1️⃣ 페이지 (Page)

**가상 메모리에서의 고정 크기 블록**

```
구성 요소:
- 가상 메모리를 나눈 단위
- 일반적인 크기: 512B ~ 8KB (시스템마다 다름)
- 현대 시스템: 보통 4KB

예시:
페이지 0: 가상 주소 0 ~ 4095
페이지 1: 가상 주소 4096 ~ 8191
페이지 2: 가상 주소 8192 ~ 12287
...
```

### 2️⃣ 프레임 (Frame)

**물리 메모리에서의 고정 크기 블록**

```
구성 요소:
- 물리 메모리(RAM)를 나눈 단위
- 페이지와 같은 크기를 유지

예시:
프레임 0: 물리 주소 0 ~ 4095
프레임 1: 물리 주소 4096 ~ 8191
프레임 2: 물리 주소 8192 ~ 12287
...
```

### 페이지 vs 프레임

| 항목 | 페이지 | 프레임 |
|------|--------|--------|
| **위치** | 가상 메모리 | 물리 메모리(RAM) |
| **크기** | 고정 (예: 4KB) | 고정 (예: 4KB) |
| **개수** | 많음 (가상 메모리 크기 / 페이지 크기) | 제한됨 (물리 메모리 크기 / 프레임 크기) |
| **역할** | 가상 주소를 분류 | 물리 주소를 분류 |

---

## 📊 페이지 테이블 (Page Table)

### 페이지 테이블이란?

```
각 페이지가 어느 프레임에 저장되어 있는지 기록하는 표
```

### 예시

```
페이지 번호 | 프레임 번호 | 설명
-----------|-----------|----------------------------------
0          | 2         | 페이지 0은 프레임 2에 저장됨
1          | 5         | 페이지 1은 프레임 5에 저장됨
2          | 1         | 페이지 2는 프레임 1에 저장됨
3          | 7         | 페이지 3은 프레임 7에 저장됨
4          | X         | 페이지 4는 스왑 영역에 있음 (메모리에 없음)
```

### 페이지 테이블의 역할

```
프로그램: "가상 주소 1000번의 데이터를 줘"
          ↓
페이지 번호 계산: 1000 / 4096 = 0번 페이지
          ↓
페이지 테이블 조회: "페이지 0은 프레임 2에 있어"
          ↓
물리 주소 계산: 프레임 2의 시작 주소 = 8192
          ↓
데이터 반환: "물리 주소 8192 + offset에서 데이터 읽음"
```

---

## 🔢 페이지 크기의 중요성

### 일반적인 페이지 크기

```
16비트 CPU:  512B (2⁹ bytes)
32비트 CPU:  4KB (2¹² bytes)  ← 가장 일반적
64비트 CPU:  8KB (2¹³ bytes) 이상
```

### 페이지 크기의 영향

```
페이지 크기가 크면:
✓ 페이지 테이블 크기가 작음 (관리 용이)
✗ 내부 단편화 증가 (낭비 증가)

페이지 크기가 작으면:
✓ 내부 단편화 감소 (효율적)
✗ 페이지 테이블 크기 증가 (관리 어려움)
```

### 2의 거듭제곱으로 표현하는 이유

```
페이지 크기가 2⁻의 거듭제곱이면:
→ 주소 계산이 단순한 이진 연산으로 가능
→ 매우 빠른 처리 가능

예) 페이지 크기 = 4KB = 2¹² bytes
    가상 주소 = 12345 (이진수로 00000000 00000000 00110000 00011001)
    
    페이지 번호 = 12345 / 4096 = 3
    오프셋(Offset) = 12345 % 4096 = 57
    
    → 이진 이동과 마스킹으로 매우 빠르게 계산!
```

---

## 📍 주소 변환 과정

### 가상 주소의 구성

```
가상 주소 = [페이지 번호] [오프셋(Offset)]
              ↑              ↑
         상위 비트       하위 비트

예) 페이지 크기 4KB (2¹²)인 경우
    32비트 가상 주소 = [상위 20비트: 페이지 번호] [하위 12비트: 오프셋]
```

### 오프셋(Offset)이란?

```
페이지 내에서의 상대 위치

예) 페이지 크기 4KB인 경우:
    가상 주소 = 5000
    페이지 번호 = 5000 / 4096 = 1
    오프셋 = 5000 % 4096 = 904
    
    의미: 페이지 1의 904번 위치
```

### 주소 변환의 핵심 원칙

```
🔑 중요한 특징:
   페이지의 오프셋 = 프레임의 오프셋 (동일함!)

예) 
    가상 주소 5000 = 페이지 1의 offset 904
    페이지 1이 프레임 3에 있다면:
    물리 주소 = 프레임 3의 시작 + 904
            = (3 × 4096) + 904
            = 12288 + 904
            = 13192
```

---

## 📝 구체적인 예시: 32비트 시스템

### 시스템 사양

```
페이지 크기: 1KB (2¹⁰ bytes)
가상 메모리: 64KB (2¹⁶ bytes)
물리 메모리(RAM): 16KB (4개의 프레임)

따라서:
- 페이지 개수 = 64KB / 1KB = 64개
- 프레임 개수 = 16KB / 1KB = 16개
```

### 페이지 테이블 예시

```
페이지 # | 프레임 # | 상태
--------|---------|----------
0       | 2       | 메모리O
1       | 3       | 메모리O
2       | 1       | 메모리O
3       | 0       | 메모리O
4       | X       | 스왑영역O (메모리 부족)
5       | X       | 스왑영역O
...     | ...     | ...
```

### 주소 변환 예시

**Q: 가상 주소 980번을 읽으려면?**

```
Step 1: 페이지 번호 계산
        980 ÷ 1024 = 0 (나머지 980)
        → 페이지 0

Step 2: 오프셋 계산
        980 % 1024 = 980
        → 오프셋 980

Step 3: 페이지 테이블 조회
        페이지 0 → 프레임 2 (메모리에 있음)

Step 4: 물리 주소 계산
        프레임 2의 시작 = 2 × 1024 = 2048
        물리 주소 = 2048 + 980 = 3028

✅ 결과: 물리 주소 3028에서 데이터를 읽음
```

**Q: 가상 주소 1364번을 읽으려면?**

```
Step 1: 페이지 번호 계산
        1364 ÷ 1024 = 1 (나머지 340)
        → 페이지 1

Step 2: 오프셋 계산
        1364 % 1024 = 340
        → 오프셋 340

Step 3: 페이지 테이블 조회
        페이지 1 → 프레임 3

Step 4: 물리 주소 계산
        프레임 3의 시작 = 3 × 1024 = 3072
        물리 주소 = 3072 + 340 = 3412

✅ 결과: 물리 주소 3412에서 데이터를 읽음
```

---

## 🔧 페이지 크기가 10바이트인 간단한 예시

### 시스템 설정 (학습용)

```
페이지 크기: 10바이트
가상 메모리: 페이지 0~9 (10개)
물리 메모리: 프레임 0~3 (4개)

메모리 레이아웃:
가상: [0~9] [10~19] [20~29] [30~39] ...
      페이지0 페이지1 페이지2 페이지3 ...

물리: [0~9] [10~19] [20~29] [30~39]
      프레임0 프레임1 프레임2 프레임3
```

### 페이지 테이블

```
페이지 | 프레임 | 비고
-------|--------|----------------
0      | 2      | 메모리에 있음
1      | 3      | 메모리에 있음
2      | 4      | 메모리에 있음
3      | 1      | 메모리에 있음
4      | 스왑   | 스왑 영역에 있음
5      | 스왑   | 스왑 영역에 있음
...
```

### 주소 변환 예시

**가상 주소 30번을 접근하려면:**

```
1. 페이지 번호 = 30 ÷ 10 = 3
2. 오프셋 = 30 % 10 = 0
3. 페이지 3 → 프레임 1 (테이블에서 조회)
4. 물리 주소 = (1 × 10) + 0 = 10

✅ 물리 주소 10번에서 데이터 읽음
```

**가상 주소 18번을 접근하려면:**

```
1. 페이지 번호 = 18 ÷ 10 = 1
2. 오프셋 = 18 % 10 = 8
3. 페이지 1 → 프레임 3 (테이블에서 조회)
4. 물리 주소 = (3 × 10) + 8 = 38

✅ 물리 주소 38번에서 데이터 읽음
```

**가상 주소 45번을 접근하려면:**

```
1. 페이지 번호 = 45 ÷ 10 = 4
2. 오프셋 = 45 % 10 = 5
3. 페이지 4 → 스왑 영역 (메모리에 없음!)
4. ⚠️ 페이지 폴트(Page Fault) 발생!

처리:
- 페이지 4를 스왑 영역에서 로드
- 기존 프레임 중 하나를 비우기 (예: 프레임 0)
- 페이지 4를 프레임 0에 적재
- 페이지 테이블 업데이트
- 물리 주소 = (0 × 10) + 5 = 5
```

---

## 🎯 페이징의 장단점

### 장점 ✅

```
1. 메모리 할당이 간단
   → 모두 같은 크기이므로 계산하기 쉬움

2. 외부 단편화 없음
   → 고정 크기이므로 낭비 없음

3. 주소 변환이 빠름
   → 단순 이진 연산으로 가능

4. 메모리 활용이 효율적
   → 복잡한 관리 불필요
```

### 단점 ✗

```
1. 페이지 테이블 관리가 복잡
   → 페이지 수가 매우 많음 (수백만 개)

2. 내부 단편화 발생
   → 프로세스 크기가 정확히 페이지 배수가 아니면 낭비

3. 페이지 테이블 크기가 큼
   → 물리 메모리를 낭비하는 원인

4. 페이지 폴트 오버헤드
   → 필요한 페이지가 메모리에 없으면 디스크 접근
```

---

## 💡 핵심 정리

| 개념 | 설명 |
|------|------|
| **페이지** | 가상 메모리를 고정 크기로 나눈 블록 |
| **프레임** | 물리 메모리를 고정 크기로 나눈 블록 |
| **페이지 테이블** | 페이지→프레임 매핑 정보를 담은 표 |
| **오프셋** | 페이지/프레임 내에서의 위치 |
| **페이지 폴트** | 필요한 페이지가 메모리에 없는 상황 |

---

## 🔑 기억할 수식

```
페이지 번호 = 가상 주소 ÷ 페이지 크기
오프셋 = 가상 주소 % 페이지 크기

물리 주소 = (프레임 번호 × 페이지 크기) + 오프셋
```

---

## ❓ 자주 묻는 질문(FAQ)

**Q: 페이지 테이블이 매우 크면 어떻게 하나요?**

A: 다단계 페이지 테이블(Multi-level Page Table)이나 해시 테이블 같은 고급 기법을 사용합니다.

**Q: 페이지 크기를 아주 크게 하면 안 되나요?**

A: 페이지가 크면 내부 단편화가 심해져서 메모리 낭비가 커집니다. 균형을 맞춰야 합니다.

**Q: 모든 프로세스가 같은 페이지 크기를 사용하나요?**

A: 네, 일반적으로 운영체제가 정한 페이지 크기를 모든 프로세스가 사용합니다.

---

## 🚀 다음 시간 미리보기

다음에는 **페이지 폴트와 페이지 교체**를 배웁니다:

- 페이지 폴트(Page Fault)란?
- 페이지를 메모리에서 내보낼 때 어떤 페이지를 선택할까?
- 다양한 페이지 교체 알고리즘 (FIFO, LRU, LFU 등)

어떤 페이지를 내보내는 것이 가장 똑똑한 방법일까요?