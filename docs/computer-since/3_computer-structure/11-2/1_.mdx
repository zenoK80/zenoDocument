---
title: 세그멘테이션의 기본 개념
description: 세그멘테이션 메모리 관리 기법의 개념을 배우고, 페이징과의 차이를 이해합니다. 가변 크기 메모리 할당을 초보자 눈높이에서 설명합니다.
slug: "segmentation-concept"
sidebar_position: 1
date: 2024-01-15
---

## 🎯 이번 강의의 목표

- 세그멘테이션이 무엇인지 이해하기
- 페이징과 세그멘테이션의 차이점 배우기
- 세그멘테이션 테이블의 구조 학습하기
- 외부 단편화의 개념 이해하기

---

## 📌 세그멘테이션(Segmentation)이란?

### 기본 개념

```
프로세스의 크기에 따라 메모리를 가변적으로 분할하는 기법
```

### 페이징과의 근본적인 차이

```
페이징:
- 메모리를 "고정된 크기"로 나눔 (예: 4KB)
- 모든 페이지의 크기가 같음
- 프로세스 크기와 무관하게 일정

세그멘테이션:
- 메모리를 "프로세스 크기에 맞춰" 나눔
- 각 세그먼트의 크기가 다름
- 프로세스의 실제 필요에 맞춤
```

### 비유: 책장 배치

```
페이징 방식:
┌─────────────────────────┐
│ 20cm │ 20cm │ 20cm │    │ ← 모두 같은 크기
└─────────────────────────┘
(크기가 15cm인 책도 20cm 공간 사용)

세그멘테이션 방식:
┌──────┬──────────┬─────────────┐
│ 15cm │   25cm   │    30cm     │ ← 책 크기에 맞춤
└──────┴──────────┴─────────────┘
(각 책의 높이에 정확히 맞춤)
```

---

## 🧩 세그멘트의 구성 요소

### 프로그램의 논리적 구분

프로그램은 다양한 용도의 코드와 데이터로 구성됩니다:

```
세그멘트의 예시:

1. 메인 함수 (Main Subroutine)
   - 크기: 300KB
   - 포함 내용: 프로그램의 주요 로직

2. 서브 함수 (Subroutine A)
   - 크기: 150KB
   - 포함 내용: 특정 기능을 담당하는 함수

3. 데이터 영역 (Data)
   - 크기: 200KB
   - 포함 내용: 프로그램에서 사용할 데이터

4. 스택 영역 (Stack)
   - 크기: 100KB
   - 포함 내용: 함수 호출 정보, 로컬 변수

→ 각각을 독립적인 세그먼트로 관리!
```

### 세그멘트의 특징

```
1. 논리적 의미 보유
   - 함수, 모듈, 데이터 등 의미 있는 단위

2. 크기가 다양함
   - 프로그래머가 필요로 하는 크기대로

3. 동적으로 변함
   - 프로그램 실행 중 크기 변화 가능

4. 프로세스마다 다름
   - 각 프로그램마다 고유한 세그멘트 구조
```

---

## 📊 세그멘테이션 테이블

### 구조

세그멘테이션 테이블은 다음 정보를 가집니다:

```
세그멘테이션 테이블:

┌─────────┬─────────┬──────────┐
│ Segment │ Limit   │ Address  │
│ Number  │ (크기)  │ (시작주소)|
├─────────┼─────────┼──────────┤
│    0    │  280    │   120    │
│    1    │  128    │   450    │
│    2    │  170    │   630    │
│    3    │  100    │   Invalid│
└─────────┴─────────┴──────────┘
```

### 각 필드의 의미

#### Segment Number (세그먼트 번호)
```
프로그램이 사용하는 세그먼트의 번호
```

#### Limit (크기 제한)
```
이 세그먼트의 크기

예) Limit = 280
→ 이 세그먼트는 최대 280바이트만 사용 가능
→ 280바이트를 초과하는 접근은 오류!
```

#### Address (물리 주소)
```
물리 메모리에서 이 세그먼트가 시작하는 주소

예) Address = 120
→ 물리 메모리의 120번지부터 시작
→ 120번지 ~ 399번지 (120 + 280 - 1) 사용

Special: Invalid (I)
→ 이 세그먼트가 메모리에 없음
→ 스왑 영역에 존재함
```

---

## 🔢 세그멘테이션 테이블의 예시

### 예제 상황

```
4개의 세그먼트로 구성된 프로그램:

세그먼트 0 (Main)    : 크기 280바이트
세그먼트 1 (Sub_A)   : 크기 128바이트
세그먼트 2 (Sub_B)   : 크기 170바이트
세그먼트 3 (Data)    : 크기 100바이트 (스왑 영역)

세그멘테이션 테이블:

┌─────────┬─────────┬──────────┐
│ Segment │ Limit   │ Address  │
├─────────┼─────────┼──────────┤
│    0    │  280    │   120    │
│    1    │  128    │   450    │
│    2    │  170    │   630    │
│    3    │  100    │    I     │
└─────────┴─────────┴──────────┘
```

### 메모리 레이아웃

```
물리 메모리:

┌───────────────────┐
│   OS 영역         │  (0 ~ 119)
├───────────────────┤
│ Segment 0         │  (120 ~ 399) ← Address 120, Limit 280
│ (Main, 280B)      │
├───────────────────┤
│                   │  (400 ~ 449) - 빈 공간
├───────────────────┤
│ Segment 1         │  (450 ~ 577) ← Address 450, Limit 128
│ (Sub_A, 128B)     │
├───────────────────┤
│                   │  (578 ~ 629) - 빈 공간
├───────────────────┤
│ Segment 2         │  (630 ~ 799) ← Address 630, Limit 170
│ (Sub_B, 170B)     │
├───────────────────┤
│ Segment 3         │  스왑 영역 (메모리에 없음)
│ (Data)     X      │
├───────────────────┤
│                   │
└───────────────────┘
```

### 각 세그먼트의 범위

```
세그먼트 0:
  시작: 120번지
  크기: 280바이트
  범위: 120 ~ 399번지

세그먼트 1:
  시작: 450번지
  크기: 128바이트
  범위: 450 ~ 577번지

세그먼트 2:
  시작: 630번지
  크기: 170바이트
  범위: 630 ~ 799번지

세그먼트 3:
  상태: Invalid (I)
  의미: 현재 메모리에 없음, 스왑 영역에 있음
```

---

## 🔍 주소 변환 과정

### 과정

```
Step 1: 가상 주소 분석
        세그먼트 번호와 오프셋으로 분해
        
Step 2: 세그멘테이션 테이블 조회
        해당 세그먼트의 정보 찾기
        
Step 3: 유효성 검사
        - Limit 확인: 오프셋 < Limit인가?
        - Address 확인: Invalid 아닌가?
        
Step 4: 주소 변환
        물리 주소 = Address + Offset
        
Step 5: 메모리 접근
        변환된 물리 주소로 데이터 접근
```

### 예시: 가상 주소 32번 접근

```
프로세스가 "세그먼트 0의 오프셋 32번" 접근

Step 1: 가상 주소 분석
        세그먼트 번호: 0
        오프셋: 32

Step 2: 세그멘테이션 테이블 조회
        세그먼트 0 찾음
        ├─ Limit: 280
        ├─ Address: 120
        └─ Status: Valid (I 아님)

Step 3: 유효성 검사
        32 < 280? → YES ✓ (범위 내)
        Address = 120? → YES ✓ (메모리에 있음)

Step 4: 주소 변환
        물리 주소 = 120 + 32 = 152

Step 5: 메모리 접근
        물리 주소 152번지에서 데이터 읽기
        ✅ 성공!
```

---

## 🚫 Limit과 오류 처리

### Limit의 역할

```
Limit = 세그먼트가 사용할 수 있는 최대 크기
```

### Limit 초과 시 오류

```
상황: 세그먼트 0의 오프셋 300번 접근

Step 1: Limit 검사
        오프셋 300 < Limit 280?
        300 < 280? → NO ✗

Step 2: 오류 발생
        ⚠️ Segmentation Fault 발생!
        
Step 3: 프로세스 종료
        프로그램 강제 종료
```

### Invalid 상태

```
상황: 세그먼트 3 접근

Step 1: 테이블 확인
        세그먼트 3의 Address: I (Invalid)
        
Step 2: 상태 확인
        메모리에 없음! 스왑 영역에 있음
        
Step 3: 처리
        ⚠️ 페이지 폴트 발생!
        스왑에서 메모리로 로드 필요
```

---

## 🔄 세그멘테이션의 장점

### 1️⃣ 논리적 의미 부여

```
프로그래머 입장에서 이해하기 쉬움

예) "함수 A의 데이터"라고 명확히 구분
```

### 2️⃣ 메모리 보호

```
Limit으로 각 세그먼트의 범위를 명확히 제한

예) 세그먼트 0이 세그먼트 1의 영역을 침범할 수 없음
```

### 3️⃣ 페이지 테이블 크기 감소

```
페이징:
- 100개 페이지 → 100개 항목 필요

세그멘테이션:
- 4개 세그먼트 → 4개 항목만 필요

장점: 메모리 절약, 관리 간단
```

### 4️⃣ 내부 단편화 최소화

```
각 세그먼트가 정확한 크기로 할당

예) 300바이트 필요 → 정확히 300바이트 할당
(페이징처럼 4KB를 낭비하지 않음)
```

---

## ⚠️ 외부 단편화(External Fragmentation)

### 개념

```
메모리 전체는 충분하지만, 연속된 빈 공간이 없어서
새 세그먼트를 할당할 수 없는 상황
```

### 예시

```
상황 1: 초기 상태

┌──────────────┐
│ Segment 0    │ (280B) - 120~399
├──────────────┤
│ Segment 1    │ (128B) - 450~577
├──────────────┤
│ Segment 2    │ (170B) - 630~799
├──────────────┤
│ 빈 공간      │ (400B)
└──────────────┘

상황 2: 세그먼트 2가 종료됨

┌──────────────┐
│ Segment 0    │ (280B) - 120~399
├──────────────┤
│ Segment 1    │ (128B) - 450~577
├──────────────┤
│ 빈 공간      │ (170B) ← 세그먼트 2가 해제됨
├──────────────┤
│ 빈 공간      │ (400B)
└──────────────┘

총 빈 공간: 570B (충분함!)

상황 3: 400B 크기 세그먼트 4 추가

문제!
세그먼트 4를 어디 넣을까?
- 630~799 (170B) → 너무 작음!
- 나머지 (400B) → 정확히 맞음!

하지만 170B의 빈 공간은?
→ 아무도 쓸 수 없음!
→ 이것이 외부 단편화!
```

### 외부 단편화가 생기는 이유

```
세그멘테이션은 가변 크기이기 때문:

1. 다양한 크기의 세그먼트 배치
2. 일부 세그먼트 종료
3. 남은 빈 공간이 나머지 세그먼트와 맞지 않음
4. 빈 공간 낭비

반면 페이징은:
- 모두 같은 크기 (예: 4KB)
- 4KB가 비면 다음 4KB 세그먼트가 들어감
- 외부 단편화 발생 X
```

---

## 🛠️ 외부 단편화 해결

### 메모리 압축(Compaction)

```
떨어진 빈 공간을 모아서 하나로 만드는 작업

압축 전:
┌──────────────┐
│ Segment 0    │
├──────────────┤
│ 빈 공간 (170B)
├──────────────┤
│ Segment 1    │
├──────────────┤
│ 빈 공간 (400B)
└──────────────┘

↓ 압축

┌──────────────┐
│ Segment 0    │
├──────────────┤
│ Segment 1    │
├──────────────┤
│ 빈 공간 (570B) ← 연속된 공간!
└──────────────┘

→ 이제 400B 세그먼트를 할당할 수 있음!
```

### 단점

```
압축은 비용이 큼:
1. CPU 자원 많이 사용
2. 프로세스 속도 저하
3. 주기적으로 수행 필요
4. 복잡한 관리

예) 메모리 최적화 작업
(Windows: 디스크 조각 모음과 유사)
```

---

## 📊 세그멘테이션 vs 페이징 비교

| 특징 | 세그멘테이션 | 페이징 |
|------|-----------|--------|
| **분할 방식** | 가변 크기 | 고정 크기 |
| **분할 기준** | 프로세스 요구 | 일정 크기 (4KB) |
| **페이지 테이블 크기** | 작음 ⭐ | 큼 |
| **내부 단편화** | 없음 ⭐ | 있음 |
| **외부 단편화** | 있음 | 없음 |
| **메모리 보호** | 우수 (Limit) ⭐ | 보통 |
| **관리 복잡도** | 복잡 | 간단 ⭐ |
| **논리적 의미** | 있음 ⭐ | 없음 |
| **추가 관리** | 압축 필요 | 불필요 |

---

## 🎓 핵심 용어

| 용어 | 설명 |
|------|------|
| **Segment** | 의미 있는 크기의 메모리 단위 |
| **Limit** | 세그먼트의 최대 크기 제한 |
| **Address** | 물리 메모리에서 세그먼트의 시작 주소 |
| **Offset** | 세그먼트 내에서의 상대 위치 |
| **External Fragmentation** | 총 빈 공간은 있지만 연속되지 않은 상태 |
| **Compaction** | 메모리 압축으로 단편화 해결 |
| **Invalid** | 세그먼트가 메모리에 없고 스왑에 있는 상태 |
| **Segmentation Fault** | 범위를 초과하는 접근 오류 |

---

## 💡 실생활 비유

### 도서관 책 배치

```
페이징 방식:
모든 책을 정확히 20cm 높이의 칸에 정렬
→ 작은 책은 공간 낭비
→ 관리는 간단

세그멘테이션 방식:
각 책의 높이에 맞춰 칸의 높이 조정
→ 공간 낭비 없음
→ 하지만 책을 넣고 빼다 보면 중간에 빈 공간 생김
→ 주기적으로 책들을 정렬해야 함 (압축)
```

---

## ❓ 자주 묻는 질문(FAQ)

**Q: Limit을 초과하면 어떻게 되나요?**

A: Segmentation Fault가 발생하여 프로그램이 강제 종료됩니다. 이것은 버그의 일반적인 원인입니다.

**Q: Invalid 세그먼트는 어떻게 사용하나요?**

A: 페이지 폴트가 발생하여 운영체제가 스왑 영역에서 메모리로 로드합니다. 그 후 정상적으로 사용됩니다.

**Q: 외부 단편화를 항상 해결해야 하나요?**

A: 충분한 연속 공간이 없을 때만 압축합니다. 성능이 저하되므로 필요할 때만 수행합니다.

**Q: 세그멘테이션은 요즘도 사용되나요?**

A: 순수 세그멘테이션은 드물고, 페이징과 혼합한 형태가 많이 사용됩니다.

---