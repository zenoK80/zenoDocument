---
title: 페이징의 주소 변환 실전 가이드
description: 페이징을 이용한 실제 주소 변환 과정을 단계별로 풀어 설명합니다. 계산 예시로 완전히 이해해봅시다.
slug: paging-address-translation-practice
sidebar_position: 4
date: 2024-01-15
---

## 🎯 이번 시간의 목표

- 페이징을 이용한 주소 변환을 직접 계산해보기
- 다양한 페이지 크기에서의 계산 이해하기
- 실제 시스템의 주소 변환 과정 배우기
- 이진 연산을 이용한 빠른 계산 방법 학습하기

---

## 🔢 주소 변환의 수학

### 기본 공식

```
페이지 번호 = ⌊가상 주소 ÷ 페이지 크기⌋  (나눗셈)
오프셋 = 가상 주소 % 페이지 크기         (나머지 연산)

물리 주소 = (프레임 번호 × 페이지 크기) + 오프셋
```

### ⌊ ⌋의 의미

```
⌊x⌋ = x 이하의 최대 정수

예) ⌊5.7⌋ = 5
   ⌊10 ÷ 3⌋ = ⌊3.333...⌋ = 3 (몫)
```

### % 연산의 의미

```
a % b = a를 b로 나눈 나머지

예) 10 % 3 = 1  (10 = 3×3 + 1)
   18 % 10 = 8  (18 = 1×10 + 8)
```

---

## 📊 예시 1: 페이지 크기 512 바이트

### 시스템 설정

```
페이지 크기: 512 바이트
가상 주소: 2049번

계산 방법: 2049를 512로 나눔
```

### 단계별 계산

```
Step 1: 페이지 번호 계산
        2049 ÷ 512 = 4.001953...
        페이지 번호 = ⌊4.001953...⌋ = 4
        
Step 2: 오프셋 계산
        2049 % 512 = 1
        오프셋 = 1
        
        검증: 4 × 512 + 1 = 2048 + 1 = 2049 ✓

결론: 가상 주소 2049 = 페이지 4의 오프셋 1
```

### 그림으로 이해하기

```
메모리 레이아웃 (페이지 크기 512B):

페이지 0: [0      ~ 511]      ┐
페이지 1: [512    ~ 1023]     │
페이지 2: [1024   ~ 1535]     │ 쭉 올라감
페이지 3: [1536   ~ 2047]     │
페이지 4: [2048   ~ 2559]  ← 여기!
페이지 5: [2560   ~ 3071]     │
...       ...                  ┘

페이지 4의 시작은 2048이고,
2048에서 1바이트 떨어진 곳이 2049이다.
따라서 페이지 4의 오프셋 1 = 주소 2049 ✓
```

---

## 📊 예시 2: 페이지 크기 4096 바이트 (4KB)

### 시스템 설정

```
페이지 크기: 4096 바이트 (현대 시스템 표준)
가상 주소: 897,654번
```

### 단계별 계산

```
Step 1: 페이지 번호 계산
        897,654 ÷ 4096 = 219.144...
        페이지 번호 = ⌊219.144...⌋ = 219
        
Step 2: 오프셋 계산
        897,654 % 4096 = 631
        오프셋 = 631
        
        검증: 219 × 4096 + 631 = 897,024 + 631 = 897,655
        어? 1이 모자라네요?
        
        다시 계산: 897,654 - (219 × 4096)
                 = 897,654 - 897,024
                 = 630 ✓

결론: 가상 주소 897,654 = 페이지 219의 오프셋 630
```

### 메모리 레이아웃

```
페이지 219: [219×4096 ~ 219×4096+4095]
           = [897,024 ~ 901,119]

이 범위 내에서 897,654는
897,654 - 897,024 = 630번째 위치
```

---

## 🔄 페이지 테이블을 이용한 완전한 변환

### 상황 설정

```
페이지 크기: 1KB (1024 바이트)
가상 메모리: 64KB (페이지 0~63)
물리 메모리: 4개 프레임 (프레임 0~3)

페이지 테이블:
┌─────────────┬─────────────┐
│ 페이지 번호 │ 프레임 번호 │
├─────────────┼─────────────┤
│      0      │      2      │
│      1      │      3      │
│      2      │      1      │
│      3      │      0      │
│      4      │   스왑 영역 │
└─────────────┴─────────────┘
```

### 가상 주소 1364번을 접근하는 과정

```
┌─────────────────────────────────────────────┐
│ Step 1: 가상 주소를 페이지와 오프셋으로 분해 │
└─────────────────────────────────────────────┘

가상 주소: 1364
페이지 크기: 1024

페이지 번호 = ⌊1364 ÷ 1024⌋ = ⌊1.33...⌋ = 1
오프셋 = 1364 % 1024 = 340

가상 주소 1364 = 페이지 1의 오프셋 340


┌──────────────────────────────────┐
│ Step 2: 페이지 테이블에서 검색   │
└──────────────────────────────────┘

페이지 1을 찾음
↓
페이지 1은 프레임 3에 있다!


┌─────────────────────────────────────────┐
│ Step 3: 물리 주소 계산                   │
└─────────────────────────────────────────┘

물리 주소 = (프레임 번호 × 페이지 크기) + 오프셋
         = (3 × 1024) + 340
         = 3072 + 340
         = 3412

✅ 최종 결과: 물리 주소 3412에서 데이터를 읽음
```

---

## 🎓 단계별 상세 해설

### 왜 이런 방식일까?

```
이유 1: 모듈러 연산의 특성
   페이지와 오프셋을 분리할 수 있기 때문에
   큰 주소도 쉽게 관리 가능

이유 2: 빠른 계산
   모두 이진 연산으로 변환 가능
   (컴퓨터가 매우 빠르게 처리 가능)

이유 3: 주소 변환의 일관성
   페이지 크기가 같으면
   오프셋은 항상 같다
```

---

## 📐 이진 연산을 이용한 빠른 계산

### 페이지 크기가 2의 거듭제곱일 때

```
페이지 크기 = 2ⁿ (예: 4KB = 2¹² bytes)

이진 연산 사용:
- 페이지 번호 = 가상 주소 >> n (오른쪽으로 n칸 이동)
- 오프셋 = 가상 주소 & ((1 << n) - 1) (마스킹)
```

### 예시: 페이지 크기 4KB (2¹²)

```
가상 주소: 897,654 (이진수: 11011011010111000110)

Step 1: 페이지 번호 (오른쪽으로 12칸 이동)
        897654 >> 12 = 219

Step 2: 오프셋 (하위 12비트만 추출)
        897654 & 0xFFF = 630
        (0xFFF = 2¹² - 1)

결과: 페이지 219의 오프셋 630
```

### 왜 이진 연산이 빠를까?

```
CPU 입장에서:
- 이진 시프트 (>>) = 매우 빠름 (1사이클)
- 비트 마스킹 (&) = 매우 빠름 (1사이클)

vs

- 나눗셈 (÷) = 느림 (여러 사이클)
- 나머지 연산 (%) = 느림 (여러 사이클)

따라서 페이지 크기를 2의 거듭제곱으로 설계!
```

---

## 🔀 다양한 페이지 크기에서의 계산

### 페이지 크기 512B (2⁹)인 경우

```
가상 주소 2049를 처리:

페이지 번호 = 2049 >> 9 = 4
오프셋 = 2049 & 0x1FF = 1
       (0x1FF = 2⁹ - 1 = 511)

검증: (4 × 512) + 1 = 2049 ✓
```

### 페이지 크기 4KB (2¹²)인 경우

```
가상 주소 12,345를 처리:

페이지 번호 = 12345 >> 12 = 3
오프셋 = 12345 & 0xFFF = 57
       (0xFFF = 2¹² - 1 = 4095)

검증: (3 × 4096) + 57 = 12288 + 57 = 12345 ✓
```

### 페이지 크기 8KB (2¹³)인 경우

```
가상 주소 65,537을 처리:

페이지 번호 = 65537 >> 13 = 8
오프셋 = 65537 & 0x1FFF = 1
       (0x1FFF = 2¹³ - 1 = 8191)

검증: (8 × 8192) + 1 = 65536 + 1 = 65537 ✓
```

---

## 🖥️ 32비트 CPU 시스템의 실제 예시

### 시스템 사양

```
CPU: 32비트
페이지 크기: 1KB (2¹⁰)
가상 메모리: 2³² = 4GB
물리 메모리: 1GB (약 1,000개의 프레임)

가상 주소 구성:
┌──────────────────┬────────────┐
│  페이지 번호(22비트) │ 오프셋(10비트) │
├──────────────────┼────────────┤
│   상위 22비트      │  하위 10비트 │
└──────────────────┴────────────┘

의미:
- 페이지: 0 ~ 2²²-1 = 약 400만 개
- 오프셋: 0 ~ 1023 (페이지 내 위치)
```

### 가상 주소 980번 변환

```
Step 1: 이진 표현
        980 = 0000000000011110100100₂

Step 2: 페이지 번호 추출 (상위 22비트)
        0000000000011110₂ = 15
        페이지 번호 = 15

Step 3: 오프셋 추출 (하위 10비트)
        0100100₂ = 36
        오프셋 = 36
        
        검증: 15 × 1024 + 36 = 15360 + 36 = 15396
        어? 980이 아니네요?
        
        다시: 980 ÷ 1024 = 0 (나머지 980)
        페이지 번호 = 0
        오프셋 = 980
```

---

## 📋 페이지 번호와 오프셋의 비트 관계

### 핵심: 비트 위치 결정

```
페이지 크기 = 2ⁿ 일 때:
- 오프셋 비트 수 = n (하위 n비트)
- 페이지 번호 비트 = 남은 모든 비트

예) 32비트 주소, 페이지 크기 4KB (2¹²)
    ┌─────────────────────────┬────────────────┐
    │  페이지 번호 (20비트)    │  오프셋 (12비트) │
    └─────────────────────────┴────────────────┘
    
    페이지 번호가 2²⁰ = 약 100만개
    오프셋이 2¹² = 4096
```

---

## 🎯 연습 문제

### 문제 1: 기본 계산

```
페이지 크기: 512 바이트
가상 주소: 1537

Q: 이 주소를 페이지와 오프셋으로 나타내세요.

풀이:
페이지 번호 = 1537 ÷ 512 = 3 (나머지 1)
오프셋 = 1537 % 512 = 1

A: 페이지 3의 오프셋 1
```

### 문제 2: 페이지 테이블 활용

```
페이지 테이블:
페이지 | 프레임
-------|-------
  0    |   1
  1    |   5
  2    |   3
  3    |   0

페이지 크기: 512바이트
가상 주소: 1537

Q: 물리 주소는?

풀이:
1. 페이지 3의 오프셋 1 (위의 문제 1 결과)
2. 페이지 3 → 프레임 0
3. 물리 주소 = (0 × 512) + 1 = 1

A: 물리 주소 1번
```

### 문제 3: 4KB 페이지

```
페이지 크기: 4KB (4096 바이트)
가상 주소: 8,192

Q: 페이지 번호와 오프셋은?

풀이:
페이지 번호 = 8192 ÷ 4096 = 2
오프셋 = 8192 % 4096 = 0

A: 페이지 2의 오프셋 0
   (정확히 페이지 2의 시작점)
```

---

## 💡 실무 팁

### 계산을 빠르게 하는 방법

```
1. 페이지 크기가 2의 거듭제곱인지 확인
   → 2ⁿ 형태면 이진 연산 사용 가능

2. 2의 거듭제곱인 경우:
   n = log₂(페이지 크기)
   페이지 번호 = 주소 >> n
   오프셋 = 주소 & ((1 << n) - 1)

3. 일반적인 페이지 크기:
   512B = 2⁹   → n = 9
   4KB = 2¹²   → n = 12
   8KB = 2¹³   → n = 13
```

---

## 🎓 핵심 정리

| 개념 | 공식 |
|------|------|
| **페이지 번호** | ⌊주소 ÷ 페이지 크기⌋ |
| **오프셋** | 주소 % 페이지 크기 |
| **물리 주소** | (프레임 번호 × 페이지 크기) + 오프셋 |
| **빠른 계산** | 비트 시프트와 마스킹 |

---

## ❓ 자주 묻는 질문(FAQ)

**Q: 왜 항상 페이지 크기를 2의 거듭제곱으로 설정하나요?**

A: 이진 연산으로 빠르게 계산할 수 있기 때문입니다. 컴퓨터는 이진 연산을 가장 잘 합니다.

**Q: 이 계산을 수동으로 자주 해야 하나요?**

A: 아니요, CPU와 운영체제가 자동으로 합니다. 하지만 원리를 이해하면 시스템을 더 잘 이해할 수 있습니다.

**Q: 어떤 페이지 크기가 최고일까요?**

A: 일반적으로 4KB가 표준이지만, 용도에 따라 다릅니다:
- 작은 페이지: 유연성 높음, 관리 복잡
- 큰 페이지: 관리 간단, 낭비 많음

---
