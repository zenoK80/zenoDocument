---
title: '질의어 최적화기와 실행 계획'
description: '같은 SQL도 여러 방법으로 실행할 수 있다! 가장 빠른 방법을 찾는 과정을 배워봅시다'
slug: 'database/query-optimizer'
sidebar_label: '질의어 최적화기'
sidebar_position: 4
date: '2025-02-01'
---

# 질의어 최적화기와 실행 계획

## 🎯 이번 시간의 핵심

**같은 목표라도 가는 길은 여러 개!**

집에서 학교까지 가는 방법이 여러 개 있듯이,
SQL도 같은 결과를 얻는 방법이 **여러 가지**입니다.

그중에서 **가장 빠르고 효율적인 방법을 선택**하는 것이 최적화입니다!

---

## 🚗 비유로 이해하기

### 집에서 아르바이트 장소까지 가는 경로

```
              도서관
               /|\
              / | \
             /  |  \
            /   |   \
           /    |    \
       [A점]←←←←●←←←←[B점]
           \    |    /
            \   |   /
             \  |  /
              \ | /
            공원(?)
```

**여러 경로가 있습니다:**
- 경로 1: 직진 → 최단거리
- 경로 2: 도서관을 거쳐감 → 멀지만 조용함
- 경로 3: 버스 탑승 → 빠름
- 경로 4: 자전거 이용 → 보통
- 경로 5: 공원을 거쳐감 → 가장 먼 거리

**질문**: 어떤 경로를 선택할까요?
- 시간이 부족하면 → 버스 (경로 3) ⏱️
- 돈을 아껴야 하면 → 직진 (경로 1) 💰
- 건강을 생각하면 → 걷기 (경로 1 또는 4) 🏃

:::tip 여기서 배우는 교훈
상황에 따라 **최적의 선택**이 달라진다!
:::

---

## 📊 SQL 실행의 여러 가지 방법

### 예시: 남자 학생 중 서울 지역 학생 찾기

```sql
SELECT 학번 FROM 학생 
WHERE 성별='남자' AND 지역='서울';
```

### 가능한 실행 계획들

#### 🔵 계획 1: 성별 먼저 찾기
```
학생 테이블 (100명)
    ⬇️ [성별='남자'] 필터링
남자 학생들 (10명)
    ⬇️ [지역='서울'] 필터링
결과: 남자 중 서울 지역 학생 (?)명
```

#### 🟢 계획 2: 지역 먼저 찾기
```
학생 테이블 (100명)
    ⬇️ [지역='서울'] 필터링
서울 지역 학생들 (50명)
    ⬇️ [성별='남자'] 필터링
결과: 서울 중 남자 학생 (?)명
```

#### 🟡 계획 3: 동시에 찾기
```
학생 테이블 (100명)
    ⬇️ [성별='남자' AND 지역='서울'] 동시 필터링
결과: 조건을 모두 만족하는 학생 (?)명
```

---

## 🏆 어떤 계획이 가장 좋을까?

### 선택도(Selectivity) 개념

:::info 선택도란?
전체 데이터 중에서 **조건을 만족하는 데이터의 비율**입니다!
:::

### 예시 데이터
- 전체 학생: **100명**
- 남자 학생: **10명** (선택도 = 10%)
- 서울 지역: **50명** (선택도 = 50%)

### 각 계획의 효율성

#### 📈 계획 1 분석 (성별 먼저)
```
100명 전체에서 확인
  ⬇️ 남자만 추출 (10%)
  ⬇️ 10명만 남음
  ⬇️ 이 10명 중에서 서울 찾기 ← 10명만 비교하면 됨!
```
**효율**: ⭐⭐⭐⭐⭐ (가장 좋음!)

#### 📉 계획 2 분석 (지역 먼저)
```
100명 전체에서 확인
  ⬇️ 서울만 추출 (50%)
  ⬇️ 50명이 남음
  ⬇️ 이 50명 중에서 남자 찾기 ← 50명을 비교해야 함
```
**효율**: ⭐⭐⭐ (보통)

#### 📊 계획 3 분석 (동시에)
```
100명을 하나씩 확인
  ⬇️ "남자야?" "서울이야?" 동시에 확인
  ⬇️ 100번의 복잡한 확인 작업
```
**효율**: ⭐⭐ (별로임)

### 💡 결론
:::success 최고의 선택
**선택도가 작은 조건을 먼저 실행하세요!**
- 10%의 선택도(남자) > 50%의 선택도(서울)
- 따라서 **계획 1이 최고의 선택**!
:::

---

## 📚 시스템은 어떻게 알까?

### 데이터 사전(Data Dictionary/Catalog)

:::info 데이터 사전이란?
데이터베이스에 저장된 **"모든 정보에 대한 정보"**입니다!
:::

```
데이터 사전에 저장된 통계 정보:
┌─────────────────────────────────┐
│ 테이블: 학생                      │
├─────────────────────────────────┤
│ 전체 학생: 100명                  │
│ 남자: 10명 (10%)                  │
│ 여자: 90명 (90%)                  │
│ 서울: 50명 (50%)                  │
│ 서울 아닌 곳: 50명 (50%)          │
│ ...기타 통계                      │
└─────────────────────────────────┘
```

### 최적화기의 사고 과정

```javascript
// 최적화기의 의사코드
function optimizeQuery() {
  // 1. 각 조건의 선택도 조회
  selectivity_남자 = dataDictionary.get('학생.성별', '남자');  // 10%
  selectivity_서울 = dataDictionary.get('학생.지역', '서울');  // 50%
  
  // 2. 선택도 비교
  if (selectivity_남자 < selectivity_서울) {
    // 남자 조건이 더 선택적 → 먼저 실행!
    executePlan_1();  // 성별로 필터링 → 지역으로 필터링
  } else {
    executePlan_2();  // 지역으로 필터링 → 성별로 필터링
  }
}
```

**자동화된 최적화 효과:**
- 사용자가 "좀 더 빠르게 해줘"라고 할 필요 없음 ✓
- 시스템이 **자동으로** 최적의 계획 선택 ✓
- 개발자가 신경 쓸 필요 없음 ✓

---

## 🔄 최적화 과정의 전체 흐름

```
SQL 질의어 입력
    ⬇️
문법 검증 (검사기, 파서)
    ⬇️
┌─────────────────────────────────┐
│ 1️⃣ 내부 형태로 변환              │
│ ├─ 관계 대수로 변환              │
│ └─ 질의 트리(Query Tree) 생성   │
└─────────────────────────────────┘
    ⬇️
┌─────────────────────────────────┐
│ 2️⃣ 여러 실행 계획 생성           │
│ ├─ 계획 1: A 방식                │
│ ├─ 계획 2: B 방식                │
│ └─ 계획 3: C 방식                │
└─────────────────────────────────┘
    ⬇️
┌─────────────────────────────────┐
│ 3️⃣ 후보 선정                      │
│ ├─ 모든 계획을 평가하지 않음      │
│ ├─ 유망한 계획만 선택            │
│ └─ 예: 10개 중 3개만 선택        │
└─────────────────────────────────┘
    ⬇️
┌─────────────────────────────────┐
│ 4️⃣ 비용 계산 및 평가             │
│ ├─ 각 계획의 처리 비용 계산      │
│ ├─ 데이터 사전 정보 참고          │
│ └─ 가장 비용 낮은 계획 선택      │
└─────────────────────────────────┘
    ⬇️
✅ 최적화된 계획 확정
    ⬇️
코드 생성 및 실행
```

---

## 💰 비용 계산 방식

### 어떤 비용을 고려할까?

:::info 환경에 따라 달라집니다
:::

#### 📀 대형 시스템 (방대한 데이터)
```
주요 비용: 디스크 I/O (입출력)
└─ 하드디스크에서 데이터를 꺼내는데 시간이 가장 오래 걸림
└─ CPU는 상대적으로 빠름
```

#### 💻 소형 데이터베이스 (작은 데이터)
```
주요 비용: CPU 처리 시간
└─ 데이터가 작아서 I/O는 빠름
└─ CPU에서 처리하는 연산 시간이 중요
```

#### 🌐 분산 데이터베이스 (네트워크 연결)
```
주요 비용: 네트워크 통신
└─ 서로 다른 장소의 데이터베이스 간 통신이 느림
└─ 불필요한 데이터 전송 줄이기가 중요
```

### 비용식(Cost Function)

```
총 비용 = (I/O 비용) + (CPU 비용) + (메모리 비용) + (통신 비용)
```

**각 항목의 의미:**
- **I/O 비용**: 디스크에서 읽고 쓰는 횟수
- **CPU 비용**: 연산하는데 걸리는 시간
- **메모리 비용**: 메모리 사용량
- **통신 비용**: 네트워크 전송량

---

## 📚 실전 예시

### 예제: 학생 정보 조회

```sql
SELECT 이름 
FROM 학생 
WHERE 점수 >= 80 AND 성별 = '여자';
```

### 최적화기의 분석

**Step 1: 데이터 사전 조회**
```
전체 학생: 1000명
점수 >= 80인 학생: 200명 (20% 선택도)
성별 = '여자': 500명 (50% 선택도)
```

**Step 2: 실행 계획 생성**
```
계획 A: 먼저 점수(20%) → 그 다음 성별(50%)
  - 1000 → 200 → 약 100명

계획 B: 먼저 성별(50%) → 그 다음 점수(20%)
  - 1000 → 500 → 약 100명

계획 C: 동시에 처리
  - 1000명 각각 2가지 조건 확인
```

**Step 3: 후보 선정**
```
계획 A, B 만 평가 (계획 C는 분명히 비효율적)
```

**Step 4: 비용 계산**
```
계획 A: 200명 읽기 비용 < 계획 B: 500명 읽기 비용
→ 계획 A 선택! ✓
```

**최종 실행 방식:**
```
1. 점수 >= 80인 학생 필터링 (200명)
2. 그 중 성별 = '여자'인 학생 필터링 (약 100명)
3. 100명의 이름만 추출해서 화면에 출력
```

---

## 🎯 핵심 요점 정리

:::note 꼭 기억하세요!

**1. 같은 SQL도 여러 방법으로 실행 가능**
- 계획 1: A 조건 먼저
- 계획 2: B 조건 먼저
- 계획 3: 동시에

**2. 선택도(Selectivity)가 낮은 조건부터 실행**
- 10% 선택도 > 50% 선택도
- 더 많은 데이터를 필터링하는 조건부터!

**3. 시스템이 자동으로 최적화**
- 데이터 사전의 통계 정보 활용
- 개발자가 신경 쓸 필요 없음

**4. 환경에 따라 비용 계산 방식 달라짐**
- 대형 시스템: I/O 비용 중심
- 소형 DB: CPU 비용 중심
- 분산 DB: 통신 비용 중심

**5. 모든 계획을 평가하지 않음**
- 유망한 계획만 후보로 선정
- 그 중 최고 비용 효율의 계획 선택
:::

---

## 💡 생각해보기

**문제**: 다음 두 경우 중 어느 것이 더 효율적일까요?

```sql
-- SQL 1: 성별로 먼저 필터링
SELECT 학번 FROM 학생 
WHERE 성별='남자' AND 점수>90;

-- 상황: 남자 1%, 점수>90 1%
```

<details>
<summary>정답 보기</summary>

두 조건의 선택도가 같으므로 (모두 1%), **어느 것을 먼저 해도 결과는 비슷**합니다.

하지만 시스템은 추가 요소를 고려합니다:
- 인덱스 있는가?
- 메모리에 이미 로드되어 있는가?
- 캐시에 있는가?

이런 것들을 종합하면 최적의 계획이 선택됩니다!

</details>

---

**작성일**: 2025-02-01  
**난이도**: ⭐⭐⭐ (약간의 노력 필요)