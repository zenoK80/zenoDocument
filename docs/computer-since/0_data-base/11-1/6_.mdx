---
title: '경험적 최적화와 데이터베이스 성능'
description: '실무에서 검증된 경험 규칙들을 활용하여 SQL을 효율적으로 처리하는 방법'
slug: 'database/heuristic-optimization'
sidebar_label: '경험적 최적화'
sidebar_position: 6
date: '2025-02-02'
---

# 경험적 최적화와 데이터베이스 성능

## 경험이 만드는 최적화의 힘

데이터베이스 시스템은 수십 년 동안 수많은 SQL 쿼리를 처리하면서 축적한 경험이 있습니다. 이 경험들로부터 나온 규칙들을 "휴리스틱 규칙"이라고 부르며, 이를 활용하는 최적화 방식을 경험적 최적화라고 합니다. 마치 우리가 집에서 학교까지 가는 길을 매일 다니다 보면 "어느 시간대에 어느 길이 빠른지" 자연스럽게 알게 되는 것처럼, 데이터베이스도 일반적으로 효율적인 처리 방식들을 규칙화했습니다.

경험적 최적화의 가장 큰 장점은 계산이 간단하다는 것입니다. 복잡한 수학적 계산 없이 누구나 이해할 수 있는 규칙들을 따르기만 하면 충분히 좋은 성능을 얻을 수 있습니다. 또한 이러한 규칙들은 시간이 지나면서 검증되었기 때문에 대부분의 상황에서 예측 가능한 결과를 만들어냅니다. 이것이 경험적 최적화가 비용 기반 최적화와 함께 가장 널리 사용되는 이유입니다.

## 선택 연산을 가능한 한 먼저 처리하기

가장 기본이 되는 경험 규칙은 WHERE 절의 조건을 가능한 한 먼저 적용하는 것입니다. 이 규칙의 핵심은 데이터를 필터링하면 뒤이은 연산에서 처리해야 할 데이터의 양이 줄어든다는 단순하지만 강력한 원리에 있습니다.

구체적인 예를 들어봅시다. 학생 테이블에 1000명의 데이터가 있다고 가정합니다. 비효율적인 방식은 모든 학생 데이터를 먼저 메모리에 로드한 후 필터링 조건을 적용하는 것입니다. 이 경우 1000명의 전체 레코드를 읽고, 그 다음에 1000명에 대해 필터링을 수행합니다. 만약 4학년만 필요하다면 이 작업은 완전히 낭비입니다.

반면 효율적인 방식은 데이터베이스에게 처음부터 4학년만 달라고 하는 것입니다. 이렇게 하면 데이터베이스는 4학년에 해당하는 약 100명의 레코드만 로드합니다. 저장 공간에서부터 네트워크 전송까지 모든 과정이 줄어듭니다. 시간으로 비교하면 비효율적 방식이 약 2000단위의 시간이 필요하다면, 효율적 방식은 100단위의 시간만 필요하므로 약 20배의 성능 향상을 기대할 수 있습니다.

이 규칙이 강력한 이유는 매우 일반적으로 적용 가능하다는 것입니다. 대부분의 SQL 쿼리에는 WHERE 절이 있고, 그 조건들을 먼저 적용하면 항상 성능이 향상됩니다.

## 카티션 곱셈의 위험성과 조인 연산의 필요성

두 개 이상의 테이블을 다룰 때 가장 주의해야 할 함정이 카티션 곱셈입니다. 카티션 곱셈은 두 테이블의 모든 행을 조합하는 연산으로, 첫 번째 테이블의 각 행이 두 번째 테이블의 모든 행과 만나게 됩니다. 만약 학생 테이블에 1000행이 있고 성적 테이블에 5000행이 있다면, 이를 카티션 곱셈하면 5,000,000행이 생성됩니다.

이 문제는 다음과 같은 SQL에서 발생합니다. SELECT 모든 것을 학생과 성적에서 WHERE 학생의 학번이 성적의 학번과 같을 때 선택하는 것입니다. 이 문구는 언뜻 조인처럼 보이지만, 실제로는 먼저 카티션 곱셈으로 5,000,000행을 만들고 나서 그 중에서 조건에 맞는 약 1000행만 남깁니다. 이는 엄청난 낭비입니다.

올바른 방식은 JOIN 키워드를 명시적으로 사용하는 것입니다. 이렇게 하면 데이터베이스는 카티션 곱셈을 하지 않고 직접 학번이 같은 행들끼리만 연결합니다. 결과는 동일하지만 중간 과정에서 5,000,000행을 만들 필요가 없습니다. 더 나아가, 추가 조건이 있다면 그 조건을 JOIN 전에 적용할 수도 있습니다. 예를 들어, 점수가 80 이상인 성적 레코드만 먼저 추출한 후 조인하면, 조인해야 할 데이터의 양을 더욱 줄일 수 있습니다.

## 프로젝션으로 필요한 데이터만 추출하기

SELECT 절에서 필요한 컬럼만 명시하는 것도 중요한 경험 규칙입니다. 학생 테이블을 예로 들면, 학번, 이름, 주소, 전화, 이메일, 생년월일 등 많은 컬럼을 포함할 수 있습니다. 각 학생당 약 500바이트의 데이터가 필요하다면, 1000명의 학생 전체 정보는 500메가바이트가 됩니다.

하지만 만약 이름만 필요하다면 이름 컬럼의 크기가 약 20바이트이므로, 1000명의 이름만으로 20메가바이트면 충분합니다. 이는 전체 데이터의 4퍼센트에 불과합니다. 네트워크 대역폭이 제한된 분산 시스템에서는 이러한 차이가 매우 중요합니다.

또 다른 측면은 메모리 사용입니다. 데이터베이스 시스템은 메모리에 데이터를 캐싱합니다. 500메가바이트의 전체 데이터를 캐싱하는 것과 20메가바이트의 필요한 데이터만 캐싱하는 것은 캐시 효율성에서 큰 차이를 만듭니다. 더 많은 데이터가 메모리에 머물 수 있으므로 디스크 접근 횟수가 줄어듭니다.

## 조건의 순서를 선택도에 따라 최적화하기

여러 조건이 AND로 연결되어 있을 때, 그 조건들의 처리 순서를 최적화하는 것도 중요합니다. 이때 사용하는 개념이 선택도입니다. 선택도는 전체 데이터 중에서 특정 조건을 만족하는 데이터의 비율을 의미합니다.

예를 들어, 다음과 같은 쿼리를 생각해봅시다. 성별이 남자이고, 점수가 90 이상이며, 학과가 AI인 학생을 찾는 것입니다. 1000명의 학생 중에서 남자는 500명으로 선택도가 50퍼센트이고, 점수 90 이상인 학생은 100명으로 10퍼센트이며, AI 학과는 50명으로 5퍼센트라고 가정합시다.

순서대로 처리하면 먼저 500명의 남자를 필터링합니다. 그 다음 그 500명 중에서 점수 90 이상인 약 50명을 찾습니다. 마지막으로 그 50명 중에서 AI 학과인 약 2.5명을 찾습니다. 이 과정에서 총 1000더하기 500더하기 50, 즉 1550명을 처리합니다.

반면 선택도가 낮은 순서대로 처리하면 어떻게 될까요? 먼저 AI 학과 50명을 필터링합니다. 그 50명 중에서 점수 90 이상인 약 5명을 찾습니다. 마지막으로 그 5명 중에서 남자인 약 2.5명을 찾습니다. 이 경우 총 처리량은 1000더하기 50더하기 5, 즉 1055명입니다. 약 32퍼센트의 감소를 달성합니다.

더 극단적인 예를 생각해보면, 선택도가 0.1퍼센트인 조건부터 처리한다면 거의 모든 데이터를 빠르게 제외할 수 있습니다. 따라서 경험적으로 가장 선택적인 조건부터 처리하는 것이 최고의 전략입니다.

## 실무에서의 최적화 사례

대규모 전자상거래 시스템을 예시로 들어봅시다. 사용자가 "지난 3개월간 구매한 상품 중 3만 원 이상 10만 원 이하이면서 배송이 완료된 상품의 리뷰를 작성하지 않은 것"을 찾는다고 합시다. 이는 여러 테이블의 조인과 많은 필터 조건을 포함합니다.

최적화되지 않은 접근 방식은 모든 주문 테이블과 모든 상품 테이블을 조인하고, 모든 리뷰 테이블까지 포함한 후 조건들을 적용하는 것입니다. 만약 전체 주문이 천만 건이라면 이는 엄청난 계산량입니다.

경험적 최적화를 적용하면 먼저 "리뷰를 작성하지 않은 상품"이라는 가장 선택적인 조건을 적용합니다. 이를 통해 데이터를 99퍼센트 줄일 수 있습니다. 그 다음 "배송이 완료된" 조건을 적용하고, 그 다음 "지난 3개월간"이라는 시간 조건을 적용합니다. 가격 범위는 마지막에 적용합니다. 이러한 순서로 처리하면 각 단계에서 데이터가 급격히 줄어들어 전체 처리 시간이 극적으로 단축됩니다.

## 경험적 최적화의 한계와 개선점

경험적 최적화가 매우 효과적이지만, 모든 상황에 완벽하게 작동하는 것은 아닙니다. 특수한 경우나 비정상적인 데이터 분포를 가진 상황에서는 경험 규칙이 항상 최고의 선택을 보장하지 못합니다.

또한 경험적 최적화는 데이터 통계에 의존하지 않습니다. 시스템이 각 조건의 실제 선택도를 알 수 없다면, 추정에만 의존해야 합니다. 만약 추정이 실제와 크게 다르다면 최적화 결과가 좋지 않을 수 있습니다. 예를 들어, AI 학과가 실제로는 5퍼센트가 아니라 40퍼센트라면, 선택도에 따른 순서 최적화가 제대로 작동하지 않습니다.

이런 이유로 현대의 데이터베이스 시스템은 경험적 최적화와 비용 기반 최적화를 함께 사용합니다. 먼저 경험적 규칙으로 명백히 비효율적인 계획들을 제거하고, 그 다음 비용 기반 최적화로 나머지 계획들 중에서 정말 최고의 선택을 찾습니다.

## 경험적 최적화의 핵심 원칙들

경험적 최적화를 이루는 기본 원칙들을 정리하면 다음과 같습니다. 첫째, 선택 연산은 가능한 한 먼저 수행합니다. 이는 처리할 데이터의 양을 빠르게 줄이기 때문입니다. 둘째, 카티션 곱셈을 피하고 조인을 명시적으로 사용합니다. 셋째, 필요한 컬럼만 프로젝션하여 메모리와 네트워크 대역폭을 절약합니다. 넷째, 선택도가 낮은 조건부터 처리합니다. 다섯째, 중복되는 연산을 제거합니다.

이러한 원칙들은 모두 같은 목표를 향합니다. 바로 처리해야 할 데이터의 양을 최소화하고, 불필요한 연산을 제거하는 것입니다. 개별 규칙들은 간단하지만, 이를 조합하면 매우 효과적인 최적화를 달성할 수 있습니다.

실제로 이러한 규칙들을 체계적으로 적용하는 과정을 보면, 초기 질의 트리에서부터 시작하여 각 규칙을 하나씩 적용하면서 트리의 구조를 변경합니다. 선택 연산은 테이블 쪽으로 내려가고, 프로젝션은 위로 올라갑니다. 카티션 곱셈은 조인으로 바뀌고, 조건의 순서는 선택도에 따라 재정렬됩니다. 결과적으로 처음에는 복잡해 보이던 쿼리가 매우 효율적인 실행 계획으로 변환됩니다.

## 실습과 검증

경험적 최적화를 제대로 이해하려면 직접 실습해보는 것이 중요합니다. 어떤 SQL 쿼리가 주어졌을 때, 경험적 규칙들을 하나씩 적용해보면서 어떻게 질의 트리가 변환되는지 관찰해봅시다. 예를 들어, 여러 테이블을 조인하는 복잡한 쿼리가 있다면 먼저 현재 쿼리가 어떤 형태의 질의 트리를 만드는지 분석합니다. 그 다음 경험적 규칙을 적용해서 트리를 변환하고, 각 단계에서 처리해야 할 데이터의 양이 어떻게 변하는지 추적합니다.

이러한 과정을 여러 번 반복하면 경험적 최적화가 단순한 이론이 아니라 실제로 효과 있는 기법임을 깨달을 수 있습니다. 또한 특정 상황에서 어떤 규칙이 더 효과적인지도 직관적으로 파악할 수 있게 됩니다.

---

**작성일**: 2025-02-02