---
title: '경험적 최적화(Heuristic Optimization)'
description: '경험에서 나온 검증된 규칙들로 SQL을 효율적으로 처리하는 방법'
slug: 'database/heuristic-optimization'
sidebar_label: '경험적 최적화'
sidebar_position: 6
date: '2025-02-01'
---

# 경험적 최적화 (Heuristic Optimization)

## 🎯 이번 시간의 핵심

**경험에서 나온 "검증된 팁들"을 이용해서 SQL을 빠르게 만드는 방법!**

마치 우리가 학교 가는 길을 많이 다니다 보니 "어느 길이 가장 빠른지" 아는 것처럼,
데이터베이스도 **경험적 규칙들**을 적용합니다!

---

## 🚗 비유로 이해하기

### 일상에서의 경험적 최적화

```
집 → 학교 가는 길 찾기

경험 1: "출근 시간은 항상 길다" ← 지피지기식 최적화
경험 2: "골목길이 빠르다" ← 테스트를 통해 확인
경험 3: "날씨가 좋으면 버스가 덜 밀린다" ← 패턴 인식

결론: "출근 시간에는 골목길로 가자!"
```

### 데이터베이스의 경험적 최적화

```
SQL 실행 경험

경험 1: "조건 먼저 처리하면 빠르다"
경험 2: "필터링은 일찍 할수록 좋다"
경험 3: "큰 곱셈은 마지막에"

규칙화: 휴리스틱 (Heuristic) 규칙
```

:::info 휴리스틱(Heuristic)이란?
**경험과 직관을 바탕으로 최적의 해를 빠르게 찾아내는 기법**

완벽한 해를 찾기보다는 "충분히 좋은" 해를 빠르게 찾는 것!
:::

---

## 📋 경험적 처리 전략의 핵심 규칙

### Rule 1: 선택 연산(Selection)을 가능하면 먼저 해라

#### 원칙
```
WHERE 절의 조건을 가능한 한 먼저 적용하세요!
```

#### 이유
```
조건으로 데이터를 먼저 필터링하면
↓
뒤이은 연산에서 처리할 데이터가 적어짐
↓
전체 처리 시간 단축!
```

#### 예시

##### ❌ 비효율적 (조건을 나중에)
```sql
SELECT * FROM 학생;
-- 1000명을 모두 메모리에 로드
-- 그 다음에 필터링
```

```
[1000명 모두 로드] → [필터링] → [100명 출력]
```

##### ✅ 효율적 (조건을 먼저)
```sql
SELECT * FROM 학생 WHERE 학년=4;
-- 먼저 4학년만 100명을 로드
-- 필터링 불필요
```

```
[100명만 로드] → [바로 출력]
```

**효과 비교:**
| 방식 | 로드 시간 | 필터링 시간 | 총 시간 |
|------|---------|----------|--------|
| ❌ 비효율 | 1000 | 1000 | 2000 |
| ✅ 효율 | 100 | 0 | 100 |
| **개선율** | **10배** | **완전 제거** | **20배!** |

---

### Rule 2: 카티션 곱셈(Cartesian Product)과 선택 연산의 분리

#### 개념 설명

:::info 카티션 곱셈이란?
두 테이블의 모든 행을 조합하는 연산입니다.
(조인의 전단계)
:::

```
테이블 R: 10행
테이블 S: 5행

카티션 곱셈: 10 × 5 = 50행 (모든 조합)
```

#### ❌ 비효율적 방법
```sql
SELECT * FROM 학생, 성적 
WHERE 학생.학번 = 성적.학번;
```

**처리 과정:**
```
1. 학생(1000행) × 성적(5000행) = 5,000,000행 생성!
2. 그 중에서 학번이 같은 것만 필터링
3. 결과: 약 1,000행
```

**문제:** 5,000,000행을 먼저 만들어야 함 💥

#### ✅ 효율적 방법 1: 조인 연산 사용
```sql
SELECT * FROM 학생 
JOIN 성적 ON 학생.학번 = 성적.학번;
```

**처리 과정:**
```
1. 학번이 같은 행들만 직접 연결 (조인)
2. 결과: 약 1,000행
```

**장점:** 불필요한 조합을 만들지 않음! ✓

#### ✅ 효율적 방법 2: 선택 먼저 (가능한 경우)
```sql
SELECT * FROM 학생 
JOIN (SELECT * FROM 성적 WHERE 점수>80) AS 성적
ON 학생.학번 = 성적.학번;
```

**처리 과정:**
```
1. 성적 테이블에서 점수>80인 것만 추출 (100행)
2. 그것과 학생 조인
3. 결과: 약 100행
```

**변환 규칙:**
```
R × S 를 σ(조건) 한 것
↓
조인 연산으로 바꿔라!
R ⨝ S  (조건)
```

---

### Rule 3: 프로젝션 연산(Projection)을 가능하면 먼저 해라

#### 개념
```
프로젝션 = 필요한 컬럼만 추출
```

#### ❌ 비효율적
```sql
SELECT 이름 FROM 학생;
-- 1. 모든 컬럼 로드 (100MB)
-- 2. 이름 컬럼만 필터링 (10MB)
-- 3. 이름만 처리 (10MB)
```

#### ✅ 효율적
```sql
SELECT 이름 FROM 학생;
-- 데이터베이스가 자동으로 최적화
-- 1. 필요한 컬럼(이름)만 로드 (10MB)
-- 2. 바로 처리
```

#### 예시

```
학생 테이블 모든 컬럼:
학번(4byte) + 이름(20byte) + 주소(100byte) 
+ 전화(15byte) + 이메일(50byte) + ... = 500byte/행

1000행 × 500byte = 500MB

vs

이름만 필요:
이름(20byte) × 1000행 = 20MB

→ 25배 용량 감소!
```

---

### Rule 4: AND로 연결된 조건들의 순서 변경

#### 원칙
```
선택도가 낮은 조건부터 먼저 처리!
```

#### 예시

```
WHERE 성별='남자' AND 점수>90 AND 학과='AI'

상황:
- 성별='남자': 선택도 50%
- 점수>90: 선택도 10%
- 학과='AI': 선택도 5%
```

#### ❌ 순서대로 처리
```
100명 → 50명(성별) → 5명(점수) → 0.25명(학과)

처리해야 할 행:
첫 조건: 100행
두 번째: 50행
세 번째: 5행
```

#### ✅ 선택도 낮은 순서 (AI→점수→성별)
```
100명 → 5명(학과) → 0.5명(점수) → 0.25명(성별)

처리해야 할 행:
첫 조건: 100행
두 번째: 5행
세 번째: 0.5행

→ 처리량 급감!
```

**효과:**
```
비효율: 100 + 50 + 5 = 155행 처리
효율: 100 + 5 + 0.5 = 105.5행 처리

→ 약 47% 감소!
```

---

### Rule 5: 합집합(Union) 전에 다른 연산들을 먼저 해라

#### 상황
```sql
SELECT * FROM 학생 WHERE 학년=4
UNION
SELECT * FROM 학생 WHERE 학과='AI';
```

#### ❌ 비효율적: 합집합 먼저
```
[4학년 전체] ∪ [AI학과 전체] → 중복 제거
```

#### ✅ 효율적: 조건을 먼저
```
[4학년 중 AI] ∪ [4학년이 아닌 AI]
```

**효과:**
```
4학년이 아니면서 AI 학과인 학생만 따로 처리
→ 처리량 감소
```

---

## 📊 경험적 최적화 규칙 정리

### 7가지 핵심 규칙

```
┌─────────────────────────────────────────────────────┐
│  경험적 최적화 체크리스트                            │
├─────────────────────────────────────────────────────┤
│ 1. ✓ 선택 연산을 가능하면 먼저 했나?               │
│ 2. ✓ 불필요한 카티션 곱셈은 없나?                 │
│ 3. ✓ 프로젝션으로 필요한 컬럼만 선택했나?         │
│ 4. ✓ AND 조건들의 순서는 최적인가?                │
│ 5. ✓ 합집합 전에 필터링했나?                       │
│ 6. ✓ 중복된 프로젝션이 있나?                       │
│ 7. ✓ 인덱스를 활용할 수 있나?                      │
└─────────────────────────────────────────────────────┘
```

---

## 💡 실전 예시: 전체 최적화 과정

### 원본 SQL

```sql
SELECT 이름, 점수
FROM 학생, 성적, 강의
WHERE 학생.학번 = 성적.학번
  AND 성적.강의번호 = 강의.번호
  AND 점수 > 80
  AND 강의.학과 = 'AI'
  AND 학생.학년 = 4;
```

### Step 1: 초기 질의 트리

```
        π(이름, 점수)
             |
    σ(모든 조건)
             |
    학생 × 성적 × 강의
```

### Step 2: Rule 1 적용 (선택 연산 먼저)

조건들을 분해해서 테이블 가까이에 배치:

```
        π(이름, 점수)
             |
        σ(학년=4)
             |
        σ(강의.학과='AI')
             |
        σ(점수>80)
             |
     조인들...
```

### Step 3: Rule 2, 3 적용 (곱셈 제거, 필요한 컬럼만)

```
        π(이름, 점수)
             |
        σ(학년=4)
             |
        σ(강의.학과='AI')
             |
        σ(점수>80)
             |
        학생 ⨝(학번) 성적
               |
            강의
         (학과별)
```

### Step 4: Rule 4 적용 (선택도 순서)

```
데이터 사전 확인:
- 학년=4: 25%
- 학과='AI': 5%
- 점수>80: 10%

최적 순서: 학과(5%) → 점수(10%) → 학년(25%)

        π(이름, 점수)
             |
        σ(학과='AI')  ← 가장 선택도 낮음
             |
        σ(점수>80)
             |
        σ(학년=4)
             |
        조인들...
```

### 최종 최적화된 SQL

```sql
SELECT 이름, 점수
FROM 강의
WHERE 학과 = 'AI'
INNER JOIN (
  SELECT * FROM 성적
  WHERE 점수 > 80
  INNER JOIN (
    SELECT * FROM 학생
    WHERE 학년 = 4
  ) USING(학번)
) USING(강의번호);
```

---

## 📈 성능 개선 효과

### 최적화 전 vs 후

```
처리 단계별 행 수:

최적화 전:
1000행(학생) × 5000행(성적) × 100행(강의) 
= 500,000,000행 생성! 😱
→ 그 중에 필터링

최적화 후:
5행(AI학과) × 0.5행(점수>80) × 1.25행(학년=4)
= 약 3행 처리 ✓
```

**개선율: 약 166,000,000배 향상! 🚀**

---

## 💻 의사코드로 본 최적화 엔진

```javascript
// 경험적 최적화 엔진
function heuristicOptimization(queryTree) {
  // Rule 1: 선택 연산을 위로 올린다 (상향식 적용)
  tree = pushSelectionUp(tree);
  
  // Rule 2: 카티션 곱셈을 조인으로 변환
  tree = replaceCartesianWithJoin(tree);
  
  // Rule 3: 프로젝션을 위로 올린다
  tree = pushProjectionUp(tree);
  
  // Rule 4: 선택도에 따라 조건 순서 정렬
  tree = reorderSelectionsBySelectivity(tree);
  
  // Rule 5: 불필요한 연산 제거
  tree = removeRedundantOperations(tree);
  
  return tree;  // 최적화된 트리 반환
}

// 선택 연산을 위로 올리기
function pushSelectionUp(node) {
  // 선택 연산이 조인 위에 있으면
  // 가능한 한 아래로 내린다 (조인 전에 필터링)
  if (node.isSelection && node.child.isJoin) {
    // 조인의 조건에 맞으면 분리
    // 예: R과 S를 조인 후 σ(R의 조건) 하는 대신
    //     σ(R의 조건)(R) ⨝ S 로 변환
    return separateAndPush(node);
  }
  return node;
}
```

**코드 설명:**
- `pushSelectionUp()`: 선택 연산을 앞으로 이동
- `replaceCartesianWithJoin()`: 무의미한 곱셈 제거
- `pushProjectionUp()`: 필요한 컬럼만 조기에 선택
- `reorderSelectionsBySelectivity()`: 조건 순서 최적화
- `removeRedundantOperations()`: 중복 제거

---

## ⚖️ 경험적 vs 비용 기반 최적화

### 경험적 최적화 (Heuristic)
```
장점:
+ 빠른 처리 (계산이 간단)
+ 항상 "충분히 좋은" 결과
+ 규칙이 명확함

단점:
- 최고의 해를 놓칠 수 있음
- 특수한 상황에 취약
```

### 비용 기반 최적화 (Cost-Based)
```
장점:
+ 가장 최적의 해 찾음
+ 통계 정보 활용
+ 상황에 따라 적응

단점:
- 계산이 복잡 (시간 소요)
- 통계 정보 필요
```

:::info 보통 둘을 함께 사용합니다!
1. 먼저 경험적 최적화로 후보 선정
2. 그 후 비용 기반 최적화로 최고 선택
:::

---

## 🎯 핵심 요점 정리

:::note 꼭 기억하세요!

**경험적 최적화의 7가지 규칙:**

1. **선택 연산 먼저** → WHERE 조건을 가능하면 먼저
2. **카티션 곱셈 제거** → 조인으로 대체
3. **프로젝션 먼저** → 필요한 컬럼만 선택
4. **조건 순서 최적화** → 선택도 낮은 것부터
5. **합집합 전 필터링** → 불필요한 행 제거
6. **중복 제거** → 같은 연산 반복하지 않기
7. **인덱스 활용** → 빠른 접근

**규칙의 핵심:**
- 처리할 데이터를 **빨리 줄이기**
- 불필요한 연산 **없애기**
- 작은 데이터부터 **처리하기**

**목표:**
- 경험에서 나온 **검증된 방법** 사용
- 모든 경우에 **적용 가능**
- 빠르고 효율적인 처리
:::

---

## 🤔 연습 문제

### 문제 1: 다음 SQL을 경험적 최적화 규칙에 따라 개선하세요

```sql
SELECT 이름 
FROM 학생, 수강, 강의
WHERE 학생.학번 = 수강.학번
  AND 수강.강의번호 = 강의.번호;
```

<details>
<summary>정답 예시</summary>

JOIN을 사용해서 카티션 곱셈 제거:

```sql
SELECT 학생.이름
FROM 학생
INNER JOIN 수강 ON 학생.학번 = 수강.학번
INNER JOIN 강의 ON 수강.강의번호 = 강의.번호;
```

개선 사항:
- ✓ 카티션 곱셈(×) → 조인(⨝)으로 변환
- ✓ 불필요한 테이블 조인 제거
- ✓ 필요한 컬럼만 선택

</details>

### 문제 2: WHERE 조건들의 순서를 최적화하세요

```sql
SELECT * FROM 학생
WHERE 학과='AI' 
  AND 성별='남자' 
  AND GPA>3.5;

상황:
- 학과='AI': 5% 선택도
- 성별='남자': 50% 선택도
- GPA>3.5: 20% 선택도
```

<details>
<summary>정답</summary>

선택도가 낮은 순서로: AI(5%) → GPA(20%) → 성별(50%)

```sql
SELECT * FROM 학생
WHERE 학과='AI' 
  AND GPA>3.5
  AND 성별='남자';
```

시스템이 자동으로 순서를 최적화하지만, 명시적으로 쓰면 더 좋습니다!

</details>

---

**작성일**: 2025-02-01  
**난이도**: ⭐⭐⭐ (개념 이해 필요)