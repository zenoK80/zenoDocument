---
title: "프로그래밍 시 주의사항 - 메모리 오류"
description: "프로그래밍 중에 자주 발생하는 메모리 관련 오류를 배웁니다."
slug: "programming-memory-errors"
sidebar_position: 5
date: "2024-01-15"
---

# 프로그래밍 시 주의사항 - 메모리 오류

좋은 프로그래밍을 위해서는 **오류를 미리 예방**하는 것이 중요합니다. 이번 시간에는 프로그래밍 중 자주 발생하는 실수들을 배우겠습니다.

## 메모리 관리의 중요성

### 메모리란?

컴퓨터의 **임시 저장 공간**입니다. 프로그램이 실행될 때 필요한 데이터들을 여기에 저장합니다.

```
컴퓨터 메모리
┌─────────────────────────┐
│  [데이터1] [데이터2]    │
│  [데이터3] [빈공간]     │
│  [데이터4] [빈공간]     │
└─────────────────────────┘
```

### 메모리 부족이 일어나면?

```
메모리가 부족 → 시스템이 느려짐 → 컴퓨터 멈춤 → 강제 종료 필요
```

:::warning
이 경험 많으시지 않나요? "컴퓨터가 자꾸 느려져요" - 대부분 메모리 문제입니다!
:::

---

## 1️⃣ 메모리 누수 (Memory Leak)

### 메모리 누수란?

사용한 메모리를 **해제하지 않아서** 계속 쌓이는 현상입니다.

### 예시

```cpp
#include <stdio.h>
#include <stdlib.h>

int main() {
    // 10번 반복하면서 메모리 할당
    for (int i = 0; i < 10; i++) {
        char *buffer = (char *)malloc(1000);  // 메모리 할당
        // 사용...
        // ❌ 오류: free(buffer)를 안 함!
    }
    return 0;
}
```

**무슨 일이 일어날까?**

```
1번 반복: 1000 바이트 할당 (해제 안 함)
2번 반복: 1000 바이트 할당 (해제 안 함)
...
10번 반복: 1000 바이트 할당 (해제 안 함)

결과: 10,000 바이트 낭비! 💔
```

### 올바른 코드

```cpp
int main() {
    for (int i = 0; i < 10; i++) {
        char *buffer = (char *)malloc(1000);  // 메모리 할당 1️⃣
        // 사용...
        free(buffer);  // 메모리 해제 2️⃣ (꼭 필요!)
    }
    return 0;
}
```

:::tip
**규칙**: 메모리를 할당했으면 **반드시 해제**해야 합니다!

malloc과 free는 쌍을 이룹니다. 🔗
:::

---

## 2️⃣ 중복된 해제 (Double Free)

### 무엇이 문제인가?

이미 해제한 메모리를 **또 다시 해제**하는 실수입니다.

### 예시

```cpp
#include <stdio.h>
#include <stdlib.h>

int main() {
    char *buffer = (char *)malloc(10);  // 메모리 할당
    printf("버퍼 사용: %s\n", buffer);
    
    free(buffer);  // 1️⃣ 첫 번째 해제
    
    // ... 다른 코드들 ...
    
    free(buffer);  // ❌ 오류: 또 다시 해제!
    
    return 0;
}
```

**무슨 일이 일어날까?**

```
처음 free: 메모리 정상 해제 ✅
두 번째 free: 이미 비워진 메모리를 또 비치려고 함 ❌
결과: 시스템 오류 발생! 💥
```

### 올바른 코드

```cpp
int main() {
    char *buffer = (char *)malloc(10);
    printf("버퍼 사용: %s\n", buffer);
    
    free(buffer);  // 해제 ✅
    buffer = NULL;  // 중요! NULL로 설정 🔒
    
    // 이제 free(buffer)를 또 호출해도 안전
    if (buffer != NULL) {
        free(buffer);  // 이 코드는 실행 안 됨
    }
    
    return 0;
}
```

:::info
**팁**: free 후에는 **NULL로 설정**하면 실수로 또 free하더라도 문제가 생기지 않습니다!
:::

---

## 3️⃣ Null 포인터 접근

### 포인터란?

메모리 주소를 가리키는 변수입니다.

```cpp
int x = 10;        // 정수 변수
int *ptr = &x;     // x의 주소를 저장하는 포인터
```

### NULL 포인터란?

**아무것도 가리키지 않는 포인터**입니다.

```cpp
int *ptr = NULL;   // 아무것도 가리키지 않음
```

### 위험한 상황

```cpp
#include <stdio.h>
#include <stdlib.h>

int main() {
    int *ptr = (int *)malloc(sizeof(int));
    *ptr = 100;
    printf("값: %d\n", *ptr);  // 100 출력
    
    free(ptr);      // 메모리 해제
    // ❌ 주의: ptr은 여전히 해제된 주소를 가리킴!
    
    printf("값: %d\n", *ptr);  // ❌ 오류! 비어있는 메모리에 접근
    
    return 0;
}
```

**무슨 일이 일어날까?**

```
free 후에도 ptr은 주소를 가지고 있음 → 그 주소 접근 → 오류 💥
```

### 올바른 코드

```cpp
int main() {
    int *ptr = (int *)malloc(sizeof(int));
    *ptr = 100;
    printf("값: %d\n", *ptr);  // 100 출력 ✅
    
    free(ptr);      // 메모리 해제
    ptr = NULL;     // NULL로 설정! 🔒
    
    // 이제 안전하게 확인 가능
    if (ptr != NULL) {
        printf("값: %d\n", *ptr);
    } else {
        printf("포인터가 NULL입니다\n");  // 이것이 실행됨
    }
    
    return 0;
}
```

:::warning
**핵심**: free 후에는 항상 **ptr = NULL**로 설정하세요!
:::

---

## 4️⃣ 별명 충돌 (Aliasing)

### 별명이란?

같은 메모리 위치를 **여러 이름**으로 접근하는 것입니다.

### 예시로 이해하기

```cpp
#include <stdio.h>
#include <string.h>

int main() {
    char src[] = "ko";    // "ko" 저장
    char dst[] = "rea";   // "rea" 저장
    
    // ❌ 문제: src와 dst가 같은 메모리를 가리키도록 할당
    src = dst;            // 잘못된 할당!
    
    // 이제 "korea"를 만들려고 함
    strcat(src, dst);     // "ko" + "rea" = "korea" 기대
    
    // 하지만 실제는 src == dst이므로...
    // 결과: "rea"만 나옴! ❌
    
    printf("%s\n", src);  // "rea" 출력 (기대: "korea")
    
    return 0;
}
```

**메모리 상태:**

```
별명 충돌 전:
┌─────┐  ┌─────┐
│ ko  │  │ rea │
└─────┘  └─────┘
  src      dst

별명 충돌 후 (src = dst):
┌─────┐
│ rea │
└─────┘
src, dst 모두 같은 위치 가리킴!
```

### 올바른 코드

```cpp
int main() {
    char src[] = "ko";
    char dst[] = "rea";
    char result[10];      // 결과를 저장할 별도 공간
    
    strcpy(result, src);  // "ko" 복사
    strcat(result, dst);  // "rea" 추가
    
    printf("%s\n", result);  // "korea" 출력! ✅
    
    return 0;
}
```

:::tip
**핵심**: 다른 변수는 **다른 메모리 위치**에 할당되어야 합니다!
:::

---

## 5️⃣ 배열 범위 초과 (Array Out of Bounds)

### 배열이란?

연속된 메모리 위치에 같은 타입의 데이터를 저장합니다.

```cpp
int arr[5] = {1, 2, 3, 4, 5};
// 인덱스: 0  1  2  3  4
```

### 범위 초과 오류

```cpp
#include <stdio.h>

int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    
    // ✅ 올바른 접근 (0 ~ 4)
    for (int i = 0; i < 5; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    
    // ❌ 범위 초과 오류
    printf("%d\n", arr[5]);   // 배열 범위 벗어남!
    printf("%d\n", arr[10]);  // 더욱 위험!
    
    return 0;
}
```

**무슨 일이 일어날까?**

```
arr[5]에 접근 → 배열 범위 벗어남
→ 다른 메모리 영역에 접근
→ 예측 불가능한 값 읽음 또는 오류 발생 💥
```

### 배열의 인덱싱 규칙

```
배열 크기가 n이면:
├─ 유효한 인덱스: 0, 1, 2, ..., n-1
├─ 인덱스 n: ❌ 범위 초과!
└─ 음수 인덱스: ❌ 불가능!
```

### 올바른 코드

```cpp
int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    int size = 5;
    
    // ✅ 범위를 확인하며 접근
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    
    // ✅ 범위 검사
    int index = 3;
    if (index >= 0 && index < size) {
        printf("%d\n", arr[index]);  // 안전! ✅
    }
    
    return 0;
}
```

:::warning
**규칙**: 배열 크기가 n이면 **0부터 n-1까지만** 사용할 수 있습니다!
:::

---

## 6️⃣ 0으로 나누기 (Division by Zero)

### 가장 간단하지만 위험한 오류

```cpp
#include <stdio.h>

int main() {
    int a = 100;
    int b = 0;
    
    // ❌ 오류: 0으로 나눗셈
    int result = a / b;
    printf("결과: %d\n", result);  // 이 코드는 실행 안 됨
    
    return 0;
}
```

**무슨 일이 일어날까?**

```
프로그램 강제 종료! 💥
"Floating point exception" 에러 발생
```

### 올바른 코드

```cpp
int main() {
    int a = 100;
    int b = 0;
    
    // ✅ 0으로 나누기 전에 확인
    if (b != 0) {
        int result = a / b;
        printf("결과: %d\n", result);
    } else {
        printf("오류: 0으로 나눌 수 없습니다\n");
    }
    
    return 0;
}
```

:::info
수학에서도 0으로 나누기는 정의되지 않습니다. 프로그래밍도 마찬가지입니다!
:::

---

## 7️⃣ 반복문 오류 (Off-by-One Error)

### +1의 차이가 문제를 만든다

```cpp
#include <stdio.h>

int main() {
    // 1부터 100까지 합을 구하기
    
    // ❌ 잘못된 코드
    int sum1 = 0;
    for (int i = 0; i <= 100; i++) {  // 0부터 시작!
        sum1 += i;
    }
    // 결과: 0 + 1 + 2 + ... + 100 (원하던 것과 다름!)
    printf("합 (잘못됨): %d\n", sum1);
    
    // ✅ 올바른 코드
    int sum2 = 0;
    for (int i = 1; i <= 100; i++) {  // 1부터 시작
        sum2 += i;
    }
    // 결과: 1 + 2 + 3 + ... + 100
    printf("합 (올바름): %d\n", sum2);
    
    return 0;
}
```

**결과 비교:**
```
잘못된 코드: 합 = 5050
올바른 코드: 합 = 5050
```

:::warning
이 경우는 우연히 같지만, 많은 경우 다른 결과가 나옵니다!
:::

### 더 위험한 예시

```cpp
// ❌ 자격증 시험 성적 처리 (0부터 시작)
int passCount = 0;
for (int i = 0; i < 100; i++) {  // 0 ~ 99 (총 100명)
    if (score[i] >= 80) passCount++;
}
// 99번 인덱스까지 확인되므로 정상

// ❌ 자격증 시험 성적 처리 (1부터 시작한다고 착각)
for (int i = 1; i <= 100; i++) {  // 1 ~ 100
    if (score[i] >= 80) passCount++;  // 인덱스 100은 범위 초과! ❌
}
```

### 올바른 코드 작성 팁

```cpp
int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    int size = 5;
    
    // ✅ 패턴 1: 0부터 시작
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    
    // ✅ 패턴 2: 1부터 시작 (size 조정)
    for (int i = 1; i <= size; i++) {
        printf("%d ", arr[i-1]);
    }
    printf("\n");
    
    return 0;
}
```

:::tip
**권장**: 항상 **0부터 시작하는 루프**를 사용하세요!
:::

---

## 8️⃣ 오버플로우와 언더플로우

### 오버플로우 (Overflow)

범위를 초과해서 증가하는 경우입니다.

```cpp
#include <stdio.h>

int main() {
    unsigned char value = 255;  // 255가 최대값
    
    value = value + 1;  // 256을 저장하려고 함
    // 하지만 unsigned char은 0~255만 저장 가능
    
    printf("값: %d\n", value);  // 0 출력! (순환함)
    
    return 0;
}
```

### 언더플로우 (Underflow)

범위보다 작게 감소하는 경우입니다.

```cpp
#include <stdio.h>

int main() {
    unsigned char value = 0;  // 0이 최소값
    
    value = value - 1;  // -1을 저장하려고 함
    // 하지만 음수 불가능
    
    printf("값: %d\n", value);  // 255 출력! (순환함)
    
    return 0;
}
```

### 올바른 처리

```cpp
int main() {
    unsigned char value = 255;
    
    // ✅ 범위 확인
    if (value < 255) {
        value = value + 1;
    } else {
        printf("최대값 도달\n");
    }
    
    return 0;
}
```

---

## 정리하며 🎯

### 프로그래밍 시 주의할 메모리 오류

| 오류 | 원인 | 해결책 |
|------|------|--------|
| **메모리 누수** | malloc 후 free 안 함 | 꼭 free() 호출 |
| **중복 해제** | free를 2번 이상 호출 | free 후 NULL 설정 |
| **NULL 접근** | free 후 메모리 접근 | NULL 확인 후 접근 |
| **별명 충돌** | 같은 메모리 여러 이름 | 다른 공간에 할당 |
| **범위 초과** | 배열 범위를 넘어감 | 범위 검사 필수 |
| **0으로 나누기** | 0으로 나눗셈 | 0인지 확인 |
| **반복문 오류** | 시작/끝 인덱스 실수 | 오프바이원 주의 |
| **오버플로우** | 최대값 초과 | 범위 확인 |

### 안전한 프로그래밍 체크리스트 ✅

```
□ 메모리를 할당했으면 반드시 해제
□ 해제 후 NULL로 설정
□ 배열 범위 확인
□ 0으로 나누기 체크
□ 반복문 시작/끝 확인
□ 포인터 NULL 확인
□ 변수 범위 확인
```

:::success
이러한 주의사항들을 기억하면 대부분의 프로그래밍 오류를 예방할 수 있습니다! 🛡️
:::