---
title: '질의 트리와 내부 형태 변환'
description: 'SQL을 컴퓨터가 이해하고 최적화할 수 있는 트리 구조로 변환하는 과정을 단계별로 배워봅시다'
slug: 'database/query-tree'
sidebar_label: '질의 트리'
sidebar_position: 5
date: '2025-02-02'
---

# 질의 트리와 내부 형태 변환

## SQL이 실행되기까지의 여정 🚀

당신이 작성한 SQL 명령어가 데이터베이스에서 실제로 실행되려면 여러 단계를 거쳐야 합니다. 이 문서에서 다루는 **질의 트리** 변환은 그 과정 중 가장 중요한 부분입니다.

처음 데이터베이스를 공부할 때 가장 신기했던 경험은 이거였어요. 같은 결과를 주는 SQL인데도 어떤 쿼리는 1초, 어떤 쿼리는 10초 이상 걸리는 현상을 마주했거든요. 그 차이가 바로 이 트리 구조를 어떻게 최적화하는가에서 비롯된다는 걸 알았을 때, 데이터베이스 설계의 오묘함이 느껴졌습니다.

SQL은 사람이 이해하기 편한 형태로 작성됩니다. "어느 테이블에서 뭘 가져오는데 어떤 조건으로"라는 일상 언어에 가까운 형태죠. 하지만 컴퓨터가 이를 최적화하고 빠르게 실행하려면 완전히 다른 형태로 변환해야 합니다. 바로 수학적 구조인 **트리** 형태로 말입니다. 이 변환 과정이 바로 우리가 배울 핵심입니다.

## 왜 트리 구조로 변환해야 할까? 🤔

이 질문에 답하기 위해 먼저 트리가 무엇인지 이해해야 합니다. 컴퓨터 과학에서 말하는 트리는 자료 구조의 한 종류로, 뿌리라는 최상위 노드에서 시작하여 여러 가지로 나뉘어지는 계층적 구조입니다. 각 가지는 또 다른 작은 트리가 되고, 이를 부분 트리라고 부릅니다. 마치 나뭇가지가 여러 개로 나뉘는 모양과 정확히 같습니다.

SQL을 트리로 변환하는 이유는 매우 실질적입니다.

**첫째, 복잡한 SQL 명령어를 계층적이고 구조화된 형태로 나타낼 수 있습니다.** 수십 개의 WHERE 조건과 여러 개의 JOIN이 얽혀 있는 복잡한 쿼리도, 트리로 표현하면 각 연산이 어떤 순서로 일어나는지 한눈에 알 수 있게 됩니다.

**둘째, 트리의 구조를 변경하면서 최적화를 시도할 수 있습니다.** 예를 들어, 어떤 조건을 먼저 처리할지, 어떤 테이블 조인을 먼저 할지를 결정할 수 있게 됩니다. 이건 굉장히 중요한데, 같은 결과를 내는 여러 가지 실행 계획 중에서 가장 빠른 경로를 선택할 수 있다는 의미거든요.

**셋째, 트리의 왼쪽 가지와 오른쪽 가지를 동시에 처리할 수 있어 병렬 처리가 가능해집니다.** 현대 멀티코어 프로세서에서 이건 엄청난 성능 향상을 가져옵니다. 우리는 트리 구조 덕분에 여러 CPU 코어를 활용할 수 있게 되는 거죠.

**넷째, 중간 결과를 캐싱하여 같은 연산을 다시 할 필요가 없게 됩니다.** 복잡한 쿼리에서는 부분 결과가 여러 번 필요할 수 있는데, 트리 구조는 그런 중복을 효율적으로 관리할 수 있습니다.

## 변환 과정: SQL에서 관계 대수로 📐

실제 예시를 들어봅시다. 다음과 같은 SQL이 있다고 가정하겠습니다.

```sql
SELECT 선원.이름
FROM 예약, 선원
WHERE 예약.아이디 = 선원.아이디 
  AND 예약.보트아이디 = 100 
  AND 선원.레이팅 > 5;
```

이 SQL이 실제로 하려는 일을 분해해보면, 먼저 예약 테이블과 선원 테이블을 연결합니다. 그 다음 보트 아이디가 100인 예약을 찾고, 그 중에서 레이팅이 5보다 큰 선원을 추출합니다. 마지막으로 그 선원들의 이름만 출력합니다.

이를 관계 대수라는 수학적 표현으로 나타내면 더욱 명확해집니다. 관계 대수는 집합 연산들을 기호로 나타내는 방식으로, 일반 수학의 대수와 유사합니다. 여기서 사용되는 기호들은 다음과 같습니다.

- **π** (파이): 프로젝션 기호. SELECT 명령어처럼 특정 열만 선택하는 연산을 나타냅니다.
- **σ** (시그마): 셀렉션 기호. WHERE 조건처럼 조건에 맞는 행을 선택하는 연산을 나타냅니다.
- **⨝** (보우타이): 조인 기호. 두 테이블을 연결하는 연산을 나타냅니다.

이런 기호들을 사용하면 복잡한 SQL을 간결하게 표현할 수 있습니다. 특히 최적화 알고리즘이 이해하기 쉬운 형태가 됩니다.

:::info 💡 개념 TIP
관계 대수를 처음 접하면 어려워 보일 수 있지만, 사실 우리가 SQL로 하는 모든 일은 이 세 가지 기호의 조합입니다. SELECT는 π, WHERE는 σ, JOIN은 ⨝이니까요. 즉, SQL을 관계 대수로 변환하는 것은 우리가 일상적으로 쓰는 언어를 수학 기호로 번역하는 것일 뿐입니다.
:::

## 트리 구조로의 최종 변환 🌳

관계 대수 표현을 트리로 변환하면 더욱 명확한 계층 구조가 만들어집니다. 이 트리의 **최상위는 최종 출력 형태인 프로젝션 노드입니다**. 그 아래로 셀렉션 노드가 있고, 더 아래로 조인 노드가 있으며, 가장 아래는 원본 데이터 테이블입니다.

**데이터는 아래에서 위로 흐르게 됩니다.** 먼저 테이블에서 데이터를 읽고, 조인으로 두 테이블을 연결한 후, 셀렉션으로 필터링하고, 마지막으로 프로젝션으로 필요한 열만 추출합니다. 이런 방식을 상향식 평가 (bottom-up evaluation)라고 부르는데, 이게 매우 효율적입니다.

이러한 트리 구조는 최적화 과정에서 매우 유연하게 변환될 수 있습니다. 예를 들어, 셀렉션의 순서를 바꿀 수 있고, 프로젝션의 위치를 조정할 수 있으며, 조인의 방식을 변경할 수 있습니다. 이 모든 변환이 같은 결과를 만들어내지만, 각각의 효율성은 크게 다릅니다. 이것이 바로 쿼리 옵티마이저의 핵심 역할입니다.

## 변환 규칙과 최적화 전략 ⚙️

데이터베이스 시스템이 질의를 최적화할 때 따르는 몇 가지 기본 규칙이 있습니다. 이 규칙들을 이해하면 왜 특정 순서로 최적화가 일어나는지 알 수 있습니다. 이건 마치 체스의 기본 전술을 배우는 것 같아요. 규칙을 모르면 매번 다시 생각해야 하지만, 알면 자동으로 최선의 방법이 떠오르는 거죠.

### 규칙 1: AND로 연결된 조건의 분해 🔀

WHERE 절에 성별이 남자이고 지역이 서울이고 점수가 80 이상이라는 세 가지 조건이 AND로 연결되어 있다면, 이를 한 번에 처리하는 것보다 하나씩 분리하여 순차적으로 처리하는 것이 효율적입니다.

왜일까요? 각 필터링 단계를 거친 후 처리할 데이터의 양이 줄어들기 때문입니다. 만약 1000명의 학생 데이터가 있는데, 첫 번째 조건에서 500명으로 줄었다면, 다음 조건은 500명에 대해서만 실행되면 됩니다. 이런 식으로 수행하면 컴퓨터가 불필요한 연산을 훨씬 줄이게 됩니다.

### 규칙 2: 셀렉션의 교환성 🔄

이는 조건을 처리하는 순서를 바꿀 수 있다는 의미입니다. **중요한 것은 선택도가 낮은 조건부터 먼저 처리해야 한다는 점입니다.**

선택도란 전체 데이터 중에서 조건을 만족하는 데이터의 비율을 의미합니다. 만약 남자 학생이 전체의 50%이고 점수 80 이상인 학생이 10%라면, 먼저 점수 조건을 필터링하는 것이 훨씬 효율적입니다. 10,000명에서 1,000명으로 먼저 줄인 후, 그 1,000명 중에서 남자를 찾는 게 차라리 낫다는 뜻이죠.

### 규칙 3: 연속된 프로젝션의 제거 ✂️

프로젝션을 여러 번 중첩하여 사용하는 것은 비효율적입니다. 예를 들어, 먼저 이름과 학번을 추출한 후 다시 이름만 추출하는 것보다, 처음부터 이름만 추출하는 것이 훨씬 빠릅니다.

시스템은 중간 단계의 불필요한 프로젝션을 모두 제거하고 최종적으로 필요한 열만 한 번에 추출합니다. 이건 마치 요리할 때 필요한 재료만 미리 꺼내놓는 것과 같습니다. 중간에 불필요한 것을 꺼냈다가 다시 정리하는 건 낭비잖아요.

### 규칙 4: 셀렉션과 프로젝션의 교환성 🔁

특정 조건 하에서는 셀렉션을 먼저 할지 프로젝션을 먼저 할지 바꿀 수 있습니다. 예를 들어, 이름과 학번만 필요한데 점수 조건으로 필터링해야 한다면, 먼저 점수로 필터링한 후 열을 선택해야 합니다.

하지만 주의할 점이 있습니다. **조건에 필요한 열이 프로젝션에서 제거되었다면, 반드시 셀렉션을 먼저 해야 합니다.** 그렇지 않으면 필터링에 필요한 데이터를 잃게 되기 때문입니다.

## 실제 변환 과정 단계별 학습 📚

이제 구체적인 SQL 예시를 통해 전체 변환 과정을 살펴봅시다. 이 과정을 이해하는 것이 데이터베이스 성능 최적화의 기초가 됩니다.

### 원본 SQL 쿼리

```sql
SELECT 학번, 이름
FROM 학생, 성적
WHERE 학생.학번 = 성적.학번
  AND 성적.점수 > 80
  AND 학생.학과 = '컴공';
```

이 쿼리는 컴퓨터공학과 학생 중에서 성적이 80점 이상인 학생의 학번과 이름을 조회하는 간단한 질의입니다.

### 1단계: 관계 대수로 변환

관계 대수 표기법을 사용하면 다음과 같이 표현됩니다. 각 기호가 어떤 역할을 하는지 유심히 봐주세요.

```
π[학번, 이름] (σ[학생.학번=성적.학번 ∧ 성적.점수>80 ∧ 학생.학과='컴공'] (학생 ⨝ 성적))
```

이를 풀어서 설명하면: 학생과 성적을 조인한 후, 세 가지 조건을 모두 만족하는 행을 선택하고, 그 중에서 학번과 이름만 추출하라는 의미입니다.

### 2단계: 초기 트리 구조 생성

```
        [Projection: 학번, 이름]
              |
        [Selection: 모든 조건]
              |
          [Join: 학번]
          /       \
      [학생]     [성적]
```

이 초기 트리는 최적화되지 않은 상태입니다. 모든 조건이 한 노드에 뭉쳐있고, 우리는 아직 어떤 조건이 가장 선택도가 낮은지 파악하지 못했습니다.

### 3단계: AND 조건 분해

앞서 배운 규칙 1을 적용합니다. AND로 연결된 조건들을 분리해서 각각의 셀렉션 노드로 만듭니다.

```
        [Projection: 학번, 이름]
              |
        [Selection: 학과='컴공']
              |
        [Selection: 점수>80]
              |
        [Selection: 학번=학번]
              |
          [Join]
          /       \
      [학생]     [성적]
```

이제 세 개의 셀렉션이 차근차근 연결되어 있습니다. 각 단계에서 데이터의 양이 줄어들 것입니다.

### 4단계: 선택도 계산 및 순서 조정

이제 중요한 부분입니다. 각 조건의 선택도를 계산해봅시다. 전체 학생이 1000명이라고 가정하겠습니다.

- 학과가 컴공: 250명 (선택도 25%)
- 점수가 80 이상: 300명 (선택도 30%)
- 학번 일치 (조인): 이미 두 테이블에 있는 데이터이므로 대부분 일치

선택도가 가장 낮은 순서는 **컴공** (25%) → **점수 80 이상** (30%)입니다. 학번 조인은 이미 조인 노드에서 처리되므로 가장 먼저 실행됩니다.

### 5단계: 최적화된 트리 구조

```
        [Projection: 학번, 이름]
              |
        [Selection: 학과='컴공']
              |
        [Selection: 점수>80]
              |
          [Join: 학번]
          /       \
      [학생]     [성적]
```

이것이 최적화된 트리입니다. 이제 실행 순서는 다음과 같습니다:

1. 학생 테이블과 성적 테이블을 조인합니다. (1000 × 학생당 평균 성적 수)
2. 그 결과에서 점수가 80 이상인 행만 필터링합니다. (약 300명으로 감소)
3. 그 300명 중에서 학과가 컴공인 행만 필터링합니다. (약 75명으로 감소)
4. 마지막으로 학번과 이름만 추출합니다.

## 트리 구조 구현의 실제 예시 💻

코드 레벨에서 이 트리 구조를 어떻게 구현하는지 살펴봅시다. 각 노드는 클래스로 표현되며, 연산자의 종류와 자식 노드들로 구성됩니다.

```javascript
class TreeNode {
  constructor(operator, condition = null, left = null, right = null) {
    this.operator = operator;
    this.condition = condition;
    this.left = left;
    this.right = right;
  }

  // 트리를 순회하면서 각 노드를 실행
  execute(data) {
    switch (this.operator) {
      case 'Table':
        return this.loadTableData(this.condition);
      case 'Join':
        const leftData = this.left.execute(data);
        const rightData = this.right.execute(data);
        return this.joinData(leftData, rightData, this.condition);
      case 'Selection':
        const parentData = this.left.execute(data);
        return this.filterData(parentData, this.condition);
      case 'Projection':
        const inputData = this.left.execute(data);
        return this.selectColumns(inputData, this.condition);
      default:
        throw new Error('Unknown operator: ' + this.operator);
    }
  }

  loadTableData(tableName) {
    // 데이터베이스에서 테이블 로드
    return database.getTable(tableName);
  }

  joinData(leftData, rightData, joinCondition) {
    // 두 데이터셋 조인
    return leftData.join(rightData, joinCondition);
  }

  filterData(data, condition) {
    // 조건에 맞는 행만 필터링
    return data.filter(row => this.evaluateCondition(row, condition));
  }

  selectColumns(data, columns) {
    // 필요한 열만 선택
    return data.map(row => {
      const selected = {};
      columns.forEach(col => {
        selected[col] = row[col];
      });
      return selected;
    });
  }

  evaluateCondition(row, condition) {
    // 조건 평가 로직
    // 실제로는 파싱과 평가가 필요함
    return true;
  }
}

// 트리 생성: 최적화된 구조
const tableNode = new TreeNode('Table', '성적');

const joinNode = new TreeNode('Join', '학번', 
  new TreeNode('Table', '학생'), 
  tableNode
);

const selection1 = new TreeNode('Selection', '점수 > 80', joinNode);
const selection2 = new TreeNode('Selection', '학과 = 컴공', selection1);
const projectionNode = new TreeNode('Projection', ['학번', '이름'], selection2);

// 실행
const result = projectionNode.execute();
```

### 코드 줄 단위 설명

**클래스 정의 (1-6줄)**: `TreeNode` 클래스는 각 노드의 기본 구조를 정의합니다. `operator`는 수행할 연산 타입, `condition`은 그 연산에 필요한 조건, `left`와 `right`는 자식 노드입니다.

**execute 메서드 (9-27줄)**: 이 메서드는 트리를 실행하는 핵심입니다. `switch` 문으로 각 연산 타입에 따라 다른 작업을 수행합니다. 재귀적으로 자식 노드를 먼저 실행한 후, 그 결과에 현재 노드의 연산을 적용합니다.

**loadTableData (29-31줄)**: 데이터베이스에서 테이블을 로드합니다. 실제로는 데이터베이스 쿼리가 일어나는 지점입니다.

**joinData (33-35줄)**: 두 데이터셋을 조인합니다. `joinCondition`은 보통 두 테이블의 공통 열입니다.

**filterData (37-40줄)**: WHERE 조건에 해당하는 부분입니다. 각 행에 대해 조건을 평가하고, 참인 행만 반환합니다.

**selectColumns (42-50줄)**: SELECT 부분에 해당합니다. 필요한 열만 추출하여 새로운 객체를 만듭니다.

### 실행 과정 주의사항 ⚠️

이 코드를 실행할 때 주의해야 할 점들이 있습니다.

첫째, **조건 평가의 복잡성**입니다. 실제 데이터베이스에서는 `evaluateCondition` 메서드가 훨씬 복잡합니다. SQL 파서를 거쳐야 하고, 타입 변환, NULL 처리, 함수 평가 등이 일어나죠.

둘째, **메모리 효율성**입니다. 위의 코드는 전체 데이터를 메모리에 로드합니다. 하지만 실제 데이터베이스는 스트리밍 방식으로 처리하여 메모리 사용을 최소화합니다.

셋째, **인덱스 활용**입니다. 이 코드에는 인덱스 개념이 없습니다. 하지만 실제 데이터베이스는 인덱스를 활용해 선택 단계를 훨씬 빠르게 수행합니다.

:::tip 🎯 실무 팁
MySQL이나 PostgreSQL에서 실행 계획을 보고 싶다면 `EXPLAIN` 명령어를 사용하세요. 예를 들어 `EXPLAIN SELECT ...`로 시작하면, 데이터베이스가 당신의 쿼리를 어떤 트리로 변환했고, 어떻게 최적화했는지 확인할 수 있습니다. 이건 정말 강력한 도구입니다!
:::

## 최적화가 성능에 미치는 영향 📊

트리 구조를 최적화하는 것이 얼마나 중요한지 이해하기 위해 구체적인 수치를 들어봅시다.

학생 데이터가 1000명이 있다고 가정하겠습니다. 각 학생은 3개의 성적 기록이 있습니다 (3개 과목). 따라서 성적 테이블은 3000개 행입니다.

- 학과가 컴공인 학생: 250명 (25%)
- 점수가 80 이상인 성적: 900개 (30%)

### 최적화되지 않은 경우 (모든 조인 먼저)

1. 학생과 성적 조인: 1000 × 3 = 3000개 행 처리
2. 모든 행에 대해 3가지 조건 확인: 3000 × 3 = 9000번 조건 평가
3. 결과: 약 75행 (250명 × 30% = 75개 성적)

**총 연산: 3000 + 9000 = 12,000회**

### 최적화된 경우 (선택도 낮은 조건부터)

1. 성적 테이블에서 점수 > 80: 900개 행으로 축소
2. 학생 테이블과 조인: 900 × (1/3 비율) = 약 300행
3. 학과 = 컴공 조건: 300 × 25% = 75행
4. 프로젝션: 75행의 2개 열

**총 연산: 3000 + 900 + 300 + 75 = 4275회**

**성능 개선: (12000 - 4275) / 12000 = 64% 향상!**

실제로 데이터베이스 최적화는 이 정도 수준의 성능 개선을 자주 만들어냅니다. 데이터 규모가 커질수록 이 차이는 더욱 극명해집니다.

## 실습 문제: 직접 최적화해보기 🧠

이제 당신이 다음 SQL을 최적화한다고 가정해봅시다.

```sql
SELECT 이름
FROM 학생
WHERE 학년 = 4 
  AND 점수 > 90 
  AND 학과 = 'AI';
```

학교 전체 학생이 1000명이라고 할 때, 다음 비율의 학생들이 각 조건을 만족합니다.

- 4학년: 200명 (20%)
- 점수 90 이상: 100명 (10%)
- AI 학과: 50명 (5%)

여기서 최적의 순서는 무엇일까요? **AI 학과 조건부터 시작하는 것입니다.** 가장 선택도가 낮기 때문입니다.

실행 순서:

1. AI 학과 조건으로 필터링: 1000명 → 50명 (95% 감소!)
2. 점수 > 90 조건: 50명 → 약 5명
3. 학년 = 4 조건: 5명 → 약 1명

**처리할 데이터가 1000명에서 1명으로 99.9% 줄었습니다!** 만약 조건을 다르게 순서화했다면 훨씬 많은 행을 확인해야 했을 겁니다. 이것이 바로 쿼리 최적화의 마법입니다.

---

**작성일**: 2025-02-02