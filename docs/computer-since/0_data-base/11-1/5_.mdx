---
title: '질의 트리(Query Tree)와 내부 형태 변환'
description: 'SQL을 실행 가능한 형태로 변환하는 과정 - 트리 구조로 변환하기'
slug: 'database/query-tree-transformation'
sidebar_label: '질의 트리와 변환'
sidebar_position: 5
date: '2025-02-01'
---

# 질의 트리(Query Tree)와 내부 형태 변환

## 🎯 이번 시간의 목표

SQL 명령어를 **컴퓨터가 이해하고 최적화할 수 있는 형태**로 변환합니다.

즉, **관계 대수의 트리(Tree) 구조**로 바꾸는 과정입니다!

---

## 📚 왜 트리 구조로 변환할까?

### 트리(Tree)란?

:::info 자료 구조의 트리
- 우리가 컴퓨터 과학에서 배우는 "트리" 자료 구조
- 뿌리(root)와 가지로 이루어짐
- 각 가지는 또 다른 작은 트리(부분 트리)
:::

```
        최상위 노드
           /|\
          / | \
         /  |  \
        /   |   \
       ●    ●    ●
      / \   |
     ●   ●  ●
```

### SQL을 트리로 변환하는 이유

| 이유 | 설명 |
|------|------|
| **구조화** | 복잡한 SQL을 계층적으로 표현 |
| **최적화 가능** | 트리의 구조를 바꿔가며 최적화 |
| **병렬 처리** | 각 가지를 따로 처리 가능 |
| **캐싱** | 중간 결과를 저장하고 재사용 |

---

## 🔄 변환 과정: SQL → 관계 대수 → 트리

### Step 1: SQL 명령어 분석

```sql
SELECT 선원.이름
FROM 예약, 선원
WHERE 예약.아이디 = 선원.아이디 
  AND 예약.보트아이디 = 100 
  AND 선원.레이팅 > 5;
```

**이 SQL이 하려는 일:**
- 예약 테이블과 선원 테이블을 연결 (조인)
- 보트 아이디 = 100인 예약 찾기
- 그 중에서 레이팅 > 5인 선원 찾기
- 그 선원들의 이름 출력

### Step 2: 관계 대수로 변환

:::info 관계 대수란?
**수학의 대수(algebra)처럼**, 집합 연산들을 기호로 나타내는 방식입니다!
:::

```
π (선원.이름) [
  σ (예약.보트아이디=100 AND 선원.레이팅>5) [
    예약 ⨝ 선원 (ON 예약.아이디=선원.아이디)
  ]
]
```

**기호 설명:**
- **π (프로젝션)**: 특정 열만 선택 → SELECT 컬럼
- **σ (셀렉션)**: 조건에 맞는 행 선택 → WHERE 조건
- **⨝ (조인)**: 두 테이블 연결 → JOIN

### Step 3: 질의 트리로 변환

```
        [프로젝션: 이름]
               |
          [셀렉션: 조건들]
               |
           [조인: 아이디]
            /        \
       예약 테이블   선원 테이블
```

**더 자세히:**
```
           π (이름)
            |
    σ (보트=100 ∧ 레이팅>5)
            |
       예약 ⨝ 선원
        /         \
     예약       선원
    (테이블)   (테이블)
```

---

## 🌳 질의 트리의 구조

### 일반적인 질의 트리 형태

```
최상위 노드 (최종 출력)
    ↓ (데이터 흐름)
연산 노드 (어떻게)
    ↓
    ├─ 연산 노드 (왼쪽 입력)
    │  └─ 데이터 테이블
    └─ 연산 노드 (오른쪽 입력)
       └─ 데이터 테이블
```

### 실제 예시: 두 테이블의 조인 후 필터링

```
        프로젝션
        (이름을 출력)
          |
        셀렉션
        (점수>80)
          |
        조인
        (학생.ID = 성적.학생ID)
       /          \
    학생 테이블   성적 테이블
```

**트리가 읽혀지는 방향:**
- 아래에서 위로 (상향식)
- 테이블에서 시작
- 점점 처리를 거쳐 최종 결과

---

## 🔀 내부 형태 변환의 정립된 규칙들

### Rule 1: AND로 연결된 조건의 분해

#### ❌ 비효율적 방법
```
WHERE 성별='남자' AND 지역='서울' AND 점수>80
```
```
        셀렉션 (모든 조건을 동시에)
               |
            테이블
```

#### ✅ 효율적 방법
```
        셀렉션 (점수>80)
               |
        셀렉션 (지역='서울')
               |
        셀렉션 (성별='남자')
               |
            테이블
```

**변환 규칙:**
```
σ(조건1 ∧ 조건2 ∧ 조건3) = σ(조건1)(σ(조건2)(σ(조건3)))
```

**변환 의미:**
- 여러 AND 조건을 **분리해서 순차 실행**
- 각 셀렉션 후 데이터를 줄임
- 다음 셀렉션에서 처리할 데이터가 더 적음

### Rule 2: 셀렉션의 교환성

#### 조건 순서 바꾸기
```
σ(성별='남자')(σ(지역='서울')(테이블))
= σ(지역='서울')(σ(성별='남자')(테이블))
```

**응용:**
- 선택도 낮은 조건부터 먼저 실행
- 10% > 50% 라면 10% 먼저!

### Rule 3: 연속된 프로젝션의 제거

#### ❌ 비효율적 방법
```
π(이름)(π(이름, 학번)(π(이름, 학번, 학과)(테이블)))
```
**3번이나 프로젝션을 함!**

#### ✅ 효율적 방법
```
π(이름)(테이블)
```
**1번만 프로젝션!**

**변환 규칙:**
```
π(A)(π(A, B)(π(A, B, C)(T))) = π(A)(T)
```

**의미:**
- 최종적으로 필요한 컬럼만 마지막에 추출
- 중간에 여러 번 추출할 필요 없음

### Rule 4: 셀렉션과 프로젝션의 교환성

```
σ(조건)(π(컬럼)) = π(컬럼)(σ(조건))
```

**하지만 조건에 따라 순서가 중요:**
- 조건에 필요한 컬럼이 프로젝션에 없으면?
- → 먼저 그 컬럼을 포함해서 프로젝션해야 함

---

## 💡 실전 예시: 완전한 변환 과정

### SQL 명령어

```sql
SELECT 학번, 이름
FROM 학생, 성적
WHERE 학생.학번 = 성적.학번
  AND 성적.점수 > 80
  AND 학생.학과 = '컴공';
```

### 과정 1: 관계 대수로 변환

```
π(학번, 이름)[
  σ(점수>80 ∧ 학과='컴공')[
    학생 ⨝ 성적
  ]
]
```

### 과정 2: 초기 트리 구조

```
        π(학번, 이름)
             |
    σ(조건1 ∧ 조건2)
             |
        학생 ⨝ 성적
        /         \
      학생       성적
```

### 과정 3: Rule 1 적용 (AND 조건 분해)

```
        π(학번, 이름)
             |
        σ(학과='컴공')
             |
        σ(점수>80)
             |
        학생 ⨝ 성적
        /         \
      학생       성적
```

### 과정 4: Rule 2 적용 (선택도에 따라 순서 조정)

```
만약 점수>80이 학과='컴공'보다 선택도가 낮다면:

        π(학번, 이름)
             |
        σ(학과='컴공')
             |
        σ(점수>80)  ← 먼저 실행 (더 선택적)
             |
        학생 ⨝ 성적
        /         \
      학생       성적
```

### 최종 최적화된 트리

```
[최종 형태]

        프로젝션
        (학번, 이름만)
           ↓
        셀렉션
        (학과='컴공')
           ↓
        셀렉션
        (점수>80) ← 이 조건이 더 선택적
           ↓
        조인
        (학번 일치)
       /         \
    학생       성적
```

---

## 📊 코드 레벨 이해 (의사코드)

### 트리 노드 클래스

```javascript
// 트리의 노드 정의
class TreeNode {
  constructor(operator, left = null, right = null) {
    this.operator = operator;  // 어떤 연산? (조인, 셀렉션 등)
    this.left = left;          // 왼쪽 자식 노드
    this.right = right;        // 오른쪽 자식 노드
  }
}

// 예시: σ(점수>80) 노드 생성
let selectionNode = new TreeNode(
  'Selection',           // 연산자
  { condition: '점수>80' },
  tableNode              // 아래에 테이블 연결
);

// 예시: 프로젝션 노드
let projectionNode = new TreeNode(
  'Projection',
  { columns: ['이름', '학번'] },
  selectionNode          // 아래에 셀렉션 연결
);
```

**노드별 역할:**

| 연산자 | 의미 | 입력 | 출력 |
|--------|------|------|------|
| Selection (σ) | 행 필터링 | 테이블 | 필터링된 행 |
| Projection (π) | 열 선택 | 테이블 | 필터링된 열 |
| Join (⨝) | 두 테이블 연결 | 테이블2개 | 연결된 테이블 |
| Union (∪) | 합집합 | 테이블2개 | 합친 결과 |

---

## 🎯 트리 구조의 장점

### 1️⃣ 시각화가 쉬움
```
트리 형태로 보면 처리 순서가 한눈에 보임
```

### 2️⃣ 최적화가 쉬움
```
노드의 순서를 바꿔가며 최고 효율 찾기
```

### 3️⃣ 부분 처리 가능
```
왼쪽 가지와 오른쪽 가지를 동시에 처리 가능
(병렬 처리)
```

### 4️⃣ 비용 계산이 쉬움
```
각 노드의 비용을 계산해서 합치기
```

---

## 🎯 핵심 요점 정리

:::note 꼭 기억하세요!

**1. SQL → 관계 대수 → 트리로 변환**
- SQL은 사람이 이해하는 형태
- 관계 대수는 수학적 표현
- 트리는 컴퓨터가 최적화하기 좋은 형태

**2. 주요 변환 규칙**
- Rule 1: AND 조건 분해
- Rule 2: 선택도에 따라 순서 조정
- Rule 3: 연속된 프로젝션 제거
- Rule 4: 셀렉션과 프로젝션 교환

**3. 트리의 구조**
- 아래: 데이터 테이블
- 중간: 각 연산 (조인, 필터링 등)
- 위: 최종 프로젝션 (출력)

**4. 목표: 비용 최소화**
- 처리할 데이터 양 줄이기
- 가장 빠른 방법 찾기
- 자원 효율성 극대화
:::

---

## 🤔 생각해보기

**문제**: 다음 SQL을 최적화하려면 어떤 순서로 셀렉션을 해야 할까요?

```sql
SELECT 이름 FROM 학생
WHERE 학년=4 AND 점수>=90 AND 학과='AI';
```

학교 전체 학생: 1000명
- 4학년: 200명 (20%)
- 점수>=90: 100명 (10%)
- AI학과: 50명 (5%)

<details>
<summary>정답 보기</summary>

최적 순서: **AI학과(5%) → 점수>=90(10%) → 학년=4(20%)**

왜? 선택도가 낮은 것부터 실행하면 처리할 데이터가 빠르게 줄어듭니다!

1. 50명 → AI학과만 필터링
2. 그 중 5명 → 점수>=90 필터링
3. 그 중 1명 → 학년=4 필터링

</details>

---

**작성일**: 2025-02-01  
**난이도**: ⭐⭐⭐ (약간의 노력 필요)