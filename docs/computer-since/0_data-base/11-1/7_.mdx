---
title: '최적화 규칙과 실행 계획 생성'
description: '변환 규칙들을 체계적으로 학습하고 최적의 실행 계획을 만드는 방법'
slug: 'database/optimization-rules-execution-plan'
sidebar_label: '최적화 규칙과 실행 계획'
sidebar_position: 7
date: '2025-02-01'
---

# 최적화 규칙과 실행 계획 생성

## 🎯 이번 시간의 목표

**정립된 변환 규칙들을 배우고**,
이 규칙들을 적용해서 **최고 효율의 실행 계획을 만드는 방법**을 배웁니다.

:::tip 규칙 = 수학의 공식처럼
마치 수학에서 분배법칙(a(b+c) = ab+ac)이 있듯이,
최적화도 명확한 규칙들이 있습니다!
:::

---

## 📐 최적화 규칙의 기본 원리

### 규칙의 형태

```
변환 전  →  변환 후
(비효율)   (효율적)
```

### 규칙의 조건

```
모든 규칙은:
1. 수학적으로 증명되어야 함
2. 결과는 같아야 함 (정확성 보장)
3. 성능이 더 좋아야 함 (효율성)
```

:::info 중요한 약속
규칙을 적용해도 **최종 결과는 변하지 않습니다!**
단지 처리 방식만 바뀝니다.
:::

---

## 📋 12가지 변환 규칙

### Rule 1: AND 연산의 분해

```
σ(조건1 ∧ 조건2 ∧ ... ∧ 조건n)
=
σ(조건1)(σ(조건2)(...σ(조건n)(R)...))
```

**의미:**
```
여러 AND 조건을 연속된 단일 조건으로 분해
```

**예시:**

```sql
-- 변환 전
WHERE 성별='남자' AND 지역='서울' AND 점수>80

-- 변환 후 (의미적으로)
WHERE 성별='남자'
  이다음에
WHERE 지역='서울'
  이다음에
WHERE 점수>80
```

**효과:**
```
각 필터링 후 데이터가 줄어듦
→ 다음 필터링에서 처리할 데이터 감소
```

**시각화:**

```
[100행]
   ↓ (성별='남자' 필터링)
[10행]
   ↓ (지역='서울' 필터링)
[5행]
   ↓ (점수>80 필터링)
[1행] ← 최종 결과
```

---

### Rule 2: 선택 연산의 교환성

```
σ(조건1)(σ(조건2)(R))
=
σ(조건2)(σ(조건1)(R))
```

**의미:**
```
어떤 조건을 먼저 적용해도 결과는 같다!
```

**예시:**

```
σ(성별='남자')(σ(지역='서울')(학생))
= σ(지역='서울')(σ(성별='남자')(학생))
```

**응용: 선택도에 따른 최적화**

```
만약 성별='남자'(10%)가 지역='서울'(50%)보다 선택도가 낮으면?

최적 순서: σ(성별='남자') 먼저!

100명 → 10명 → 5명
(빠름!)
```

---

### Rule 3: 연속된 프로젝션의 제거

```
π(A)(π(A, B)(π(A, B, C)(R)))
=
π(A)(R)
```

**의미:**
```
최종적으로 필요한 컬럼만 한 번에 추출하세요!
```

**예시:**

```
❌ 비효율적:
π(이름)(π(이름, 학번)(π(이름, 학번, 학과)(학생)))
         ↑ 3번이나 프로젝션

✅ 효율적:
π(이름)(학생)
        ↑ 1번만 프로젝션
```

**효과:**

```
메모리 사용:
- 비효율: A,B,C 로드 → A,B 필터링 → A 필터링 (3번 반복)
- 효율: 처음부터 A만 로드 (1번)

시간 절감: 약 3배!
```

---

### Rule 4: 프로젝션과 선택의 교환성

```
σ(조건)(π(속성목록)(R))
=
π(속성목록)(σ(조건)(R))
```

**조건:**
```
프로젝션의 속성 목록에
조건에 필요한 모든 속성이 포함되어야 함!
```

**예시 1: 교환 가능한 경우**

```
-- 변환 전
π(이름, 학번)(σ(학년=4)(학생))

-- 변환 후
σ(학년=4)(π(이름, 학번, 학년)(학생))
          ↑ 학년이 프로젝션에 포함됨
```

**예시 2: 교환 불가능한 경우**

```
❌ 불가능:
π(이름)(σ(학년=4)(학생))
↑ 학년이 없음! 조건을 적용할 수 없음

✅ 가능한 해결:
π(이름)(σ(학년=4)(π(이름, 학년)(학생)))
```

---

### Rule 5: 선택과 조인의 관계

```
σ(R.조건)(R ⨝ S)
=
σ(R.조건)(R) ⨝ S
```

**의미:**
```
조인 후 한쪽 테이블 조건으로 필터링하면?
→ 먼저 그 테이블에서 필터링하고 조인하세요!
```

**예시:**

```sql
-- 변환 전
SELECT *
FROM 학생 JOIN 성적 ON 학생.학번=성적.학번
WHERE 학생.학년=4;

-- 변환 후 (최적화된 실행)
SELECT *
FROM (SELECT * FROM 학생 WHERE 학년=4) AS 학생4학년
JOIN 성적 ON 학생4학년.학번=성적.학번;
```

**효과:**

```
조인 전 데이터 크기:
- 비효율: 학생 1000명 JOIN 성적 5000행
- 효율: 학생(250명) JOIN 성적 5000행

→ 조인 비용 4배 감소!
```

---

### Rule 6: 선택의 분배 (조인과 관련)

```
σ(R.조건 AND S.조건)(R ⨝ S)
=
σ(R.조건)(R) ⨝ σ(S.조건)(S)
```

**의미:**
```
두 테이블 모두에 조건이 있으면?
→ 각각 먼저 필터링하고 조인하세요!
```

**예시:**

```sql
-- 변환 전
SELECT *
FROM 학생 JOIN 성적
WHERE 학생.학년=4 AND 성적.점수>80;

-- 변환 후 (최적화)
SELECT *
FROM (SELECT * FROM 학생 WHERE 학년=4) 학생4
JOIN (SELECT * FROM 성적 WHERE 점수>80) 성적80
;
```

**효과 비교:**

```
비효율:
1000 × 5000 = 5,000,000행 생성
→ 그중에 필터링

효율:
250 × 1000 = 250,000행만 조인
→ 약 20배 감소!
```

---

### Rule 7: 교환적 및 결합적 성질

```
R ⨝ S = S ⨝ R  (교환적)

(R ⨝ S) ⨝ T = R ⨝ (S ⨝ T)  (결합적)
```

**의미:**
```
조인의 순서를 바꿀 수 있습니다!
```

**예시:**

```
R, S, T 세 테이블을 조인하는 경우:

옵션 1: (R ⨝ S) ⨝ T
옵션 2: (R ⨝ T) ⨝ S
옵션 3: (S ⨝ T) ⨝ R
... 등등

결과는 모두 같지만,
처리 비용은 달라질 수 있음!
```

**최적 순서 찾기:**

```
크기 비교:
S: 100행
T: 500행
R: 10,000행

최적: (작은 것끼리 먼저)
(S ⨝ T) ⨝ R
= 500행 ⨝ 10,000행
= 더 작은 중간 결과
```

:::tip 작은 데이터끼리 먼저
두 개의 작은 테이블을 조인해서 중간 결과를 만들면,
최종 조인이 더 빨라집니다!
:::

---

### Rule 8: 프로젝션의 분배 (조인과 관련)

```
π(A, B, C, D)(R ⨝ S)
=
π(A, B)(R) ⨝ π(C, D)(S)
```

**조건:**
```
- A, B는 R의 속성
- C, D는 S의 속성
- 조인 조건에 필요한 속성은 모두 포함
```

**예시:**

```sql
-- 변환 전
SELECT 학생.이름, 성적.점수
FROM 학생 JOIN 성적 ON 학생.학번=성적.학번;

-- 변환 후
SELECT π(이름, 학번)(학생) ⨝ π(학번, 점수)(성적);
```

**효과:**

```
로드 메모리:
- 비효율: 모든 컬럼 로드 후 조인
- 효율: 필요한 컬럼만 로드해서 조인

→ I/O 비용 감소
```

---

### Rule 9-12: 기타 규칙들

#### Rule 9: 합집합과의 분배

```
σ(조건)((R ∪ S))
=
σ(조건)(R) ∪ σ(조건)(S)

π(속성)((R ∪ S))
=
π(속성)(R) ∪ π(속성)(S)
```

**의미:**
```
합집합 연산 전에 필터링하거나 프로젝션하세요!
```

#### Rule 10: 교집합의 성질

```
(R ∩ S) = (R - (R - S))
```

**의미:**
```
복잡한 교집합도 다양하게 표현 가능
```

#### Rule 11: 곱셈의 교환성과 결합성

```
R × S = S × R
(R × S) × T = R × (S × T)
```

**주의:**
```
조인은 교환적이지만 카티션 곱은 효율이 떨어지므로
→ 조인으로 변환할 것!
```

#### Rule 12: OR/AND의 분배

```
WHERE (A OR B) AND C
=
(WHERE A AND C) OR (WHERE B AND C)
```

**의미:**
```
복잡한 조건도 분배하면 최적화 기회 증가
```

---

## 🎯 실전 예시: 규칙 적용 단계별

### 원본 SQL

```sql
SELECT 선원.이름
FROM 예약, 선원
WHERE 예약.선원아이디 = 선원.아이디
  AND 예약.보트아이디 = 100
  AND 선원.레이팅 > 5;
```

### Step 1: 관계 대수로 변환

```
π(선원.이름) [
  σ(보트아이디=100 ∧ 레이팅>5) [
    예약 ⨝ 선원 (조인 조건: 선원아이디=아이디)
  ]
]
```

### Step 2: Rule 1 적용 (AND 분해)

```
π(선원.이름) [
  σ(보트아이디=100) [
    σ(레이팅>5) [
      예약 ⨝ 선원
    ]
  ]
]
```

### Step 3: Rule 6 적용 (선택 분배)

조건을 각 테이블에 분배:

```
π(선원.이름) [
  σ(보트아이디=100) [예약]  ⨝  σ(레이팅>5) [선원]
]
```

### Step 4: Rule 5 적용 (프로젝션 추가)

필요한 컬럼만 추출:

```
π(선원.이름) [
  π(선원아이디)(σ(보트아이디=100)[예약])  ⨝  
  π(아이디, 이름)(σ(레이팅>5)[선원])
]
```

### 최종 최적화된 트리

```
        π(이름)
          |
    σ(레이팅>5) ⨝ σ(보트=100)
    /                    \
선원 테이블            예약 테이블
```

### 최적화 효과

```
최적화 전:
- 예약 100행 × 선원 1000행 = 100,000행 조인 생성
- 그 중 조건에 맞는 것 필터링
- 복잡한 처리

최적화 후:
- 예약에서 보트=100 필터링 (10행)
- 선원에서 레이팅>5 필터링 (500행)
- 10 × 500 = 5,000행 조인
- 결과: 약 20배 성능 개선!
```

---

## 📊 최적화 과정 요약

```
입력: SQL
  ⬇️ 파싱
관계 대수 표현
  ⬇️ Rule 1,2,3 적용
분해 및 순서 최적화
  ⬇️ Rule 5,6 적용
선택과 조인 최적화
  ⬇️ Rule 8 적용
프로젝션 최적화
  ⬇️ 여러 계획 생성
실행 계획 후보군
  ⬇️ 비용 계산
최고 효율 계획 선택
  ⬇️ 코드 생성
실행
  ⬇️
최적화된 결과 ✅
```

---

## 💻 코드로 본 규칙 적용

```javascript
// Rule 1: AND 분해
function rule1_decomposeAND(condition) {
  // "조건1 AND 조건2 AND 조건3"을
  // [조건1, 조건2, 조건3] 배열로 분해
  let conditions = condition.split(' AND ');
  return conditions;
}

// Rule 2: 선택도에 따라 순서 변경
function rule2_reorderBySelectivity(conditions) {
  // 각 조건의 선택도를 계산
  conditions.forEach(cond => {
    cond.selectivity = calculateSelectivity(cond);
  });
  
  // 선택도 낮은 순으로 정렬
  conditions.sort((a, b) => a.selectivity - b.selectivity);
  
  return conditions;
}

// Rule 5: 조인 전 선택 실행
function rule5_pushSelectionDown(queryTree) {
  if (queryTree.isJoin) {
    // 왼쪽, 오른쪽 테이블에 각각 조건 적용
    leftCond = extractConditionFor(leftTable);
    rightCond = extractConditionFor(rightTable);
    
    return newJoin(
      applySelection(leftTable, leftCond),
      applySelection(rightTable, rightCond)
    );
  }
}

// 실행 결과
console.log("규칙 적용 완료! ✓");
console.log("예상 성능 개선: 10~1000배");
```

---

## ⚖️ 규칙 적용의 주의사항

### 주의 1: 모든 규칙이 항상 좋은 건 아닙니다

```
예외 상황:
- 컬럼이 많은 작은 테이블 × 컬럼이 적은 큰 테이블
  → 프로젝션 먼저가 오히려 나쁠 수 있음
  
- 조건이 복잡한 경우
  → AND 분해가 오버헤드 발생
```

### 주의 2: 인덱스를 고려해야 합니다

```
인덱스가 있으면:
- σ(학년=4) 는 빠름 (인덱스 사용)
- 선택도가 높아도 문제없음

인덱스가 없으면:
- σ(학년=4) 는 느림 (전체 스캔)
- 선택도 낮은 조건부터 필수!
```

---

## 🎯 핵심 요점 정리

:::note 꼭 기억하세요!

**12가지 변환 규칙의 핵심:**

1. **Rule 1**: AND 분해로 선택을 단계적으로 실행
2. **Rule 2**: 선택도에 따라 순서 변경
3. **Rule 3**: 마지막 프로젝션만 유지
4. **Rule 4**: 프로젝션과 선택 교환 (신중히!)
5. **Rule 5**: 조인 전 선택 실행
6. **Rule 6**: 각 테이블에 선택 분배
7. **Rule 7**: 조인 순서 변경 가능
8. **Rule 8**: 조인 전 프로젝션
9-12. **기타 규칙**: 집합 연산 최적화

**적용 전략:**
- 규칙은 가이드라인일 뿐
- 환경에 따라 예외 존재
- 비용 계산으로 최종 확인
- 인덱스 존재 여부 확인

**목표:**
- 처리할 데이터 감소
- 불필요한 연산 제거
- 조인 비용 최소화
:::

---

## 🤔 연습 문제

### 문제: 다음 SQL을 규칙들로 최적화하세요

```sql
SELECT 고객.이름, 주문.총액
FROM 고객, 주문, 상품
WHERE 고객.고객ID = 주문.고객ID
  AND 주문.상품ID = 상품.상품ID
  AND 고객.등급 = 'VIP'
  AND 상품.카테고리 = '전자제품'
  AND 주문.금액 > 100000;
```

<details>
<summary>정답 (단계별)</summary>

**Step 1**: Rule 1 (AND 분해)
```
σ(고객등급=VIP), σ(카테고리=전자), σ(금액>100000)로 분해
```

**Step 2**: Rule 6 (선택 분배)
```
고객 테이블: σ(등급=VIP)
상품 테이블: σ(카테고리=전자)
주문 테이블: σ(금액>100000)
```

**Step 3**: Rule 8 (프로젝션)
```
고객: 이름, 고객ID만
주문: 금액, 고객ID, 상품ID만
상품: 상품ID만
```

**최종 쿼리:**
```sql
SELECT π(이름, 총액)[
  π(이름, 고객ID)[σ(등급='VIP')[고객]]
  ⨝
  π(금액, 고객ID, 상품ID)[σ(금액>100000)[주문]]
  ⨝
  π(상품ID)[σ(카테고리='전자')[상품]]
]
```

</details>

---

**작성일**: 2025-02-01  
**난이도**: ⭐⭐⭐⭐ (충분한 학습 필요)