---
title: '최적화 규칙과 실행 계획 생성'
description: '변환 규칙들을 체계적으로 학습하고 최적의 실행 계획을 만드는 방법을 배워봅시다'
slug: 'database/optimization-rules-execution-plan'
sidebar_label: '최적화 규칙과 실행 계획'
sidebar_position: 7
date: '2025-02-02'
---

# 최적화 규칙과 실행 계획 생성

## 수학처럼 검증된 변환 규칙들

지금까지 우리는 경험적 최적화라는 실무 중심의 기법을 배웠습니다.

이제 한 단계 더 나아가 그 경험들을 **체계적으로 정리한 변환 규칙들**을 살펴봅시다.

일반 수학에서 분배법칙이나 교환법칙이 있듯이, 데이터베이스 최적화도 명확한 규칙들로 이루어져 있습니다.

중요한 점은 이 규칙들이 단순한 경험담이 아니라는 것입니다.

모두 **수학적으로 증명된 정식들**입니다.

따라서 언제나 같은 결과를 보장하면서도 성능을 개선할 수 있습니다.

규칙을 올바르게 적용하면 비효율적인 실행 계획을 효율적인 계획으로 변환할 수 있습니다.

여기서 가장 중요한 점을 강조하고 싶습니다.

규칙을 적용해도 **최종 결과는 절대 변하지 않습니다**.

단지 컴퓨터가 그 결과를 얻기 위해 거쳐가는 경로만 달라질 뿐입니다.

:::tip 규칙의 가장 큰 강점
같은 답을 만들면서도 더 빠르게 도달할 수 있다는 것이 규칙의 핵심입니다.
:::

## 규칙이 갖춰야 할 세 가지 조건

모든 변환 규칙은 기본적인 구조를 따릅니다.

왼쪽은 **변환 전의 형태**입니다.

비효율적이거나 복잡한 방식으로 처리하는 경우입니다.

오른쪽은 **변환 후의 형태**입니다.

더 간단하거나 빠른 방식으로 처리하는 경우입니다.

그런데 수학적으로 두 형태는 완벽하게 동일한 결과를 만들어냅니다.

규칙이 유효하려면 세 가지 조건을 모두 만족해야 합니다.

### 첫 번째 조건: 수학적 증명

규칙은 수학적으로 엄밀하게 증명되어야 합니다.

단순한 추측이나 경험만으로는 부족합니다.

논리적 과정을 거쳐서 반드시 성립함을 보여야 합니다.

### 두 번째 조건: 정확성 보장

변환 전후의 결과가 항상 같아야 합니다.

어떤 데이터를 입력하든 결과는 동일해야 합니다.

예외가 있으면 규칙이 아닙니다.

### 세 번째 조건: 성능 개선

변환 후가 변환 전보다 성능이 더 좋아야 합니다.

같은 결과를 만드는 것이 목표가 아니라, 더 빨리 만드는 것이 목표입니다.

이 세 조건을 모두 만족할 때만 진정한 최적화 규칙이 됩니다.

:::info 규칙 vs 관습
관습은 "대개 이렇게 하면 빠르더라"는 수준이지만, 규칙은 "이렇게 하면 반드시 최적이다"는 보장입니다.
:::

## Rule 1: AND 조건의 분해와 순차 처리

가장 기본이 되는 규칙부터 시작해봅시다.

**AND로 연결된 여러 조건들을 분해**하는 것입니다.

WHERE 절에 세 가지 조건이 있다면 어떻게 할까요?

한 번에 처리하는 것보다 순차적으로 처리하는 것이 효율적입니다.

### 구체적인 예시

학생 데이터에서 성별이 남자이고, 지역이 서울이며, 점수가 80 이상인 학생을 찾는다고 합시다.

비효율적 방식은 각 행마다 **세 가지 조건을 모두 동시에** 확인하는 것입니다.

효율적 방식은 다릅니다.

먼저 성별이 남자인 학생만 필터링합니다.

100명이 10명으로 줄어듭니다.

그 다음 그 10명 중에서 지역이 서울인 학생을 찾습니다.

마지막으로 그 결과에서 점수가 80 이상인 학생을 찾습니다.

### 처리 단계별 데이터 감소

각 단계를 거칠 때마다 처리해야 할 데이터의 양이 줄어듭니다.

100명 → 성별 조건으로 10명 → 지역 조건으로 5명 → 점수 조건으로 1명

세 번째 필터링에서는 10명 정도만 확인하면 됩니다.

처음부터 100명을 다 확인하는 것과는 비교가 안 됩니다.

:::tip 분해의 가치
조건을 분해하면 각 단계에서 불필요한 데이터를 빠르게 제거할 수 있습니다.
:::

## Rule 2: 셀렉션의 교환성과 선택도 최적화

AND로 분해된 조건들은 한 가지 특성을 가지고 있습니다.

**어떤 순서로 처리해도 최종 결과는 같습니다**.

성별부터 필터링하고 지역을 필터링하는 것이나, 지역부터 필터링하고 성별을 필터링하는 것이나 결과는 동일합니다.

그런데 여기서 중요한 발견이 있습니다.

**성능은 다르다**는 것입니다.

이것이 바로 **선택도** 개념의 중요성입니다.

### 선택도란 무엇인가?

선택도는 전체 데이터 중에서 조건을 만족하는 데이터의 비율을 의미합니다.

남자가 전체의 10퍼센트라면 선택도는 10퍼센트입니다.

서울이 50퍼센트라면 선택도는 50퍼센트입니다.

### 최적의 순서

선택도가 낮은 조건부터 처리하면 더 빠릅니다.

남자가 10퍼센트이고 서울이 50퍼센트라면?

남자부터 필터링해야 합니다.

100명에서 10명으로 줄인 후, 그 10명 중에서 5명을 찾는 것이 더 빠릅니다.

반대의 순서면 100명에서 50명으로 줄인 후, 그 50명 중에서 5명을 찾습니다.

처리량이 더 많습니다.

### 실제 수치로 비교

선택도 순서가 중요한지 수치로 확인해봅시다.

남자(10%) → 서울(50%) 순서:
- 첫 번째: 100행 처리
- 두 번째: 10행 처리
- 합계: 110행

서울(50%) → 남자(10%) 순서:
- 첫 번째: 100행 처리
- 두 번째: 50행 처리
- 합계: 150행

약 27퍼센트의 차이가 납니다.

대규모 데이터셋에서는 이것이 수십 배의 성능 차이로 나타납니다.

:::warning 주의사항
조건들을 분해하는 것만으로는 충분하지 않습니다.

분해한 후에 선택도 순서로 재정렬해야 진정한 최적화가 됩니다.
:::

## Rule 3: 연속된 프로젝션의 제거

다음 규칙은 프로젝션에 관한 것입니다.

프로젝션이란 필요한 컬럼만 추출하는 작업입니다.

효율적인 프로젝션은 한 번만 필요합니다.

### 비효율적 방식의 문제점

비효율적 방식을 생각해봅시다.

먼저 학번, 이름, 학과 세 컬럼을 추출합니다.

그 다음 그 결과에서 학번, 이름만 추출합니다.

마지막으로 그 결과에서 이름만 추출합니다.

총 세 번이나 프로젝션을 합니다.

이는 완전히 낭비입니다.

### 효율적 방식

처음부터 이름만 추출하면 됩니다.

결과는 동일하지만 한 번만 필터링하면 됩니다.

중간에 불필요한 단계를 모두 제거했습니다.

### 메모리 효율성

이 규칙이 중요한 이유는 데이터의 양이 급격하게 줄어들 수 있기 때문입니다.

학생 테이블의 전체 너비가 500바이트라고 가정합시다.

필요한 이름 컬럼만 20바이트입니다.

1000명의 학생 데이터를 처리할 때:
- 비효율: 500메가바이트 로드
- 효율: 20메가바이트 로드

**25배의 메모리 절약**입니다.

캐시 효율성도 크게 향상됩니다.

더 많은 데이터가 메모리에 머물러 있을 수 있기 때문입니다.

:::tip 프로젝션의 위치가 중요
필요한 컬럼만 조기에 추출하면 이후 모든 연산이 빨라집니다.
:::

## Rule 4: 프로젝션과 셀렉션의 교환

여기서 주의할 점이 하나 있습니다.

**프로젝션과 셀렉션을 항상 교환할 수는 없습니다**.

조건에 필요한 컬럼이 프로젝션에 포함되어 있어야만 교환이 가능합니다.

### 교환 불가능한 경우

학년이 4인 학생의 이름을 찾는 경우를 생각해봅시다.

만약 먼저 이름만 추출한다면 어떻게 될까요?

학년 정보가 없어집니다.

그러면 학년이 4인지 확인할 수 없습니다.

따라서 프로젝션을 먼저 할 수 없습니다.

### 교환 가능한 경우

반대로 먼저 학년이 4인 학생을 필터링한 후 이름만 추출하면?

완벽합니다.

학년 정보는 필터링에만 필요하고, 최종 결과에는 필요 없습니다.

필터링이 끝난 후에는 학년 정보를 버려도 됩니다.

### 핵심 원칙

이 규칙을 올바르게 이해하려면 **어떤 데이터가 중간 단계에서 필요한지, 최종 결과에만 필요한지** 구분해야 합니다.

중간에 사용하지만 최종 결과에 필요 없는 컬럼이 있다면?

그 컬럼을 포함하면서 필터링한 후, 최종 프로젝션에서 제거해야 합니다.

:::info 실무 적용
SQL을 작성할 때 SELECT에는 필요한 것만 명시하세요.

데이터베이스가 중간 단계에서 필터링에 필요한 컬럼을 자동으로 관리합니다.
:::

## Rule 5: 조인 전 선택 실행

여러 테이블을 조인할 때도 최적화 규칙이 중요합니다.

조인 후에 특정 테이블의 조건으로 필터링한다면 어떻게 될까요?

먼저 그 테이블에서 필터링한 후 조인하는 것이 훨씬 효율적입니다.

### 비효율적인 방식

학생 테이블 1000명과 성적 테이블 5000행을 조인합니다.

중간 결과는 상당히 큽니다.

그 다음에 학생의 학년이 4라는 조건으로 필터링합니다.

이미 조인을 다 한 후에 필터링을 합니다.

비효율적입니다.

### 효율적인 방식

먼저 학생 테이블에서 학년이 4인 학생만 추출합니다.

약 250명입니다.

그 다음에 이 250명과 성적 테이블을 조인합니다.

조인 비용이 크게 줄어듭니다.

### 성능 비교

비효율: 1000 × 5000 = 5,000,000행 조인 후 필터링

효율: (학년=4 필터링 후 250명) × 5000행 = 1,250,000행 조인

**약 4배의 성능 개선**입니다.

대규모 데이터셋에서는 이러한 차이가 엄청납니다.

:::warning 조인의 위험성
조인은 매우 비용이 큰 연산입니다.

가능한 한 조인 대상의 데이터를 먼저 줄이세요.
:::

## Rule 6: 조인 순서의 최적화

여러 테이블을 한 번에 조인할 때는 또 다른 고민이 생깁니다.

**어떤 순서로 조인할 것인가**입니다.

(학생 조인 성적) 후 강의와 조인하는 것과,
(학생 조인 강의) 후 성적과 조인하는 것은 최종 결과는 같습니다.

하지만 중간 단계의 비용은 완전히 다릅니다.

### 데이터 크기 비교

학생: 1000명

성적: 5000행

강의: 100행

### 순서 1: 강의 → 성적 → 학생

(강의 조인 성적) 먼저 하면 결과는 약 500행입니다.

강의 100행이 성적 5000행과 조인되지만, 실제로는 강의 하나당 약 50개의 성적이 있을 것으로 추정됩니다.

그 다음 이 500행을 학생 1000명과 조인하면?

500 × 1000 = 500,000행 조인

### 순서 2: 학생 → 성적 → 강의

(학생 조인 성적) 먼저 하면 결과가 훨씬 더 커집니다.

1000 × 5000 = 5,000,000행

그 다음 강의와 조인하는 것은 비용이 매우 높습니다.

### 결론

조인 순서 하나만 바꿔도 **전체 성능이 크게 달라질 수 있습니다**.

일반적인 규칙은 **작은 테이블끼리 먼저 조인**하는 것입니다.

작은 중간 결과를 만들면, 그 다음 조인이 훨씬 빨라집니다.

:::tip 조인 순서의 기본 원칙
항상 작은 것끼리 먼저 조인하세요.

큰 테이블은 나중에 처리하는 것이 효율적입니다.
:::

## Rule 7: 프로젝션의 분산 처리

조인 전에 필요한 컬럼만 미리 추출하는 것도 중요합니다.

학생의 이름과 성적의 점수를 구한다고 합시다.

### 비효율적 방식

전체 학생 데이터를 로드합니다.

전체 성적 데이터를 로드합니다.

조인합니다.

필요한 컬럼만 추출합니다.

중간에 엄청난 양의 불필요한 데이터를 처리했습니다.

### 효율적 방식

학생에서 이름과 학번만 미리 추출합니다.

성적에서 학번과 점수만 미리 추출합니다.

그 다음에 조인합니다.

### 효과

조인 대상의 데이터 양이 크게 줄어듭니다.

메모리 사용과 I/O 비용이 모두 감소합니다.

시스템 전체의 처리 속도가 향상됩니다.

## 실전 예시: 여러 규칙의 조합

이제 이 규칙들을 실제로 적용해봅시다.

다음과 같은 SQL이 있다고 가정합니다.

```sql
SELECT 선원.이름
FROM 예약, 선원
WHERE 예약.아이디 = 선원.아이디 
  AND 예약.보트아이디 = 100 
  AND 선원.레이팅 > 5;
```

### Step 1: 관계 대수로 표현

이를 관계 대수로 변환합니다.

프로젝션으로 이름을 명시합니다.

셀렉션으로 두 조건을 표현합니다.

조인으로 두 테이블을 연결합니다.

### Step 2: AND 조건 분해

하나의 셀렉션 노드가 아닌 여러 개의 셀렉션 노드로 나뉩니다.

각 조건이 독립적으로 처리될 준비가 됩니다.

### Step 3: 선택을 조인 아래로 내리기

보트 조건은 예약 테이블에만 영향을 미칩니다.

레이팅 조건은 선원 테이블에만 영향을 미칩니다.

각 테이블에 별도의 필터링을 먼저 적용합니다.

그 다음 조인합니다.

### Step 4: 프로젝션 최적화

필요한 컬럼만 미리 추출합니다.

불필요한 컬럼은 최소한으로 유지합니다.

### 최종 효과

단계별로 규칙을 적용하면 초기의 비효율적인 계획이 점점 효율적으로 변환됩니다.

최종 결과는 약 **20배의 성능 개선**을 가져올 수 있습니다.

이는 이론적인 개선이 아니라 실제로 측정된 수치입니다.

:::info 실제 사례
많은 데이터베이스 시스템에서 이러한 규칙들이 자동으로 적용됩니다.

하지만 규칙들을 이해하면, 더 좋은 SQL을 직접 작성할 수 있습니다.
:::

## 규칙 적용 시의 주의사항

모든 규칙이 항상 성능 개선을 가져오는 것은 아닙니다.

특정 상황에서는 예외가 발생합니다.

### 인덱스가 있는 경우

학년에 인덱스가 있다면 어떻게 될까요?

학년으로 필터링하는 것이 매우 빠릅니다.

선택도가 높더라도 인덱스 덕분에 빠를 수 있습니다.

인덱스가 없다면?

반드시 선택도가 낮은 조건부터 처리해야 합니다.

### 복잡한 조건

매우 복잡한 조건이 있다면?

AND 분해가 오버헤드를 발생시킬 수 있습니다.

조건이 단순하면 한 번에 처리하는 것이 더 빠를 수도 있습니다.

### 규칙은 가이드라인

따라서 규칙은 절대적인 진리가 아니라 **가이드라인**일 뿐입니다.

최종적으로는 **비용 계산**을 통해 어느 계획이 가장 효율적인지 확인해야 합니다.

:::warning 규칙의 한계
규칙을 맹목적으로 따르지 마세요.

항상 구체적인 상황을 고려하여 적용하세요.
:::

## 경험적 최적화와 비용 기반 최적화의 협력

현대의 데이터베이스 시스템은 두 가지 방식을 함께 사용합니다.

### 1단계: 경험적 최적화

먼저 이 규칙들을 사용해 명백히 비효율적인 계획들을 빠르게 제거합니다.

카티션 곱셈이 있다면 조인으로 바꿉니다.

불필요한 프로젝션이 있다면 제거합니다.

조건의 순서를 선택도에 따라 조정합니다.

### 2단계: 비용 기반 최적화

남은 후보 계획들에 대해 더 정밀한 비용 계산을 수행합니다.

실제 통계 정보를 바탕으로 각 계획의 비용을 계산합니다.

가장 비용이 낮은 계획을 선택합니다.

### 장점

두 방식을 조합하면 **빠른 처리 속도**와 **높은 최적화 품질**을 동시에 달성할 수 있습니다.

경험적 최적화는 빠르고, 비용 기반 최적화는 정확합니다.

함께 사용하면 실무에서 최고의 성능을 얻을 수 있습니다.

## 최적화 규칙의 실제 효과

이 규칙들이 얼마나 효과적인지 구체적인 수치로 확인해봅시다.

예약 테이블: 100행

선원 테이블: 1000행

### 최적화되지 않은 방식

100 × 1000 = 100,000행을 조인합니다.

그 다음에 조건으로 필터링합니다.

최종 결과는 약 10행입니다.

하지만 중간에 100,000행을 처리했습니다.

### 최적화된 방식

보트 아이디 조건으로 예약을 10행으로 줄입니다.

레이팅 조건으로 선원을 500행으로 줄입니다.

10 × 500 = 5,000행만 조인합니다.

### 성능 개선

100,000행 대 5,000행

**약 20배의 성능 개선**입니다.

### 대규모 데이터셋

이 효과는 대규모 데이터셋에서 더욱 극적입니다.

수백만 행을 다루는 시스템에서는?

이 규칙들의 올바른 적용이 **성능의 생사를 가르게** 됩니다.

:::tip 규칙 학습의 가치
이러한 규칙들을 이해하면, 더 나은 SQL을 작성할 수 있습니다.

그리고 데이터베이스 시스템의 동작을 더 깊이 이해할 수 있습니다.
:::

**작성일**: 2025-02-02