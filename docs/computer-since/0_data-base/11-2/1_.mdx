---
title: 'Selection 연산과 접근 방법'
description: '데이터베이스에서 특정 데이터를 찾는 여러 가지 검색 기법을 배워봅시다'
slug: 'database/selection-access-methods'
sidebar_label: 'Selection 연산과 접근 방법'
sidebar_position: 1
date: '2025-02-01'
---

# Selection 연산과 접근 방법

## 📌 Selection 연산이란

특정 조건을 만족하는 데이터를 찾는 연산입니다.

```
예시: 점수가 50점 이상인 학생을 찾아라

테이블 R
┌─────┬────────┐
│학번 │ 점수   │
├─────┼────────┤
│ 1   │ 100점  │
│ 2   │ 80점   │
│ 3   │ 50점   │ ← 찾아야 할 데이터
│ 4   │ 70점   │
│ 5   │ 90점   │
└─────┴────────┘

σ(점수 >= 50점)(R) → 학번 출력
```

---

## 🔍 4가지 검색 방법

### 1) 선형 탐색 (Linear Search)

모든 레코드를 처음부터 끝까지 순차적으로 검색합니다.

```
데이터: [100, 80, 50, 70, 90]

검색: 50점 찾기
┌────────────────────┐
│ 1번 검사: 100 ≠ 50 │
│ 2번 검사: 80 ≠ 50  │
│ 3번 검사: 50 = 50  │ ✓ 찾음!
└────────────────────┘

탐색 횟수: 3회 (평균 50%)
시간 복잡도: O(n)
```

**특징:**
- 데이터가 정렬되지 않아도 가능
- 모든 레코드를 확인해야 할 수도 있음
- 가장 단순하지만 느림

---

### 2) 이진 탐색 (Binary Search)

정렬된 데이터에서 중간값과 비교하여 범위를 반으로 줄여가며 검색합니다.

```
정렬된 데이터: [50, 70, 80, 90, 100]

검색: 50점 찾기

1단계: 중간값 80과 비교
  50 < 80 → 왼쪽 영역 선택
  [50, 70]

2단계: 중간값 70과 비교
  50 < 70 → 왼쪽 영역 선택
  [50]

3단계: 50과 비교
  50 = 50 → 찾음! ✓

탐색 횟수: 3회 (log₂n)
시간 복잡도: O(log n)
```

**특징:**
- 반드시 정렬되어야 함
- 탐색 횟수가 빠르게 감소
- 선형 탐색보다 훨씬 효율적

**성능 비교:**
```
데이터 1000개
- 선형 탐색: 평균 500회
- 이진 탐색: 평균 10회

→ 이진 탐색이 50배 빠름!
```

---

### 3) 인덱스 이용 (Index)

책의 목차처럼 인덱스 테이블을 이용해 빠르게 찾습니다.

```
책에서 120페이지 찾기:

1단계: 목차 확인
  ┌─────────────────────┐
  │ 목차                 │
  │ 1장: 1-30페이지      │
  │ 2장: 31-90페이지     │
  │ 3장: 91-150페이지    │ ← 120은 여기!
  └─────────────────────┘

2단계: 해당 장으로 이동
  3장 찾아가기 → 120페이지 도착

탐색 횟수: 2회
```

**인덱스 구조:**
```
인덱스 테이블
┌────────┬──────────┐
│ 점수   │ 레코드번호│
├────────┼──────────┤
│ 50     │ 3        │
│ 70     │ 4        │
│ 80     │ 2        │
│ 90     │ 5        │
│ 100    │ 1        │
└────────┴──────────┘

검색: 50점 → 인덱스 확인 → 레코드 3번 직접 접근
```

**특징:**
- 매우 빠른 검색 (거의 상수 시간)
- 인덱스 유지 비용 발생
- 삽입/삭제 시 인덱스도 업데이트해야 함

---

### 4) 해싱 (Hashing)

해시 함수를 사용하여 데이터의 주소를 직접 계산합니다.

```
해시 함수: h(x) = x mod 10

데이터 저장:
- 50점: h(50) = 50 mod 10 = 0 → 주소 0 저장
- 70점: h(70) = 70 mod 10 = 0 → 주소 0 (충돌 처리)
- 80점: h(80) = 80 mod 10 = 0 → 주소 0 (충돌 처리)

검색: 50점
1단계: h(50) = 0 계산
2단계: 주소 0으로 직접 이동
3단계: 데이터 발견 ✓

탐색 횟수: 1회 (해시 충돌 없을 때)
```

**특징:**
- 가장 빠른 검색 (이상적인 경우)
- 해시 충돌 처리 필요
- 범위 검색에는 부적합

---

## 📊 4가지 방법 비교

```
┌─────────────────┬──────────┬────────────┬─────────────┐
│ 검색 방법       │ 정렬필요 │ 속도       │ 장점/단점   │
├─────────────────┼──────────┼────────────┼─────────────┤
│ 선형 탐색       │ 불필요  │ O(n)      │ 간단, 느림  │
│ 이진 탐색       │ 필수     │ O(log n)  │ 빠름        │
│ 인덱스          │ 필수     │ O(1)~O(log)│ 매우 빠름   │
│ 해싱            │ 불필요  │ O(1)      │ 초고속      │
└─────────────────┴──────────┴────────────┴─────────────┘
```

---

## 💡 실제 적용

### WHERE 절에서의 선택

```sql
-- 1) 정렬되지 않은 작은 데이터 → 선형 탐색
SELECT * FROM 학생 WHERE 이름 = '김철수';

-- 2) 정렬된 데이터 → 이진 탐색
SELECT * FROM 정렬된_학생 WHERE 학번 = 1001;

-- 3) 자주 검색되는 컬럼 → 인덱스 사용
CREATE INDEX idx_학번 ON 학생(학번);
SELECT * FROM 학생 WHERE 학번 = 1001;

-- 4) 매우 빠른 검색 필요 → 해시 구조
SELECT * FROM 사용자 WHERE 사용자ID = 'user123';
```

---

## 🎯 선택 기준

```
작은 테이블 (< 1000행)
└─ 선형 탐색으로도 충분

중간 테이블 (1000~10만 행)
└─ 이진 탐색 또는 인덱스 권장

큰 테이블 (> 10만 행)
└─ 인덱스 필수

매우 자주 검색되는 컬럼
└─ 해시 인덱스 고려
```

---

**작성일**: 2025-02-01  
**난이도**: ⭐⭐