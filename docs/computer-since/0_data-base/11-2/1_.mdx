---
title: 'Selection 연산과 접근 방법'
description: '데이터베이스에서 특정 데이터를 찾는 선형 탐색, 이진 탐색, 인덱스, 해싱 등 4가지 검색 기법을 단계별로 배워봅시다'
slug: 'database/selection-access-methods'
sidebar_label: 'Selection 연산과 접근 방법'
date: '2025-02-02'
---

# Selection 연산과 접근 방법

## 🎯 Selection 연산이란

데이터베이스에서 특정 조건을 만족하는 데이터를 찾는 작업을 **Selection 연산**이라고 부릅니다. 관계 대수에서는 σ(시그마) 기호로 표현하며, SQL의 WHERE 절이 바로 이 연산입니다. 처음 데이터베이스를 배울 때는 이것이 단순한 "찾기" 기능이라고 생각하기 쉽습니다. 하지만 실제로는 매우 복잡한 작업이고, 어떤 방식으로 찾는지에 따라 성능이 천지차이가 난다는 것을 알게 됩니다.

구체적인 예를 들어봅시다. 학교의 학생 성적 데이터베이스에서 "점수가 50점 이상인 모든 학생"을 찾는다고 가정하겠습니다. 이것이 바로 Selection 연산입니다. 관계 대수로 표현하면 σ(점수 >= 50)(학생 테이블)이 됩니다.

실제로 이 작업이 얼마나 자주 일어나는지 생각해보세요. 웹사이트에서 검색 버튼을 누를 때마다, 앱에서 필터링할 때마다 Selection 연산이 실행됩니다. 따라서 이 연산을 얼마나 효율적으로 수행하는지가 애플리케이션의 성능을 좌우합니다. 데이터가 1000개면 상관없지만, 1억 개라면? 어떻게 찾는지에 따라 1초에 끝나기도 하고 1분 이상 걸리기도 합니다.

## 🔍 검색 방법 1: 선형 탐색 (Linear Search)

선형 탐색은 가장 단순한 검색 방법입니다. 모든 레코드를 처음부터 끝까지 순차적으로 검색하면서, 각 레코드가 조건을 만족하는지 확인합니다. 마치 책을 첫 페이지부터 마지막 페이지까지 차근차근 읽으면서 원하는 내용을 찾는 것과 같습니다.

첫 번째로 배울 때는 이 방법이 가장 이해하기 쉽습니다. 특별한 준비 과정이 없고, 어떤 순서로 데이터가 저장되어 있든 작동합니다. 하지만 처음 배운 후 실제로 큰 데이터에 적용해보면 성능의 비참함을 느끼게 됩니다.

```javascript
class LinearSearch {
  constructor(data) {
    this.data = data; // 정렬되지 않은 배열
  }

  search(target) {
    let comparisons = 0;
    
    for (let i = 0; i < this.data.length; i++) {
      comparisons++;
      if (this.data[i] === target) {
        console.log(`찾음! ${comparisons}회 비교`);
        return { found: true, comparisons, index: i };
      }
    }
    
    console.log(`못 찾음. ${comparisons}회 비교 (전체 스캔)`);
    return { found: false, comparisons };
  }
}

// 사용 예시
const scores = [100, 85, 92, 78, 88, 95, 82];
const linearSearch = new LinearSearch(scores);
linearSearch.search(92);  // 찾음! 3회 비교
linearSearch.search(999); // 못 찾음. 7회 비교 (전체 스캔)
```

**코드 리뷰:**

- `constructor(data)` 부분: 생성자에서 정렬되지 않은 배열을 받아서 저장합니다. 이것이 선형 탐색의 장점입니다. 어떤 상태의 데이터든 받을 수 있습니다.
- `let comparisons = 0` 라인: 비교 횟수를 추적하기 위해 카운터를 초기화합니다. 실제 성능 분석을 위해 중요합니다.
- `for (let i = 0; i < this.data.length; i++)` 루프: 처음부터 끝까지 모든 원소를 순회합니다. 이것이 "선형"이라고 불리는 이유입니다. 원소가 n개면 최악의 경우 n번 반복합니다.
- `if (this.data[i] === target)` 조건: 현재 원소가 찾는 값인지 확인합니다. 일치하면 즉시 반환합니다.

**성능 특징:**

- **시간 복잡도**: O(n) - n은 레코드 수입니다.
- **평균 탐색 횟수**: n/2 - 데이터가 1000개면 평균 500번 비교합니다.
- **최악의 경우**: n - 찾는 데이터가 맨 끝에 있거나 없을 때입니다.

**흔한 실수와 해결법:**

- 만약 큰 데이터(100만 개 이상)에 선형 탐색을 사용하면, 평균 50만 번의 비교가 필요합니다. 현대 CPU는 초당 수십억 번의 연산을 수행하지만, 그래도 1초 이상 걸릴 수 있습니다. 데이터가 자주 검색된다면 반드시 다른 방법을 고려해야 합니다.
- 조건이 복잡한 경우 (예: `score > 80 AND name.startsWith('김')`) 각 레코드마다 전체 조건을 평가해야 하므로 더 느려집니다.

## 🎯 검색 방법 2: 이진 탐색 (Binary Search)

이진 탐색은 정렬된 데이터에서만 사용할 수 있는 방법입니다. 하지만 정렬되어 있다면, 엄청나게 빠릅니다. 핵심은 중간값을 확인하여 검색 범위를 반으로 줄여나가는 것입니다. 마치 전화번호부에서 이름을 찾을 때, "이름이 'ㅇ'부터 시작하니까 중간 부분을 펼쳐봐야겠다"는 식으로 접근하는 것과 같습니다.

실제로 이진 탐색의 효율성은 놀랍습니다. 1000개 데이터에서 선형 탐색은 평균 500회 비교를 하지만, 이진 탐색은 겨우 10회면 충분합니다. 데이터가 100만 개라면? 선형 탐색은 50만 회, 이진 탐색은 20회입니다. 이것이 로그 함수의 마법입니다.

```javascript
class BinarySearch {
  constructor(data) {
    this.data = data.sort((a, b) => a - b); // 반드시 정렬
  }

  search(target) {
    let left = 0;
    let right = this.data.length - 1;
    let comparisons = 0;

    while (left <= right) {
      comparisons++;
      const mid = Math.floor((left + right) / 2);
      const midValue = this.data[mid];

      if (midValue === target) {
        console.log(`찾음! ${comparisons}회 비교`);
        return { found: true, comparisons, index: mid };
      } else if (midValue < target) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }

    console.log(`못 찾음. ${comparisons}회 비교`);
    return { found: false, comparisons };
  }
}

// 사용 예시
const scores = [100, 85, 92, 78, 88, 95, 82];
const binarySearch = new BinarySearch(scores);
binarySearch.search(92);  // 찾음! 2~3회 비교
binarySearch.search(999); // 못 찾음. 3회 비교 (훨씬 빠름!)
```

**코드 리뷰:**

- `this.data = data.sort((a, b) => a - b)` 라인: 이진 탐색을 사용하려면 반드시 정렬되어야 합니다. 이것이 이진 탐색의 유일한 전제조건입니다. 정렬되지 않으면 이진 탐색의 논리가 깨집니다.
- `let left = 0`, `let right = this.data.length - 1` 부분: 탐색 범위의 좌측 끝과 우측 끝을 표시합니다. 이 범위를 계속 줄여나갑니다.
- `const mid = Math.floor((left + right) / 2)` 계산: 범위의 중간값 인덱스를 구합니다. 이 중간값과 비교하여 범위를 반으로 줄입니다.
- `if (midValue < target) { left = mid + 1; }` 조건: 중간값이 찾는 값보다 작으면, 오른쪽 절반만 탐색하면 됩니다. 왼쪽 절반은 모두 버립니다.

**성능 특징:**

- **시간 복잡도**: O(log n) - n이 100만이어도 약 20번만 필요합니다.
- **탐색 횟수**: log₂(n) - 데이터가 1000개면 log₂(1000) ≈ 10회입니다.
- **데이터 1억 개**: 겨우 27회 비교로 충분합니다!

**흔한 실수와 해결법:**

- 정렬되지 않은 데이터에 이진 탐색을 적용하면 잘못된 결과가 나옵니다. 예를 들어, [50, 90, 30, 80, 70] 배열에서 50을 찾으려고 이진 탐색을 하면 찾지 못할 수도 있습니다. 반드시 정렬을 먼저 확인하세요.
- 정렬에 드는 비용도 고려해야 합니다. 정렬은 일반적으로 O(n log n) 시간이 걸립니다. 따라서 한 번만 검색할 거라면 선형 탐색이 나을 수도 있고, 여러 번 검색할 거라면 정렬 후 이진 탐색이 낫습니다.

## 🏗️ 검색 방법 3: 인덱스 (Index)

이제 실제 데이터베이스에서 사용하는 방법입니다. 인덱스는 책의 목차처럼 작동합니다. 원본 데이터는 그대로 두고, 별도의 "찾기 쉬운 구조"를 만들어놓는 것입니다. 마치 도서관의 책 목록처럼, "철학 관련 책들이 302-310 구간에 있다"는 정보를 미리 알고 있으면, 전체 도서관을 돌아다니지 않아도 됩니다.

처음 데이터베이스를 배울 때 인덱스의 개념이 혼란스럽습니다. "인덱스를 생성하면 데이터가 복사되는 건가? 메모리가 두 배가 되는 건가?"라고 생각하기 쉽습니다. 맞습니다. 인덱스를 사용하면 저장 공간이 늘어납니다. 하지만 그 대신 검색 속도가 극적으로 빨라지므로, 대부분의 경우 가치 있는 트레이드오프입니다.

```javascript
class IndexSearch {
  constructor(data) {
    this.data = data;
    this.index = new Map(); // 인덱스 테이블
    
    for (let i = 0; i < data.length; i++) {
      const value = data[i];
      if (!this.index.has(value)) {
        this.index.set(value, []);
      }
      this.index.get(value).push(i);
    }
  }

  search(target) {
    let comparisons = 0;
    comparisons++; // Map 조회 1회
    
    if (this.index.has(target)) {
      const indices = this.index.get(target);
      const results = indices.map(i => this.data[i]);
      console.log(`찾음! ${comparisons}회 비교, 결과: ${results}`);
      return { found: true, comparisons, results };
    }
    
    console.log(`못 찾음. ${comparisons}회 비교`);
    return { found: false, comparisons };
  }
}

// 사용 예시
const scores = [100, 85, 92, 78, 88, 95, 92]; // 92가 중복
const indexSearch = new IndexSearch(scores);
indexSearch.search(92);  // 찾음! 1회 비교, 결과: [92, 92]
indexSearch.search(999); // 못 찾음. 1회 비교
```

**코드 리뷰:**

- `this.index = new Map()` 부분: 인덱스 테이블을 생성합니다. JavaScript의 Map은 해시 테이블 기반이므로, 매우 빠른 조회를 제공합니다.
- `for (let i = 0; i < data.length; i++)` 루프: 원본 데이터의 모든 원소를 순회하면서 인덱스를 구축합니다. 이 과정은 한 번만 합니다.
- `this.index.set(value, [])` 라인: 각 값에 대해 빈 배열을 만들어서 해당 값의 인덱스들을 저장할 준비를 합니다.
- `this.index.get(value).push(i)` 부분: 같은 값이 여러 번 나타날 수 있으므로 (92가 두 번), 배열에 인덱스를 추가합니다.
- `comparisons++` 부분: 인덱스 조회는 상수 시간이므로 1회로 계산합니다. 실제 데이터베이스에서도 마찬가지입니다.

**성능 특징:**

- **검색 시간**: O(1) (이상적인 경우) 또는 O(log n) (B-tree 인덱스의 경우)
- **구축 시간**: O(n) - 인덱스를 처음 만들 때는 모든 데이터를 순회해야 합니다.
- **추가 메모리**: 원본의 약 10~30% 정도 추가 공간이 필요합니다.

**흔한 실수와 해결법:**

- 인덱스를 생성했다고 해서 모든 쿼리가 빨라지는 것은 아닙니다. 인덱스된 컬럼으로 검색할 때만 빠릅니다. 예를 들어, 학번에 인덱스가 있지만 이름으로 검색하면 여전히 선형 탐색을 합니다.
- 데이터를 삽입, 수정, 삭제할 때마다 인덱스도 함께 업데이트해야 합니다. 따라서 매우 자주 쓰기가 일어나는 테이블에 인덱스가 많으면 오히려 성능이 떨어질 수 있습니다.
- 불필요한 인덱스는 제거하세요. 생성하지 않는 인덱스는 메모리만 낭비하고 쓰기 성능을 해칩니다.

## ⚡ 검색 방법 4: 해싱 (Hashing)

해싱은 조금 다른 개념입니다. 인덱스처럼 "어디에 있는가"를 저장하는 대신, "주소를 계산해서 직접 찾아가는" 방식입니다. 마치 도시의 주소처럼, 우편번호를 알면 위치를 찾아갈 수 있듯이, 데이터를 입력하면 저장 위치를 계산할 수 있습니다.

처음 해싱을 배울 때는 "정말 이렇게 간단하게 찾을 수 있나?"라고 의심합니다. 맞습니다. 이상적인 경우에는 정말 그렇습니다. 하지만 "해시 충돌"이라는 문제가 생깁니다. 서로 다른 데이터가 같은 주소를 가질 수 있다는 뜻입니다. 이 충돌을 어떻게 처리하느냐가 해싱의 핵심입니다.

```javascript
class HashSearch {
  constructor(data, hashSize = 10) {
    this.hashSize = hashSize;
    this.hashTable = Array(hashSize).fill(null).map(() => []);
    
    for (let value of data) {
      const hashValue = this.hash(value);
      this.hashTable[hashValue].push(value);
    }
  }

  hash(value) {
    // 단순 해시 함수: 값을 테이블 크기로 나눈 나머지
    return value % this.hashSize;
  }

  search(target) {
    let comparisons = 0;
    
    const hashValue = this.hash(target);
    comparisons++; // 해시 계산 1회
    
    const bucket = this.hashTable[hashValue];
    for (let value of bucket) {
      comparisons++;
      if (value === target) {
        console.log(`찾음! ${comparisons}회 비교`);
        return { found: true, comparisons };
      }
    }
    
    console.log(`못 찾음. ${comparisons}회 비교`);
    return { found: false, comparisons };
  }
}

// 사용 예시
const scores = [100, 85, 92, 78, 88, 95, 82];
const hashSearch = new HashSearch(scores, 10);
hashSearch.search(92);  // 찾음! 1~2회 비교 (충돌에 따라 다름)
hashSearch.search(999); // 못 찾음. 1회 비교
```

**코드 리뷰:**

- `this.hashTable = Array(hashSize).fill(null).map(() => [])` 라인: 해시 테이블을 생성합니다. 각 버킷(주소)에 배열을 만들어서 충돌된 값들을 저장합니다. 이것을 "연쇄법"이라고 부릅니다.
- `hash(value)` 메서드: 값을 입력받아서 저장 위치를 계산합니다. 여기서는 나머지 연산을 사용했지만, 실제 데이터베이스는 훨씬 복잡한 함수를 사용합니다.
- `const bucket = this.hashTable[hashValue]` 부분: 계산된 해시 값에 해당하는 버킷을 가져옵니다. 충돌이 없었다면 이 버킷에 원하는 값이 있을 것입니다.
- `for (let value of bucket)` 루프: 버킷 내에서 실제 값을 찾습니다. 충돌이 많으면 이 루프가 여러 번 실행됩니다.

**성능 특징:**

- **이상적인 경우**: O(1) - 충돌이 없으면 단 한 번의 계산과 접근으로 끝납니다.
- **최악의 경우**: O(n) - 모든 값이 같은 해시 값을 가지면 선형 탐색과 같아집니다.
- **실제 경우**: O(1 + α) - α는 로드 팩터(데이터 수 / 버킷 수)입니다. 보통 0.5~0.75 범위에서 유지합니다.

**흔한 실수와 해결법:**

- 해시 함수가 잘못되면 성능이 극도로 떨어집니다. 예를 들어, 학생 아이디가 1, 11, 21, 31처럼 10씩 증가한다면, `hash(x) = x mod 10`은 모두 같은 주소를 할당해서 끔찍한 충돌을 일으킵니다.
- 범위 검색에는 사용할 수 없습니다. "50~90점 사이의 모든 학생"을 찾으려면 모든 버킷을 순회해야 하므로 의미가 없습니다. 이 경우 이진 탐색이나 B-tree 인덱스를 사용해야 합니다.
- 데이터의 분포를 모를 때는 해싱을 피하세요. 해시 함수는 데이터의 특성을 알고 설계해야 효율적입니다.

## 📊 4가지 방법 종합 비교

이제 4가지 방법을 직접 비교해봅시다. 이 비교를 통해 상황에 따라 어떤 방법을 선택해야 하는지 판단할 수 있습니다.

100만 개의 정렬되지 않은 데이터에서 특정 값 하나를 찾는다고 가정합시다. 각 비교는 약 0.001 밀리초 걸린다고 하면:

- **선형 탐색**: 평균 500만 회 비교 = 5초 (너무 느림!)
- **이진 탐색**: 약 20회 비교 = 0.02밀리초 (정렬 시간 별도)
- **인덱스**: 약 20회 비교 = 0.02밀리초 (인덱스 생성 시간 별도)
- **해싱**: 평균 2~3회 비교 = 0.002~0.003밀리초 (이상적인 경우)

성능은 확실합니다. 하지만 실제 선택은 더 복잡합니다.

**정렬 상태**: 데이터가 정렬되어 있다면 이진 탐색을 바로 사용할 수 있습니다. 정렬되어 있지 않다면 정렬에 드는 비용이 추가됩니다 (O(n log n)).

**검색 빈도**: 데이터를 한 번만 검색한다면, 인덱스를 만드는 비용(O(n))이 아깝습니다. 하지만 여러 번 검색한다면 인덱스를 만드는 것이 확실히 이득입니다.

**범위 검색 필요 여부**: "50점 이상"이라는 범위 검색이 필요하다면 해싱은 불가능하고, 이진 탐색이나 B-tree 인덱스를 사용해야 합니다.

**데이터 수정 빈도**: 데이터를 매우 자주 삽입, 수정, 삭제한다면 인덱스 유지 비용이 높으므로, 인덱스를 신중하게 선택해야 합니다.

## 🎓 실전 선택 가이드

실제 데이터베이스를 설계할 때, 어떤 검색 방법을 선택해야 할까요?

**작은 테이블 (1000행 미만)**: 선형 탐색으로도 충분합니다. 전체 테이블이 메모리에 들어가고, 어차피 빠릅니다. 인덱스를 생성할 필요가 없습니다. 단, 향후 데이터가 증가할 가능성이 있다면 미리 인덱스를 만들어두는 것도 좋습니다.

**중간 테이블 (1000~10만 행)**: 자주 검색되는 컬럼에 인덱스를 생성하세요. 이진 탐색만으로도 괜찮지만, 데이터베이스 시스템이 자동으로 B-tree 인덱스를 관리해주므로 인덱스가 더 편합니다.

**큰 테이블 (10만 행 이상)**: 인덱스가 필수입니다. 특히 자주 검색되는 컬럼들에는 반드시 인덱스를 생성하세요. 여러 컬럼으로 검색한다면 복합 인덱스를 고려하세요.

**초대형 테이블 (1000만 행 이상)**: 인덱스뿐 아니라 파티셔닝도 고려하세요. 테이블을 여러 개로 분할하여 병렬 처리하면 성능이 극적으로 향상됩니다.

**범위 검색이 자주 필요**: 반드시 B-tree 인덱스를 사용하세요. 해싱은 "정확히 이 값"을 찾을 때만 빠르고, 범위 검색에는 전혀 도움이 되지 않습니다.

**사용자 ID 같은 정확한 값 검색**: 해시 인덱스를 고려하세요. 단, 범위 검색이 필요 없을 때만입니다.

**매우 자주 수정되는 테이블**: 인덱스를 최소화하세요. 읽기 성능은 향상되지만 쓰기 성능이 떨어집니다. 필수적인 검색 컬럼에만 인덱스를 두세요.

---

작성일: 2025-02-02