---
title: "Join 연산의 구현 방법"
description: "두 테이블을 연결하는 세 가지 조인 방식과 각각의 특징, 성능 차이를 이해해봅시다"
slug: "database/join-implementation-methods"
sidebar_label: "Join 연산의 구현 방법"
date: "2025-02-02"
---

# Join 연산의 구현 방법

## 🔍 Join이란 무엇인가?

데이터베이스에서 가장 중요한 연산 중 하나가 Join입니다.

두 개 이상의 테이블에서 필요한 데이터를 함께 가져오기 위해 테이블들을 연결합니다.

예를 들어봅시다.

학생 정보는 한 테이블에 있고, 성적 정보는 다른 테이블에 있습니다.

학생의 이름과 그 학생의 성적을 함께 보려면 두 테이블을 연결해야 합니다.

바로 Join이 하는 일입니다.

이 개념을 처음 배울 때 저는 "그냥 두 테이블을 옆에 붙이는 거 아닌가?"라고 단순하게 생각했습니다.

하지만 실제로는 **공통 기준으로 행들을 매칭**하는 매우 복잡한 과정입니다.

두 테이블을 어떻게 연결하는지에 따라 성능이 100배 이상 차이날 수 있습니다.

> **💡 Tip:** Join은 단순히 두 테이블을 붙이는 것이 아니라, 공통 기준으로 데이터를 정확히 매칭하는 과정입니다.

## 📚 왜 여러 Join 방식이 필요할까?

여기서 중요한 질문이 나옵니다.

두 테이블을 연결하는 방법이 정말 한 가지일까요?

답은 아니오입니다.

데이터베이스는 **상황에 따라 다른 방식으로 Join을 구현**합니다.

세 가지 주요 방식이 있습니다: 정렬-병합 조인, 중첩 루프 조인, 해시 조인.

각 방식은 서로 다른 장점과 단점을 가지고 있습니다.

데이터베이스 시스템은 상황을 분석하여 가장 효율적인 방식을 자동으로 선택합니다.

이를 **쿼리 옵티마이저**라고 부르는데, 옵티마이저가 최적의 선택을 할 수 있도록 개발자가 좋은 SQL을 작성해야 합니다.

실무에서 마주치는 많은 성능 문제들이 사실 Join 방식의 선택 실패에서 비롯됩니다.

예를 들어, 백만 건의 주문 데이터를 처리하는데 갑자기 쿼리가 느려진다면?

옵티마이저가 부적절한 Join 방식을 선택했을 가능성이 높습니다.

## 방식 1: 정렬-병합 조인 (Sort-Merge Join)

정렬-병합 조인은 가장 직관적인 방식입니다.

### 동작 원리 상세 분석

먼저 두 테이블을 모두 정렬합니다.

그 다음 양쪽을 동시에 비교하며 병합합니다.

구체적으로 설명해봅시다.

학생 테이블의 학번이 \[1001, 1002, 1003, 1004\]로 이미 정렬되어 있다고 합시다.

성적 테이블의 학번이 \[1003, 1001, 1002, 1004\]로 뒤섞여 있습니다.

먼저 성적 테이블을 \[1001, 1002, 1003, 1004\]로 정렬합니다.

이제 두 테이블을 동시에 읽으면서 비교합니다.

학생 테이블의 포인터가 1001을 가리키고 있습니다.

성적 테이블의 포인터도 1001을 가리킵니다.

일치합니다!

결과에 추가합니다.

양쪽 포인터를 다음으로 이동합니다.

학생 테이블의 1002와 성적 테이블의 1002가 일치합니다.

이렇게 계속 진행합니다.

포인터들이 뒤로 돌아가지 않으므로, 각 행을 한 번씩만 확인합니다.

### 성능 분석 (구체적 계산)

정렬-병합 조인의 비용을 분석해봅시다.

학생 테이블: 1000명, 성적 테이블: 1000명

정렬 비용: 학생 테이블이 이미 정렬되어 있으면 0비용입니다.

성적 테이블을 정렬하는 데 약 1000 × log(1000) = 약 10,000 비용이 들어갑니다.

병합 비용: 양쪽을 한 번씩만 읽으면서 비교합니다.

각 행마다 한 번씩 비교하므로 약 2000회의 비교가 필요합니다.

총 비용: 약 12,000

### 장점과 단점 비교

정렬-병합 조인은 **두 테이블을 완전히 조인**하는 경우에 매우 효율적입니다.

메모리 사용도 최소화됩니다.

양쪽 포인터만 유지하면 되기 때문입니다.

대용량 데이터 처리에 좋습니다.

정렬되지 않은 데이터라도, 정렬 비용이 상대적으로 적다면 이 방식이 최적일 수 있습니다.

하지만 반드시 정렬 과정이 필요합니다.

이는 추가 비용을 발생시킵니다.

부분 조인에는 비효율적입니다.

특정 행만 필요한 경우, 전체를 정렬하는 것이 낭비입니다.

예를 들어, 특정 학생 50명의 성적만 필요한데 1000명을 모두 정렬한다면?

매우 비효율적입니다.

> **⚠️ 주의:** 데이터가 이미 정렬된 인덱스 컬럼으로 조인할 때 이 방식이 자동 선택됩니다.

## 방식 2: 중첩 루프 조인 (Nested Loop Join)

중첩 루프 조인은 가장 단순하고 직관적인 방식입니다.

### 동작 원리 상세 분석

개념은 매우 간단합니다.

외부 테이블의 각 행에 대해 내부 테이블 **전체를 검색**합니다.

마치 두 개의 for 루프가 중첩된 것처럼 동작합니다.

구체적으로 동작을 살펴봅시다.

학생 테이블의 첫 번째 행 (1001번 김철수)을 읽습니다.

성적 테이블을 처음부터 끝까지 검색합니다.

1001번이 있나요?

있습니다!

결과에 추가합니다.

다음 학생 (1002번 이영희)을 읽습니다.

성적 테이블을 **다시 처음부터 끝까지** 검색합니다.

이렇게 계속됩니다.

학생 100명이 있다면, 성적 테이블을 100번 전체 검색하는 것입니다.

### 성능 분석 (인덱스의 영향 포함)

중첩 루프 조인의 비용을 계산해봅시다.

학생 테이블: 100명, 성적 테이블: 1000명

**인덱스 없는 경우:**

총 비교 횟수: 100 × 1000 = **100,000회**입니다.

매우 많습니다.

하지만 인덱스가 있으면 상황이 완전히 달라집니다.

**인덱스 있는 경우:**

성적 테이블의 학번에 인덱스가 있다면?

각 학생마다 인덱스를 사용해 직접 찾을 수 있습니다.

비교 횟수: 100 × log(1000) = 약 1,000회

**약 100배 빨라집니다!**

실무에서는 이 차이가 매우 중요합니다.

처음에 인덱스 없이 쿼리가 1시간이 걸렸는데, 인덱스를 추가하니 30초가 되었다는 경험담을 많이 들을 수 있습니다.

### 코드 레벨의 이해

의사코드로 두 가지 경우를 비교해봅시다.

```javascript
// 인덱스 없는 경우 - 매우 느림
for (let student of 학생_테이블) {
  for (let score of 성적_테이블) {
    if (student.학번 === score.학번) {
      result.push({
        이름: student.이름,
        점수: score.점수
      });
    }
  }
}
```

**코드 리뷰:**
- `for (let student of 학생_테이블)` - 학생 100명을 순회합니다
- `for (let score of 성적_테이블)` - **각 학생마다** 성적 테이블 1000명을 모두 순회합니다
- `if (student.학번 === score.학번)` - 총 100,000번의 비교가 발생합니다

```javascript
// 인덱스 있는 경우 - 빠름
for (let student of 학생_테이블) {
  let scores = 성적_인덱스.get(student.학번);
  if (scores) {
    for (let score of scores) {
      result.push({
        이름: student.이름,
        점수: score.점수
      });
    }
  }
}
```

**코드 리뷰:**
- `let scores = 성적_인덱스.get(student.학번)` - 인덱스를 사용해 거의 즉시 조회합니다
- O(1) 또는 O(log n) 시간에 완료됩니다
- 100번의 인덱스 조회만 필요합니다

**흔한 실수와 해결법:**
- 만약 중첩 루프 조인이 자동으로 선택되었는데 쿼리가 매우 느리다면, 조인 컬럼에 인덱스가 있는지 확인하세요
- `EXPLAIN` 명령으로 실제 실행 계획을 확인할 수 있습니다
- 인덱스가 없다면 추가하면 즉시 성능이 개선됩니다

### 장점과 단점

장점은 정렬 비용이 없다는 것입니다.

메모리도 효율적입니다.

외부 테이블이 작을 때 매우 효율적입니다.

특정 행만 필요한 경우 나머지 행을 처리하지 않을 수 있습니다.

예를 들어 특정 부서 직원 20명의 급여 정보만 필요하다면?

50만 명 전체를 처리할 필요 없이 20명만 처리하면 됩니다.

단점은 많은 비교가 필요하다는 것입니다.

외부 테이블이 크면 매우 비효율적입니다.

인덱스가 없으면 성능이 급격히 떨어집니다.

> **⚠️ 주의:** 두 테이블이 모두 크면 중첩 루프 조인은 절대 사용하면 안 됩니다.

## 방식 3: 해시 조인 (Hash Join)

해시 조인은 현대 데이터베이스에서 가장 자주 사용되는 방식입니다.

### 동작 원리 상세 분석

해시 함수를 사용하여 같은 값을 가진 행들끼리 모아서 비교합니다.

이 개념을 처음 이해할 때는 조금 복잡하지만, 단계별로 나누면 매우 우아합니다.

### Step 1: 작은 테이블을 메모리에 로드

먼저 두 테이블 중 **작은 테이블**을 메모리에 로드합니다.

성적 테이블 (1000명)이 학생 테이블 (10,000명)보다 작다고 합시다.

성적 테이블을 메모리에 로드합니다.

메모리가 충분하다는 가정 하에 이를 수행합니다.

만약 작은 테이블도 메모리에 로드할 수 없다면?

다른 Join 방식을 선택하거나, 분할 처리(Grace Hash Join)를 수행합니다.

### Step 2: 해시 테이블 생성

각 행의 학번에 해시 함수를 적용합니다.

해시 함수는 학번을 입력받아 일정한 범위의 숫자를 반환합니다.

학번 1001 → 해시값 0001

학번 1002 → 해시값 0002

학번 1003 → 해시값 0003

이렇게 같은 해시값을 가진 행들을 같은 버킷에 모읍니다.

메모리상의 구조:

해시값 0001 버킷: \[1001번 학생들\]

해시값 0002 버킷: \[1002번 학생들\]

해시값 0003 버킷: \[1003번 학생들\]

### Step 3: 큰 테이블을 읽으며 해시 조회

학생 테이블을 하나씩 읽습니다.

학생 1001번을 읽었습니다.

해시 함수로 0001을 계산합니다.

메모리의 0001 버킷을 봅시다.

있습니다!

해당 성적 정보와 결합합니다.

다음 학생을 읽고 반복합니다.

### 성능 분석 (대규모 데이터셋)

매우 큰 데이터셋으로 분석해봅시다.

학생 테이블: 1,000,000명, 성적 테이블: 10,000명

**정렬-병합 조인:**

두 테이블을 정렬: 1,000,000 × log(1,000,000) + 10,000 × log(10,000)

약 20,000,000 비용

**중첩 루프 조인:**

1,000,000 × 10,000 = **10,000,000,000회** 비교

인덱스 없으면 시간이 너무 오래 걸립니다.

**해시 조인:**

성적 테이블 로드: 10,000

학생 테이블 읽으며 해시 조회: 1,000,000 × O(1)

약 **1,010,000 비용**

### 비교

정렬-병합 vs 해시 조인: 약 20배

중첩 루프 vs 해시 조인: 약 10,000배

해시 조인이 압도적으로 빠릅니다.

### 코드 레벨의 이해

의사코드로 표현하면 다음과 같습니다.

```javascript
// 1단계: 작은 테이블로 해시 테이블 생성
let hashTable = {};
for (let score of 성적_테이블) {
  let key = hash(score.학번);
  if (!hashTable[key]) {
    hashTable[key] = [];
  }
  hashTable[key].push(score);
}

// 2단계: 큰 테이블을 읽으며 해시 테이블 조회
for (let student of 학생_테이블) {
  let key = hash(student.학번);
  let scores = hashTable[key];
  
  if (scores) {
    for (let score of scores) {
      if (student.학번 === score.학번) {
        result.push({
          이름: student.이름,
          점수: score.점수
        });
      }
    }
  }
}
```

**코드 리뷰:**
- `let hashTable = {}\` - 해시 테이블을 메모리에 생성합니다
- `let key = hash(score.학번)` - 각 행에 해시 함수를 적용합니다
- `hashTable[key].push(score)` - 같은 해시값의 행들을 배열로 저장합니다
- `let scores = hashTable[key]` - O(1) 시간에 조회합니다
- 전체 시간복잡도는 O(n)입니다

**흔한 실수와 해결법:**
- 만약 메모리 부족 에러가 발생한다면, 더 이상 작은 테이블을 메모리에 로드할 수 없다는 뜻입니다
- 이 경우 정렬-병합 조인으로 자동 전환되거나, 분할 처리가 수행됩니다
- 해시 충돌이 많으면 성능이 떨어질 수 있지만, 좋은 해시 함수를 사용하면 거의 문제 없습니다

### 장점과 단점

장점은 매우 빠르다는 것입니다.

O(n) 시간으로 동작합니다.

정렬 비용이 없습니다.

인덱스가 필요 없습니다.

대용량 데이터에 최적입니다.

실무에서 가장 자주 선택되는 이유가 바로 이것입니다.

단점은 메모리가 충분해야 한다는 것입니다.

작은 테이블을 모두 메모리에 로드해야 하기 때문입니다.

범위 조인 (초과, 미만 같은 비교)에 부적합합니다.

해시 함수는 동등 비교만 (등호 조건)에만 효과적입니다.

해시 충돌이 발생할 수 있지만, 일반적으로 문제가 되지 않습니다.

## 세 가지 방식의 종합 비교

각 방식의 특징을 비교 표로 정리해봅시다.

| 특징 | 정렬-병합 조인 | 중첩 루프 조인 | 해시 조인 |
|------|---------------|---------------|----------|
| 정렬 필요 | 필수 | 불필요 | 불필요 |
| 메모리 사용 | 적음 | 적음 | 많음 |
| 처리 속도 | 중간 | 느림 | 빠름 |
| 최적 데이터 크기 | 중간 | 작은 외부 | 큰 테이블 |
| 인덱스 의존도 | 낮음 | 높음 | 없음 |
| 범위 조인 | 가능 | 가능 | 불가능 |

이 표만으로도 각 방식의 차이가 명확히 보입니다.

## 📊 데이터베이스의 실제 선택 과정

현실에서 데이터베이스 옵티마이저는 어떻게 결정할까요?

### 고려 요소들

테이블의 크기가 가장 중요합니다.

두 테이블이 모두 크면 해시 조인을 선호합니다.

한 테이블이 작으면 중첩 루프 조인을 고려합니다.

메모리의 여유도 중요합니다.

메모리가 충분하면 해시 조인을 선호합니다.

메모리가 부족하면 정렬-병합 조인을 선택합니다.

인덱스의 유무도 영향을 줍니다.

조인 컬럼에 인덱스가 있으면 중첩 루프 조인이 좋습니다.

인덱스가 없으면 해시 조인을 선택합니다.

조인 조건의 형태도 고려됩니다.

등호 조건이면 해시 조인이 가장 좋습니다.

초과, 미만 같은 범위 조건이면 정렬-병합 조인을 선택합니다.

### 실무 예시

1000명의 학생과 100,000명의 주문 기록을 조인한다고 합시다.

데이터베이스의 선택은?

학생 테이블이 훨씬 작습니다.

학생을 메모리에 로드할 수 있습니다.

따라서 해시 조인을 선택할 것입니다.

100,000명의 주문 기록을 읽으며 학생을 찾는 방식으로 진행됩니다.

처리 시간은 초 단위로 완료될 것입니다.

## 💡 성능 최적화를 위한 개발자의 역할

개발자는 조인 방식을 직접 선택할 수는 없습니다.

하지만 큰 영향을 줄 수 있습니다.

### 할 수 있는 것들

조인 컬럼에 인덱스를 만드세요.

중첩 루프 조인이 선택될 확률이 높아집니다.

필요한 컬럼만 SELECT 하세요.

불필요한 데이터를 읽는 비용이 줄어듭니다.

조인하기 전에 조건으로 필터링하세요.

작은 테이블을 해시 조인 대상으로 만들 수 있습니다.

### 피해야 할 것들

너무 많은 테이블을 한 번에 조인하지 마세요.

연쇄적인 조인은 성능을 크게 떨어뜨립니다.

조인 컬럼을 변환하지 마세요.

예를 들어 WHERE DATE_FORMAT(가입일) = '2025-02-02' 같은 표현은 인덱스를 사용할 수 없게 만듭니다.

이것이 성능을 급격히 떨어뜨리는 가장 흔한 실수입니다.

> **⚠️ 주의:** 좋은 SQL을 작성하는 것이 가장 중요합니다. 그러면 데이터베이스가 최적의 조인 방식을 자동으로 선택합니다.

---

작성일: 2025-02-02