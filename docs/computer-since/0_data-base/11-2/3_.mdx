---
title: '데이터베이스 튜닝 전략'
description: '성능 향상을 위한 3단계 튜닝 방법과 인덱싱 전략을 배워봅시다'
slug: 'database/tuning-strategies'
sidebar_label: '데이터베이스 튜닝 전략'
sidebar_position: 3
date: '2025-02-01'
---

# 데이터베이스 튜닝 전략

## 📌 튜닝이란?

시스템의 성능을 향상하기 위해 다양한 부분을 조정하는 작업입니다.

```
기타 튜닝: 줄의 음정을 맞추기
자동차 튜닝: 엔진 성능 향상
DB 튜닝: 처리 속도 향상

병목 지점을 찾아 개선하는 과정
```

---

## 🎯 3단계 튜닝 방법

### Level 1: 하드웨어 튜닝 (가장 낮은 단계)

물리적 장치를 교체하거나 추가합니다.

```
비용 높음, 효과 높음

1) CPU 교체
   - 구형 프로세서 → 신형 고성능 프로세서
   - 처리 속도 향상

2) 메모리 증설
   - 4GB → 8GB, 16GB, 32GB
   - 메모리 병목 해결
   
3) 디스크 추가
   - SSD 추가 또는 HDD → SSD 교체
   - I/O 성능 대폭 향상
   
4) 네트워크 업그레이드
   - 느린 인터넷 → 빠른 인터넷
   - 통신 속도 향상
```

### 메모리 규칙

#### 5분 규칙
```
메모리에 있던 데이터가 5분 이내에
다시 사용될 가능성이 있다면
→ 메모리는 충분히 커야 함

예: 자주 사용하는 데이터는
    메모리에서 비우지 말 것
```

#### 1분 규칙
```
1분마다 계속 메모리를 사용하는 경우
→ 해당 규칙을 적용하여 메모리 크기 설정

예: 실시간 거래 시스템은
    메모리를 충분히 할당
```

---

### Level 2: 파라미터 튜닝 (중간 단계)

데이터베이스 설정값을 조정합니다.

```
비용 낮음, 효과 중간

1) 체크포인트(Checkpoint) 간격 조정
   
예: 아래한글 자동 저장 설정
┌────────────────────────┐
│ 문제 상황:              │
│ 1분마다 자동 저장      │
│ → 1분마다 작업 멈춤    │
│ → 시스템이 느려짐      │
└────────────────────────┘

해결:
- 1분 → 30분으로 변경
- 자동 저장 횟수 감소
- 시스템 부하 감소
- 처리 속도 향상

규칙:
┌─────────────────────┐
│ 간격 짧음 (1분)     │
│ - 안전성 높음       │
│ - 성능 낮음         │
│ - 배터리 소모 빠름  │
├─────────────────────┤
│ 간격 길음 (30분)    │
│ - 성능 높음         │
│ - 안전성 낮음       │
│ - 배터리 소모 적음  │
└─────────────────────┘
```

```
2) 버퍼 크기 조정
   - 작은 버퍼 → 큰 버퍼
   - I/O 횟수 감소
   
3) 블로킹 팩터 조정
   - 한 번에 읽는 데이터량 조정
   - 블록당 레코드 개수 최적화
   
4) 캐시 크기 조정
   - 메모리 캐시 확대
   - 디스크 접근 감소
```

---

### Level 3: 설계 및 구조 튜닝 (가장 높은 단계)

데이터베이스 구조 자체를 개선합니다.

```
비용 높음, 효과 매우 높음
```

#### 정규화 / 역정규화
```
정규화:
- 중복 제거
- 일관성 유지
- 저장 공간 절감
- 조인 필요 (성능 저하)

역정규화:
- 계산된 값 사전 저장
- 조인 감소
- 성능 향상
- 유지보수 복잡 (트레이드오프)
```

#### 인덱싱 전략
```
인덱스 추가:
+ 검색 성능 향상
- 갱신 성능 저하
- 저장 공간 증가

언제 추가?
√ 검색이 많은 컬럼
√ WHERE 조건에 자주 쓰이는 컬럼
√ 조인 조건 컬럼
√ 정렬 컬럼

언제 제거?
√ 갱신이 많은 컬럼
√ 사용되지 않는 인덱스
√ 저장 공간 확보 필요
```

#### 뷰 활용
```
뷰: 자주 사용되는 조인 결과를 미리 저장

장점:
+ 조인 비용 절감
+ 쿼리 단순화
+ 성능 향상

단점:
- 저장 공간 증가
- 데이터 갱신 시 뷰도 갱신

실체화된 뷰(Materialized View):
- 결과를 물리적으로 저장
- 더 빠른 조회 가능
```

#### 파티셔닝
```
큰 테이블을 작은 부분으로 나누기

예: 100만 행 테이블
├─ 파티션 1: 1월 데이터 (25만 행)
├─ 파티션 2: 2월 데이터 (25만 행)
├─ 파티션 3: 3월 데이터 (25만 행)
└─ 파티션 4: 4월 데이터 (25만 행)

장점:
+ 검색 속도 향상 (파티션만 검색)
+ 유지보수 용이
+ 병렬 처리 가능
```

---

## 🎯 인덱싱 전략

### 인덱스를 추가할 컬럼

```sql
-- 1. WHERE 절에 자주 나오는 컬럼
CREATE INDEX idx_학년 ON 학생(학년);
SELECT * FROM 학생 WHERE 학년=4;

-- 2. JOIN 조건 컬럼
CREATE INDEX idx_학번 ON 성적(학번);
SELECT * FROM 학생 
JOIN 성적 ON 학생.학번 = 성적.학번;

-- 3. 기본키 및 외래키
CREATE INDEX idx_pk ON 학생(학번);
CREATE INDEX idx_fk ON 성적(학번);

-- 4. 정렬에 사용되는 컬럼
CREATE INDEX idx_이름 ON 학생(이름);
SELECT * FROM 학생 ORDER BY 이름;
```

### 인덱스를 피할 컬럼

```sql
-- 1. 갱신이 많은 컬럼
-- UPDATE 쿼리가 많으면 인덱스 부담 증가

-- 2. 카디널리티가 낮은 컬럼
-- 성별 (남/여 2가지만) 같은 컬럼
-- 인덱스 효과 없음

-- 3. 사용되지 않는 컬럼
-- 정말 필요한 경우만

-- 4. NULL 값이 많은 컬럼
-- NULL은 인덱스 효율 떨어짐
```

---

## 📊 튜닝의 우선순위

```
Level 3: 설계 개선 (가장 효과적)
    ↓
Level 2: 파라미터 조정
    ↓
Level 1: 하드웨어 업그레이드 (가장 비용 높음)

권장 순서:
1. 먼저 설계/구조 개선 (무료)
2. 파라미터 조정 (저비용)
3. 마지막에 하드웨어 업그레이드 (고비용)
```

---

## 💡 효율적인 SQL 작성

### 피해야 할 작업

```sql
-- 1) 불필요한 정렬
SELECT * FROM 학생 ORDER BY 이름;  -- 필요 없으면 제거

-- 2) 중복 제거 (DISTINCT)
SELECT DISTINCT 학번 FROM 성적;  -- 불필요하면 제거

-- 3) 중복 제거 (UNION)
SELECT * FROM 학생
UNION  -- 중복 제거 추가 비용
SELECT * FROM 휴학생;

-- 대안:
SELECT * FROM 학생
UNION ALL  -- 중복 제거 없음 (빠름)
SELECT * FROM 휴학생;

-- 4) 전체 COUNT
SELECT COUNT(*) FROM 학생;  -- 큰 테이블이면 느림

-- 5) 함수 사용
SELECT * FROM 학생 
WHERE UPPER(이름) = 'KIM';  -- 함수 사용은 느림
```

### 권장 SQL 작성

```sql
-- 1) 필요한 컬럼만 선택
SELECT 이름, 학번 FROM 학생;  -- 좋음
SELECT * FROM 학생;          -- 불필요한 데이터까지 로드

-- 2) 일찍 필터링
SELECT 이름 FROM 학생 
WHERE 학년 = 4;  -- 먼저 필터링

-- 3) 인덱스 활용
SELECT * FROM 학생 
WHERE 학번 = 1001;  -- 학번에 인덱스 있으면 빠름

-- 4) UNION ALL 사용
SELECT * FROM 학생
UNION ALL  -- 중복 제거 없어서 빠름
SELECT * FROM 휴학생;

-- 5) 배치 처리로 분할
-- 1시간 분량 한번에 처리하지 말고
-- 10분 단위로 나누어 처리
FOR i IN 1..6 LOOP
  SELECT * FROM 학생 
  WHERE 등록시간 BETWEEN i*10분 AND (i+1)*10분;
END LOOP;
```

---

## 🔍 튜닝 영역

```
사업 규칙 (Business Rules)
   ↓
설계 (Design)
   ↓
프로그램 (Program)
   ↓
구조 (Architecture)
   ↓
접근 방식 (Access Method)
   ↓
접근 경로 (Access Path)
   ↓
메모리 (Memory)
   ↓
물리적 구조 (Physical Structure)
   ↓
I/O (Input/Output)
   ↓
자원 할당 (Resource Allocation)
```

---

**작성일**: 2025-02-01  
**난이도**: ⭐⭐⭐