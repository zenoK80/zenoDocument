---
title: "교착상태의 정의와 발생 상황"
description: "교착상태의 정의와 발생 상황에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/advanced-concurrency-control/2-교착상태-개념"
sidebar_label: "교착상태"
date: "2026-02-21"
---

# 🔒 교착상태(Deadlock)의 정의와 발생 상황

데이터베이스를 여러 사람이 동시에 사용하다 보면, 아무도 앞으로 나아가지 못하고 서로 눈치만 보며 멈춰버리는 상황이 생깁니다. 마치 좁은 골목길에서 서로 반대 방향으로 오던 두 차가 마주쳐 누구도 비켜주지 않는 것처럼요. 이번 문서에서는 이 **교착상태(Deadlock)** 가 무엇인지, 왜 발생하는지, 그리고 어떻게 예방하고 회복할 수 있는지를 초보자도 이해할 수 있도록 아주 자세하게 풀어드립니다.

---

## 1️⃣ 교착상태란 무엇인가?

### 로킹 기법의 복습: 교착상태의 무대

교착상태를 이해하려면 먼저 **로킹 기법(Locking)**이 무엇인지 간단히 짚고 넘어가야 합니다. 로킹 기법은 데이터베이스에서 여러 사람이 동시에 같은 데이터를 수정하려 할 때 충돌을 방지하기 위한 방법입니다. 쉽게 말해 "강의실 자물쇠"와 같습니다. 강의실을 쓰려면 먼저 자물쇠(로크)를 얻어야 하고, 다 쓰고 나면 자물쇠를 반납(언록)해야 다른 사람이 쓸 수 있죠.

이렇게 **로크(Lock, 잠금)** 를 획득하고, 사용한 뒤 **언록(Unlock, 잠금 해제)** 을 반복하면서 여러 트랜잭션(작업 묶음)이 질서 있게 데이터베이스를 사용할 수 있도록 하는 것이 로킹 기법의 핵심입니다.

그런데 이 로킹 기법에는 치명적인 단점이 하나 있습니다. 바로 **교착상태(Deadlock)** 에 빠질 수 있다는 것입니다.

### 교착상태의 정의

> **교착상태(Deadlock)** 란, 트랜잭션 집합 내의 각 트랜잭션이 서로 다른 트랜잭션이 이미 점유(로크)한 데이터를 기다리는 상태가 되어, 어떤 트랜잭션도 영원히 진행하지 못하고 무한히 대기하는 상황을 말합니다.

일상생활에서 비유를 들자면, A와 B가 회의를 하는데 서로 자기 주장만 반복하면서 합의가 이루어지지 않아 회의 자체가 진행되지 못하고 멈춰버리는 상황입니다. 누구도 한 발짝도 물러서지 않으니, 아무것도 결정이 되지 않는 거죠.

컴퓨터에서는 여러분도 한 번쯤 경험해 보셨을 겁니다. 여러 프로그램을 동시에 열어두고 사용하다 보면 갑자기 화면이 멈추고 **"응답 없음"** 메시지가 뜨는 경우가 있죠. 이 상태에서는 프로그램이 종료되지도 않고, 정상적으로 작동하지도 않아서 강제로 전원을 끄거나 작업 관리자에서 프로세스를 강제 종료시켜야만 해결됩니다. 바로 이것이 교착상태의 실생활 예시입니다.

데이터베이스에서도 마찬가지입니다. T1, T2, T3라는 세 개의 트랜잭션이 각각 데이터베이스를 사용하려는데, T1이 자원을 쥐고 있고, T2는 T1이 쥔 자원을 기다리고, T3는 T2가 쥔 자원을 기다리고, T1은 다시 T3가 쥔 자원을 기다리는 상황이 되면 — 누구도 앞으로 나아가지 못하고 시스템이 그대로 멈춰버립니다.

:::info 잠깐, 로킹 기법 복습
로크(Lock) = 자물쇠처럼 데이터베이스 자원을 독점하는 것
언록(Unlock) = 자물쇠를 반납해서 다른 사람이 쓸 수 있게 하는 것
로크를 얻지 못하면 기다려야 하고, 이 기다림이 무한정 지속되면 교착상태가 됩니다.
:::

---

## 2️⃣ 교착상태가 발생하는 4가지 조건

교착상태는 아무 때나 발생하지 않습니다. 딱 4가지 조건이 **동시에 모두 충족될 때** 교착상태가 발생합니다. 마치 화재가 나려면 "연료 + 산소 + 열"이 모두 있어야 하는 것처럼, 교착상태도 4가지 조건이 전부 맞아떨어질 때 발생합니다.

### 🔴 조건 1: 상호 배제 (Mutual Exclusion)

**상호 배제**란, 한 번에 하나의 프로세스(작업 단위)만이 특정 자원을 사용할 수 있다는 조건입니다. 쉽게 말해 "이 강의실은 지금 우리 반만 쓸 수 있고, 다른 반은 못 들어온다"는 것과 같습니다.

로킹 기법에서 로크를 얻었다는 것은 독점권을 얻었다는 의미입니다. 내가 로크를 쥐고 있는 동안에는 다른 트랜잭션은 같은 자원에 접근할 수 없습니다. 그렇기 때문에 상호 배제 조건이 충족됩니다.

그렇다면 "네이버 서버에 수백만 명이 동시에 접속하는데, 어떻게 한 번에 하나씩만 쓰냐?"라는 의문이 생길 수 있습니다. 이것은 운영체제의 **시분할 시스템(Time Sharing System)** 덕분입니다. 시간을 아주 잘게 쪼개서, 각 사용자에게 아주 짧은 시간씩 번갈아가며 자원 사용 권한을 줬다 뺏었다 반복합니다. 이 처리 속도가 너무 빨라서 사용자는 자신이 기다리고 있다는 사실을 느끼지 못하는 것입니다.

어쨌든 교착상태가 발생하려면 이 상호 배제 조건이 반드시 충족되어야 합니다.

### 🔴 조건 2: 점유 대기 (Hold and Wait)

**점유 대기**란, 어떤 프로세스가 이미 자원을 점유(로크를 쥐고 있는 상태)한 채로, 다른 자원을 추가로 요청하며 기다리는 상태를 말합니다.

예를 들어, 1번 트랜잭션이 A라는 데이터를 이미 로크로 잠가놓고 사용하고 있습니다. 그런데 2번 트랜잭션이 이 A 데이터가 필요해서 기다리고 있는 상태, 이것이 점유 대기입니다.

1번은 A를 **점유**하고 있고, 2번은 A를 달라고 **대기**하고 있는 것이죠. 마치 도서관에서 누군가 책을 대출해 읽고 있는데, 다른 사람이 그 책을 반납할 때까지 기다리는 것과 같습니다. 이 상태 자체는 아직 교착상태가 아닙니다. 1번이 언록(반납)을 하면 2번이 사용할 수 있으니까요. 하지만 이 상태가 무한정 지속되거나, 아래의 다른 조건들과 결합될 때 교착상태로 이어집니다.

### 🔴 조건 3: 비선점 (Non-preemption)

**비선점**이란, 어떤 프로세스에 이미 할당된 자원은 그 프로세스가 스스로 반납하기 전까지는 강제로 빼앗을 수 없다는 조건입니다.

쉽게 말하면, "내가 강의실을 빌려서 쓰고 있는데, 다른 사람이 강제로 나를 쫓아내고 강의실을 사용할 수 없다"는 것입니다. 내가 완료(커밋)하거나 취소(롤백)하기 전까지는, 내가 쥔 자원을 중간에 뺏어갈 수 없습니다.

이것이 왜 교착상태 조건이 되냐면 — 1번 트랜잭션이 자원을 오래 쥐고 있어도 강제로 회수할 수 없으니, 2번 트랜잭션은 무한정 기다릴 수밖에 없기 때문입니다. 선점(preemption)이 가능하다면 "야, 1번아, 잠깐 나와봐. 내가 먼저 쓸게"처럼 강제로 자원을 가져올 수 있겠지만, 비선점 환경에서는 불가능합니다.

### 🔴 조건 4: 환형 대기 / 순환 대기 (Circular Wait)

**환형 대기(순환 대기)** 란, 여러 프로세스들이 서로 상대방이 가진 자원을 기다리는 고리(사이클) 형태가 만들어지는 것입니다.

예를 들어 이런 상황을 상상해 보세요:

- **아래한글**은 현재 자신의 자원을 사용하면서, **엑셀**의 데이터를 달라고 요청 중
- **엑셀**은 현재 자신의 자원을 사용하면서, **아래한글**의 데이터를 달라고 요청 중

이렇게 되면 아래한글은 엑셀을 기다리고, 엑셀은 아래한글을 기다리는 **원형 고리**가 형성됩니다. 누가 먼저 움직여야 하는데, 아무도 움직일 수가 없는 상황이 됩니다. 마치 가위바위보에서 가위가 보를 이기고, 보가 바위를 이기고, 바위가 가위를 이기는 순환 구조처럼, 아무도 최종적으로 이기지 못하는 상황인 것입니다.

3개 이상의 프로세스로 확장해도 마찬가지입니다. A → B → C → A 처럼 사이클이 형성되면 모두 멈춰버립니다.

:::warning 4가지 조건 모두 충족 시 교착상태 발생
상호 배제, 점유 대기, 비선점, 환형 대기 — 이 네 가지 조건이 **동시에 모두** 충족될 때 교착상태가 발생합니다. 하나라도 충족되지 않으면 교착상태는 발생하지 않습니다.
:::

### 📊 교착상태 발생 4가지 조건 요약

| 조건 | 영문 | 설명 | 비유 |
|------|------|------|------|
| 상호 배제 | Mutual Exclusion | 한 번에 하나의 프로세스만 자원 사용 가능 | 강의실은 한 반만 사용 |
| 점유 대기 | Hold and Wait | 자원을 점유한 채 다른 자원을 기다림 | 책을 빌린 채 다른 책 대기 |
| 비선점 | Non-preemption | 자원을 강제로 빼앗을 수 없음 | 강의 중인 강의실 강제 퇴거 불가 |
| 환형 대기 | Circular Wait | 서로가 서로의 자원을 기다리는 사이클 | 아래한글↔엑셀 서로 데이터 요청 |

---

## 3️⃣ 교착상태 예방 방법

교착상태는 발생하고 나서 해결하는 것보다, **미리 예방**하는 것이 훨씬 좋습니다. 교착상태를 예방하는 방법에는 크게 4가지가 있습니다.

### 🛡️ 방법 1: 실행 전 필요한 데이터 전부 잠그기 (정적 2단계 로킹 기법)

첫 번째 방법은, 트랜잭션이 실행되기 **전에** 필요한 모든 데이터를 미리 전부 잠가 버리는 것입니다. 이것을 **정적 2단계 로킹 기법(Static 2-Phase Locking)**이라고 합니다.

예를 들어 "나는 이 트랜잭션에서 A, B, C 데이터가 필요해"라고 미리 선언하고, 실행 시작 전에 A, B, C를 전부 잠가버리는 것입니다. 그렇게 하면 나 말고 다른 트랜잭션이 A, B, C 중 어느 것도 건드릴 수 없으므로, 순환 대기가 발생할 여지가 없습니다.

이론적으로는 완벽한 방법이지만, **현실에서는 사용이 거의 불가능**합니다. 왜냐하면 트랜잭션을 시작하기 전에 어떤 데이터가 필요한지 정확히 알기 어렵고, 미리 모든 데이터를 잠가버리면 다른 모든 트랜잭션들이 기다려야 해서 시스템 효율이 극도로 떨어지기 때문입니다.

### 🛡️ 방법 2: 스케줄링을 잘 짜는 방법

두 번째 방법은, 트랜잭션들이 서로 충돌하지 않도록 **수행 순서(스케줄)를 미리 완벽하게 짜는 것**입니다.

공항 관제탑에서 비행기들이 서로 충돌하지 않도록 이착륙 시간을 세밀하게 스케줄링하는 것을 생각해 보세요. 관제탑이 "A 비행기는 10시에 이륙, B 비행기는 10시 15분에 착륙" 이렇게 정교하게 짜두면, 비행기들이 서로 충돌하지 않죠. 강의실 시간표도 마찬가지입니다. 9시~10시는 1반, 10시~11시는 2반, 이렇게 미리 스케줄이 짜져 있기 때문에 강의실 충돌이 생기지 않습니다.

하지만 데이터베이스에서 **수십만 명이 동시에 접속해서 서로 다른 트랜잭션을 실행하는 상황**을 미리 완벽하게 스케줄링하는 것은 현실적으로 불가능합니다. 강의실 몇 개, 비행기 몇 십 대 정도는 스케줄을 짤 수 있지만, 수십만 개의 트랜잭션 수행 순서를 미리 다 계획하는 것은 사실상 불가능합니다.

:::note 방법 1, 2의 한계
정적 2단계 로킹 기법과 완벽한 스케줄링은 **이론적으로는 교착상태를 완전히 방지**할 수 있습니다. 하지만 **현실에서는 적용이 거의 불가능**하므로, 아래의 방법 3, 4가 실제로 활용됩니다.
:::

### 🛡️ 방법 3: 요구 거절법 (Request Denial)

세 번째 방법은 **요구 거절법**입니다. 이름처럼, 자원을 달라는 요청을 아예 거절해버리는 방법입니다.

미용실에 비유해 보겠습니다. 손님이 미용실에 들어와서 머리를 자르고 싶다고 합니다. 이때 미용사가 상황을 파악합니다.

- **손님이 금방 서비스받을 수 있다면**: "잠깐만 기다리세요, 곧 해드릴게요" → 기다리게 함
- **한참 기다려야 한다면**: "오늘은 너무 바빠서 안 됩니다. 내일 오세요" → 거절

거절당한 손님은 기다리지 않고 미용실을 떠납니다. 기다리는 사람이 없으면, 대기 상태가 형성되지 않으므로 교착상태도 발생하지 않습니다.

데이터베이스에서도 마찬가지입니다. 자원을 요청하는 트랜잭션에게 시스템이 상황을 파악해서:

1. 자원을 바로 줄 수 있으면 → **허용**
2. 잠깐 기다리면 줄 수 있으면 → **대기 허용**
3. 지금 당장 줄 수 없고 오래 기다려야 한다면 → **거절(롤백 후 재시도)**

이렇게 거절해버리면, 무한 대기 상태가 형성되지 않아 교착상태를 방지할 수 있습니다.

### 🛡️ 방법 4: 타임스탬프(Timestamp) 이용법

네 번째 방법은 **타임스탬프(Timestamp, 시간 값)**를 이용하는 것입니다. 타임스탬프는 시스템 시계에서 계속 증가하는 시간 값으로, 각 트랜잭션에 고유한 시간 번호를 부여합니다.

시간은 절대로 같은 값이 두 번 나오지 않습니다. 그러므로 "어떤 트랜잭션이 먼저 요청했는지"를 시간 값으로 명확하게 구분할 수 있습니다.

예를 들어, T1이 10시에 요청했고 T2가 11시에 요청했다면, 이 두 트랜잭션이 충돌할 때 누구에게 우선권을 줄지를 시간 값 기준으로 결정합니다. 이렇게 하면 충돌이 발생해도 대기 상태 없이 처리할 수 있어 교착상태가 발생하지 않습니다. 타임스탬프 기법에 대한 자세한 내용은 뒤에서 더 살펴보겠습니다.

---

## 4️⃣ 교착상태 회복 방법

예방을 했음에도 불구하고 교착상태가 **이미 발생해버렸다면** 어떻게 해야 할까요? 이제는 예방이 아니라 **회복(Recovery)** 을 해야 합니다.

### 🔧 사이클을 끊어라: 프로세스 강제 종료

교착상태가 발생했다는 것은, 트랜잭션들이 서로를 기다리는 **순환 고리(사이클)**가 형성되었다는 것을 의미합니다. 이 사이클을 끊어버리면 교착상태가 해소됩니다.

가장 간단한 방법은 컴퓨터를 그냥 껐다 켜는 것입니다. 그러면 모든 자원이 해제되면서 교착상태도 사라지죠. 하지만 이렇게 하면 그동안 작업한 내용이 전부 날아가버립니다.

그래서 조금 더 스마트한 방법이 필요합니다. 아래한글, 엑셀, 파워포인트가 서로 교착상태에 빠졌을 때를 생각해 봅시다.

- **아래한글**: 1시간 작업
- **엑셀**: 30분 작업
- **파워포인트**: 10분 작업

이 중에서 사이클을 끊기 위해 딱 하나만 강제 종료한다면, 당연히 **가장 적게 작업한 파워포인트**를 종료시키는 것이 손실이 가장 적습니다. 이것이 회복 전략의 핵심입니다.

### 🔧 희생자(Victim) 선택

교착상태 회복 과정에서 강제로 종료할 트랜잭션을 **희생자(Victim)** 라고 합니다. 희생자를 선택하는 기준은 다음과 같습니다.

- **비용이 가장 적게 드는 것** (지금까지 한 작업량이 가장 적은 것)
- **메모리를 가장 적게 점유하고 있는 것**
- **시스템 자원을 현재 가장 적게 사용하고 있는 것**

희생자로 선정된 트랜잭션은 **롤백(Rollback, 작업 취소)** 을 통해 강제로 되돌려집니다. 그 트랜잭션이 가지고 있던 자원이 해제되면서 사이클이 끊어지고, 나머지 트랜잭션들이 정상적으로 진행될 수 있게 됩니다.

```sql
-- 교착상태 회복 시 희생자 트랜잭션 롤백 예시
-- T3 (파워포인트 역할, 가장 작업량이 적은 트랜잭션)를 강제 롤백

ROLLBACK TRANSACTION T3;
-- 위 명령으로 T3가 점유하던 자원(Lock)이 해제됨
-- 해제된 자원을 T1 또는 T2가 획득하여 교착상태 해소
```

### ⚠️ 기아 상태(Starvation) 방지

희생자 선택에는 한 가지 문제가 생길 수 있습니다. 동일한 시스템 구조에서 교착상태가 반복적으로 발생하면, 매번 같은 트랜잭션이 희생자로 선정될 수 있습니다.

예를 들어, 파워포인트가 구조적으로 항상 자원 사용량이 가장 적다면, 교착상태가 날 때마다 파워포인트가 희생자로 선정되는 것입니다. 이렇게 특정 프로세스가 계속 희생자로만 선정되는 현상을 **기아 상태(Starvation)** 라고 합니다.

이를 방지하기 위해 **희생자 선정 횟수를 카운팅**합니다. 예를 들어 "파워포인트가 3번 연속으로 희생자로 선정되었다면, 다음번에는 파워포인트를 제외하고 나머지 중에서 희생자를 선정한다"는 규칙을 두는 것입니다.

:::tip 기아 상태 방지 핵심
희생자 선정 시 **횟수를 카운팅**하여, 특정 트랜잭션이 반복적으로 희생자가 되지 않도록 해야 합니다. 횟수가 일정 이상이 되면 해당 트랜잭션은 희생자 후보에서 제외합니다.
:::

---

## 5️⃣ 독립성 레벨(Isolation Level)과 이상 현상

### 독립성 레벨이란?

**독립성 레벨(Isolation Level, 고립화 수준)** 이란, 병행 수행 시 트랜잭션들 사이에서 어느 정도까지 간섭을 허용할 것인지의 수준을 말합니다. "독립되어 있다"는 것은 다른 트랜잭션의 간섭을 받지 않는다는 의미입니다.

독립성 레벨이 높을수록 간섭이 줄어들고, 데이터의 정확성은 높아지지만, 동시에 여러 사람이 사용하기 어려워집니다. 반대로 독립성 레벨이 낮을수록 많은 사람이 동시에 사용할 수 있지만, 데이터 정확성에 문제가 생길 수 있습니다.

| 독립성 레벨 | 간섭 정도 | 동시성 | 처리 속도 |
|------------|---------|--------|---------|
| 낮음 | 간섭 많음 | 높음 (많은 사람 동시 사용) | 빠름 |
| 높음 | 간섭 적음 | 낮음 (적은 사람 동시 사용) | 느림 |

### 직렬성 위반의 3가지 이상 현상

독립성 레벨을 이해하려면 먼저 병행 수행에서 발생할 수 있는 3가지 이상 현상을 알아야 합니다.

#### ❌ 이상 현상 1: 부정 판독 (Dirty Read)

**Dirty Read(부정 판독)** 는 아직 커밋(확정)되지 않은, 즉 취소될 수도 있는 데이터를 다른 트랜잭션이 읽어버리는 현상입니다.

```sql
-- 부정 판독 (Dirty Read) 발생 예시

-- T1: x = 100을 x = 200으로 갱신 (아직 커밋 안 함)
UPDATE 계좌 SET 잔액 = 200 WHERE id = 'x'; -- T1이 갱신

-- T2: T1이 갱신한 200을 읽어옴 (아직 T1이 커밋하지 않았는데!)
SELECT 잔액 FROM 계좌 WHERE id = 'x'; -- T2가 200을 읽음 ← Dirty Read!

-- T1: 뭔가 문제가 생겨서 롤백!
ROLLBACK; -- x는 다시 100으로 돌아감

-- 결과: T2는 이미 취소된 값 200을 읽어버린 상태 → 잘못된 데이터 사용!
```

❌ **잘못된 상황**: T2가 읽은 200은 T1이 롤백하면서 사라진, 실제로 존재하지 않았던 값입니다. 이렇게 **취소된 값을 읽어버리는 것**이 Dirty Read입니다.

#### ❌ 이상 현상 2: 비반복 판독 (Non-repeatable Read)

**Non-repeatable Read(비반복 판독)** 는 같은 트랜잭션 안에서 같은 데이터를 두 번 읽었는데, 중간에 다른 트랜잭션이 그 값을 변경해서 두 번 읽은 값이 서로 달라지는 현상입니다.

```sql
-- 비반복 판독 (Non-repeatable Read) 발생 예시

-- T1: x 값을 처음 읽음 → 100 반환
SELECT 잔액 FROM 계좌 WHERE id = 'x'; -- 결과: 100

-- T2: 중간에 x 값을 변경하고 커밋
UPDATE 계좌 SET 잔액 = 200 WHERE id = 'x';
COMMIT; -- T2가 x를 200으로 확정

-- T1: 똑같은 쿼리를 다시 읽음 → 200 반환 (값이 바뀌어 있음!)
SELECT 잔액 FROM 계좌 WHERE id = 'x'; -- 결과: 200

-- 결과: T1이 동일한 명령어로 100, 200을 각각 읽음 → 일관성 깨짐!
```

❌ **잘못된 상황**: Dirty Read와 달리, 200은 실제로 존재하는 유효한 값입니다. 다만 T1 입장에서 같은 쿼리를 두 번 날렸는데 결과가 달라졌으므로, **반복해서 읽어도 같은 값이 나오지 않는** 문제가 발생합니다.

#### ❌ 이상 현상 3: 가상 판독 (Phantom Read)

**Phantom Read(가상 판독)** 는 같은 조건으로 두 번 조회했는데, 중간에 다른 트랜잭션이 새로운 행(데이터)을 삽입해서 두 번째 조회 시 없던 행이 나타나는 현상입니다.

```sql
-- 가상 판독 (Phantom Read) 발생 예시

-- T1: 나이가 20세 이상인 회원 조회 → 10명 반환
SELECT * FROM 회원 WHERE 나이 >= 20; -- 결과: 10개 행

-- T2: 나이 25세인 새 회원 삽입 후 커밋
INSERT INTO 회원 (이름, 나이) VALUES ('홍길동', 25);
COMMIT;

-- T1: 동일한 조건으로 다시 조회 → 11명 반환 (새 행이 나타남!)
SELECT * FROM 회원 WHERE 나이 >= 20; -- 결과: 11개 행

-- 결과: 없던 행(유령처럼)이 나타난 것 → Phantom(유령) Read
```

❌ **잘못된 상황**: 기존 값이 변경된 것도 아니고, 취소된 값을 읽은 것도 아닙니다. 단지 **새로운 행이 삽입**되어, 같은 조회 조건으로 다른 결과가 나온 것입니다. 유령(Phantom)처럼 없던 데이터가 나타났다고 해서 Phantom Read라고 합니다.

### 📊 SQL 표준 독립성 레벨 4단계

SQL 표준에서는 독립성 레벨을 4단계로 정의합니다. 아래로 내려갈수록 독립성 레벨이 높아집니다.

| 독립성 레벨 | Dirty Read | Non-repeatable Read | Phantom Read | 동시성 |
|-----------|-----------|---------------------|--------------|--------|
| **Read Uncommitted** | 허용 ✅ | 허용 ✅ | 허용 ✅ | 최고 |
| **Read Committed** | 불허 ❌ | 허용 ✅ | 허용 ✅ | 높음 |
| **Repeatable Read** | 불허 ❌ | 불허 ❌ | 허용 ✅ | 보통 |
| **Serializable** | 불허 ❌ | 불허 ❌ | 불허 ❌ | 최저 |

#### 1단계: Read Uncommitted (읽기 미확정)

가장 낮은 독립성 레벨로, **아무런 제약이 없는 단계**입니다. Dirty Read, Non-repeatable Read, Phantom Read를 모두 허용합니다. 누구나 마음대로 읽을 수 있어서 병행성(동시 사용 가능한 사람 수)은 가장 높지만, 데이터 정확성은 가장 낮습니다.

#### 2단계: Read Committed (읽기 확정)

**커밋된 데이터만 읽을 수 있는 단계**입니다. Dirty Read는 허용하지 않지만, Non-repeatable Read와 Phantom Read는 여전히 발생할 수 있습니다. 많은 실제 데이터베이스 시스템의 기본값으로 사용됩니다.

#### 3단계: Repeatable Read (반복 읽기 가능)

**같은 데이터를 반복해서 읽어도 항상 같은 값을 보장하는 단계**입니다. Dirty Read와 Non-repeatable Read는 허용하지 않습니다. 단, 새로운 행이 추가되는 Phantom Read는 여전히 발생할 수 있습니다. 기존에 있는 값이 변경되지는 않았으니, 새로 추가되는 행은 막을 수 없는 것입니다.

#### 4단계: Serializable (직렬화 가능)

**가장 높은 독립성 레벨**로, Dirty Read, Non-repeatable Read, Phantom Read를 모두 허용하지 않습니다. 트랜잭션들이 마치 순차적으로(직렬로) 하나씩 실행되는 것처럼 완벽한 일관성을 보장합니다.

하지만 그만큼 제약이 많고 오버헤드가 크며, 동시성이 가장 낮아 처리 속도가 느립니다.

:::danger Serializable이 항상 정답은 아닙니다
Serializable은 가장 완벽한 일관성을 보장하지만, 동시에 가장 적은 사람만 데이터베이스를 사용할 수 있습니다. 실제 서비스에서는 성능과 일관성 사이의 **트레이드오프(Trade-off, 균형점)**를 고려해서 적절한 독립성 레벨을 선택해야 합니다.
:::

---

## 6️⃣ 타임스탬프 기반 병행 제어

### 타임스탬프란?

**타임스탬프(Timestamp)** 는 시스템 시계에서 발급하는 **고유한 시간 값**으로, 각 트랜잭션에게 발급됩니다. 시간은 절대로 같은 값이 두 번 나오지 않기 때문에, 타임스탬프를 이용하면 트랜잭션 간의 우선순위를 명확하게 결정할 수 있습니다.

> 타임스탬프 기반 병행 제어의 핵심: **시간 값은 충돌하지 않으므로, 교착상태가 발생하지 않습니다.**

타임스탬프는 각 데이터 항목에 대해 두 가지 값을 관리합니다.

- **Read-TS (읽기 타임스탬프)**: 해당 데이터를 마지막으로 성공적으로 읽은 시간
- **Write-TS (쓰기 타임스탬프)**: 해당 데이터를 마지막으로 성공적으로 쓴(기록한) 시간

### Wait-Die 기법과 Wound-Wait 기법

타임스탬프를 활용한 교착상태 방지 기법 중 대표적인 것이 **Wait-Die**와 **Wound-Wait**입니다. 두 기법 모두 트랜잭션을 **고참(먼저 시작한 트랜잭션)**과 **신참(나중에 시작한 트랜잭션)**으로 구분합니다.

예를 들어 T1이 10시에 시작했고, T2가 11시에 시작했다면 T1이 고참, T2가 신참입니다.

#### Wait-Die 기법 (비선점 방식)

**Wait-Die** 는 신참(타임스탬프 값이 큰 쪽)에게 우선권을 주는 방법입니다.

- 신참이 고참의 자원을 요청하면 → **Wait(기다려)**: 신참이 우선권이 있으므로 기다림
- 고참이 신참의 자원을 요청하면 → **Die(포기)**: 고참은 포기하고 롤백

#### Wound-Wait 기법 (선점 방식)

**Wound-Wait** 는 고참(타임스탬프 값이 작은 쪽)에게 우선권을 주는 방법입니다.

- 고참이 신참의 자원을 요청하면 → **Wound(강탈)**: 고참이 신참을 강제 롤백시키고 자원 획득
- 신참이 고참의 자원을 요청하면 → **Wait(기다려)**: 신참은 고참이 끝날 때까지 대기

| 기법 | 우선권 | 방식 | 설명 |
|------|--------|------|------|
| Wait-Die | 신참 우선 | 비선점 | 신참이 기다림, 고참은 포기 |
| Wound-Wait | 고참 우선 | 선점 | 고참이 강탈, 신참이 기다림 |

### 타임스탬프 순서 프로토콜

타임스탬프 프로토콜의 핵심 원칙은 간단합니다. **항상 최신 작업의 시간보다 내가 요청하는 시간이 크거나 같아야 작업을 허용한다**는 것입니다.

```sql
-- 타임스탬프 프로토콜 개념 예시 (의사코드)

-- 읽기 작업 허용 조건
-- 내가 요청한 시간(TS) >= 마지막으로 쓰기가 성공한 시간(Write-TS)
IF TS(T) >= Write-TS(x) THEN
    -- 읽기 허용: 최신 값을 읽을 수 있음
    READ(x)
    Read-TS(x) = MAX(Read-TS(x), TS(T)) -- 읽기 타임스탬프 갱신
ELSE
    -- 읽기 거부: 옛날 값을 읽으려는 시도 → 롤백
    ROLLBACK(T)

-- 쓰기 작업 허용 조건
-- 내가 요청한 시간(TS) >= 마지막 읽기 성공 시간(Read-TS)
-- 내가 요청한 시간(TS) >= 마지막 쓰기 성공 시간(Write-TS)
IF TS(T) >= Read-TS(x) AND TS(T) >= Write-TS(x) THEN
    -- 쓰기 허용
    WRITE(x)
    Write-TS(x) = TS(T) -- 쓰기 타임스탬프 갱신
ELSE
    -- 쓰기 거부: 옛날 시점에 덮어쓰려는 시도 → 롤백
    ROLLBACK(T)
```

- `TS(T)`: 트랜잭션 T의 타임스탬프 (요청 시간)
- `Write-TS(x)`: 데이터 x의 마지막 쓰기 성공 시간
- `Read-TS(x)`: 데이터 x의 마지막 읽기 성공 시간

쉽게 말하면, "10시에 변경된 데이터가 있는데, 9시 데이터로 덮어쓰려 하면 안 된다"는 것입니다. 항상 더 최신의 작업만 허용하고, 옛날 시점의 작업은 거부합니다.

### 다중 버전 타임스탬프 (Multi-Version Timestamp)

기본 타임스탬프는 항상 가장 최신 값만 유지합니다. 즉, 새로 쓸 때마다 이전 값은 덮어씌워집니다.

하지만 때로는 "10일 전의 값은 뭐였지?", "일주일 전 상태를 알아야 해" 처럼 **과거 버전의 데이터가 필요한 경우**가 있습니다. 이를 위한 것이 **다중 버전 타임스탬프(Multi-Version Timestamp)** 입니다.

다중 버전 타임스탬프는 데이터가 변경될 때마다 이전 값을 버리지 않고 버전별로 모두 보관합니다.

- **5일 값**: 100
- **10일 값**: 200
- **15일 값**: 300

이렇게 여러 버전을 관리하므로 원하는 시점의 데이터를 조회할 수 있습니다. 단, 버전을 모두 저장하므로 **저장 공간이 그만큼 더 필요**하고, 여러 버전을 비교하면서 직렬성을 만족시켜야 하는 복잡성이 증가합니다.

### 다중 버전 2단계 로킹 기법

**다중 버전 2단계 로킹 기법**은 타임스탬프 기법과 로킹 기법, 두 가지를 결합한 방법입니다.

- **로킹 기법의 문제**: 교착상태에 빠질 수 있음
- **타임스탬프 기법의 문제**: 연쇄 복귀(한 트랜잭션의 롤백이 다른 트랜잭션에도 연쇄적으로 영향을 주는 문제)가 발생할 수 있음

두 기법 각각은 문제가 있지만, 이 둘을 결합하면 서로의 단점을 보완할 수 있습니다. **2단계 로킹 기법**에 **다중 버전 타임스탬프**를 결합하여, 교착상태와 연쇄 복귀 문제를 함께 해결하려는 것이 다중 버전 2단계 로킹 기법의 핵심입니다.

---

## 7️⃣ 낙관적 병행 제어 (Optimistic Concurrency Control)

### 낙관적 병행 제어란?

**낙관적 병행 제어(Optimistic Concurrency Control)** 는 "문제가 없겠지"라는 긍정적인 가정 하에, 실행 도중에는 검사를 하지 않고 **모든 작업이 끝난 뒤 한꺼번에 확인**하는 방법입니다. **확인 기법**이라고도 합니다.

시험을 예로 들어볼게요. 10명이 시험을 봤을 때, 원래대로라면 한 명씩 시험지를 제출할 때마다 이름을 확인하고 마킹이 제대로 됐는지 검사한 뒤 처리해야 합니다. 하지만 낙관적 병행 제어는 다릅니다. "다들 잘 썼겠지"라고 낙관적으로 생각하고, 시험지를 모두 제출받은 다음 한꺼번에 검토하는 방식입니다.

### 3단계 구성: 판독 → 확인 → 기록

낙관적 병행 제어는 3단계로 구성됩니다.

```
[판독 단계] → [확인 단계] → [기록 단계]
  (Read)       (Validate)    (Write)
```

#### 1단계: 판독 (Read)

트랜잭션이 필요한 데이터를 읽어옵니다. 이때 중요한 점은, **원본 데이터를 직접 수정하지 않고 복사본을 만들어 복사본에 작업을 수행**한다는 것입니다.

원본이 직접 손상되면 복구가 어렵기 때문에, 복사본에서 작업하면서 "문제없겠지" 하고 낙관적으로 처리합니다.

```
원본 데이터: [A=100, B=200]
복사본 생성: [A=100, B=200] ← 복사본에서 작업 수행
갱신 작업: A = A + 50 → 복사본: [A=150, B=200]
```

#### 2단계: 확인 (Validate)

모든 트랜잭션의 작업이 완료되면, **복사본들을 한꺼번에 검토**합니다. 직렬성을 위반하는지 (충돌이 있는지) 확인합니다.

- 이상이 없다 → 다음 단계(기록)로 진행
- 이상이 있다 → 해당 트랜잭션을 롤백하고 재시도

#### 3단계: 기록 (Write)

확인 단계를 통과한 복사본의 내용을 **원본 데이터에 반영**합니다.

```
복사본: [A=150, B=200] → 이상 없음 확인
원본에 반영: [A=150, B=200] ← 원본 업데이트 완료
```

:::tip 낙관적 병행 제어의 장점
트랜잭션 실행 도중 로크를 걸지 않으므로, 다른 트랜잭션의 접근을 막지 않습니다. 따라서 **충돌이 드문 환경**에서는 매우 효율적입니다. 로킹 기법처럼 기다리는 시간이 줄어들어 처리 속도가 빨라질 수 있습니다.
:::

:::warning 낙관적 병행 제어의 단점
충돌이 자주 발생하는 환경에서는 확인 단계에서 많은 트랜잭션이 롤백되고 재시도되어 오히려 비효율적일 수 있습니다. 충돌 빈도가 낮은 환경에 적합한 기법입니다.
:::

---

## 8️⃣ 주의사항 및 실전 팁

### ✅ 올바른 예시와 ❌ 잘못된 예시로 이해하는 교착상태

```sql
-- ❌ 잘못된 예: 교착상태를 유발하는 순서로 로크 획득

-- T1의 실행 순서
LOCK TABLE A;   -- T1이 A를 잠금
-- ... 작업 중 ...
LOCK TABLE B;   -- T1이 B도 잠그려 함 (B는 T2가 이미 잠금 → 대기!)

-- T2의 실행 순서 (동시에 실행)
LOCK TABLE B;   -- T2가 B를 잠금
-- ... 작업 중 ...
LOCK TABLE A;   -- T2가 A도 잠그려 함 (A는 T1이 이미 잠금 → 대기!)

-- 결과: T1은 T2를 기다리고, T2는 T1을 기다림 → 교착상태 발생!
```

```sql
-- ✅ 올바른 예: 동일한 순서로 로크를 획득하여 교착상태 방지

-- T1의 실행 순서 (항상 A → B 순서로 잠금)
LOCK TABLE A;   -- T1이 A를 잠금
LOCK TABLE B;   -- T1이 B를 잠금 (T2가 아직 A, B를 잠그지 않았다면 성공)
-- ... 작업 수행 ...
UNLOCK TABLE B; -- B 해제
UNLOCK TABLE A; -- A 해제

-- T2의 실행 순서 (항상 A → B 순서로 잠금 → T1이 끝날 때까지 기다림)
LOCK TABLE A;   -- T2가 A 획득 시도 → T1이 A를 쥐고 있으면 대기
LOCK TABLE B;   -- A를 얻은 후에 B 획득 시도
-- ... 작업 수행 ...
UNLOCK TABLE B;
UNLOCK TABLE A;

-- 결과: 항상 같은 순서로 잠그므로 순환 대기가 발생하지 않음!
```

위 예시처럼, **모든 트랜잭션이 동일한 순서로 자원을 요청**하면 환형 대기(순환 대기) 조건이 충족되지 않아 교착상태가 발생하지 않습니다.

### 💡 실전 팁 모음

:::tip 실무에서의 교착상태 예방 팁

1. **자원 획득 순서를 통일하라**: 모든 트랜잭션이 항상 같은 순서로 테이블/자원에 접근하도록 코딩 규칙을 정하면 순환 대기를 방지할 수 있습니다.

2. **트랜잭션은 짧고 빠르게**: 트랜잭션 내에서 수행하는 작업이 짧을수록 로크를 쥐고 있는 시간이 줄어들어 교착상태 발생 확률이 낮아집니다.

3. **한꺼번에 필요한 자원을 잠가라**: 가능하다면 트랜잭션 시작 시 필요한 자원을 한꺼번에 잠그고 시작하는 방식도 교착상태를 줄이는 데 도움이 됩니다.

4. **독립성 레벨을 상황에 맞게 선택하라**: 모든 경우에 Serializable이 정답이 아닙니다. 서비스 특성에 맞는 레벨을 선택하는 것이 중요합니다.
:::

:::warning 기아 상태(Starvation)에도 주의하세요
교착상태를 해결하기 위해 희생자를 선정할 때, 특정 트랜잭션이 계속 희생자로 선정되지 않도록 반드시 **횟수 카운팅** 메커니즘을 함께 구현해야 합니다. 그렇지 않으면 특정 트랜잭션은 영원히 진행되지 못하는 기아 상태에 빠질 수 있습니다.
:::

---

## ✅ 핵심 정리

- **교착상태(Deadlock)** 는 트랜잭션들이 서로가 점유한 자원을 무한정 기다리며 아무것도 진행되지 못하는 상태입니다.
- 교착상태는 **상호 배제, 점유 대기, 비선점, 환형 대기** 4가지 조건이 동시에 충족될 때 발생합니다.
- **교착상태 예방법**으로는 ①실행 전 모든 데이터 잠금(정적 2단계 로킹), ②완벽한 스케줄링, ③요구 거절법, ④타임스탬프 이용 등이 있습니다.
- **교착상태 회복**은 희생자(Victim) 트랜잭션을 선정해 강제 롤백하여 사이클을 끊는 방식으로 이루어집니다.
- **기아 상태(Starvation)** 는 특정 트랜잭션이 반복적으로 희생자로 선정되는 문제이며, 횟수 카운팅으로 방지합니다.
- **독립성 레벨(Isolation Level)** 은 트랜잭션 간 간섭 허용 정도를 결정하는 수준으로, Read Uncommitted → Read Committed → Repeatable Read → Serializable 순으로 높아집니다.
- **Dirty Read**는 롤백된 데이터를 읽는 것, **Non-repeatable Read**는 같은 데이터를 두 번 읽었을 때 값이 달라지는 것, **Phantom Read**는 같은 조건 조회 시 없던 행이 나타나는 것입니다.
- **타임스탬프 기법**은 시간 값이 충돌하지 않는 특성을 이용해 교착상태를 방지합니다.
- **Wait-Die**는 신참에게 우선권을 주는 비선점 방식, **Wound-Wait**는 고참에게 우선권을 주는 선점 방식입니다.
- **다중 버전 타임스탬프**는 데이터의 여러 버전을 보관하여 원하는 시점의 값을 조회할 수 있는 기법입니다.
- **낙관적 병행 제어(확인 기법)** 는 판독 → 확인 → 기록의 3단계로 구성되며, 복사본에 작업 후 이상이 없으면 원본에 반영하는 방식입니다.

---

작성일: 2026-02-21