---
title: "로킹 기법의 개념과 동작 원리"
description: "로킹 기법의 개념과 동작 원리에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/advanced-concurrency-control/1-locking-기법-개요"
sidebar_label: "로킹 기법"
date: "2026-02-21"
---

# 🔒 로킹 기법의 개념과 동작 원리 — 고급 병행제어 완전 정복

데이터베이스를 공부하다 보면 "여러 사람이 동시에 같은 데이터를 사용할 때 어떻게 충돌을 막을까?" 라는 질문을 마주치게 됩니다. 이 문제를 해결하는 핵심 기술이 바로 **병행제어(Concurrency Control)** 이며, 그 중에서도 가장 대표적인 기법이 **로킹(Locking) 기법**입니다. 이번 문서에서는 로킹 기법의 기본 개념부터 시작하여, 교착상태(Deadlock)의 원인과 해결책, 독립성 레벨(Isolation Level), 타임스탬프(Timestamp) 기법, 낙관적 병행제어까지 초보자도 충분히 이해할 수 있도록 하나씩 풀어서 설명합니다.

---

## 🏁 1. 로킹 기법이란 무엇인가?

### 로킹 기법의 기본 아이디어

**로킹 기법**이란, 데이터베이스의 특정 데이터를 사용하기 전에 반드시 **자물쇠(Lock)를 획득**하고, 사용이 끝나면 **자물쇠를 해제(Unlock)** 하는 방식으로 동시 접근을 제어하는 기법입니다.

이것을 실생활에 비유하면 **강의실 예약 시스템**과 같습니다. 강의실을 사용하려면 먼저 예약(자물쇠 획득)을 해야 하고, 강의가 끝나면 예약을 해제(자물쇠 해제)해야 다음 사람이 사용할 수 있습니다. 만약 예약 시스템이 없다면 여러 수업이 같은 강의실로 몰려들어 혼란이 생기겠죠. 데이터베이스도 마찬가지입니다. 로킹이 없다면 여러 트랜잭션(작업 묶음)이 같은 데이터를 동시에 수정하다가 **데이터가 엉망이 되는 이상 현상**이 발생합니다.

> **로킹의 핵심 원칙:** 데이터를 읽거나 쓰기 전에 반드시 Lock을 획득하고, 작업이 끝나면 반드시 Unlock으로 해제한다.

### 왜 로킹 기법이 필요한가?

여러 명의 사용자가 동시에 데이터베이스에 접근하는 상황을 생각해봅시다. 예를 들어, 은행 계좌에 잔액이 100만원 있을 때, A와 B가 동시에 50만원씩 출금하려고 한다면 어떻게 될까요? 제어가 없다면 둘 다 잔액을 100만원으로 읽고, 둘 다 50만원을 빼서 50만원을 저장하게 되어 실제로는 100만원이 출금되었지만 계좌 잔액은 50만원으로만 줄어드는 심각한 오류가 발생합니다.

로킹 기법은 이런 **충돌(Conflict)** 을 막기 위해 **상호배제(Mutual Exclusion)**, 즉 "한 번에 한 명만 사용"이라는 규칙을 강제로 지키게 해줍니다.

| 구분 | 로킹 없을 때 | 로킹 있을 때 |
|------|-------------|-------------|
| 동시 접근 | 여러 트랜잭션이 동시에 데이터 수정 가능 | 한 번에 하나의 트랜잭션만 데이터 수정 |
| 데이터 정합성 | 충돌로 인해 데이터 오류 발생 가능 | 순서대로 처리되어 데이터 정합성 유지 |
| 대기 여부 | 대기 없음 (대신 충돌 발생) | 앞 트랜잭션이 끝날 때까지 대기 |

---

## 💀 2. 교착상태(Deadlock)란 무엇인가?

### 교착상태의 정의

로킹 기법은 강력한 도구이지만, 치명적인 약점이 하나 있습니다. 바로 **교착상태(Deadlock)** 에 빠질 수 있다는 것입니다.

**교착상태**란, 트랜잭션들의 집합 내에서 각 트랜잭션이 서로 상대방이 점유하고 있는 자원의 잠금 해제를 무한정 기다리는 상태를 말합니다. 쉽게 말하면, "내가 네 걸 기다리고, 너는 내 걸 기다리는" 서로 꼬인 상황입니다.

일상에서 이런 경험을 해본 적 있으신가요? 컴퓨터를 사용하다가 프로그램이 **'응답 없음'** 상태가 되어 아무리 기다려도 반응이 없고, 결국 강제 종료나 전원을 끄는 방법밖에 없었던 경우 말이죠. 그것이 바로 교착상태의 대표적인 증상입니다.

> **교착상태 정의:** 트랜잭션 집합 내의 각 트랜잭션이, 해당 집합 내의 다른 트랜잭션이 잠근(Lock) 데이터를 서로 기다리고 있어 아무도 진행하지 못하는 상태

### 교착상태가 발생하는 4가지 조건 🚨

교착상태는 다음 **4가지 조건이 동시에 충족될 때** 발생합니다. 이 중 하나라도 깨지면 교착상태는 발생하지 않습니다.

#### ① 상호배제 (Mutual Exclusion)

**상호배제**란 "한 번에 하나의 프로세스(작업 단위)만이 특정 자원을 사용할 수 있다"는 조건입니다. 로킹 기법 자체가 이 원칙 위에 세워져 있습니다. 강의실에 자물쇠가 있어서 내가 잠그면 다른 사람은 들어올 수 없는 것처럼, 트랜잭션이 데이터에 Lock을 걸면 다른 트랜잭션은 그 Lock이 해제될 때까지 해당 데이터를 사용할 수 없습니다. 동시에 여러 사람이 같은 자원을 쓰면 충돌이 발생하기 때문에 이 조건은 필수적입니다.

:::info 시분할 시스템 참고
"한 번에 하나만"이라면서 왜 네이버 같은 서비스에는 수백만 명이 동시에 접속할 수 있을까요? 이는 **시분할 시스템(Time Sharing System)** 덕분입니다. 시간을 아주 잘게 쪼개서 각 사용자에게 번갈아 가며 권한을 줬다 뺏기를 반복하는데, 그 속도가 너무 빨라 사용자는 기다리는 것을 느끼지 못하는 것입니다.
:::

#### ② 점유와 대기 (Hold and Wait)

**점유와 대기**란 이미 어떤 자원을 점유(Lock을 보유)하고 있는 트랜잭션이, 다른 트랜잭션이 점유한 자원을 추가로 요청하며 기다리는 상태입니다. 예를 들어, 1번 트랜잭션이 강의실 A를 사용하고 있는데, 2번 트랜잭션이 강의실 A를 달라며 문 앞에서 기다리고 있는 상황입니다. 이처럼 누군가는 자원을 쥐고 있고, 다른 누군가는 그 자원을 기다리는 상태가 교착상태의 두 번째 조건입니다.

#### ③ 비선점 (Non-Preemption)

**비선점**이란 어떤 트랜잭션이 자원을 사용하고 있을 때, 외부에서 강제로 그 자원을 빼앗을 수 없다는 조건입니다. 즉, 자원은 그것을 점유한 트랜잭션이 스스로 완료(커밋)하거나 취소(롤백)하기 전까지는 강제로 회수할 수 없습니다. 마치 도서관에서 내가 빌린 책을 관리자가 내 동의 없이 강제로 가져갈 수 없는 것과 같습니다. 이 때문에 기다리는 트랜잭션은 무한정 기다릴 수밖에 없게 됩니다.

#### ④ 순환 대기 (Circular Wait)

**순환 대기**란 트랜잭션들이 서로의 자원을 원형으로 기다리는 상태입니다. 예를 들어, 한글 프로그램은 엑셀의 데이터를 기다리고, 엑셀은 파워포인트의 데이터를 기다리고, 파워포인트는 한글의 데이터를 기다리는 식으로 **사이클(순환 고리)** 이 형성된 경우입니다. 이 고리가 형성되는 순간 아무도 먼저 자원을 해제할 수 없어 시스템 전체가 멈추게 됩니다.

```
한글 → 엑셀 데이터 대기
엑셀 → 파워포인트 데이터 대기
파워포인트 → 한글 데이터 대기
     ↑__________________________↓
         (순환 고리 형성 = 교착상태!)
```

:::warning 교착상태 4가지 조건 요약
교착상태는 다음 4가지 조건이 **모두** 충족될 때 발생합니다:
1. **상호배제** — 한 번에 하나의 트랜잭션만 자원 사용
2. **점유와 대기** — 자원을 쥔 채로 다른 자원을 기다림
3. **비선점** — 외부에서 자원을 강제로 빼앗을 수 없음
4. **순환 대기** — 트랜잭션들이 서로의 자원을 원형으로 기다림
:::

---

## 🛡️ 3. 교착상태 예방(Prevention) 방법

교착상태가 발생하기 **전에** 막는 방법들이 있습니다. 크게 4가지 접근 방식을 살펴봅니다.

### 방법 1️⃣ 실행 전 모든 데이터 잠금 — 정적 2단계 로킹 기법

**아이디어:** 트랜잭션이 실행을 시작하기 전에, 앞으로 사용할 모든 데이터를 미리 Lock해두는 방법입니다. 이렇게 하면 순환 대기가 발생할 수 없어 교착상태를 원천적으로 차단합니다. 이것이 바로 **정적 2단계 로킹 기법(Static 2-Phase Locking)**입니다.

**비유:** 요리를 시작하기 전에 냉장고에서 필요한 재료를 모두 꺼내놓고, 재료가 다 마련됐을 때만 요리를 시작하는 것과 같습니다. 그러면 요리 도중에 재료가 없어서 기다리는 상황이 생기지 않습니다.

:::danger 현실적 한계
이 방법은 이론적으로는 완벽하지만, 실제 환경에서는 거의 사용하기 어렵습니다. 트랜잭션이 시작하기 전에 "내가 앞으로 어떤 데이터를 사용할지"를 정확히 미리 알 수 없는 경우가 대부분이기 때문입니다. 또한, 모든 데이터를 미리 잠그면 다른 트랜잭션들이 불필요하게 오랜 시간 대기해야 합니다.
:::

### 방법 2️⃣ 스케줄링(Scheduling)

**아이디어:** 트랜잭션들이 서로 충돌하지 않도록 실행 순서를 미리 계획하는 방법입니다. 마치 공항 관제탑에서 비행기의 이착륙 순서를 미리 스케줄링하여 충돌 없이 운영하는 것과 같습니다. 학교 시간표처럼 어느 강의실에서 언제 어떤 수업이 진행될지 미리 정해놓으면 강의실 충돌이 발생하지 않겠죠.

**비유:** 비행기가 공항에서 관제탑 없이 마음대로 이착륙을 한다면 어떻게 될까요? 당연히 충돌 사고가 날 것입니다. 관제탑이 철저한 이착륙 스케줄을 관리하기 때문에 안전하게 운영됩니다.

:::danger 현실적 한계
이 방법도 동시에 수십만 명이 접속하는 실제 데이터베이스 환경에서는 적용이 거의 불가능합니다. 강의실 10개의 시간표를 짜는 것과, 수십만 건의 트랜잭션 스케줄을 실시간으로 짜는 것은 차원이 다른 문제입니다. 트랜잭션의 실행 순서는 예측 불가능하게 섞이기 때문입니다.
:::

### 방법 3️⃣ 요구 거절법 (Request Denial)

**아이디어:** 트랜잭션이 자원을 요청했을 때, 시스템이 현재 상황을 판단하여 그 요청을 수락할지, 잠깐 기다리라고 할지, 아니면 **아예 거절**할지를 결정하는 방법입니다.

**비유:** 미용실에 갔더니 대기 손님이 너무 많아요. 헤어 디자이너가 "오늘은 예약이 꽉 찼으니 내일 다시 오세요"라고 거절합니다. 손님은 돌아가고, 미용실 안에서는 무한 대기가 발생하지 않습니다. 반면, "30분만 기다리시면 됩니다"라고 하면 짧게 기다릴 수 있습니다. 요구 거절법은 이처럼 **무한 대기를 방지**하여 교착상태를 예방합니다.

거절을 당한 트랜잭션은 대기 상태로 들어가지 않고 즉시 종료되거나 나중에 다시 시도하게 됩니다. 이렇게 하면 순환 대기가 형성되지 않아 교착상태를 예방할 수 있습니다.

### 방법 4️⃣ 타임스탬프(Timestamp)를 이용한 교착상태 예방

**아이디어:** 각 트랜잭션에 고유한 **시간 값(타임스탬프)** 을 부여하고, 이 시간값의 순서에 따라 자원 접근 우선순위를 결정하는 방법입니다. 시간은 절대로 중복되지 않으므로, 항상 명확한 우선순위가 존재하여 교착상태가 발생하지 않습니다.

예를 들어, 10시에 요청한 트랜잭션과 11시에 요청한 트랜잭션이 충돌한다면, 타임스탬프를 기준으로 둘 중 하나에게 확실한 우선권을 주기 때문에 순환 대기가 생길 수 없습니다. 타임스탬프 기법의 세부 동작은 뒷부분에서 더 자세히 설명합니다.

---

## 🔥 4. 교착상태 회복(Recovery) 방법

예방을 했음에도 불구하고 교착상태가 이미 발생했다면 어떻게 해야 할까요? 이번에는 교착상태를 **탐지하고 회복**하는 방법을 알아봅니다.

### 희생자(Victim) 선택과 롤백

교착상태를 깨는 가장 효과적인 방법은 **순환 고리를 끊는 것**입니다. 즉, 교착상태에 참여한 트랜잭션 중 하나를 강제로 종료(롤백)시켜서 순환 고리를 끊는 것입니다.

**비유:** 한글, 엑셀, 파워포인트 세 프로그램이 서로의 데이터를 기다리며 교착상태에 빠졌습니다. 한글은 1시간 작업, 엑셀은 30분 작업, 파워포인트는 10분 작업을 했습니다. 이 중 어떤 것을 강제 종료하는 게 가장 피해가 적을까요? 당연히 **가장 적게 작업한 파워포인트**이겠죠. 파워포인트를 강제 종료하면 순환 고리가 끊어지고, 한글과 엑셀은 다시 정상 동작을 재개할 수 있습니다.

이처럼 교착상태 회복에서는 강제 종료될 트랜잭션을 **희생자(Victim)** 라고 부릅니다. 희생자 선정 기준은 보통 다음과 같습니다:

- 현재까지 사용한 **시스템 자원이 가장 적은** 트랜잭션
- 작업 처리량이 **가장 적은** 트랜잭션
- **메모리 점유량이 가장 작은** 트랜잭션

선정된 희생자는 **롤백(Rollback)** 을 통해 작업을 취소하고, 해당 트랜잭션이 점유하던 자원은 시스템으로 반납됩니다.

### 기아 상태(Starvation) 방지

여기서 또 하나의 문제가 발생할 수 있습니다. 만약 시스템의 구조적 특성상 교착상태가 생길 때마다 항상 같은 트랜잭션(예: 파워포인트)이 희생자로 선정된다면 어떻게 될까요? 그 트랜잭션은 영원히 완료되지 못하는 **기아 상태(Starvation)** 에 빠지게 됩니다.

이를 방지하기 위해, 희생자 선정 기준에 **희생자로 선정된 횟수**를 포함시킵니다. 예를 들어, 3번 이상 희생자로 선정된 트랜잭션은 다음번 희생자 후보에서 제외하는 방식으로 특정 트랜잭션이 계속 희생되는 것을 방지합니다.

:::tip 교착상태 회복 절차 요약
1. 교착상태 탐지 (순환 고리 발견)
2. 희생자 선정 (비용이 가장 적은 트랜잭션 선택)
3. 희생자 롤백 (작업 취소 및 자원 반납)
4. 기아 상태 방지 (희생자 선정 횟수 제한)
:::

---

## 🏷️ 5. 독립성 레벨(Isolation Level) — 얼마나 철저하게 막을 것인가?

### 독립성 레벨이란?

병행제어를 할 때 "얼마나 엄격하게 간섭을 막을 것인가"의 수준을 **독립성 레벨(Isolation Level)** 이라고 합니다. SQL 표준에서 공식적으로 정의한 개념입니다.

독립성 레벨이 높을수록:
- 간섭을 더 철저하게 차단합니다
- 데이터 정합성(정확성)이 더 잘 보장됩니다
- 대신 동시에 접속할 수 있는 사용자 수가 줄어들어 **동시성(Concurrency)이 낮아집니다**

독립성 레벨이 낮을수록:
- 간섭을 덜 차단합니다
- 여러 사람이 동시에 사용하기 더 수월합니다 (**동시성이 높아집니다**)
- 대신 데이터 이상 현상이 발생할 위험이 높아집니다

### 3가지 이상 현상 (직렬성 위반 유형)

독립성 레벨을 이해하려면 먼저 **병행 수행에서 발생할 수 있는 3가지 이상 현상**을 알아야 합니다.

#### 이상 현상 1: 부정판독 (Dirty Read) 🗑️

**Dirty Read**란 어떤 트랜잭션이 아직 커밋(확정)되지 않은, 즉 **롤백될 수도 있는 데이터를 읽어오는 현상**입니다.

```
T1: X = 100 → X = X + 100 = 200 → Write(X=200)  ← 아직 커밋 안 됨!
T2:                                Read(X) → 200을 읽음  ← 롤백될 값!
T1:                                                      → Rollback! (X는 다시 100)
T2: 200을 읽었지만, 실제 X는 100으로 되돌아감 → 잘못된 값 사용!
```

위 상황에서 T2는 **존재하지 않는 값(롤백으로 사라진 200)** 을 읽어온 셈입니다. 마치 마트에서 이미 판매 완료된 재고를 보고 주문했는데, 실제로는 없는 것과 같습니다.

#### 이상 현상 2: 비반복판독 (Non-Repeatable Read) 🔄

**Non-Repeatable Read**란 같은 트랜잭션 내에서 **같은 데이터를 두 번 읽었는데 값이 다른 현상**입니다.

```
T1: Read(X) → 100 읽음
T2:           Update(X = X * 2) → X = 200으로 변경, Commit
T1: Read(X) → 200 읽음  ← 같은 쿼리인데 결과가 다름!
```

T1은 같은 명령어로 두 번 X를 읽었지만, 그 사이에 T2가 값을 변경했기 때문에 처음에는 100, 나중에는 200을 읽게 됩니다. **값이 롤백된 것이 아니라 변경된 것**이 문제입니다. 마치 뉴스를 오전에 봤을 때 기온이 20도였는데, 오후에 같은 뉴스를 다시 봤더니 25도로 수정되어 있는 것과 같습니다.

#### 이상 현상 3: 가상판독 (Phantom Read) 👻

**Phantom Read(팬텀 리드)** 란 같은 조건으로 두 번 조회했는데, 두 번째 조회 시 **처음에는 없었던 새로운 행이 나타나는 현상**입니다.

```
T1: SELECT * WHERE 조건 → {10, 20} 조회
T2:                       INSERT INTO ... VALUES(30) → Commit
T1: SELECT * WHERE 동일 조건 → {10, 20, 30} 조회  ← 유령처럼 30이 나타남!
```

기존 값(10, 20)은 변경되거나 롤백된 것이 아닙니다. 단지 새로운 행(30)이 **삽입**되어 두 번째 조회 결과에 유령처럼 나타난 것입니다. 마치 같은 상점 목록을 두 번 확인했는데, 두 번째 확인 시 새로 개업한 가게가 추가된 것과 같습니다.

### 4가지 독립성 레벨

SQL 표준에서는 독립성 레벨을 다음 4단계로 정의합니다. 아래로 내려갈수록 독립성 레벨이 **높아집니다**.

| 독립성 레벨 | Dirty Read | Non-Repeatable Read | Phantom Read | 동시성 |
|------------|:----------:|:-------------------:|:------------:|:------:|
| **Read Uncommitted** | 허용 ❌ | 허용 ❌ | 허용 ❌ | 최고 ⬆️ |
| **Read Committed** | 불허 ✅ | 허용 ❌ | 허용 ❌ | 높음 |
| **Repeatable Read** | 불허 ✅ | 불허 ✅ | 허용 ❌ | 중간 |
| **Serializable** | 불허 ✅ | 불허 ✅ | 불허 ✅ | 최저 ⬇️ |

*(✅ 불허 = 이상 현상이 발생하지 않도록 막음 / ❌ 허용 = 이상 현상이 발생할 수 있음)*

#### Read Uncommitted (읽기 미완료)

**가장 낮은 독립성 레벨**입니다. 아무런 제약이 없어 Dirty Read조차 허용합니다. 커밋되지 않은 데이터도 자유롭게 읽을 수 있습니다. 제한이 전혀 없기 때문에 동시성이 최고로 높고 처리 속도가 가장 빠르지만, 데이터 정합성은 전혀 보장되지 않습니다.

#### Read Committed (커밋된 데이터만 읽기)

**Dirty Read를 허용하지 않는 레벨**입니다. 커밋이 확정된 데이터만 읽을 수 있어, 롤백으로 사라질 데이터를 읽는 문제를 방지합니다. 다만 같은 트랜잭션 내에서 값이 변경되는 Non-Repeatable Read는 여전히 발생할 수 있습니다. 많은 실제 데이터베이스 시스템의 기본(Default) 설정이 이 레벨입니다.

#### Repeatable Read (반복 읽기 보장)

**Non-Repeatable Read까지 방지하는 레벨**입니다. 같은 트랜잭션 내에서 같은 데이터를 몇 번을 읽어도 항상 같은 값이 반환됨을 보장합니다. 그러나 새로운 행이 삽입되는 Phantom Read는 여전히 발생할 수 있습니다. 기존에 있는 데이터의 변경은 막지만, 새로 추가되는 데이터는 통제할 수 없기 때문입니다.

#### Serializable (직렬화 가능)

**가장 높은 독립성 레벨**입니다. Dirty Read, Non-Repeatable Read, Phantom Read 모두를 차단합니다. 마치 트랜잭션들이 한 번에 하나씩 순서대로 실행되는 것처럼(직렬화) 완벽한 일관성을 보장합니다. 단, 가장 엄격한 제약으로 인해 동시성이 가장 낮고, 오버헤드(추가 처리 비용)가 크며 처리율이 가장 낮습니다.

:::tip 어떤 레벨을 선택해야 할까?
- **금융 시스템**처럼 데이터 정합성이 절대적으로 중요한 경우: Serializable 또는 Repeatable Read
- **일반 웹 서비스**처럼 높은 동시성이 필요한 경우: Read Committed (가장 많이 사용)
- **임시 통계** 등 정확도보다 속도가 중요한 경우: Read Uncommitted
:::

---

## ⏱️ 6. 타임스탬프(Timestamp) 기법

### 타임스탬프란?

**타임스탬프 기법**은 각 트랜잭션에 **고유한 시간 값(타임스탬프)** 을 부여하고, 이 시간 값의 순서에 따라 트랜잭션의 실행 순서를 결정하는 병행제어 기법입니다.

시간 값은 절대로 중복되지 않기 때문에, 로킹 기법처럼 서로 기다리는 상황이 발생하지 않아 **교착상태가 원천적으로 발생하지 않습니다**. 이것이 타임스탬프 기법의 가장 큰 장점입니다.

각 데이터 항목은 두 가지 타임스탬프 값을 유지합니다:

- **Read-TS (읽기 타임스탬프):** 해당 데이터를 마지막으로 성공적으로 **읽은** 트랜잭션의 타임스탬프
- **Write-TS (쓰기 타임스탬프):** 해당 데이터를 마지막으로 성공적으로 **쓴** 트랜잭션의 타임스탬프

### 타임스탬프 순서 프로토콜

타임스탬프 기법의 핵심 규칙은 간단합니다. **항상 최신 값에 대해서만 읽기/쓰기를 허용**한다는 것입니다.

```
규칙: 내가 요청하는 시간(TS) ≥ 마지막으로 성공한 시간(Read-TS 또는 Write-TS)
```

**비유:** 10시에 마지막으로 업데이트된 문서가 있습니다. 내가 9시에 저장된 옛날 버전에다가 내용을 덮어쓰면 어떻게 될까요? 10시에 작성된 최신 내용이 사라지는 심각한 문제가 발생합니다. 타임스탬프 프로토콜은 이런 상황을 막기 위해, 내가 요청하는 시간이 마지막 성공 시간보다 **반드시 크거나 같아야** 한다는 규칙을 강제합니다.

```
예시:
- Write-TS(X) = 10시 (마지막으로 X에 쓰기 성공한 시간)
- 트랜잭션 T가 X를 읽으려 함
  - T의 타임스탬프가 11시 → 허용 ✅ (더 최신 요청)
  - T의 타임스탬프가 9시  → 거부 ❌ (옛날 요청, 옛날 값을 읽으려는 것)
```

### Wait-Die vs Wound-Wait 기법

타임스탬프를 이용해 자원 요청의 우선순위를 정하는 두 가지 방법이 있습니다. 여기서 **고참**은 먼저 시작한(타임스탬프가 작은) 트랜잭션이고, **신참**은 나중에 시작한(타임스탬프가 큰) 트랜잭션입니다.

| 기법 | 우선권 부여 대상 | 특징 |
|------|-----------------|------|
| **Wait-Die** | 신참(나중에 요청한 트랜잭션)에게 우선권 | 비선점 방식 |
| **Wound-Wait** | 고참(먼저 요청한 트랜잭션)에게 우선권 | 선점 방식 |

- **Wait-Die 기법:** 신참에게 자원 사용 우선권을 주고, 고참은 기다립니다(Wait). 만약 고참이 기다려도 자원을 얻지 못할 것 같으면 스스로 롤백(Die)합니다.
- **Wound-Wait 기법:** 고참에게 자원 사용 우선권을 주고, 신참은 기다립니다(Wait). 만약 고참이 신참이 점유한 자원을 원한다면, 신참을 강제로 롤백시키고(Wound) 자원을 가져옵니다.

두 방법 모두 교착상태를 방지하는 목적은 같지만, 누구에게 우선권을 주느냐에 따라 시스템의 특성이 달라집니다.

### 다중 버전 타임스탬프 (Multi-Version Timestamp)

일반 타임스탬프는 **가장 최신 값 하나만** 유지합니다. 하지만 경우에 따라서는 5일 전 값, 10일 전 값, 15일 전 값 등 **여러 버전의 데이터를 동시에 유지**해야 할 때가 있습니다. 이럴 때 사용하는 것이 **다중 버전 타임스탬프(Multi-Version Timestamp)** 기법입니다.

각 데이터 항목의 변경 이력을 버전별로 보관하여, 트랜잭션이 필요한 시점의 버전을 선택하여 읽을 수 있게 해줍니다. 단, 여러 버전을 유지하는 만큼 **저장 공간이 더 많이 필요**하고, 적절한 버전을 선택하여 직렬성을 유지하는 관리 비용도 증가합니다.

### 다중 버전 2단계 로킹 기법

**다중 버전 2단계 로킹 기법**은 이름 그대로 **타임스탬프 기법**과 **2단계 로킹 기법**을 결합한 방식입니다. 왜 두 가지를 합쳤을까요?

- **로킹 기법의 약점:** 교착상태가 발생할 수 있음
- **타임스탬프 기법의 약점:** 연쇄 복귀(Cascading Rollback, 한 트랜잭션의 롤백이 다른 트랜잭션의 롤백을 연쇄적으로 유발하는 문제)가 발생할 수 있음

두 기법의 장점을 결합하여 교착상태 문제와 연쇄 복귀 문제를 함께 해결하려는 시도가 바로 다중 버전 2단계 로킹 기법입니다.

---

## 🌟 7. 낙관적 병행제어 (Optimistic Concurrency Control)

### 낙관적 병행제어란?

**낙관적 병행제어(Optimistic Concurrency Control)** 는 일명 **확인 기법(Validation Technique)** 이라고도 합니다. 이 기법의 핵심 철학은 "**일단 낙관적으로 생각하고 마음껏 작업하게 한 뒤, 끝나고 나서 검사하자**"입니다.

기존의 로킹 기법은 매번 자원을 요청할 때마다 Lock을 확인하고, 충돌이 있으면 기다리게 합니다. 반면 낙관적 병행제어는 **실행 도중에는 아무런 검사를 하지 않고**, 작업이 완전히 끝난 후에 한꺼번에 검사합니다.

**비유:** 시험 감독관이 두 가지 방식으로 시험을 진행할 수 있습니다.

- **엄격한 방식 (로킹 기법):** 학생이 답안지를 한 장 제출할 때마다 즉시 이름, 마킹 여부 등을 확인하고 통과 여부를 결정합니다.
- **낙관적 방식 (낙관적 병행제어):** "다들 잘 썼겠지"라고 믿고 모든 답안지를 다 모은 뒤, 시험이 끝나고 한꺼번에 확인합니다.

낙관적 병행제어는 **충돌이 자주 발생하지 않는 환경**에서 매우 효율적입니다. 충돌이 드물다면, 매번 Lock을 거는 오버헤드 없이 작업하다가 마지막에만 검사하면 되니까요.

### 낙관적 병행제어의 3단계

낙관적 병행제어는 **판독 → 확인 → 기록** 이라는 3단계로 구성됩니다.

#### 1단계: 판독(Read) 단계

트랜잭션이 실행되는 동안 필요한 데이터를 읽어옵니다. 이때 중요한 점은 **원본 데이터에 직접 작업하지 않고, 복사본(Local Copy)을 만들어** 복사본에 대해 모든 작업을 수행한다는 것입니다. 원본은 건드리지 않기 때문에 문제가 생겨도 원본은 안전하게 보존됩니다.

```
원본 데이터: X = 100 (변경 없음, 안전하게 보관)
복사본:      X = 100 → 작업 수행 → X = 200 (복사본에서만 변경)
```

#### 2단계: 확인(Validation) 단계

모든 트랜잭션의 작업이 끝나면, 복사본에 대해 한꺼번에 **직렬성 위반 여부**를 검사합니다. 즉, 다른 트랜잭션과 충돌이 있는지, 데이터 정합성을 해치는지 확인합니다. 이 단계에서 문제가 발견되면 해당 트랜잭션을 롤백합니다.

#### 3단계: 기록(Write) 단계

확인 단계를 통과한(이상이 없는) 트랜잭션의 복사본 내용을 **원본 데이터베이스에 실제로 반영**합니다. 검증을 마친 데이터만 원본에 기록되므로, 데이터 정합성이 보장됩니다.

```
복사본 확인 결과: 이상 없음 ✅
       ↓
원본에 X = 200 기록 완료
```

:::note 낙관적 병행제어의 장단점
**장점:**
- 충돌이 드문 환경에서 Lock 오버헤드 없이 매우 빠르게 동작
- 교착상태가 발생하지 않음

**단점:**
- 충돌이 잦은 환경에서는 롤백이 자주 발생하여 오히려 비효율적
- 롤백 시 복사본에서 작업한 내용이 모두 날아감
:::

---

## ⚠️ 8. 주의사항과 실전 팁

### 로킹 기법 사용 시 주의사항

```sql
-- ❌ 잘못된 예시: Lock을 걸고 나서 Unlock을 잊어버림
BEGIN TRANSACTION;
  LOCK TABLE accounts;          -- 자물쇠를 걸었음
  UPDATE accounts SET balance = balance - 50000 WHERE id = 1;
  -- (Unlock을 하지 않아 다른 트랜잭션이 영원히 대기하게 됨!)
COMMIT;
```

```sql
-- ✅ 올바른 예시: 트랜잭션 종료 시 자동으로 Lock이 해제됨
BEGIN TRANSACTION;
  -- 트랜잭션 시작 시 필요한 데이터에 Lock 획득
  SELECT balance FROM accounts WHERE id = 1 FOR UPDATE; -- 쓰기 Lock
  UPDATE accounts SET balance = balance - 50000 WHERE id = 1;
COMMIT; -- 커밋 시 자동으로 Lock 해제 ✅
-- 또는
ROLLBACK; -- 롤백 시에도 자동으로 Lock 해제 ✅
```

:::danger 절대 하면 안 되는 것
Lock을 획득한 채로 트랜잭션을 오랫동안 열어두지 마세요. Lock을 오래 유지할수록 다른 트랜잭션들이 대기하는 시간이 길어지고, 교착상태가 발생할 위험이 높아집니다. 트랜잭션은 가능한 한 짧고 빠르게 처리하는 것이 원칙입니다.
:::

### 독립성 레벨 설정 팁

```sql
-- ❌ 잘못된 예시: 항상 최고 레벨(Serializable)을 사용
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
-- 데이터 정합성은 완벽하지만, 대부분의 경우 불필요하게 성능이 저하됨

-- ✅ 올바른 예시: 상황에 맞는 독립성 레벨 선택
-- 일반적인 웹 서비스 조회 쿼리
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
SELECT * FROM products WHERE category = '전자제품';

-- 금융 이체 처리 (정합성이 매우 중요)
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
BEGIN TRANSACTION;
  UPDATE accounts SET balance = balance - 100000 WHERE id = 1; -- 출금
  UPDATE accounts SET balance = balance + 100000 WHERE id = 2; -- 입금
COMMIT;
```

### 각 기법 비교 요약

| 기법 | 교착상태 | 동시성 | 구현 복잡도 | 주요 사용 환경 |
|------|:--------:|:------:|:-----------:|:-------------:|
| **기본 로킹** | 발생 가능 | 중간 | 낮음 | 일반적 환경 |
| **정적 2PL** | 발생 안 함 | 낮음 | 높음 | 이론적 |
| **타임스탬프** | 발생 안 함 | 높음 | 중간 | 연쇄 복귀 주의 |
| **다중 버전 TS** | 발생 안 함 | 높음 | 높음 | 버전 관리 필요 시 |
| **낙관적 병행제어** | 발생 안 함 | 매우 높음 | 중간 | 충돌이 드문 환경 |

---

## ✅ 핵심 정리

- **로킹 기법**은 데이터 사용 전 Lock 획득, 사용 후 Unlock 해제로 동시 접근을 제어하는 병행제어 기법이다.
- **교착상태(Deadlock)** 는 트랜잭션들이 서로의 자원을 무한히 기다리는 상태로, 4가지 조건(상호배제·점유와대기·비선점·순환대기)이 모두 충족될 때 발생한다.
- **교착상태 예방** 방법으로는 사전 잠금(정적 2PL), 스케줄링, 요구 거절법, 타임스탬프 기법이 있다.
- **교착상태 회복**은 희생자(Victim)를 선정하여 롤백시키고 자원을 반납받는 방식으로 처리하며, 기아 상태 방지를 위해 희생 횟수를 관리한다.
- **독립성 레벨(Isolation Level)** 은 병행 수행 시 간섭의 정도를 4단계(Read Uncommitted → Read Committed → Repeatable Read → Serializable)로 구분하며, 높을수록 정합성이 강하고 동시성이 낮다.
- **3가지 이상 현상**으로 Dirty Read(롤백된 값 읽기), Non-Repeatable Read(값 변경으로 같은 쿼리 결과 다름), Phantom Read(새 행 삽입으로 조회 결과 달라짐)가 있다.
- **타임스탬프 기법**은 트랜잭션에 고유 시간값을 부여하여 순서를 결정하며, 교착상태가 발생하지 않는다.
- **Wait-Die 기법**은 신참에게 우선권을 주고, **Wound-Wait 기법**은 고참에게 우선권을 부여한다.
- **다중 버전 타임스탬프**는 데이터의 여러 버전을 보관하여 필요한 시점의 값을 사용할 수 있게 한다.
- **다중 버전 2단계 로킹 기법**은 로킹 기법과 타임스탬프 기법을 결합하여 각각의 단점을 보완한다.
- **낙관적 병행제어**는 판독→확인→기록의 3단계로 진행되며, 복사본에 작업 후 검증을 통과하면 원본에 반영하는 방식으로 충돌이 드문 환경에서 효율적이다.

---

작성일: 2026-02-21