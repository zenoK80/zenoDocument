---
title: "교착상태 발생의 4가지 조건"
description: "교착상태 발생의 4가지 조건에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/advanced-concurrency-control/3-교착상태-발생조건"
sidebar_label: "발생 조건"
date: "2026-02-21"
---

# 🔒 교착상태(Deadlock) 완전 정복: 발생 조건부터 해결까지

데이터베이스를 공부하다 보면 반드시 마주치는 개념이 있습니다. 바로 **교착상태(Deadlock, 데드락)** 입니다. 이름만 들어도 뭔가 심각한 느낌이 들지 않나요? 실제로도 교착상태는 시스템을 완전히 멈춰버리게 만드는 심각한 문제입니다. 이번 문서에서는 교착상태가 무엇인지, 왜 발생하는지, 그리고 어떻게 예방하고 해결하는지를 초보자도 이해할 수 있도록 아주 친절하게 설명드리겠습니다.

---

## 🧩 교착상태란 무엇인가?

### 로킹 기법(Locking)을 먼저 이해하자

교착상태를 이해하려면, 먼저 **로킹 기법(Locking, 잠금 기법)** 이 무엇인지부터 알아야 합니다. 데이터베이스는 여러 사람이 동시에 접근해서 데이터를 읽고 쓸 수 있는 공유 자원입니다. 이렇게 동시에 여러 사람이 접근하면 데이터가 뒤죽박죽될 수 있는데, 이를 막기 위해 사용하는 것이 바로 로킹 기법입니다.

로킹 기법은 마치 **강의실에 자물쇠를 거는 것**과 같습니다. 누군가 강의실을 사용하려면 먼저 자물쇠(Lock)를 얻어야 합니다. 자물쇠를 얻은 사람만 강의실(데이터)을 사용할 수 있고, 사용이 끝나면 자물쇠를 반납(Unlock)합니다. 그러면 다음 사람이 자물쇠를 얻어서 사용할 수 있게 됩니다.

- **Lock(잠금)**: 데이터를 사용하기 전에 독점권을 획득하는 것
- **Unlock(잠금 해제)**: 데이터 사용이 끝난 후 독점권을 반납하는 것

이 과정을 반복하면서 여러 트랜잭션(작업 묶음)이 충돌 없이 데이터베이스를 사용할 수 있습니다.

### 그런데 왜 교착상태가 생길까?

로킹 기법은 편리하고 효과적이지만, 치명적인 단점이 하나 있습니다. 바로 **교착상태(Deadlock)에 빠질 수 있다**는 것입니다.

교착상태는 우리 일상에서도 쉽게 볼 수 있습니다. 예를 들어, 회의실에서 두 사람이 의사결정을 해야 하는데, A는 "내 의견이 맞아"라고 주장하고, B도 "내 의견이 맞아"라고 주장하면서 서로 양보하지 않으면 회의가 영원히 진행되지 않죠. 이런 상황이 바로 교착상태입니다.

데이터베이스에서의 교착상태는 다음과 같이 정의합니다:

> **트랜잭션(작업 묶음) 집합 내에서 각 트랜잭션이 서로 다른 트랜잭션이 잠근(Lock) 데이터를 기다리는 상태. 결국 아무도 진행하지 못하고 무한정 대기하게 되는 상황.**

쉽게 말하면, T1이 T2를 기다리고, T2가 T1을 기다리는 상태가 되어버려서 아무것도 진행되지 않는 것입니다. 마치 좁은 골목길에서 차 두 대가 서로 마주보고 서서 "네가 비켜라", "아니 네가 비켜라"를 반복하는 것처럼 말이죠.

:::info 일상 속 교착상태
컴퓨터를 사용하다가 프로그램이 아무 반응 없이 멈춰버린 경험이 있으신가요? 화면에 "응답 없음"이라고 뜨면서 프로그램이 종료도 안 되고, 강제로 작업 관리자를 열어서 프로세스를 종료시켜야만 해결되는 상황. 바로 이것이 교착상태의 대표적인 증상입니다.
:::

---

## ⚠️ 교착상태가 발생하는 4가지 조건

교착상태는 단순히 "두 트랜잭션이 서로 기다린다"고 해서 무조건 발생하는 것이 아닙니다. 교착상태가 발생하려면 **반드시 4가지 조건이 동시에 충족**되어야 합니다. 이 4가지 조건 중 하나라도 깨지면 교착상태는 발생하지 않습니다. 이 점이 교착상태 예방의 핵심 원리이기도 합니다.

### 1️⃣ 상호 배제 (Mutual Exclusion, 독점 사용)

**상호 배제**란 한 번에 오직 한 개의 프로세스(트랜잭션)만이 특정 자원을 독점적으로 사용할 수 있다는 조건입니다. 이것은 우리가 로킹 기법을 사용하는 이유 그 자체이기도 합니다.

강의실 비유로 설명하자면, 강의실은 한 수업만 사용할 수 있습니다. A 수업이 강의실을 사용하고 있으면, B 수업은 그 강의실을 동시에 사용할 수 없습니다. 이처럼 **자원(강의실)은 한 번에 하나의 프로세스(수업)에게만 할당**됩니다.

데이터베이스에서는 어떤 트랜잭션이 Lock을 획득하면, 그 트랜잭션이 Unlock하기 전까지 다른 트랜잭션은 해당 데이터에 접근할 수 없습니다. 이 조건이 충족되어야만 교착상태가 발생할 가능성이 생깁니다.

:::note 동시에 많은 사람이 접속하는 것은 어떻게 가능한가?
"한 번에 하나의 프로세스만 자원을 쓸 수 있다면, 네이버 같은 사이트에 수십만 명이 동시에 접속하는 건 어떻게 가능한가?" 라고 의문이 드실 수 있습니다. 이는 **시분할 시스템(Time-Sharing System)** 덕분입니다. CPU는 사용자들에게 아주 짧은 시간 단위로 권한을 줬다 뺏었다를 반복합니다. 그 속도가 워낙 빠르기 때문에 사용자는 "내가 기다리고 있구나"라는 것을 전혀 느끼지 못하는 것입니다.
:::

### 2️⃣ 점유 대기 (Hold and Wait, 가지고 기다리기)

**점유 대기**란, 어떤 프로세스가 이미 자원을 점유(Hold)하고 있으면서, 동시에 다른 자원을 얻기 위해 대기(Wait)하고 있는 상태를 말합니다.

쉽게 풀어보면 이렇습니다: 1번 트랜잭션이 A 데이터에 Lock을 걸고 사용 중입니다. 그런데 1번 트랜잭션이 작업을 완료하려면 B 데이터도 필요합니다. 그래서 B 데이터에도 Lock을 달라고 요청하며 기다립니다. 이 상태가 바로 점유 대기입니다.

마치 방 두 개가 필요한 수업인데, 1번 강의실은 이미 잠그고 사용 중이면서, 2번 강의실도 달라고 기다리는 상황과 같습니다. 잠금(Lock)을 취득한 상태에서 또 다른 잠금을 기다리고 있다는 것이 핵심입니다.

### 3️⃣ 비선점 (Non-Preemption, 강제로 뺏을 수 없음)

**비선점**이란, 다른 프로세스가 사용 중인 자원을 강제로 빼앗을 수 없다는 조건입니다. **선점(Preemption)** 의 반대 개념으로, 자원은 그것을 사용하고 있는 프로세스가 스스로 자발적으로 반납(Unlock)할 때만 회수될 수 있습니다.

예를 들어 1번 트랜잭션이 A 데이터를 잠그고 작업 중인데, 2번 트랜잭션이 "나도 A 데이터가 필요해!"라고 해도, 1번 트랜잭션의 작업이 완료(커밋, Commit)되거나 취소(롤백, Rollback)되기 전까지는 2번 트랜잭션이 강제로 A 데이터를 가져올 수 없습니다. 마치 누군가 강의실을 사용하고 있을 때, 다른 사람이 강제로 문을 열고 들어올 수 없는 것처럼 말이죠.

그래서 2번 트랜잭션은 무한정 기다릴 수밖에 없게 되고, 이 "끝이 보이지 않는 기다림"이 교착상태로 이어질 수 있습니다.

### 4️⃣ 순환 대기 (Circular Wait, 원형으로 기다리기)

**순환 대기**는 교착상태의 가장 핵심적인 조건으로, 프로세스들이 서로 상대방의 자원을 기다리는 형태가 **원형(Cycle)** 을 이루는 상태입니다.

예를 들어 A, B, C 세 개의 트랜잭션이 있다고 합시다:
- **A**는 자신의 자원을 점유하면서, **B**의 자원을 달라고 기다리고 있습니다.
- **B**는 자신의 자원을 점유하면서, **C**의 자원을 달라고 기다리고 있습니다.
- **C**는 자신의 자원을 점유하면서, **A**의 자원을 달라고 기다리고 있습니다.

이렇게 되면 A → B → C → A 의 순환 고리가 만들어집니다. 아무도 먼저 자원을 반납하지 않으니, 아무것도 진행되지 않습니다.

실생활 예시로는 아래 한글과 엑셀을 동시에 사용할 때를 들 수 있습니다. 아래 한글은 엑셀의 데이터를 요청하고, 엑셀은 아래 한글의 데이터를 요청하는 상황이 되면, 두 프로그램이 서로를 기다리면서 사이클이 발생합니다. 결국 둘 다 멈춰버리게 됩니다.

:::warning 4가지 조건이 모두 충족되어야 교착상태 발생
교착상태는 위의 4가지 조건이 **동시에** 충족될 때만 발생합니다. 따라서 교착상태를 예방하려면 이 4가지 중 **하나라도 깨면** 됩니다. 이것이 교착상태 예방 전략의 핵심 원리입니다.
:::

4가지 조건을 표로 정리하면 다음과 같습니다:

| 조건 | 영문명 | 핵심 의미 | 비유 |
|------|--------|-----------|------|
| 상호 배제 | Mutual Exclusion | 한 번에 하나의 프로세스만 자원 사용 가능 | 강의실은 한 수업만 사용 가능 |
| 점유 대기 | Hold and Wait | 자원을 점유한 채로 다른 자원을 기다림 | 1번 강의실 쓰면서 2번 강의실 기다림 |
| 비선점 | Non-Preemption | 자원을 강제로 빼앗을 수 없음 | 사용 중인 강의실 강제 침입 불가 |
| 순환 대기 | Circular Wait | 프로세스들이 원형으로 서로를 기다림 | A→B→C→A가 서로 기다리는 고리 |

---

## 🛡️ 교착상태 예방 방법

교착상태는 발생하면 시스템 전체가 멈출 수 있기 때문에, **미리 예방하는 것**이 최선입니다. 교착상태를 예방하는 방법으로는 크게 4가지가 있습니다.

### 방법 1: 실행 전 필요한 데이터를 모두 잠그기 (정적 2단계 로킹)

이 방법은 트랜잭션이 실행을 시작하기 전에, 그 트랜잭션이 필요로 하는 모든 데이터를 미리 다 잠가두는 방식입니다. 이렇게 하면 순환 대기가 발생할 수 없기 때문에 교착상태는 절대 발생하지 않습니다.

이 방식은 **정적 2단계 로킹 기법(Static Two-Phase Locking)** 이라고 불립니다. 이론적으로는 완벽하지만, **현실에서는 사용하기 어렵습니다**. 왜냐하면 트랜잭션이 시작되기 전에 어떤 데이터가 필요한지 미리 100% 정확하게 알기가 매우 어렵기 때문입니다.

:::warning 정적 2단계 로킹의 한계
이론적으로는 완벽한 교착상태 예방책이지만, 실무에서는 거의 사용되지 않습니다. 트랜잭션이 실행 전에 필요한 모든 데이터를 정확히 예측하는 것이 현실적으로 불가능에 가깝기 때문입니다.
:::

### 방법 2: 스케줄링을 잘 짜기

트랜잭션들의 실행 순서를 미리 충돌이 생기지 않도록 잘 계획하는 방법입니다. 마치 학교 수업 시간표를 짜는 것처럼, 어느 트랜잭션이 언제 어떤 데이터를 사용할지 미리 계획하면 충돌을 피할 수 있습니다.

비행기를 예로 들면, 공항에서 수십 대의 비행기가 동시에 이착륙하지 않는 이유는 관제탑에서 이착륙 스케줄을 철저하게 관리하기 때문입니다. 마찬가지로 트랜잭션 스케줄링도 충돌이 없도록 정밀하게 계획하면 교착상태를 방지할 수 있습니다.

하지만 이 방법 역시 **현실에서는 한계**가 있습니다. 동시에 수십만 명의 사용자가 접속하는 대규모 데이터베이스에서 모든 트랜잭션의 스케줄을 사전에 완벽하게 계획하는 것은 사실상 불가능합니다.

### 방법 3: 요구 거절법 (자원 요청 거절하기)

이 방법은 현실적으로 가장 많이 활용되는 방식 중 하나입니다. 어떤 트랜잭션이 자원을 요청할 때, 시스템이 현재 상황을 파악하여 요청을 허용할지, 잠시 기다리게 할지, 아니면 아예 거절할지를 결정하는 방식입니다.

미용실 비유가 아주 딱 맞습니다. 미용실에 갔는데 손님이 많아서 오래 기다려야 한다면, 헤어 디자이너는 두 가지 선택을 할 수 있습니다:
- "잠깐만 기다려 주세요, 금방 될 거예요." → **대기 허용**
- "오늘은 너무 바빠서 서비스가 어렵습니다. 다음에 오세요." → **요구 거절**

"다음에 오세요"라고 거절을 받은 손님은 기다리지 않고 돌아갑니다. 기다리지 않으면 점유 대기 조건이 깨지므로 교착상태가 발생하지 않게 됩니다.

### 방법 4: 타임스탬프(Timestamp, 시간값)를 이용하기

타임스탬프는 각 트랜잭션이 요청한 시간을 기록하여, 그 시간값을 기준으로 우선순위를 정하는 방법입니다. 시간은 절대 중복되지 않기 때문에, 타임스탬프를 사용하면 원칙적으로 교착상태가 발생하지 않습니다.

예를 들어:
- T1이 오전 10시에 자원을 요청
- T2가 오전 11시에 자원을 요청

이 경우 어떤 기준을 사용하든(먼저 요청한 T1 우선 또는 나중에 요청한 T2 우선) 명확한 우선순위가 생기기 때문에 서로를 기다리는 순환 고리가 형성되지 않습니다.

| 예방 방법 | 원리 | 현실 적용 가능성 |
|-----------|------|-----------------|
| 실행 전 전체 잠금 (정적 2단계 로킹) | 시작 전에 모든 자원 선점 | ❌ 현실적으로 거의 불가능 |
| 스케줄링 | 트랜잭션 순서를 미리 계획 | ❌ 대규모 시스템에서 불가능 |
| 요구 거절법 | 위험한 요청은 거절 | ✅ 현실적으로 활용 가능 |
| 타임스탬프 | 시간값으로 우선순위 결정 | ✅ 현실적으로 활용 가능 |

---

## 🔧 교착상태 회복 방법 (이미 빠졌을 때)

아무리 예방해도 교착상태가 발생할 수 있습니다. 이미 교착상태에 빠진 경우에는 **회복(Recovery)** 방법을 사용해야 합니다.

### 희생자(Victim) 선정과 롤백(Rollback)

교착상태가 발생하면, 교착상태에 관여하고 있는 트랜잭션 중 하나를 강제로 종료시켜서 순환 고리를 끊어야 합니다. 강제로 종료되는 이 트랜잭션을 **희생자(Victim)** 라고 부릅니다.

아래 한글, 엑셀, 파워포인트 세 프로그램이 교착상태에 빠졌다고 가정해봅시다:
- 아래 한글: 1시간 동안 작업한 내용이 있음
- 엑셀: 30분 동안 작업한 내용이 있음
- 파워포인트: 10분 동안 작업한 내용이 있음

이 중에서 누구를 희생자로 선정할까요? 당연히 **가장 작업량이 적은 파워포인트**가 희생자로 선정됩니다. 희생자를 종료시키면 순환 고리가 깨지고, 교착상태가 해소됩니다.

희생자를 선택하는 기준은 다음과 같습니다:
- **비용(Cost)이 가장 적게 드는 트랜잭션**: 가장 작업을 적게 한 것
- **메모리를 가장 적게 점유하고 있는 트랜잭션**
- **시스템 자원을 가장 적게 사용 중인 트랜잭션**

희생자가 결정되면 해당 트랜잭션을 **롤백(Rollback, 작업 취소)** 시켜서 원래 상태로 되돌립니다. 그리고 그 트랜잭션이 점유하고 있던 자원을 시스템이 강제로 회수합니다.

```sql
-- 교착상태 발생 시 희생자 트랜잭션 롤백 예시

-- T1: 1시간 작업한 트랜잭션 (희생자 아님)
BEGIN TRANSACTION T1;
  UPDATE documents SET content = '수정된 내용' WHERE id = 1; -- 아래 한글 작업
  -- A 자원 점유 중, B 자원 기다리는 중

-- T2: 30분 작업한 트랜잭션 (희생자 아님)
BEGIN TRANSACTION T2;
  UPDATE spreadsheets SET value = 100 WHERE id = 1; -- 엑셀 작업
  -- B 자원 점유 중, C 자원 기다리는 중

-- T3: 10분 작업한 트랜잭션 (희생자로 선정!)
BEGIN TRANSACTION T3;
  UPDATE presentations SET slide = '슬라이드1' WHERE id = 1; -- 파워포인트 작업
  -- C 자원 점유 중, A 자원 기다리는 중

-- 교착상태 감지 후 T3를 희생자로 선정하여 롤백
ROLLBACK TRANSACTION T3; -- T3의 모든 작업을 취소하고 순환 고리를 끊음
-- T3가 점유하던 자원이 해제되어 T1 또는 T2가 진행 가능해짐
```

### 기아 상태(Starvation) 방지

여기서 한 가지 문제가 생길 수 있습니다. 만약 시스템 구조상 항상 파워포인트가 자원을 가장 적게 점유한다면, 교착상태가 발생할 때마다 **항상 파워포인트만 희생자로 선정**됩니다. 파워포인트 입장에서는 억울하겠죠.

이렇게 특정 트랜잭션이 계속 희생자로 선정되어 영원히 진행하지 못하는 상태를 **기아 상태(Starvation)** 라고 합니다.

기아 상태를 방지하기 위해서는 **희생자로 선정된 횟수**를 기록합니다. 만약 특정 트랜잭션이 일정 횟수(예: 3회) 이상 희생자로 선정되면, 그 다음부터는 해당 트랜잭션을 희생자 후보에서 제외하고 다른 트랜잭션을 희생자로 선정합니다.

:::tip 기아 상태 방지 핵심
희생자 선정 시 단순히 비용만 볼 것이 아니라, **과거에 희생자로 선정된 횟수**도 함께 고려해야 합니다. 특정 트랜잭션이 반복적으로 희생자가 되지 않도록 횟수 제한을 두는 것이 중요합니다.
:::

---

## 📊 격리 수준(Isolation Level)이란?

### 격리 수준의 개념

교착상태와 함께 반드시 알아야 할 개념이 바로 **격리 수준(Isolation Level, 독립성 레벨)** 입니다. 병행 수행(여러 트랜잭션을 동시에 실행)을 할 때, 트랜잭션 간에 얼마나 서로 간섭을 허용할 것인지를 나타내는 수준입니다.

격리 수준이 높다는 것은 간섭을 거의 허용하지 않는다는 것으로, 데이터의 일관성(정확성)은 높아지지만 동시에 여러 사람이 사용하기 어려워집니다. 반대로 격리 수준이 낮다는 것은 간섭을 많이 허용하여 동시 사용성은 높아지지만 데이터 이상 현상이 발생할 수 있습니다.

> **격리 수준(Isolation Level)**: 병행 수행 시 트랜잭션 간의 간섭 정도를 나타내는 수준. 높을수록 데이터 정확성은 올라가고 동시 사용성은 낮아진다.

### 격리 수준을 이해하기 위한 3가지 이상 현상

격리 수준을 설명하기 전에, 병행 수행 시 발생할 수 있는 3가지 이상 현상을 먼저 이해해야 합니다.

#### 🔴 부정 판독 (Dirty Read, 오염된 값 읽기)

Dirty Read는 아직 **커밋(Commit, 최종 확정)되지 않은 데이터를 읽어오는 것**입니다. 나중에 롤백(취소)될 수도 있는 값을 미리 읽어버리는 것이죠.

```
[Dirty Read 발생 시나리오]

시간     T1 (트랜잭션 1)              T2 (트랜잭션 2)
------------------------------------------------------------------
1단계    x = 100 (초기값)
2단계    x = x + 100 → x = 200
         Write(x = 200)              
3단계                                 Read(x) → 200을 읽음  ← T2가 200 읽음
4단계    ROLLBACK! (x = 100으로 복구)
5단계                                 T2가 읽은 200은 이제 존재하지 않는 값!
```

T1이 x를 200으로 바꾸었고, T2가 그 200을 읽었습니다. 그런데 T1이 롤백되어 x가 다시 100으로 돌아갔습니다. T2가 읽은 200은 이제 존재하지 않는 **유령 값**이 되어버린 것입니다. 이것이 Dirty Read입니다.

#### 🟡 비반복 판독 (Non-Repeatable Read, 반복해서 읽으면 값이 달라짐)

Non-Repeatable Read는 **같은 데이터를 두 번 읽었는데 값이 달라지는 현상**입니다. Dirty Read와 다른 점은, 롤백된 값이 아니라 **다른 트랜잭션이 변경한 값**을 읽게 되는 것입니다.

```
[Non-Repeatable Read 발생 시나리오]

시간     T1 (트랜잭션 1)              T2 (트랜잭션 2)
------------------------------------------------------------------
1단계    Read(x) → 100               
2단계                                 x = x * 2 → x = 200
                                      Write(x = 200)
                                      COMMIT
3단계    Read(x) → 200  ← 같은 명령인데 결과가 다름!
```

T1이 x를 처음 읽었을 때는 100이었는데, T2가 x를 200으로 변경하고 커밋한 후, T1이 다시 x를 읽으니 200이 나왔습니다. **같은 명령인데 결과가 다른 것**, 이것이 비반복 판독입니다.

#### 🟢 가상 판독 (Phantom Read, 없던 데이터가 나타남)

Phantom Read는 **같은 조건으로 조회했는데, 없던 행(데이터)이 새로 나타나는 현상**입니다. 값이 변경된 것이 아니라, 새로운 데이터가 추가된 것입니다.

```
[Phantom Read 발생 시나리오]

시간     T1 (트랜잭션 1)              T2 (트랜잭션 2)
------------------------------------------------------------------
1단계    SELECT * FROM scores
         → 10, 20 (2개의 행 조회)
2단계                                 INSERT INTO scores VALUES (30)
                                      COMMIT
3단계    SELECT * FROM scores
         → 10, 20, 30  ← 30이 새로 생겼다! (유령처럼)
```

T1이 처음 조회했을 때는 10, 20 두 개의 값이 있었는데, T2가 30을 추가한 후 T1이 다시 조회하니 30이 추가되어 있습니다. 기존 값이 변경된 것도 아니고, 취소된 것도 아닙니다. 마치 유령(Phantom)처럼 새로운 데이터가 나타난 것입니다.

### SQL 표준 격리 수준 4단계

SQL 표준에서는 격리 수준을 4단계로 정의합니다. 아래로 내려갈수록 격리 수준이 높아집니다.

| 격리 수준 | 부정 판독 (Dirty Read) | 비반복 판독 (Non-Repeatable Read) | 가상 판독 (Phantom Read) | 동시성 |
|-----------|----------------------|----------------------------------|--------------------------|--------|
| **READ UNCOMMITTED** | 허용 ⭕ | 허용 ⭕ | 허용 ⭕ | 가장 높음 |
| **READ COMMITTED** | 차단 ❌ | 허용 ⭕ | 허용 ⭕ | 높음 |
| **REPEATABLE READ** | 차단 ❌ | 차단 ❌ | 허용 ⭕ | 보통 |
| **SERIALIZABLE** | 차단 ❌ | 차단 ❌ | 차단 ❌ | 가장 낮음 |

#### READ UNCOMMITTED (읽기 미확정)

가장 낮은 격리 수준으로, **아무런 제약이 없는 단계**입니다. Dirty Read, Non-Repeatable Read, Phantom Read 모두 허용됩니다. 이상 현상이 발생할 수 있지만, 그만큼 동시성(여러 명이 동시에 사용할 수 있는 정도)이 가장 높습니다. 잠금(Lock)이 거의 걸리지 않기 때문에 처리 속도는 빠르지만 데이터 정확성은 보장할 수 없습니다.

#### READ COMMITTED (읽기 확정)

커밋이 완료된 데이터만 읽을 수 있는 단계입니다. **Dirty Read는 차단**하지만, 같은 데이터를 두 번 읽었을 때 값이 달라질 수 있는 Non-Repeatable Read는 허용합니다. 실무에서 많이 사용되는 격리 수준이며, 대부분의 데이터베이스 시스템에서 기본값으로 설정되어 있습니다.

#### REPEATABLE READ (반복 읽기)

같은 데이터를 여러 번 읽어도 항상 같은 값이 나오도록 보장하는 단계입니다. **Dirty Read와 Non-Repeatable Read를 차단**합니다. 하지만 새로운 행이 삽입되는 Phantom Read는 여전히 허용됩니다. 기존 데이터의 변경은 막을 수 있지만, 완전히 새로운 데이터의 추가까지 막지는 못합니다.

#### SERIALIZABLE (직렬화)

가장 높은 격리 수준으로, **세 가지 이상 현상(Dirty Read, Non-Repeatable Read, Phantom Read)을 모두 차단**합니다. 마치 트랜잭션을 하나씩 순서대로 처리하는 것처럼 완벽한 데이터 일관성을 보장합니다. 하지만 그만큼 오버헤드(추가 처리 부담)가 크고, 동시성이 가장 낮아집니다.

:::tip 어떤 격리 수준을 선택해야 할까?
실무에서는 **READ COMMITTED**가 가장 많이 사용됩니다. 데이터 정확성과 동시성 사이의 균형이 잘 맞기 때문입니다. 금융 시스템처럼 데이터 정확성이 절대적으로 중요한 경우에는 **SERIALIZABLE** 수준을 사용하기도 합니다.
:::

---

## ⏱️ 타임스탬프(Timestamp) 기법 상세 이해

### 타임스탬프란?

**타임스탬프(Timestamp)** 는 시스템 시계에서 발급되는 **고유한 시간값**입니다. 트랜잭션마다 시작 시각이 다르기 때문에 타임스탬프 값은 절대 중복되지 않습니다. 이 고유한 시간값을 이용하여 트랜잭션 간의 순서를 정하고 교착상태를 방지할 수 있습니다.

타임스탬프는 두 가지 시간값을 관리합니다:
- **Read-TS (읽기 타임스탬프)**: 해당 데이터를 마지막으로 성공적으로 읽은 시간
- **Write-TS (쓰기 타임스탬프)**: 해당 데이터를 마지막으로 성공적으로 쓴 시간

### Wait-Die 기법 vs Wound-Wait 기법

타임스탬프를 이용한 교착상태 방지 기법에는 두 가지가 있습니다. 핵심은 **고참(먼저 요청한 트랜잭션)** 과 **신참(나중에 요청한 트랜잭션)** 중 누구에게 우선권을 주느냐에 따라 달라집니다.

:::note 고참과 신참의 구분
타임스탬프 값이 **작을수록 고참**(먼저 시작한 트랜잭션), 값이 **클수록 신참**(나중에 시작한 트랜잭션)입니다. 예를 들어 10시에 시작한 트랜잭션이 고참, 11시에 시작한 트랜잭션이 신참입니다.
:::

#### Wait-Die 기법 (비선점)

**Wait-Die 기법**은 **신참에게 우선권**을 주는 방식입니다.

- 고참이 신참의 자원을 원하면 → **기다린다(Wait)**
- 신참이 고참의 자원을 원하면 → **포기한다(Die, 롤백)**

11시에 시작한 신참 트랜잭션이 자원을 점유하고 있고, 10시에 시작한 고참 트랜잭션이 그 자원을 원한다면, 고참은 신참이 끝날 때까지 기다립니다. 반대로 고참이 자원을 점유하고 있고 신참이 원한다면, 신참은 포기하고 롤백됩니다. 이 기법은 **비선점(Non-Preemptive)** 방식입니다.

#### Wound-Wait 기법 (선점)

**Wound-Wait 기법**은 **고참에게 우선권**을 주는 방식입니다.

- 고참이 신참의 자원을 원하면 → **신참을 강제 종료(Wound, 선점)**
- 신참이 고참의 자원을 원하면 → **기다린다(Wait)**

고참이 자원을 원한다면 신참을 강제로 종료시키고 자원을 빼앗습니다(선점). 신참이 자원을 원한다면 고참이 끝날 때까지 기다립니다. 이 기법은 **선점(Preemptive)** 방식입니다.

| 구분 | Wait-Die | Wound-Wait |
|------|----------|------------|
| 우선권 | 신참(타임스탬프 큰 쪽) | 고참(타임스탬프 작은 쪽) |
| 방식 | 비선점 | 선점 |
| 고참이 신참 자원 요청 시 | 기다림 (Wait) | 신참 강제 종료 (Wound) |
| 신참이 고참 자원 요청 시 | 포기 (Die) | 기다림 (Wait) |

### 타임스탬프 순서 프로토콜

타임스탬프 기법에서 중요한 원칙이 있습니다. 모든 읽기와 쓰기 작업은 반드시 **가장 최근에 성공한 시간값보다 나중에 이루어져야** 합니다.

```
[타임스탬프 프로토콜 예시]

데이터 X의 상태:
  - Read-TS(X) = 10시 (마지막으로 성공적으로 읽은 시간)
  - Write-TS(X) = 9시  (마지막으로 성공적으로 쓴 시간)

새로운 트랜잭션 T의 타임스탬프 = TS(T)

[읽기 요청 시]
  TS(T) >= Write-TS(X) → 읽기 허용 ✅  (10시 또는 그 이후 요청은 OK)
  TS(T) < Write-TS(X)  → 읽기 거부 ❌  (9시 이전 옛날 값을 읽으려는 시도)

[쓰기 요청 시]
  TS(T) >= Read-TS(X) 이고 TS(T) >= Write-TS(X) → 쓰기 허용 ✅
  TS(T) < Read-TS(X)  또는 TS(T) < Write-TS(X)  → 쓰기 거부 ❌
```

이 원칙 덕분에 항상 **최신 데이터만 읽고 쓰게 됩니다**. 옛날 시간값을 가진 트랜잭션이 현재 데이터를 덮어쓰는 등의 이상 현상이 방지됩니다.

---

## 🎯 주의사항 및 실전 팁

### 교착상태 설계 시 주의사항

:::danger 교착상태를 유발하는 코드 패턴
두 트랜잭션이 서로 반대 순서로 자원을 잠그는 패턴은 교착상태를 유발합니다. 절대 피해야 합니다.
:::

```sql
-- ❌ 잘못된 예시: 교착상태를 유발하는 패턴

-- T1이 실행하는 순서
BEGIN TRANSACTION;
  LOCK TABLE A;   -- 1. A를 먼저 잠금
  -- ... 작업 ...
  LOCK TABLE B;   -- 2. 그 다음 B를 잠금 (T2가 B를 잠그고 있으면 대기)
COMMIT;

-- T2가 실행하는 순서 (T1과 반대 순서!)
BEGIN TRANSACTION;
  LOCK TABLE B;   -- 1. B를 먼저 잠금
  -- ... 작업 ...
  LOCK TABLE A;   -- 2. 그 다음 A를 잠금 (T1이 A를 잠그고 있으면 대기 → 교착상태!)
COMMIT;

-- 결과: T1은 B를 기다리고, T2는 A를 기다리는 순환 대기 발생! ❌
```

```sql
-- ✅ 올바른 예시: 항상 같은 순서로 자원을 잠그기

-- T1이 실행하는 순서
BEGIN TRANSACTION;
  LOCK TABLE A;   -- 1. A를 먼저 잠금 (항상 A → B 순서)
  LOCK TABLE B;   -- 2. 그 다음 B를 잠금
  -- ... 작업 ...
COMMIT;

-- T2가 실행하는 순서 (T1과 동일한 순서!)
BEGIN TRANSACTION;
  LOCK TABLE A;   -- 1. A를 먼저 잠금 (항상 A → B 순서)
  LOCK TABLE B;   -- 2. 그 다음 B를 잠금
  -- ... 작업 ...
COMMIT;

-- 결과: 두 트랜잭션이 같은 순서로 잠금 → 순환 대기 없음 ✅
```

**핵심 팁**: 여러 자원을 잠글 때는 **항상 동일한 순서로 잠가야** 교착상태를 예방할 수 있습니다.

### 격리 수준 선택 시 주의사항

```sql
-- ❌ 잘못된 예시: 무조건 가장 낮은 격리 수준 사용
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
-- Dirty Read가 허용되어 잘못된 데이터를 읽을 수 있음
-- 금융 데이터, 재고 데이터 등에서 심각한 오류 발생 가능

-- ✅ 올바른 예시: 상황에 맞는 격리 수준 선택

-- 일반적인 조회 (읽기 작업이 많고, 정확성도 중요한 경우)
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
BEGIN TRANSACTION;
  SELECT product_name, stock_quantity  -- 커밋된 데이터만 읽음
  FROM products
  WHERE category = '전자제품';
COMMIT;

-- 금융 트랜잭션 (데이터 정확성이 절대적으로 중요한 경우)
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
BEGIN TRANSACTION;
  SELECT balance FROM accounts WHERE account_id = 1001; -- 잔액 확인
  UPDATE accounts SET balance = balance - 100000 WHERE account_id = 1001; -- 출금
  UPDATE accounts SET balance = balance + 100000 WHERE account_id = 1002; -- 입금
COMMIT;
-- 모든 이상 현상 차단, 완벽한 일관성 보장
```

:::warning 격리 수준과 성능의 트레이드오프
격리 수준이 높을수록 데이터 정확성은 올라가지만, 시스템의 동시 처리 능력은 낮아집니다. SERIALIZABLE 수준을 모든 곳에 적용하면 시스템 성능이 급격히 저하될 수 있습니다. 각 상황에 맞는 격리 수준을 선택하는 것이 중요합니다.
:::

### 교착상태 모니터링 팁

실무에서는 교착상태가 발생하면 데이터베이스 시스템이 자동으로 이를 감지하고 희생자를 선정하여 롤백시킵니다. 하지만 교착상태가 자주 발생한다면 설계에 문제가 있다는 신호이므로, 반드시 원인을 분석하고 개선해야 합니다.

:::tip 교착상태 최소화 실전 팁
1. **자원 잠금 순서를 통일하세요**: 모든 트랜잭션이 같은 순서로 자원을 잠그면 순환 대기가 발생하지 않습니다.
2. **트랜잭션을 짧게 유지하세요**: 트랜잭션 시간이 짧을수록 교착상태 발생 확률이 낮아집니다.
3. **필요한 자원만 최소한으로 잠그세요**: 불필요한 잠금은 교착상태 위험을 높입니다.
4. **격리 수준을 상황에 맞게 설정하세요**: 모든 곳에 최고 수준의 격리를 적용할 필요는 없습니다.
:::

---

## 📝 핵심 정리

- **교착상태(Deadlock)** 란 트랜잭션들이 서로 상대방의 자원을 기다리며 아무것도 진행하지 못하는 상태이다.
- 교착상태 발생의 **4가지 필요 조건**은 상호 배제, 점유 대기, 비선점, 순환 대기이며 4가지가 동시에 충족될 때 발생한다.
- **상호 배제(Mutual Exclusion)**: 한 번에 하나의 프로세스만 자원을 독점 사용할 수 있다.
- **점유 대기(Hold and Wait)**: 자원을 점유한 채로 다른 자원을 기다리는 상태이다.
- **비선점(Non-Preemption)**: 사용 중인 자원을 강제로 빼앗을 수 없다.
- **순환 대기(Circular Wait)**: 프로세스들이 원형으로 서로의 자원을 기다리는 상태이다.
- 교착상태 **예방법**으로는 실행 전 전체 잠금(정적 2단계 로킹), 스케줄링, 요구 거절법, 타임스탬프 기법이 있다.
- 교착상태 **회복법**은 희생자(Victim)를 선정하여 롤백시키고 자원을 강제 회수하는 방식이다.
- **기아 상태(Starvation)** 방지를 위해 희생자 선정 횟수를 제한해야 한다.
- **격리 수준(Isolation Level)** 은 트랜잭션 간 간섭 정도를 나타내며 READ UNCOMMITTED → READ COMMITTED → REPEATABLE READ → SERIALIZABLE 순으로 높아진다.
- 3가지 이상 현상은 **Dirty Read(부정 판독)**, **Non-Repeatable Read(비반복 판독)**, **Phantom Read(가상 판독)** 이다.
- **타임스탬프 기법**은 시간값을 이용해 트랜잭션 우선순위를 정하며, 원칙적으로 교착상태가 발생하지 않는다.
- **Wait-Die**는 신참에게, **Wound-Wait**는 고참에게 우선권을 부여하는 타임스탬프 기반 기법이다.

---

작성일: 2026-02-21