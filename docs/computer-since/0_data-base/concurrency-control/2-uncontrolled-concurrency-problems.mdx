---
title: "무제어 동시공용의 문제점 (갱신 분실)"
description: "무제어 동시공용의 문제점 (갱신 분실)에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/concurrency-control/2-uncontrolled-concurrency-problems"
sidebar_label: "무제어 동시공용 문제"
date: "2026-02-21"
---

# 🔄 무제어 동시공용의 문제점과 병행 제어

데이터베이스를 혼자 쓰는 사람은 아무도 없습니다. 여러분이 쇼핑몰 사이트에서 상품 재고를 확인하는 그 순간, 수천 명의 다른 사람들도 동시에 같은 데이터베이스에 접근하고 있습니다. 이처럼 **여러 사람이 동시에 하나의 데이터베이스를 사용할 때 아무런 제어 없이 그냥 내버려 두면 어떤 일이 벌어질까요?** 이 문서에서는 그 문제의 본질과 해결 방법까지 차근차근 살펴봅니다.

---

## 🧭 병행 제어란 무엇인가?

### 병행(竝行)과 제어(制御)의 의미

**병행(竝行)** 이라는 단어를 먼저 풀어봅시다. "병렬로 동시에 수행된다"는 뜻입니다. 쉽게 말해, 여러 일이 동시에 진행되는 것입니다. 마치 여러 대의 기차가 각자의 선로 위에서 동시에 달리는 것처럼요. **제어(制御)** 는 그 동시에 일어나는 일들을 중간에 조율하고 관리한다는 뜻입니다.

따라서 **병행 제어(Concurrency Control)** 란, 동시에 실행되는 여러 트랜잭션(작업 묶음)들을 안전하게 조율하여 데이터의 정확성과 무결성을 지키는 기술입니다.

### 왜 병행 제어가 필요한가?

네이버, 쿠팡, 카카오 같은 서비스를 생각해보세요. 하루에 수백만 명이 동시에 접속합니다. 만약 이 서비스들이 한 사람이 데이터를 다 처리하고 나서야 다음 사람을 처리한다면, 마지막에 접속한 사람은 무한정 기다려야 할 것입니다. 그래서 **복수 사용자 DBMS(Database Management System, 데이터베이스 관리 시스템)** 는 반드시 병행성을 지원해야 합니다.

여러분이 네이버를 이용할 때 "지금 다른 사람 때문에 기다리고 있어"라고 느끼는 경우는 거의 없죠? 마치 1대1로 혼자 서버를 쓰는 것처럼 느껴집니다. 바로 이 경험이 **병행 제어가 제대로 동작하고 있다는 증거**입니다.

### 병행 제어의 목적

병행 제어가 추구하는 목표는 세 가지입니다.

| 목표 | 설명 |
|---|---|
| **공유도 최대화** | 동시에 최대한 많은 사용자가 데이터베이스에 접근할 수 있게 한다 |
| **응답 시간 최소화** | 사용자가 기다리는 시간을 줄여 빠른 서비스를 제공한다 |
| **시스템 활용도 최대화** | CPU, 메모리 등 컴퓨터 자원을 낭비 없이 최대한 활용한다 |

> 핵심은 **"여러 사람이 동시에 써도 데이터가 정확하게 유지되어야 한다"** 는 것입니다. 이것이 병행 제어가 존재하는 이유입니다.

---

## ⚠️ 무제어 동시공용의 문제점이란?

### 제어 없이 동시에 쓰면 어떻게 될까?

병행 제어를 굳이 안 해도 아무 문제가 없다면, 복잡한 기술을 도입할 이유가 없겠죠. 하지만 실제로는 **아무런 제어 없이 여러 사람이 동시에 데이터를 사용하면 심각한 문제들이 발생**합니다. 이를 **무제어 동시공용의 문제점** 이라고 합니다.

"무제어"란 병행 제어가 없다는 뜻이고, "동시공용"이란 동시에 여러 사람이 공유해서 사용한다는 뜻입니다. 즉, **제어 없이 동시에 공유해서 사용할 때 생기는 문제**를 말합니다.

무제어 동시공용의 문제점은 크게 세 가지입니다.

1. **갱신 분실(Lost Update)** - 한 트랜잭션의 수정이 사라져 버리는 문제
2. **모순성/불일치(Inconsistency)** - 데이터가 일관성 없이 뒤섞여 버리는 문제
3. **연쇄 복귀(Cascading Rollback)** - 한 트랜잭션의 취소가 다른 트랜잭션에도 연쇄적으로 영향을 줘야 하는데 그게 불가능해지는 문제

이 문서에서는 이 세 가지 문제를 하나씩 자세히 살펴봅니다.

:::info 트랜잭션이란?
**트랜잭션(Transaction)** 은 데이터베이스에서 하나의 논리적인 작업 단위입니다. 예를 들어 은행에서 "A 계좌에서 돈을 빼서 B 계좌에 넣는" 행위 전체가 하나의 트랜잭션입니다. 이 작업은 반드시 전부 성공하거나 전부 실패해야 합니다.
:::

---

## 💸 첫 번째 문제: 갱신 분실 (Lost Update)

### 갱신 분실이란?

**갱신 분실(Lost Update)** 은 두 개의 트랜잭션이 같은 데이터를 동시에 수정할 때, 한 트랜잭션의 수정 결과가 다른 트랜잭션에 의해 덮어쓰여져 사라지는 문제입니다. **"탐지 불가능(Dirty Write)"** 이라고도 부릅니다. 왜냐하면 어떤 값이 손실되었는지 시스템이 알아채기 어렵기 때문입니다.

마치 두 명이 같은 구글 문서를 동시에 편집하는데, 한 명이 저장하기 직전에 다른 한 명이 덮어쓰기로 저장해버려서 앞 사람의 수정 내용이 통째로 사라지는 것과 같습니다.

### 구체적인 예시: 홍길동과 홍길순

이해를 돕기 위해 구체적인 상황을 살펴봅시다.

- **트랜잭션 T1 = 홍길동**: 데이터 X에 100을 더하는 작업 (`X = X + 100`)
- **트랜잭션 T2 = 홍길순**: 데이터 X를 2배로 만드는 작업 (`X = X * 2`)
- **X의 초기값**: 10

병행 제어 없이 이 두 트랜잭션이 동시에 수행되면 다음과 같은 일이 벌어집니다.

```
시간  | 홍길동 (T1)           | 홍길순 (T2)           | X의 값
------|----------------------|----------------------|-------
1번   | X를 읽어옴 (값: 10)   |                      | 10
      | X + 100 = 110 계산   |                      | 10 (아직 저장 안 함)
2번   |                      | X를 읽어옴 (값: 10)   | 10
      |                      | X * 2 = 20 계산      | 10
3번   |                      | X에 20 저장 (Write)  | 20
4번   | X에 110 저장 (Write) |                      | 110 → 110이 저장됨?
```

:::warning 여기서 잠깐!
위 표를 보면 4번 순서에서 T1이 110을 저장하면 문제없어 보입니다. 하지만 실제로는 **T1이 110을 저장하기 전에 T2가 먼저 20을 저장했고, T1은 이미 저장된 T2의 값(20) 위에 110을 덮어씌웁니다.** 즉, T2의 작업이 무효가 됩니다. 반대 순서로 진행되면 T1의 110이 T2의 20에 의해 덮어써질 수 있습니다.
:::

강의에서 설명한 핵심 시나리오를 다시 정확하게 표현하면:

```
시간  | 홍길동 (T1)            | 홍길순 (T2)            | X의 값
------|------------------------|------------------------|-------
1번   | X 읽기 (값: 10)        |                        | 10
      | 110 계산 (저장 안 함)  |                        | 10
2번   |                        | X 읽기 (값: 10)        | 10
3번   |                        | 20 계산 후 X에 저장    | 20
4번   | X에 110 저장 안 되고   |                        |
      | T2 작업 후 다시 확인   |                        |
      | → 결국 X = 20만 남음  |                        | 20
```

**T1이 계산한 110이라는 값은 저장되지 못하고 사라집니다.** T2의 갱신(20)만 최종 결과로 남고, T1의 갱신(110)은 분실됩니다. 이것이 바로 **갱신 분실** 입니다.

### 왜 이런 문제가 생겼는가?

```
핵심 원인: T1이 Write(저장)를 하기 전에 T2가 같은 X를 Read(읽기)해버렸기 때문
```

T1이 X를 읽어서 계산을 했지만 아직 저장하지 않은 상태에서, 실행 권한이 T2로 넘어갔습니다. T2는 T1이 수정 중인 것도 모르고 원래 X값(10)을 읽어서 자기 계산을 마치고 저장했습니다. 이후 T1도 저장을 하면 T2의 결과를 덮어쓰거나, T2가 마지막에 저장하면 T1의 결과가 사라집니다.

> **갱신 분실의 핵심: Write가 완료되기 전에 다른 트랜잭션이 같은 데이터를 Read 또는 Write하면 발생한다.**

---

## 🔀 두 번째 문제: 모순성/불일치 (Inconsistency)

### 모순성이란?

**모순성(Inconsistency)** 은 두 트랜잭션이 인터리빙(Interleaving, 서로 뒤섞여 실행)되면서 데이터의 일관성이 깨지는 문제입니다. **불일치 분석 문제** 라고도 합니다. 원래 의도한 결과와 다른 이상한 결과가 나오는 것이죠.

마치 요리할 때 레시피 순서를 뒤섞어 따라하면 원하는 음식이 나오지 않는 것처럼, 트랜잭션의 작업 순서가 뒤섞이면 원하는 데이터 결과가 나오지 않습니다.

### 구체적인 예시

- **T1**: X와 Y 각각에 100을 더하는 작업 (`X = X + 100`, `Y = Y + 100`)
- **T2**: X와 Y 각각을 2배로 만드는 작업 (`X = X * 2`, `Y = Y * 2`)
- 초기값: X = 50, Y = 50

정상적인 순서(T1 먼저 완료 후 T2):
```
T1 완료 후: X = 150, Y = 150
T2 완료 후: X = 300, Y = 300
```

하지만 **인터리빙**이 발생하면:

```
시간 | T1 작업                    | T2 작업                    | X값  | Y값
-----|---------------------------|---------------------------|------|-----
1번  | X 읽기 → X + 100 → X 저장 |                           |  150 |  50
2번  |                           | X 읽기 → X * 2 → X 저장   |  300 |  50
3번  |                           | Y 읽기 → Y * 2 → Y 저장   |  300 | 100
4번  | Y 읽기 → Y * 2 된 값에    |                           |      |
     | 100을 더해버림!            |                           |  300 | 200
```

T1은 Y에 단순히 100을 더하려 했는데, T2가 이미 Y를 2배(100)로 만든 뒤에 T1이 그 값에 100을 더해버립니다. 결과는 **200**이 되어버립니다. T1이 원래 의도한 결과인 150이 아닌, T2의 영향을 받아 200이라는 모순된 결과가 나온 것입니다.

> **모순성의 핵심: 두 트랜잭션이 섞여 실행되면서 어떤 트랜잭션은 수정 전 값을, 다른 트랜잭션은 수정 후 값을 읽어 데이터 일관성이 깨진다.**

---

## 🌊 세 번째 문제: 연쇄 복귀 (Cascading Rollback)

### 연쇄 복귀란?

**연쇄 복귀(Cascading Rollback)** 는 병행 수행 중인 트랜잭션들 중 하나에 문제가 생겨 롤백(Rollback, 작업 취소)을 해야 할 때, 그 트랜잭션의 값을 이미 읽어간 다른 트랜잭션도 함께 롤백되어야 하는데 그것이 불가능한 문제입니다. **비완료 의존성(Uncommitted Dependency) 문제** 라고도 합니다.

쉽게 비유하자면, 홍길동이 문서를 수정 중인데 홍길순이 그 수정된 문서(아직 최종 확정 전)를 복사해 갔습니다. 이후 홍길동이 "이 수정은 없던 일로 하겠다(롤백)"고 했는데, 홍길순은 이미 그 잘못된 복사본으로 작업을 마치고 자리를 떠나버린 상황입니다. 홍길순의 작업도 취소해야 하는데 이미 사라진 상태라 취소할 수 없습니다.

### 구체적인 예시

- 초기값 X = 100
- **T1**: X에 100을 더하고 저장 (`X = X + 100 = 200`), 이후 롤백(취소)
- **T2**: T1이 저장한 200을 읽어서 2배 처리

```
시간 | T1 작업                     | T2 작업                     | X값
-----|----------------------------|-----------------------------|-----
1번  | X 읽기 → 100 + 100 = 200   |                             | 100
2번  | X에 200 저장 (Write)        |                             | 200
3번  |                            | X 읽기 (값: 200)             | 200
4번  |                            | 200 * 2 = 400 저장 완료     | 400
     |                            | T2는 시스템 종료 (완료 상태)  |
5번  | T1 롤백 발생! X → 100으로   |                             | 100
     | 되돌려야 함                 |                             |
     | T2도 롤백해야 하는데...      | 이미 떠나버림! 롤백 불가능!   |
```

T2는 T1이 저장한 **미완료 데이터(아직 확정되지 않은 값 200)** 를 읽어갔습니다. T1이 롤백을 해서 X는 다시 100이 됐지만, T2는 이미 200을 기반으로 400을 계산하고 작업을 완료한 뒤 시스템을 떠났습니다. T2의 작업도 취소해야 하지만 **T2를 되돌릴 방법이 없습니다.**

:::danger 이 상황이 왜 심각한가?
T2는 존재하지 않는 데이터(롤백된 200)를 기반으로 400이라는 결과를 만들어냈습니다. 이 400은 **완전히 잘못된 값**입니다. 은행 시스템이라면 없는 돈이 생겨난 것과 같습니다. 이처럼 **회복 불가능한(Unrecoverable) 상태**에 빠지는 것이 연쇄 복귀 문제의 핵심입니다.
:::

> **연쇄 복귀의 핵심: 미완료(아직 커밋되지 않은) 데이터를 다른 트랜잭션이 읽어갔을 때, 원본 트랜잭션이 롤백되면 읽어간 트랜잭션도 롤백되어야 하지만 이미 완료되어 불가능한 상태가 된다.**

---

## ⚡ 충돌의 원인과 트랜잭션 스케줄

### 충돌은 언제 발생하는가?

무제어 동시공용의 세 가지 문제는 모두 **데이터 충돌(Conflict)** 에서 비롯됩니다. 충돌이 발생하는 경우를 정리하면 다음과 같습니다.

| 연산 조합 | 충돌 발생 여부 | 설명 |
|---|---|---|
| Read → Read | ❌ 충돌 없음 | 읽기만 하면 서로 영향 없음 |
| Read → Write | ✅ **충돌 발생** | 읽은 값이 다른 트랜잭션에 의해 바뀜 |
| Write → Read | ✅ **충돌 발생** | 미완료 데이터를 읽어가는 문제 |
| Write → Write | ✅ **충돌 발생** | 한 트랜잭션의 쓰기가 다른 쓰기로 덮어써짐 |

> **결론: 어느 한 쪽이라도 Write(쓰기) 연산이 포함되면 충돌이 발생할 수 있다.**

### 트랜잭션 스케줄이란?

**스케줄(Schedule)** 이란 여러 트랜잭션에 포함된 각각의 연산들이 실행되는 순서를 말합니다. 마치 연예인의 스케줄표처럼, 어떤 일을 언제 어떤 순서로 할지 정해놓은 것입니다.

스케줄의 종류는 크게 두 가지입니다.

#### 🔵 직렬 스케줄 (Serial Schedule)

**직렬 스케줄**은 각 트랜잭션이 완전히 끝난 다음에야 다음 트랜잭션이 시작되는 스케줄입니다. 인터리빙(뒤섞임)이 전혀 없습니다.

```
직렬 스케줄 예시:
[T1 시작 → T1의 모든 작업 완료 → T1 종료] → [T2 시작 → T2의 모든 작업 완료 → T2 종료]
```

- **장점**: 충돌이 절대 발생하지 않으므로 결과가 100% 정확합니다.
- **단점**: 앞 트랜잭션이 끝날 때까지 다른 모든 트랜잭션이 기다려야 하므로 **실무에서 사용 불가능**합니다. 네이버 서버가 이 방식이라면 마지막 접속자는 수백만 명이 처리될 때까지 기다려야 합니다.

트랜잭션이 n개라면 직렬 스케줄의 가짓수는 **n! (n 팩토리얼)** 개입니다. 예를 들어 T1, T2, T3가 있다면 3! = 6가지 순서(T1→T2→T3, T1→T3→T2, T2→T1→T3 등)가 존재합니다.

#### 🔴 비직렬 스케줄 (Non-Serial Schedule)

**비직렬 스케줄**은 트랜잭션들이 인터리빙되어 실행되는 스케줄입니다. 한 트랜잭션이 끝나기 전에 다른 트랜잭션이 시작됩니다. 실제 모든 DBMS가 사용하는 방식입니다.

```
비직렬 스케줄 예시:
T1 시작 → T1 일부 작업 → T2 시작 → T2 일부 작업 → T1 나머지 작업 → T2 완료 → T1 완료
```

- **장점**: 여러 트랜잭션이 동시에 진행되므로 효율적입니다.
- **단점**: 충돌이 발생할 수 있어 위에서 설명한 세 가지 문제가 나타날 수 있습니다.

### 직렬 가능 스케줄 (Serializable Schedule)

여기서 핵심 개념이 등장합니다. 바로 **직렬 가능 스케줄(Serializable Schedule)** 입니다. 이름이 비슷해서 헷갈리기 쉬우니 주의하세요.

> **직렬 가능 스케줄 = 비직렬 스케줄이지만 결과가 직렬 스케줄과 동일한 스케줄**

비직렬 스케줄의 효율성을 가지면서도, 직렬 스케줄처럼 100% 정확한 결과를 보장하는 황금같은 스케줄입니다. 실무에서 우리가 원하는 것이 바로 이것입니다.

| 스케줄 종류 | 효율성 | 결과 정확성 | 실무 사용 |
|---|---|---|---|
| 직렬 스케줄 | ❌ 낮음 | ✅ 100% 정확 | ❌ 불가능 |
| 비직렬 스케줄 | ✅ 높음 | ❌ 불정확 가능 | ⚠️ 위험 |
| 직렬 가능 스케줄 | ✅ 높음 | ✅ 100% 정확 | ✅ 이상적 |

---

## 🧪 충돌 직렬 가능성 테스트 (Conflict Serializability Test)

### 어떤 스케줄이 직렬 가능한지 어떻게 알까?

직렬 가능성을 판별하는 알고리즘이 있습니다. **충돌 직렬 가능성 테스트**는 다음 절차로 진행됩니다.

**① 트랜잭션 노드(node, 점) 그리기**

참여하는 트랜잭션 수만큼 노드를 그립니다. T1, T2, T3가 있다면 3개의 노드를 그립니다.

**② 충돌이 생기는 경우에 화살표(간선) 긋기**

같은 데이터 X에 대해 다음 세 가지 경우에 해당 방향으로 화살표를 그립니다.

- T1이 X를 Write한 것을 T2가 Read하면 → T1 → T2 화살표
- T1이 X를 Read한 것을 T2가 Write하면 → T1 → T2 화살표
- T1이 X를 Write한 것을 T2가 Write하면 → T1 → T2 화살표

**③ 사이클(cycle, 순환) 유무 확인**

- **사이클 없음** → 충돌 직렬 가능 → 결과가 100% 정확
- **사이클 있음** → 충돌 직렬 가능하지 않음 → 결과 이상 가능성 있음

### 사이클이 있는 스케줄 예시 (충돌 직렬 가능하지 않음)

아래 표기법에서 `W1(x)`는 "트랜잭션1이 x를 Write한다", `R3(x)`는 "트랜잭션3이 x를 Read한다"를 의미합니다.

```
스케줄: W1(x) → R3(x) → R2(x) → W2(x) → R1(x)
```

이를 그래프로 분석하면:
- W1(x) → R3(x): **T1에서 T3로 화살표**
- R3(x) → W2(x): **T3에서 T2로 화살표** (Read 후 Write)
- W2(x) → R1(x): **T2에서 T1로 화살표**

```
T1 → T3 → T2 → T1 (사이클 발생!)
```

사이클이 생겼으므로 이 스케줄은 **충돌 직렬 가능하지 않습니다.** 결과의 정확성을 보장할 수 없습니다.

### 사이클이 없는 스케줄 예시 (충돌 직렬 가능)

```
스케줄: R3(x) → R1(x) → W2(x) → ...
```

그래프를 그려봤을 때 T3 → T1 → T2로 화살표가 이어지고 다시 T3로 돌아오는 사이클이 없다면:

```
T3 → T1 → T2 (사이클 없음!)
```

이 스케줄은 **충돌 직렬 가능합니다.** 결과가 100% 정확합니다.

:::note 현실적인 한계
이론적으로는 이런 그래프 알고리즘으로 직렬 가능성을 검사할 수 있지만, **현실적으로는 불가능**합니다. 10개의 트랜잭션만 동시에 수행해도 10! = 3,628,800가지 스케줄이 생깁니다. 이를 일일이 검증하고 사용할 스케줄을 고르는 것은 실무에서 불가능합니다. 그래서 **로킹(Locking)** 이나 **타임스탬프(Timestamp)** 같은 실용적인 기법을 사용합니다.
:::

---

## 🔐 해결책: 로킹 기법 (Locking)

### 로킹이란?

**로킹(Locking)** 은 데이터를 사용하기 전에 먼저 잠그고(Lock), 다 사용한 후에 풀어주는(Unlock) 방식으로 충돌을 방지하는 기법입니다.

마치 도서관에서 책을 빌리는 것과 같습니다. 내가 책을 빌려가면 다른 사람은 그 책을 빌릴 수 없고, 내가 반납해야 다른 사람이 빌릴 수 있습니다. 이처럼 **한 트랜잭션이 데이터를 잠그면(Lock), 다른 트랜잭션은 그 데이터에 접근할 수 없고 잠금이 해제될 때까지 기다려야 합니다.**

이를 **상호 배제(Mutual Exclusion)** 또는 **독점 제어** 라고 합니다.

### 이진 로킹 (Binary Locking)

**이진 로킹**은 가장 단순한 형태의 로킹으로, Lock과 Unlock 두 가지 상태만 있습니다.

```sql
-- 이진 로킹의 기본 규약

-- ✅ 올바른 예시
LOCK(X)      -- 1. 데이터 X를 잠근다
READ(X)      -- 2. X를 읽는다
X = X + 100  -- 3. 계산한다
WRITE(X)     -- 4. X를 저장한다
UNLOCK(X)    -- 5. 잠금을 해제한다

-- ❌ 잘못된 예시 1: 잠그지 않고 읽기
READ(X)      -- 잠금 없이 읽으면 충돌 발생 가능!

-- ❌ 잘못된 예시 2: 이미 잠긴 것을 또 잠금
LOCK(X)      -- X를 잠금
LOCK(X)      -- 이미 잠긴 X를 또 잠금 → 불가능!

-- ❌ 잘못된 예시 3: 잠그지 않은 것을 해제
UNLOCK(X)    -- 잠그지도 않은 X를 해제 → 불가능!
```

이진 로킹의 규약은 다음과 같습니다.

- 데이터를 읽거나 쓰기 전에 **반드시 먼저 Lock** 을 걸어야 한다
- 작업이 끝나면 **반드시 Unlock** 으로 풀어줘야 한다
- 이미 잠긴 데이터를 **또 잠글 수 없다**
- 잠그지 않은 데이터를 **Unlock할 수 없다**

**이진 로킹의 문제점**: `Read → Read` 는 충돌이 생기지 않는데도, 이진 로킹으로 잠그면 다른 트랜잭션이 읽기조차 할 수 없습니다. 따라서 **병행성이 매우 제한적**입니다.

### 공용 로크와 베타 로크 (Shared Lock & Exclusive Lock)

이진 로킹의 문제를 해결하기 위해 **두 종류의 로크**를 사용합니다.

#### 📖 공용 로크 (Shared Lock, S-Lock) - 읽기 전용 로크

**공용 로크(S-Lock)** 는 읽기(Read) 작업만 수행할 때 거는 자물쇠입니다. 읽기 읽기는 충돌이 없으므로, **S-Lock으로 잠근 데이터는 다른 트랜잭션도 S-Lock을 걸고 함께 읽을 수 있습니다.**

마치 도서관에서 같은 책을 여러 명이 동시에 읽을 수 있도록 복사본을 두는 것과 같습니다.

#### ✏️ 베타 로크 (Exclusive Lock, X-Lock) - 읽기/쓰기 로크

**베타 로크(X-Lock)** 는 읽기와 쓰기 모두 수행할 때 거는 자물쇠입니다. 쓰기가 포함되므로 충돌 위험이 있어, **X-Lock으로 잠긴 데이터는 다른 어떤 로크도 걸 수 없습니다.**

마치 도서관에서 내가 책에 직접 메모를 쓰고 있다면 다른 사람은 아무도 그 책에 접근하면 안 되는 것과 같습니다.

#### 로크 양립성 표

| | S-Lock 요청 | X-Lock 요청 |
|---|---|---|
| **잠금 없음** | ✅ 허용 | ✅ 허용 |
| **S-Lock 걸린 상태** | ✅ 허용 (함께 읽기 가능) | ❌ 불가 |
| **X-Lock 걸린 상태** | ❌ 불가 | ❌ 불가 |

```sql
-- 공용 로크와 베타 로크 사용 예시

-- ✅ 읽기만 할 때: S-Lock 사용
LOCK_S(X)    -- 공용 로크로 잠금 (다른 트랜잭션도 읽기 가능)
READ(X)      -- X 읽기
UNLOCK(X)    -- 잠금 해제

-- ✅ 읽고 쓸 때: X-Lock 사용
LOCK_X(X)    -- 베타 로크로 잠금 (다른 트랜잭션 접근 완전 차단)
READ(X)      -- X 읽기
X = X + 100  -- 계산
WRITE(X)     -- X 쓰기
UNLOCK(X)    -- 잠금 해제

-- ❌ 쓰기 작업에 S-Lock 사용 (잘못된 예시)
LOCK_S(X)    -- S-Lock은 읽기 전용! 쓰기에는 사용 불가
WRITE(X)     -- 쓰기 작업에 S-Lock은 맞지 않음
```

:::warning 로킹의 치명적 문제: 교착 상태(Deadlock)
로킹 기법의 가장 큰 단점은 **교착 상태(Deadlock)** 에 빠질 수 있다는 것입니다.

예시: 강의실에 홍길동과 홍길순이 각자 방을 잠그고 서로의 방 열쇠를 기다리는 상황.
- 홍길동은 A방을 잠그고, B방을 기다림
- 홍길순은 B방을 잠그고, A방을 기다림
- 둘 다 영원히 기다리는 교착 상태 발생!

단순 로킹과 공용/베타 로크 모두 이 교착 상태에서 자유롭지 않습니다.
:::

---

## 🔒 2단계 로킹 규약 (Two-Phase Locking Protocol, 2PL)

### 왜 2단계 로킹이 필요한가?

단순한 S-Lock/X-Lock만으로는 **직렬 가능성(Serializability)** 을 100% 보장할 수 없습니다. 즉, 결과가 완전히 정확하게 나온다는 보장이 없습니다. 결과가 틀릴 수 있는 시스템은 실무에서 사용할 수 없습니다. 이 문제를 해결하기 위해 **추가적인 규약**이 필요했고, 그것이 바로 **2단계 로킹 규약(2PL)** 입니다.

### 2단계 로킹의 핵심 규칙

**2단계 로킹의 핵심**: Lock과 Unlock 연산을 두 단계로 엄격히 구분합니다.

1. **확장 단계(Growing Phase)**: Lock만 수행할 수 있고, **Unlock은 절대 불가**
2. **축소 단계(Shrinking Phase)**: Unlock만 수행할 수 있고, **Lock은 절대 불가**

> **한번 Unlock을 시작하면(축소 단계 진입), 다시는 Lock을 할 수 없다.**

이것이 일반 로킹과의 결정적 차이입니다. 일반 로킹은 Lock → Unlock → Lock → Unlock ... 이렇게 반복이 가능하지만, 2단계 로킹은 한번 Unlock이 시작되면 Lock은 영원히 끝납니다.

```
일반 로킹 (직렬성 보장 안 됨):
Lock → Lock → Unlock → Lock → Unlock → Unlock  ← Lock이 Unlock 뒤에 나옴 (❌)

2단계 로킹 (직렬성 보장):
Lock → Lock → Lock → Unlock → Unlock → Unlock  ← Unlock 뒤에 Lock 없음 (✅)
[-----확장 단계------] [--------축소 단계--------]
```

```sql
-- ❌ 2단계 로킹이 아닌 경우 (직렬성 보장 안 됨)
LOCK(X)    -- Lock
UNLOCK(X)  -- Unlock
LOCK(Y)    -- 다시 Lock! → Unlock 후 Lock이 나왔으므로 2PL 위반

-- ✅ 2단계 로킹을 만족하는 경우 (직렬성 보장)
LOCK(X)    -- Lock (확장 단계)
LOCK(Y)    -- Lock (확장 단계)
UNLOCK(X)  -- Unlock (축소 단계 시작)
UNLOCK(Y)  -- Unlock (축소 단계)
-- Unlock 이후 Lock이 전혀 없음 → 2PL 만족!
```

**2단계 로킹의 장점**: **트랜잭션 직렬 가능성(Serializability) 100% 보장** → 결과가 항상 정확합니다.

**2단계 로킹의 단점**: 교착 상태(Deadlock)는 여전히 발생할 수 있습니다.

### 로크의 전환: 로크 상승과 로크 하강

2단계 로킹에서 로크의 종류가 변경될 수 있습니다.

- **로크 상승(Lock Upgrading)**: S-Lock(읽기)에서 X-Lock(읽기/쓰기)으로 변경. 읽다가 쓰기 작업이 필요해질 때 사용합니다.
- **로크 하강(Lock Downgrading)**: X-Lock(읽기/쓰기)에서 S-Lock(읽기)으로 변경. 쓰기를 마치고 읽기만 남았을 때 병행성을 높이기 위해 사용합니다.

---

## 🛡️ 2단계 로킹의 변형들

### 기본 2단계 로킹 (Basic 2PL)

확장 단계와 축소 단계를 구분하는 가장 기본적인 형태입니다. 직렬성은 보장되지만 교착 상태가 발생할 수 있습니다.

### 보수적(정적) 2단계 로킹 (Conservative/Static 2PL)

**보수적 2단계 로킹**은 트랜잭션이 시작하기 전에 필요한 **모든 데이터에 대한 Lock을 미리 한꺼번에** 획득하는 방식입니다.

마치 요리를 시작하기 전에 필요한 재료를 모두 냉장고에서 꺼내놓고 시작하는 것처럼요. 요리 중간에 냉장고를 다시 열 필요가 없으니 다른 사람과 냉장고 앞에서 부딪힐 일이 없습니다.

- **장점**: 유일하게 **교착 상태가 발생하지 않습니다!** 모든 자원을 미리 잠가두니 기다릴 일이 없습니다.
- **단점**: 사전에 어떤 데이터가 필요한지 정확히 선언해야 하므로 **현실적으로 구현이 어렵습니다.**

### 엄격한 2단계 로킹 (Strict 2PL) ⭐ 가장 널리 사용

**엄격한 2단계 로킹**은 **트랜잭션이 완료(Commit)되거나 취소(Rollback)되기 전까지 X-Lock(베타 로크)을 절대 해제하지 않는** 방식입니다.

왜 이 방식이 필요할까요? **연쇄 복귀(Cascading Rollback) 문제를 방지**하기 위해서입니다. 작업 도중 Unlock을 해버리면 다른 트랜잭션이 아직 미완료된 데이터를 읽어갈 수 있습니다. 커밋된 후에만 Unlock을 하면, 다른 트랜잭션은 항상 **확정된(커밋된) 안전한 데이터**만 읽어갈 수 있어 연쇄 복귀 문제가 사라집니다.

### 엄중한 2단계 로킹 (Rigorous 2PL)

**엄중한 2단계 로킹**은 엄격한 2PL보다 더 강력한 버전으로, X-Lock뿐만 아니라 **S-Lock(공용 로크)도 트랜잭션이 완료될 때까지 해제하지 않습니다.**

### 2단계 로킹 변형 비교

| 종류 | 교착 상태 | 직렬성 | 연쇄 복귀 방지 | 특징 |
|---|---|---|---|---|
| 기본 2PL | 발생 가능 | ✅ 보장 | ❌ | 기본형 |
| 보수적 2PL | **발생 안 함** | ✅ 보장 | ✅ | 미리 모든 Lock 획득 |
| 엄격한 2PL | 발생 가능 | ✅ 보장 | ✅ | X-Lock을 커밋까지 유지 |
| 엄중한 2PL | 발생 가능 | ✅ 보장 | ✅ | 모든 Lock을 커밋까지 유지 |

:::tip 교착 상태는 필요악
2단계 로킹에서 교착 상태는 어쩔 수 없이 발생할 수 있지만, 이는 **복구가 가능**합니다. 반면 직렬성이 보장되지 않아 결과값이 틀리는 것은 그 시스템 자체를 사용할 수 없게 만듭니다. 따라서 교착 상태는 "필요악"으로 받아들이고, 직렬성 보장을 우선시합니다.
:::

---

## 📐 로킹의 단위 (Granularity of Locking)

### 얼마나 크게, 얼마나 작게 잠글 것인가?

로킹할 때 **얼마나 큰 단위로 잠글 것인지**가 중요한 설계 결정입니다. 마치 건물을 잠글 때 건물 전체를 잠글 수도 있고, 층별로 잠글 수도 있고, 강의실별로 잠글 수도 있는 것처럼요.

데이터베이스에서 로킹 단위는 다음과 같이 구분됩니다.

```
데이터베이스 전체
    └── 테이블(파일)
            └── 레코드(행)
                    └── 속성(컬럼)
```

### 로킹 단위가 크면?

건물 전체를 하나로 잠그는 것과 같습니다.

- ✅ 자물쇠(Lock) 수가 적어 **로킹 오버헤드(관리 비용) 감소**
- ✅ 병행 제어 기법이 **단순**해짐
- ❌ 동시에 한 명만 사용 가능하므로 **공유도와 동시성 감소**

### 로킹 단위가 작으면?

강의실 하나하나씩 잠그는 것과 같습니다.

- ✅ 여러 사람이 동시에 다른 데이터를 사용할 수 있어 **동시성(병행성) 증가**
- ✅ **공유도 증가**
- ❌ 자물쇠 수가 많아 **로킹 오버헤드 증가**
- ❌ 병행 제어 기법이 **복잡**해짐

| 구분 | 로킹 단위 큼 | 로킹 단위 작음 |
|---|---|---|
| **로킹 오버헤드** | 적음 (관리 쉬움) | 많음 (관리 복잡) |
| **병행 제어** | 단순 | 복잡 |
| **동시성/공유도** | 낮음 | 높음 |
| **예시** | DB 전체 잠금 | 레코드 단위 잠금 |

> **실무에서는 로킹 단위를 작게 설정해 동시성을 높이는 것이 일반적입니다.** 대신 그만큼 복잡도 관리가 필요합니다.

---

## ⚠️ 주의사항과 실수하기 쉬운 포인트

:::warning 갱신 분실은 소리 없이 찾아온다
갱신 분실(Lost Update)의 가장 무서운 점은 **에러 메시지나 경고 없이** 조용히 발생한다는 것입니다. 시스템 입장에서는 "데이터를 저장했다"고 인식하지만, 실제로는 다른 트랜잭션의 값이 내 값을 덮어쓴 것입니다. 이를 "탐지 불가능(Dirty Write)"이라고도 부릅니다.
:::

:::warning 직렬 스케줄과 직렬 가능 스케줄을 혼동하지 말 것
- **직렬 스케줄(Serial Schedule)**: 트랜잭션이 순서대로 하나씩 실행 (인터리빙 없음)
- **직렬 가능 스케줄(Serializable Schedule)**: 비직렬(인터리빙 있음)이지만 결과가 직렬과 동일

이 둘은 완전히 다릅니다! 시험에서도 자주 혼동하는 개념이니 주의하세요.
:::

:::danger 무제어 상태에서 Write 연산은 절대 방치 금지
Read-Read 조합은 충돌이 없지만, Write가 포함된 모든 조합(Read-Write, Write-Read, Write-Write)은 충돌이 발생합니다. **아무런 제어 없이 Write 연산이 동시에 실행되도록 두면 반드시 데이터 손상이 발생합니다.**
:::

:::tip 2단계 로킹을 확인하는 쉬운 방법
트랜잭션의 Lock/Unlock 목록을 순서대로 나열했을 때, **Unlock이 나온 이후에 Lock이 다시 나오면 2PL 위반**입니다. Lock들이 먼저 모이고 그 다음 Unlock들이 나와야 합니다.
```
✅ 2PL: Lock, Lock, Lock, Unlock, Unlock, Unlock
❌ 비2PL: Lock, Unlock, Lock, Unlock
```
:::

---

## 📋 핵심 정리

- **병행 제어(Concurrency Control)** 는 여러 트랜잭션이 동시에 하나의 DB를 사용할 때 데이터 정확성을 유지하기 위한 기술이다
- **무제어 동시공용**은 병행 제어 없이 동시에 데이터를 공유할 때 발생하는 문제들의 총칭이다
- **갱신 분실(Lost Update)** 은 한 트랜잭션의 Write가 완료되기 전에 다른 트랜잭션이 덮어써서 수정 결과가 사라지는 문제다
- **모순성/불일치(Inconsistency)** 는 두 트랜잭션이 인터리빙되어 원래 의도와 다른 이상한 결과가 나오는 문제다
- **연쇄 복귀(Cascading Rollback)** 는 미완료 데이터를 읽어간 트랜잭션이 원본 트랜잭션 롤백 후에도 함께 롤백되지 못하는 문제다
- **충돌은 Write 연산이 포함될 때** 발생하며, Read-Read 조합만 충돌이 없다
- **직렬 스케줄**은 인터리빙이 없어 결과가 100% 정확하지만 실무에서 사용 불가능하다
- **직렬 가능 스케줄**은 비직렬이면서도 직렬과 동일한 결과를 보장하는 이상적인 스케줄이다
- **충돌 직렬 가능성 테스트**에서 사이클이 없으면 직렬 가능, 사이클이 있으면 직렬 가능하지 않다
- **로킹(Locking)** 은 데이터를 사용 전에 잠그고 사용 후 해제하는 실용적인 병행 제어 기법이다
- **S-Lock(공용 로크)** 은 읽기 전용이며 여러 트랜잭션이 동시에 걸 수 있다
- **X-Lock(베타 로크)** 은 읽기/쓰기 모두 가능하며 다른 어떤 로크와도 양립하지 않는다
- **2단계 로킹(2PL)** 은 확장 단계(Lock만)와 축소 단계(Unlock만)를 분리해 직렬성을 100% 보장한다
- **보수적 2PL**만 교착 상태를 예방할 수 있으며, **엄격한 2PL**은 연쇄 복귀를 방지한다
- **교착 상태(Deadlock)** 는 2PL에서도 발생할 수 있으나 이는 복구 가능한 "필요악"으로 여긴다
- **로킹 단위가 크면** 관리가 쉽지만 동시성이 낮고, **로킹 단위가 작으면** 동시성은 높지만 관리가 복잡하다

---

작성일: 2026-02-21