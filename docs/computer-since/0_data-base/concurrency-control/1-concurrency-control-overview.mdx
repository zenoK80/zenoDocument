---
title: "병행 제어의 개념과 목적"
description: "병행 제어의 개념과 목적에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/concurrency-control/1-concurrency-control-overview"
sidebar_label: "병행 제어 개요"
date: "2026-02-21"
---

# 🔐 병행 제어(Concurrency Control)의 개념과 목적

데이터베이스를 혼자 쓰는 사람은 아무도 없습니다. 지금 이 순간에도 수만 명의 사람들이 동시에 네이버, 카카오, 은행 앱에 접속하고 있습니다. 이 수많은 사람들이 동시에 같은 데이터에 접근할 때, 아무런 제어 없이 내버려 두면 어떤 일이 벌어질까요? 데이터가 뒤엉키고, 잘못된 값이 저장되고, 심하면 금융 사고로까지 이어질 수 있습니다. 이 문제를 해결하기 위해 등장한 개념이 바로 **병행 제어(Concurrency Control)** 입니다.

이 문서에서는 병행 제어가 무엇인지, 왜 필요한지, 어떤 문제들이 발생하는지, 그리고 실제로 어떻게 해결하는지를 초보자도 이해할 수 있도록 아주 자세하게 설명합니다.

---

## 🧩 병행 제어란 무엇인가?

### 병행(竝行)과 제어(制御)의 의미

**병행(竝行)** 이라는 단어는 "동시에 나란히 수행된다"는 뜻입니다. 마치 고속도로에서 여러 차선의 자동차들이 나란히 달리는 것처럼, 여러 작업이 동시에 실행되는 상황을 가리킵니다. **제어(制御)** 는 그 병행으로 실행되는 것들을 중간에서 적절히 관리하고 조율한다는 뜻입니다.

따라서 **병행 제어(Concurrency Control)** 란, 여러 개의 트랜잭션(작업 묶음)이 동시에 하나의 데이터베이스에 접근할 때 발생하는 문제들을 방지하고, 데이터의 정확성과 무결성을 유지하도록 관리하는 기술 전반을 말합니다.

### 트랜잭션(Transaction)이란?

:::info 트랜잭션이란?
**트랜잭션(Transaction)** 은 데이터베이스에서 수행되는 **하나의 논리적 작업 단위(작업 묶음)** 입니다. 예를 들어 은행에서 "A 계좌에서 돈을 빼고 B 계좌에 입금한다"는 일련의 과정이 하나의 트랜잭션입니다. 이 과정 중 하나라도 실패하면 전체가 취소(롤백)되어야 합니다.
:::

예를 들어 하나의 데이터베이스에 여러 사용자가 동시에 작업을 요청한다고 생각해 보겠습니다.

- **T1(홍길동)**: 상품 재고 데이터를 읽어서 수량을 변경
- **T2(홍길순)**: 같은 상품 재고 데이터를 읽어서 수량을 변경
- **T3(홍길박)**: 같은 데이터를 읽기만 함

이 세 개의 트랜잭션이 동시에 실행될 때, 먼저 시작했다고 반드시 먼저 끝나는 것이 아닙니다. 마치 마라톤에서 먼저 출발했다고 반드시 먼저 결승선을 통과하지 않는 것처럼, 트랜잭션의 **시작과 종료가 서로 중복**될 수 있습니다. 이렇게 겹쳐서 실행되는 것을 **병행 수행(Concurrent Execution)** 이라고 합니다.

### 왜 병행성을 지원해야 하는가?

단순히 생각하면 "한 명씩 차례대로 처리하면 되지 않나요?"라고 물을 수 있습니다. 하지만 현실에서는 그것이 불가능합니다. 네이버 서버에 동시에 수백만 명이 접속한다고 상상해 보세요. 한 명씩 순서대로 처리한다면 맨 뒤에 있는 사람은 수백만 번의 처리가 끝날 때까지 기다려야 합니다. 이는 현실적으로 사용 불가능한 시스템입니다.

> 여러 명이 동시에 데이터베이스를 사용하는 **복수 사용자 DBMS(Multi-user DBMS)** 는 반드시 병행성(Concurrency)을 지원해야 합니다. 그리고 그 병행 수행 과정에서 발생하는 문제들을 제거하는 것이 바로 병행 제어입니다.

---

## 🎯 병행 제어의 목적

병행 제어가 궁극적으로 추구하는 목표는 다음 세 가지입니다.

### 1. 공유도(Sharing) 최대화

**공유도** 란 얼마나 많은 사용자가 동시에 데이터베이스를 사용할 수 있는가를 나타내는 지표입니다. 병행 제어는 동시에 최대한 많은 사람들이 데이터베이스에 접근할 수 있도록 해야 합니다. 마치 도서관에서 한 권의 책을 여러 사람이 복사본으로 동시에 읽을 수 있게 하는 것처럼, 읽기 작업은 충돌이 없으므로 최대한 동시에 허용해야 합니다.

### 2. 응답 시간(Response Time) 최소화

여러분이 네이버를 이용할 때 "지금 다른 사람들 때문에 내 요청이 처리되지 않고 있어"라고 느낀 적이 있나요? 아마 없을 것입니다. 실제로는 수백만 명이 동시에 같은 서버를 사용하고 있지만, 사용자 입장에서는 마치 **내가 혼자 서버를 독점해서 쓰는 것처럼** 빠르게 응답을 받습니다. 이것이 바로 병행 제어가 응답 시간을 최소화하는 덕분입니다.

### 3. 시스템 활용도(System Utilization) 최대화

CPU, 메모리, 디스크 같은 컴퓨터 자원을 최대한 효율적으로 사용해야 합니다. 한 트랜잭션이 디스크에서 데이터를 읽어오는 동안(I/O 대기) CPU는 놀고 있을 수 있습니다. 이 틈을 이용해 다른 트랜잭션이 CPU 연산을 수행하면 전체 시스템 효율이 올라갑니다. 병행 제어는 이러한 자원 활용을 극대화합니다.

### 4. 데이터 무결성(Integrity) 보장

앞의 세 가지 목표를 달성하면서도, **모든 트랜잭션이 직렬 가능한 스케줄(Serializable Schedule)** 에 따라 실행되어 데이터의 정확성과 무결성이 유지되어야 합니다. 아무리 빠르고 많은 사람이 동시에 사용하더라도 데이터가 틀리면 그 시스템은 쓸 수 없습니다.

| 목표 | 설명 | 비유 |
|------|------|------|
| **공유도 최대화** | 최대한 많은 사용자가 동시 접근 | 도서관의 복사본 열람 |
| **응답 시간 최소화** | 각 사용자가 빠른 응답 받음 | 혼자 쓰는 것처럼 느껴짐 |
| **시스템 활용도 최대화** | CPU/메모리 자원을 최대한 활용 | 쉬는 시간 없이 일하는 공장 |
| **데이터 무결성 보장** | 결과가 항상 정확해야 함 | 계산기 결과는 항상 맞아야 함 |

---

## ⚠️ 무제어 동시 공용의 문제점

병행 제어를 하지 않고 여러 트랜잭션이 동시에 데이터를 사용하면 어떤 일이 벌어질까요? 이것을 **무제어 동시 공용(Uncontrolled Concurrent Access)** 의 문제점이라고 합니다. 크게 세 가지 문제가 발생합니다.

### 🔴 문제 1: 갱신 분실(Lost Update) — 탐지 불가능 문제

**갱신 분실** 이란 두 개의 트랜잭션이 같은 데이터를 동시에 수정할 때, 한 트랜잭션의 수정 내용이 다른 트랜잭션의 수정 내용에 의해 덮어씌워져 **사라져 버리는 문제** 입니다. 마치 두 사람이 같은 화이트보드에 동시에 글을 쓰다가, 한 사람이 이미 쓴 내용 위에 다른 사람이 덮어쓰는 것과 같습니다.

**구체적인 예시를 살펴봅시다:**

- 초기 X 값 = **10**
- **T1(홍길동)**: X를 읽어서 100을 더한 후 저장 → X = 110이 되어야 함
- **T2(홍길순)**: X를 읽어서 2배로 만든 후 저장 → X = 20이 되어야 함

```
시간 순서:
① T1: X를 읽어옴 (X = 10)
② T1: X + 100 = 110 계산 (아직 저장 안 함!)
③ T2: X를 읽어옴 (X = 10, 왜냐면 T1이 아직 저장 안 했으니까)
④ T2: X × 2 = 20 계산 후 저장 (X = 20)
⑤ T1: 110을 저장 → X = 110
⑥ T2: 다시 20을 저장 → X = 20 (T1의 110이 덮어써짐!)
```

결국 T1이 수행한 "+100" 갱신은 완전히 사라져 버립니다. T2의 결과만 남고 T1의 갱신은 무효가 됩니다. 이것이 **갱신 분실(Lost Update)** 문제이며, 왜 발생했냐면 T1이 Write(저장)를 하기 전에 T2가 같은 데이터를 Read(읽기)해버렸기 때문입니다.

:::warning 갱신 분실이 일어나는 핵심 원인
T1이 **Write(저장)하기 전에** T2가 같은 데이터를 **Read(읽기)** 해버리는 것이 문제입니다. 즉, 아직 반영되지 않은 중간 상태의 데이터를 다른 트랜잭션이 가져가서 사용하게 됩니다.
:::

### 🟠 문제 2: 모순성(Inconsistency) — 불일치 분석 문제

**모순성(불일치 분석 문제)** 이란 두 개의 트랜잭션이 서로 다른 시점의 데이터를 읽어서 작업하기 때문에 **일관성이 깨진 결과** 가 나오는 문제입니다. 마치 한 팀원은 오전에 측정한 재고를 기준으로 보고서를 쓰고, 다른 팀원은 오후에 측정한 재고를 기준으로 보고서를 쓰면 두 보고서가 서로 맞지 않는 것과 같습니다.

**예시:**

- X = 10, Y = 10 (초기값)
- **T1**: X와 Y에 각각 100을 더함 → X = 110, Y = 110이 되어야 함
- **T2**: X와 Y를 각각 2배로 만듦 → X = 20, Y = 20이 되어야 함

그런데 실행 순서가 **인터리빙(Interleaving, 뒤섞임)** 되면:

```
① T1: X를 읽어서 +100 → X = 110 저장
② T2: X를 읽음 (X = 110) → 2배 → X = 220 저장
③ T1: Y를 읽어서 +100 → Y = 110 저장  ← 이미 T2가 X를 2배로 만들었는데 Y는 T1 작업 기준
④ T2: Y를 읽음 (Y = 110) → 2배 → Y = 220 저장
```

X와 Y는 T1의 작업과 T2의 작업이 혼재된 상태로 처리됩니다. T1 입장에서 보면 "X에는 100을 더하기 전에 2배가 먼저 적용됐고, Y에는 100을 더한 후 2배가 적용됐다"는 **모순**이 생겨버립니다. 원래 의도한 결과와 전혀 다른 결과가 나오게 됩니다. 이것이 **불일치 분석 문제(Inconsistency / Dirty Analysis)** 입니다.

### 🔵 문제 3: 연쇄 복귀(Cascading Rollback) — 비완료 의존성 문제

**연쇄 복귀** 란 한 트랜잭션이 실패해서 취소(롤백, Rollback)해야 할 때, 그 트랜잭션의 중간 데이터를 이미 읽어간 다른 트랜잭션도 함께 취소되어야 하는데, 그것이 불가능한 상황을 말합니다.

**예시:**

- 초기 X = 100
- **T1(홍길동)**: X에 100을 더해서 X = 200으로 저장
- **T2(홍길순)**: T1이 저장한 X = 200을 읽어서 2배 → X = 400 저장 후 **시스템 종료(떠남)**
- **T1**: 어떤 이유로 작업 취소(롤백) → X를 원래 값 100으로 되돌려야 함

그런데 T2는 이미 T1이 저장한 200(잘못된 값)을 기반으로 400을 저장하고 시스템을 떠났습니다. T1이 롤백되어 X = 100으로 되돌아가도, T2가 저장한 400은 그대로 남아있거나 T2 자체를 취소할 수 없습니다. T2는 이미 **커밋(Commit, 완료)** 하고 떠났기 때문입니다.

> 이처럼 잘못된 데이터를 읽어서 이미 처리하고 시스템을 떠난 트랜잭션은 복구할 수 없습니다. 이것을 **연쇄 복귀(Cascading Rollback)** 또는 **비완료 의존성(Dirty Read)** 문제라고 합니다.

:::danger 비완료 의존성(Dirty Read)
아직 커밋(완료)되지 않은 트랜잭션의 데이터를 다른 트랜잭션이 읽는 것을 **Dirty Read(더티 리드)** 라고 합니다. 이 데이터는 나중에 롤백될 수 있기 때문에 절대로 신뢰할 수 없는 데이터입니다. 이것이 연쇄 복귀 문제의 근본 원인입니다.
:::

### 충돌이 발생하는 조건 정리

세 가지 문제는 모두 트랜잭션 간의 **충돌(Conflict)** 에서 비롯됩니다. 충돌은 어떤 경우에 발생할까요?

| 연산 조합 | T1 연산 | T2 연산 | 충돌 여부 |
|-----------|---------|---------|-----------|
| Read-Read | 읽기 | 읽기 | ✅ 충돌 없음 |
| Read-Write | 읽기 | **쓰기** | ❌ 충돌 발생 |
| Write-Read | **쓰기** | 읽기 | ❌ 충돌 발생 |
| Write-Write | **쓰기** | **쓰기** | ❌ 충돌 발생 |

**핵심 원칙:** 두 연산 중 **하나라도 Write(쓰기)가 포함**되면 충돌이 발생합니다. Read-Read만 충돌이 없습니다. 이 원칙을 반드시 기억하세요.

---

## 📅 트랜잭션 스케줄의 종류

충돌 문제를 해결하기 위해서는 트랜잭션들의 실행 순서를 잘 조정해야 합니다. 이 **실행 순서를 스케줄(Schedule)** 이라고 합니다. 마치 연예인에게 오늘 어디서 무엇을 할지 정해주는 스케줄표처럼, 트랜잭션들이 언제 어떤 연산을 수행할지를 결정하는 것입니다.

### 직렬 스케줄(Serial Schedule)

**직렬 스케줄** 이란 트랜잭션들이 순서대로 하나씩 실행되는 방식입니다. T1이 완전히 끝난 다음에 T2가 시작하고, T2가 완전히 끝난 다음에 T3가 시작하는 방식입니다. 마치 은행 창구에서 한 사람씩 차례대로 업무를 보는 것과 같습니다.

```
직렬 스케줄 예시 (T1 → T2 순서):

T1: [읽기X] → [계산] → [저장X] → [읽기Y] → [계산] → [저장Y] → 완료
                                                                      ↓
T2:                                                              [읽기X] → [계산] → [저장X] → 완료
```

T1이 완전히 끝난 후에 T2가 시작하므로 절대로 인터리빙이 일어나지 않습니다. 따라서 **충돌이 발생하지 않아 결과가 100% 정확**합니다.

만약 트랜잭션이 n개라면 직렬 스케줄의 경우의 수는 n! (n 팩토리얼)개입니다. 3개면 3! = 6가지, 4개면 4! = 24가지가 됩니다.

**단점:** 네이버 서버가 직렬 스케줄로만 동작한다면 맨 마지막 사용자는 앞의 수백만 명이 모두 처리될 때까지 기다려야 합니다. 실무에서는 사용할 수 없습니다.

### 비직렬 스케줄(Non-Serial Schedule)

**비직렬 스케줄** 이란 트랜잭션들이 서로 겹쳐서 실행되는 방식입니다. T1이 아직 끝나지 않았는데 T2가 시작하고, 이 둘이 뒤섞여(인터리빙되어) 실행됩니다. 현실의 데이터베이스 시스템이 사용하는 방식입니다.

```
비직렬 스케줄 예시:

T1: [읽기X] ──────────────────── [저장X] → [읽기Y] → [저장Y] → 완료
                ↓          ↑
T2:         [읽기X] → [저장X] ──────────────────────────── → 완료
```

T1이 끝나기 전에 T2가 시작하고 서로 뒤섞여 실행됩니다. 효율은 높지만 앞서 설명한 갱신 분실, 모순성, 연쇄 복귀 같은 문제가 발생할 수 있습니다.

### ⭐ 직렬 가능 스케줄(Serializable Schedule)

**직렬 가능 스케줄** 은 가장 중요한 개념입니다. 이름이 헷갈릴 수 있는데, 직렬 스케줄이 아닙니다. **비직렬 스케줄이지만, 그 실행 결과가 어떤 직렬 스케줄의 결과와 동일한 스케줄** 을 말합니다.

> 비직렬(인터리빙)로 실행하지만, 결과는 직렬로 실행한 것과 똑같다면? 효율성(비직렬)과 정확성(직렬과 동일한 결과)을 모두 얻을 수 있습니다. 이것이 바로 우리가 원하는 **직렬 가능 스케줄** 입니다.

| 스케줄 종류 | 병행 실행 | 결과 정확도 | 실무 사용 |
|-------------|-----------|------------|-----------|
| **직렬 스케줄** | ❌ (순서대로) | 100% 정확 | ❌ (비효율) |
| **비직렬 스케줄** | ✅ (뒤섞임) | 부정확할 수 있음 | 조건부 |
| **직렬 가능 스케줄** | ✅ (뒤섞임) | 100% 정확 | ✅ (최적) |

### 직렬 가능성 테스트 알고리즘 (충돌 직렬 가능성)

어떤 스케줄이 직렬 가능한지 어떻게 확인할 수 있을까요? 바로 **우선순위 그래프(Precedence Graph)** 를 이용하는 방법이 있습니다.

**방법:**
1. 참여하는 각 트랜잭션을 **노드(점)** 로 그린다
2. 같은 데이터 항목에 대해 충돌이 발생하는 경우(Write-Read, Read-Write, Write-Write), 먼저 수행한 트랜잭션에서 나중에 수행한 트랜잭션 방향으로 **화살표(간선)** 를 그린다
3. 그래프에 **사이클(순환 고리)** 이 발생하면 → **직렬 가능하지 않음** (결과가 부정확할 수 있음)
4. 그래프에 사이클이 없으면 → **직렬 가능** (결과가 정확함)

**예시 1: 사이클이 있는 경우 (직렬 가능하지 않음)**

```
스케줄: W1(x) → R3(x) → R2(x) → W2(x) → R1(x)

그래프:
T1 ──→ T3 ──→ T2 ──→ T1  ← 사이클 발생!

결론: 이 스케줄은 직렬 가능하지 않습니다.
      결과가 부정확하게 나올 수 있으므로 사용 불가.
```

**예시 2: 사이클이 없는 경우 (직렬 가능)**

```
스케줄: R3(x) → R1(x) → W2(x) → ...

그래프:
T3 ──→ T1 ──→ T2   ← 사이클 없음!

결론: 이 스케줄은 직렬 가능합니다.
      결과가 직렬 스케줄과 동일하게 정확합니다.
```

:::note 직렬 가능성 검사의 현실적 한계
이론적으로는 우선순위 그래프로 직렬 가능성을 검사할 수 있지만, 현실에서는 불가능합니다. 트랜잭션 10개만 동시에 실행되어도 10! = 3,628,800가지 스케줄을 모두 검사해야 합니다. 이것은 **NP-완전(NP-complete)** 문제로, 현실적으로 풀 수 없습니다. 그래서 실무에서는 **로킹(Locking)** 이나 **타임스탬프(Timestamp)** 같은 실용적인 기법을 사용합니다.
:::

### 결과 동등, 충돌 동등, 뷰 동등

직렬 가능성을 판단하는 세 가지 동등 개념이 있습니다.

**① 결과 동등(Result Equivalent):** 두 스케줄의 실행 순서가 달라도 **최종 결과가 동일**한 경우를 말합니다. 동일한 초기 상태에서 시작해서 동일한 결과로 끝납니다.

**② 충돌 동등(Conflict Equivalent):** **충돌 교환 원리** 를 사용합니다. 충돌이 발생하지 않는 연산들 사이의 순서를 교환해서 비직렬 스케줄을 직렬 스케줄과 동일하게 만들 수 있을 때, 두 스케줄은 충돌 동등하다고 합니다.

예를 들어 T1의 Read(x)와 T2의 Read(x)는 충돌이 없으므로 순서를 바꿔도 됩니다. 이 교환을 반복해서 비직렬 스케줄을 직렬 스케줄로 변환할 수 있다면, 그 스케줄은 **충돌 직렬 가능(Conflict Serializable)** 합니다.

**③ 뷰 동등(View Equivalent):** T3가 어떤 데이터를 읽고(Read) 저장하면, T4와 T5는 별도로 읽지 않고 T3가 읽어온 값을 그대로 가져다 기록합니다. T4와 T5가 똑같은 "뷰(View, 관점)"를 갖고 있어서 항상 같은 값을 읽고 기록할 때 **뷰 동등**하다고 합니다. 뷰 동등은 항상 같은 결과를 보장합니다.

---

## 🔒 로킹(Locking) 기법

직렬 가능성 테스트가 현실적으로 불가능하기 때문에, 실제 데이터베이스에서는 **로킹(Locking)** 기법을 사용합니다. 로킹은 마치 강의실을 혼자 사용할 때 문을 잠그는 것과 같습니다. 먼저 점유한 사람이 자물쇠를 잠그고 사용하면, 다른 사람은 자물쇠가 풀릴 때까지 기다려야 합니다.

이것을 **상호 배제(Mutual Exclusion)** 또는 **독점 제어** 라고 합니다.

### 이진 로크(Binary Lock)

**이진 로크** 는 가장 단순한 형태의 로크입니다. 잠그거나(Lock) 풀거나(Unlock) 두 가지 상태만 존재합니다.

**이진 로크의 규약:**

```
1. 데이터를 읽거나 쓰려면 반드시 먼저 Lock(잠금)을 해야 한다.
2. 사용이 끝나면 종료 전에 반드시 Unlock(해제)해야 한다.
3. 이미 잠긴 데이터는 다시 잠굴 수 없다.
4. 잠그지 않은 데이터는 Unlock할 수 없다.
```

```sql
-- 이진 로크 사용 예시 (개념적 표현)

-- ✅ 올바른 순서
LOCK(X);        -- X를 잠금
READ(X);        -- X 읽기
X = X + 100;   -- 계산
WRITE(X);       -- X 저장
UNLOCK(X);      -- X 해제

-- ❌ 잘못된 순서 (잠그지도 않고 읽기 시도)
READ(X);        -- 오류! Lock 없이 읽기 불가
```

**이진 로크의 문제점:** Read-Read(읽기-읽기)는 충돌이 없으므로 동시에 허용해야 하는데, 이진 로크로 잠가버리면 읽기-읽기도 차단됩니다. 이는 **병행성을 지나치게 제한**합니다.

### 공용 로크와 전용 로크 (S-Lock & X-Lock)

이진 로크의 문제를 해결하기 위해 **두 종류의 로크** 가 등장합니다.

**① 공용 로크(Shared Lock, S-Lock) — 읽기 전용 로크:**

읽기 작업만 수행할 때 사용하는 로크입니다. S-Lock으로 잠긴 데이터는 다른 트랜잭션도 S-Lock을 걸어서 동시에 읽을 수 있습니다. 읽기-읽기는 충돌이 없으니까요. 마치 도서관의 책을 여러 명이 동시에 복사본으로 읽는 것과 같습니다.

**② 전용 로크(Exclusive Lock, X-Lock) — 읽기+쓰기 로크:**

읽기와 쓰기 모두 수행할 때 사용하는 로크입니다. X-Lock으로 잠긴 데이터는 다른 트랜잭션이 **어떤 로크도 걸 수 없습니다.** 혼자 독점해서 사용합니다. 마치 강의실을 혼자 쓰기 위해 잠근 것과 같습니다.

**로크 양립성(Lock Compatibility):**

| | S-Lock 요청 | X-Lock 요청 |
|--|-------------|-------------|
| **잠금 없음** | ✅ 허용 | ✅ 허용 |
| **S-Lock 걸림** | ✅ 허용 (동시 읽기 가능) | ❌ 불가 |
| **X-Lock 걸림** | ❌ 불가 | ❌ 불가 |

> **핵심:** S-Lock끼리는 양립(동시 사용 가능)하지만, X-Lock이 걸린 데이터는 어떤 로크도 추가로 걸 수 없습니다.

**공용 로크/전용 로크 규약:**

```
읽기 작업 → S-Lock 또는 X-Lock 사용 가능
쓰기 작업 → X-Lock만 사용 가능
작업 완료 → 반드시 Unlock
S-Lock이 걸린 것 → S-Lock 추가 가능, X-Lock 불가
X-Lock이 걸린 것 → 어떤 Lock도 불가
```

:::warning 로킹 기법의 한계
공용 로크와 전용 로크만으로는 **직렬 가능성(결과의 100% 정확성)을 보장할 수 없습니다.** 로킹 도중 Lock/Unlock을 반복하다 보면 결과가 부정확해질 수 있습니다. 또한 모든 로킹 기법은 **교착 상태(Deadlock)** 에 빠질 수 있습니다.
:::

### 교착 상태(Deadlock)란?

**교착 상태** 는 두 개 이상의 트랜잭션이 서로 상대방이 보유한 자원의 해제를 기다리다가 아무도 진행하지 못하는 상태입니다. 마치 강의실을 서로 잠가놓고 "네가 먼저 열어줘"라고 기다리는 상황과 같습니다.

```
교착 상태 예시:

T1: X를 Lock → Y를 Lock하려고 대기 중...
T2: Y를 Lock → X를 Lock하려고 대기 중...

T1은 T2가 Y를 풀어주길 기다리고,
T2는 T1이 X를 풀어주길 기다린다.
→ 무한 대기 상태 (교착 상태)
```

---

## 🔑 2단계 로킹 규약(2-Phase Locking Protocol, 2PL)

공용 로크와 전용 로크만으로는 직렬 가능성을 보장할 수 없습니다. 그래서 추가적인 규약이 필요한데, 그것이 바로 **2단계 로킹 규약(2PL)** 입니다.

### 2단계 로킹의 핵심 원칙

2단계 로킹은 트랜잭션의 Lock/Unlock 과정을 두 단계로 엄격히 나눕니다.

**① 확장 단계(Growing Phase):** Lock만 할 수 있고 Unlock은 절대 할 수 없는 단계. 자물쇠를 잠그기만 합니다.

**② 축소 단계(Shrinking Phase):** Unlock만 할 수 있고 Lock은 절대 할 수 없는 단계. 자물쇠를 풀기만 합니다.

> **핵심 규칙:** 한 번 Unlock을 시작하면(축소 단계 진입) 다시는 Lock을 할 수 없습니다. 즉, **Lock → Unlock → Lock 패턴이 절대 불가능** 합니다.

```
✅ 2단계 로킹을 만족하는 예:
T1: Lock(X) → Lock(Y) → Unlock(X) → Unlock(Y)
    [확장 단계]          [축소 단계 시작, 이후 Lock 불가]

❌ 2단계 로킹을 위반하는 예:
T1: Lock(X) → Unlock(X) → Lock(Y) → Unlock(Y)
                         ↑
              Unlock 후 다시 Lock → 위반!
```

2단계 로킹을 준수하면 **직렬 가능성(Serializability)을 100% 보장** 합니다. 결과가 항상 정확하게 나옵니다.

:::warning 2단계 로킹도 교착 상태 발생 가능
2단계 로킹은 직렬 가능성을 보장하지만, **교착 상태(Deadlock)는 막을 수 없습니다.** 그러나 교착 상태는 탐지하고 복구할 수 있는 방법이 있으므로, 결과가 부정확한 것보다는 낫습니다. 교착 상태는 "필요 악"으로 받아들입니다.
:::

### 로크 상승과 로크 하강

2단계 로킹에서 로크의 종류가 바뀌는 경우가 있습니다.

- **로크 상승(Lock Upgrade):** S-Lock(읽기 로크)으로 읽다가 쓰기 작업이 필요해져서 X-Lock(쓰기 로크)으로 변경하는 것. 읽기에서 쓰기로 "올라가는" 것.
- **로크 하강(Lock Downgrade):** X-Lock(쓰기 로크)으로 작업하다가 읽기만 해도 되는 상황이 되어 S-Lock으로 변경하는 것. 쓰기에서 읽기로 "내려가는" 것.

### 2단계 로킹의 변형

| 종류 | 설명 | 교착 상태 | 연쇄 복귀 |
|------|------|-----------|-----------|
| **기본 2PL** | 확장/축소 단계만 구분 | 발생 가능 | 발생 가능 |
| **보수적(정적) 2PL** | 트랜잭션 시작 전에 필요한 모든 Lock을 미리 선언 | **발생 안 함** | 발생 가능 |
| **엄격한(Strict) 2PL** | X-Lock은 커밋/철회 후에만 Unlock | 발생 가능 | **예방** |
| **엄중한(Rigorous) 2PL** | 모든 Lock(S-Lock 포함)을 커밋/철회 후에만 Unlock | 발생 가능 | **완전 예방** |

**보수적(정적) 2PL 상세:**

트랜잭션이 시작되기 전에 읽을 데이터, 쓸 데이터를 **모두 미리 선언하고 Lock** 을 겁니다. 모든 것이 미리 잠겨 있으므로 다른 트랜잭션이 끼어들 틈이 없어 **교착 상태가 발생하지 않습니다.** 하지만 현실에서는 어떤 데이터를 읽고 쓸지 미리 전부 알기가 어려워 적용이 쉽지 않습니다.

**엄격한(Strict) 2PL 상세:**

가장 널리 사용되는 방법입니다. X-Lock(전용 로크)은 트랜잭션이 **커밋(Commit)되거나 철회(Abort)되기 전까지 절대 Unlock하지 않습니다.** 커밋된 데이터는 정상 데이터이므로 다른 트랜잭션이 읽어도 안전합니다. 따라서 **연쇄 복귀(Dirty Read) 문제를 예방** 합니다.

```
엄격한 2PL 동작 방식:

T1: Lock(X) → Read(X) → Write(X) → [커밋 완료] → Unlock(X)
                                      ↑
                           커밋 전까지 X의 Lock은 절대 해제 안 함
                           → T2는 커밋된 정상 데이터만 읽을 수 있음
                           → 연쇄 복귀 예방
```

---

## 📐 로킹 단위(Granularity)

로크를 걸 때 얼마나 큰 단위로 잠글지를 결정하는 것이 **로킹 단위(Lock Granularity)** 입니다. 마치 건물 전체를 잠글 수도 있고, 층별로 잠글 수도 있고, 강의실별로 잠글 수도 있는 것처럼 다양한 단위가 있습니다.

### 로킹 단위의 계층

```
데이터베이스 전체  ← 가장 큰 단위
      ↓
   테이블(파일)
      ↓
   레코드(행)
      ↓
   속성(컬럼)     ← 가장 작은 단위
```

### 로킹 단위 크기에 따른 트레이드오프

| 구분 | 단위가 **클 때** | 단위가 **작을 때** |
|------|----------------|-----------------|
| **예시** | 데이터베이스 전체 잠금 | 레코드 하나씩 잠금 |
| **로크 수** | 적게 필요 (오버헤드 ↓) | 많이 필요 (오버헤드 ↑) |
| **병행 제어 복잡도** | 단순 | 복잡 |
| **동시성/공유도** | 낮음 (나 혼자만 사용) | 높음 (많은 사람 동시 사용) |
| **병행성** | 낮음 | 높음 |

**로킹 단위가 클 때 (예: 데이터베이스 전체):**
자물쇠가 하나만 필요하므로 관리가 단순합니다. 하지만 데이터베이스 전체를 혼자 독점하므로 다른 사용자는 전혀 접근할 수 없습니다. 동시성이 극도로 낮아집니다.

**로킹 단위가 작을 때 (예: 레코드 단위):**
수백만 개의 레코드가 있다면 수백만 개의 자물쇠가 필요할 수 있습니다. 관리가 복잡하지만, 서로 다른 레코드에 접근하는 사용자들은 동시에 작업할 수 있어 **동시성과 공유도가 높아집니다.**

:::tip 실무에서의 로킹 단위
실제 DBMS는 상황에 따라 로킹 단위를 동적으로 조정합니다. 소수의 레코드를 다룰 때는 레코드 단위로, 테이블 전체를 스캔할 때는 테이블 단위로 자동으로 잠그는 **로크 에스컬레이션(Lock Escalation)** 기법도 사용합니다.
:::

---

## 🧠 주의사항과 핵심 팁

### ⚡ 병행 제어 설계 시 주의할 점

**1. 교착 상태는 불가피하게 받아들여야 합니다**

로킹 기법을 사용하는 한 교착 상태는 발생할 수 있습니다. 교착 상태는 감지(Deadlock Detection)하거나 예방(Deadlock Prevention)하는 별도의 메커니즘으로 처리합니다. 교착 상태 때문에 로킹을 포기하면 데이터 무결성을 잃게 됩니다. 교착 상태는 "복구 가능한 문제"이지만, 데이터 부정확은 "시스템을 아예 사용 불가능하게 만드는 문제"입니다.

:::danger 절대로 로킹 없이 동시 쓰기를 허용하지 마세요
병행 제어 없이 여러 트랜잭션이 동시에 같은 데이터를 쓰게 두면 갱신 분실, 모순성, 연쇄 복귀 등 심각한 데이터 무결성 문제가 발생합니다. 이는 금융 사고, 재고 오류, 개인정보 침해로 이어질 수 있습니다.
:::

**2. 직렬 가능성과 실용적 기법의 관계를 이해하세요**

직렬 가능성을 이론적으로 검사하는 것(우선순위 그래프)은 현실적으로 불가능합니다. 로킹(특히 2단계 로킹)과 타임스탬프는 직렬 가능성을 **실용적으로 보장하는 근사 기법** 입니다. 완벽한 이론보다 실용적인 구현이 더 중요합니다.

**3. 읽기와 쓰기를 구분하세요**

Read-Read는 충돌이 없습니다. 최대한 많은 읽기 작업이 동시에 이루어질 수 있도록 S-Lock을 활용하세요. 쓰기가 포함될 때만 X-Lock을 사용하면 동시성을 최대화할 수 있습니다.

**4. 2단계 로킹의 단계 경계를 명확히 하세요**

한 번 Unlock을 시작하면 다시 Lock을 해서는 안 됩니다. 코드 레벨에서 "이 지점 이후로는 Lock을 추가하지 않는다"는 경계를 명확히 설계해야 합니다.

### 자주 헷갈리는 용어 정리

| 용어 | 의미 |
|------|------|
| **직렬 스케줄** | 트랜잭션이 하나씩 순서대로 실행됨 |
| **비직렬 스케줄** | 트랜잭션이 뒤섞여 동시에 실행됨 |
| **직렬 가능 스케줄** | 비직렬이지만 결과가 직렬과 동일함 |
| **충돌 직렬 가능** | 충돌 교환으로 직렬로 변환 가능 |
| **갱신 분실** | 한 트랜잭션의 수정이 덮어씌워짐 |
| **연쇄 복귀** | 롤백이 필요한데 연쇄적으로 취소 불가 |
| **교착 상태** | 서로가 서로를 기다리며 무한 대기 |
| **S-Lock** | 공용(읽기) 로크, 동시 읽기 허용 |
| **X-Lock** | 전용(읽기+쓰기) 로크, 독점 사용 |
| **2PL** | 확장/축소 두 단계로만 Lock/Unlock 허용 |

---

## ✅ 핵심 정리

- **병행 제어(Concurrency Control)** 는 여러 트랜잭션이 동시에 데이터베이스를 사용할 때 데이터 무결성을 유지하는 기술이다.
- 병행 제어의 목적은 **공유도 최대화, 응답 시간 최소화, 시스템 활용도 최대화, 데이터 무결성 보장** 이다.
- **무제어 동시 공용의 3가지 문제**: 갱신 분실(Lost Update), 모순성(Inconsistency), 연쇄 복귀(Cascading Rollback)
- **충돌 발생 조건**: 두 연산 중 하나라도 Write가 포함되면 충돌 발생 (Read-Read만 충돌 없음)
- **직렬 스케줄**: 순서대로 실행, 결과 100% 정확하지만 실무 사용 불가
- **직렬 가능 스케줄**: 비직렬이지만 직렬과 동일한 결과 → 효율성과 정확성을 모두 갖춤
- **우선순위 그래프에서 사이클이 없으면** 충돌 직렬 가능 스케줄이다.
- **이진 로크**: 잠금/해제 두 가지 상태, 읽기-읽기도 차단하여 병행성 제한
- **S-Lock(공용 로크)**: 읽기 전용, S-Lock끼리는 동시 사용 가능
- **X-Lock(전용 로크)**: 읽기+쓰기, 다른 어떤 로크도 동시 불가
- **2단계 로킹(2PL)**: 확장 단계(Lock만)와 축소 단계(Unlock만)로 나누어 직렬 가능성 100% 보장
- **보수적 2PL**: 미리 모든 Lock 선언, 교착 상태 발생하지 않음
- **엄격한 2PL**: 커밋 후에만 X-Lock 해제, 연쇄 복귀 예방, 가장 많이 사용
- **로킹 단위가 클수록** 오버헤드는 줄지만 동시성(공유도)이 낮아지고, **작을수록** 동시성은 높지만 관리가 복잡해진다.
- **교착 상태는 2단계 로킹에서도 발생** 하며, 이는 필요 악으로 받아들이고 별도 메커니즘으로 처리한다.

---

작성일: 2026-02-21