---
title: "접근제어 방법: 사용자 인증과 권한 관리"
description: "접근제어 방법: 사용자 인증과 권한 관리에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/database-access-control-security/2-access-control"
sidebar_label: "접근제어"
date: "2026-02-21"
---

## 🔐 데이터베이스 보안, 왜 중요할까?

여러분이 집에 소중한 물건을 보관하고 있다고 상상해 보세요. 당연히 현관문에 잠금장치를 달고, 비밀번호를 설정하고, 가족에게만 열쇠를 줄 것입니다. **데이터베이스도 마찬가지입니다.** 데이터베이스 안에는 고객의 개인정보, 금융 거래 내역, 기업의 기밀 문서 등 매우 중요한 데이터가 담겨 있기 때문에, 아무나 접근하지 못하도록 철저하게 보호해야 합니다.

보안(Security)이라는 기술은 범위가 매우 넓습니다. 소프트웨어 보안, 하드웨어 보안, 네트워크 장비 보안, 그리고 **데이터베이스와 관련된 데이터 보안**까지 다양한 영역(도메인)으로 나뉩니다. 이번 문서에서는 그중에서도 **데이터베이스 접근제어 기법과 보안 구현 방법**에 집중해서 살펴보겠습니다.

> 💡 데이터베이스 보안의 핵심은 "누가, 어떤 데이터에, 어떤 방식으로 접근할 수 있는가"를 통제하는 것입니다.

데이터베이스 보안을 관리하는 방법은 크게 세 가지로 나눌 수 있습니다:

| 보안 관리 방법 | 핵심 개념 | 비유 |
|---|---|---|
| **접근제어(Access Control)** | 누가 들어올 수 있는지 통제 | 건물 출입구의 보안 게이트 |
| **정보 흐름 제어(Information Flow Control)** | 데이터가 이동하는 경로를 통제 | 택배가 올바른 주소로 가는지 감시 |
| **추론 제어(Inference Control)** | 간접적으로 비밀 정보를 알아내는 것을 차단 | 퍼즐 조각으로 전체 그림을 맞추지 못하게 방지 |

---

## 🚪 접근제어 — 데이터베이스의 출입문을 지키는 법

### 접근제어란 무엇인가?

**접근제어(Access Control)**란 사용자가 데이터베이스에 접근하려고 할 때, 그 사용자가 정당한 권한을 가지고 있는지 확인하고, 권한이 있는 경우에만 접근을 허용하는 기술입니다.

여러분이 회사 건물에 들어갈 때를 떠올려 보세요. 출입구에서 **사원증을 태그**하거나, **비밀번호를 입력**하거나, **지문을 인식**해야 문이 열립니다. 사원증이 없는 외부인은 들어갈 수 없죠. 데이터베이스의 접근제어도 정확히 이와 같은 원리입니다.

사용자가 데이터베이스에 접근하는 경로는 다양합니다:

- **응용 프로그램**(Application)을 통한 접근
- **웹 브라우저**를 통한 접근
- **모바일 앱**을 통한 접근
- **서버에 직접 연결**(다이렉트 접속)하는 방법

이 모든 경로에서 사용자의 **아이디(ID)와 패스워드(비밀번호)**, **권한(Permission)**, **역할(Role)** 등을 확인한 후에야 "그래, 들어와도 좋아"라고 허용하는 것이 바로 접근제어입니다.

:::info 접근제어의 핵심 질문
접근제어는 결국 이 세 가지 질문에 답하는 것입니다:
1. **당신은 누구인가?** (인증, Authentication)
2. **당신은 무엇을 할 수 있는가?** (권한 부여, Authorization)
3. **당신이 접근하려는 대상의 등급은?** (접근 통제, Access Control)
:::

### 정보 흐름 제어 — 데이터가 올바르게 흘러가는지 감시하기

정보 흐름 제어는 접근이 허용된 이후의 이야기입니다. 사용자가 데이터베이스에 정상적으로 접근한 뒤, **데이터가 이동하는 과정에서 발생할 수 있는 위험을 통제**하는 방법입니다.

마치 택배를 보내는 것과 비슷합니다. 내가 서울에서 부산으로 택배를 보냈는데, 중간에 누군가가 택배 상자를 열어서 내용물을 바꿔치기하거나 훔쳐간다면 큰 문제가 되겠죠? 데이터도 마찬가지입니다. 사용자가 네이버에서 이메일을 확인하거나, 쇼핑몰에서 상품을 주문하거나, 카카오톡으로 메시지를 보낼 때, 이 데이터들은 여러 서버를 거쳐 목적지에 도착합니다.

이 과정에서 **해커가 중간에 데이터를 가로채서 변조(위조)**하거나, **권한이 없는 곳으로 데이터를 부당하게 전달**하는 것을 막는 기술이 바로 정보 흐름 제어입니다.

### 추론 제어 — 퍼즐 조각으로 비밀을 알아내는 것을 차단하기

**추론 제어(Inference Control)**는 매우 흥미로운 개념입니다. 직접 접근이 차단되어 있는 데이터를, **다른 공개된 데이터를 분석해서 간접적으로 알아내는 것**을 방지하는 기술입니다.

쉽게 비유하면 이렇습니다. 냉장고(데이터베이스) 안에 비밀 레시피가 있는데, 냉장고 문에 자물쇠가 걸려 있어서 직접 열어볼 수 없습니다. 그런데 냉장고 밖에 놓인 **재료 목록표(통계 데이터)**를 보고 "아, 이 재료들이면 카레를 만들겠구나"라고 추측해내는 것이죠.

예를 들어, **통계 추론(Statistical Inference)**이라는 것이 있습니다:

- 회사의 **부서별 평균 연봉** 데이터는 공개되어 있습니다 (통계 데이터)
- 그런데 어떤 부서에 직원이 **단 한 명**뿐이라면?
- 그 부서의 평균 연봉 = 그 직원의 실제 연봉이 되어버립니다
- 이렇게 공개된 통계 데이터를 역으로 분석하면 **비공개인 개인 정보(로데이터, Raw Data)**를 알아낼 수 있습니다

:::warning 추론 공격의 위험성
통계 데이터 자체는 누구나 볼 수 있도록 공개된 정보이지만, 이를 교묘하게 분석하면 보호되어야 할 세부 데이터를 역추적할 수 있습니다. 그래서 의미 없는 데이터를 중간에 섞어 넣거나, 데이터를 분할하거나, 불필요한 코드를 추가하는 등의 방법으로 추론을 방해합니다.
:::

---

## ⚔️ 데이터베이스를 위협하는 주요 공격 유형

데이터베이스 보안을 이해하려면, 어떤 공격들이 존재하는지 알아야 합니다. 주요 공격 유형은 크게 세 가지 도메인으로 나뉩니다.

| 공격 도메인 | 대표 공격 | 핵심 원리 |
|---|---|---|
| **네트워크 관련** | DDoS (분산 서비스 거부 공격) | 서버에 과도한 트래픽을 보내 다운시킴 |
| **인증 프로세스 관련** | 백도어, 인증 우회 | 아이디/패스워드 인증 절차를 무력화 |
| **SQL 관련** | SQL Injection (SQL 주입) | SQL 코드에 악성 코드를 삽입 |

### 🧟 DDoS 공격 — 좀비 PC의 집단 공격

**DDoS(Distributed Denial of Service Attack, 분산 서비스 거부 공격)**는 뉴스에서도 자주 들을 수 있는 대표적인 사이버 공격입니다.

원리를 쉽게 설명하면 이렇습니다. 식당에 동시에 수용할 수 있는 인원이 100명이라고 합시다. 정상적인 손님은 10명인데, 갑자기 해커가 조종하는 **가짜 손님 500명**이 한꺼번에 몰려들면 식당은 마비되어 정상 손님도 서비스를 받을 수 없게 됩니다. 이것이 DDoS의 본질입니다.

서버는 동시 접속자 수에 한계가 있습니다. 1만 명, 5만 명, 10만 명 등으로 설정되어 있죠. 해커는 **좀비 PC(Zombie PC)**를 이용해서 이 한계를 넘어서는 접속을 시도합니다.

**좀비 PC란?** 여러분의 컴퓨터도 좀비 PC가 될 수 있습니다. 무료 프로그램을 다운받아 설치하거나, 불법 영화를 다운로드하거나, 의심스러운 웹사이트에 접속하는 과정에서 **나도 모르게 악성코드가 설치**될 수 있습니다. 이 악성코드는 평소에는 가만히 숨어 있다가, 해커가 명령을 내리면 일제히 특정 서버에 접속 요청을 보냅니다. 내 의지와 상관없이 내 컴퓨터가 공격 도구로 사용되는 것입니다.

:::danger DDoS는 서버 용량 증가로 해결되지 않습니다
"그러면 서버 용량을 늘리면 되지 않나요?"라고 생각할 수 있지만, 해커는 그 이상의 좀비 PC를 동원하면 됩니다. 근본적인 해결책은 **비정상 접속을 탐지하여 강제로 세션을 종료**시키거나, **블록체인(Blockchain) 기술로 데이터를 전 세계에 분산 저장**하여 특정 서버 하나를 공격하는 것이 무의미하게 만드는 방법 등이 있습니다.
:::

### 🔑 인증 프로세스 공격 — 출입문 자체를 무력화하기

인증 프로세스 공격은 아이디와 패스워드를 확인하는 **인증 절차 자체를 무력화**시키는 공격입니다. 마치 건물 보안 게이트의 전원을 꺼버려서 누구나 통과할 수 있게 만드는 것과 같습니다.

구체적인 방법으로는:

- **아이디/패스워드를 변형**시켜서 서버가 정상 사용자로 인식하게 만들기
- **오류를 발생**시켜서 검증 과정을 건너뛰게 만들기
- **백도어(Back Door)**를 이용해 인증 없이 우회 접근하기
- 해커가 **직접 서버를 공격**해서 인증 과정 없이 침투하기

이러한 공격들은 서버와 데이터베이스 사이의 인증 체계를 교란시켜, 권한 없는 사용자가 자유롭게 데이터베이스에 접근할 수 있게 만듭니다.

### 💉 SQL Injection — SQL 코드에 독을 주입하는 공격

**SQL Injection(SQL 주입)**은 공격 난이도는 상대적으로 낮지만 **파괴력이 어마어마한** 매우 위험한 공격입니다. SQL 명령어에 악성 코드를 주입(Injection)해서 데이터베이스를 조작하는 방식입니다.

예를 들어, 아래와 같은 정상적인 SQL 쿼리가 있다고 합시다:

```sql
-- 정상적인 SQL 쿼리: ID가 100인 학생 정보를 조회
SELECT * FROM 학생 WHERE id = 100;
```

해커가 이 쿼리의 **입력 값(100)**을 가로채서 다른 값으로 조작하면, 본래 볼 수 없었던 데이터가 유출됩니다.

❌ **잘못된 예시 — SQL Injection에 취약한 코드:**

```python
# 사용자가 입력한 값을 그대로 SQL에 넣는 위험한 방식
user_input = request.get("id")  # 사용자가 입력한 값을 받아옴
query = "SELECT * FROM 학생 WHERE id = " + user_input  # 입력값을 그대로 SQL에 연결
# 해커가 user_input에 "100 OR 1=1" 같은 값을 넣으면?
# 결과: SELECT * FROM 학생 WHERE id = 100 OR 1=1
# → 1=1은 항상 참이므로 학생 테이블의 모든 데이터가 유출됨!
```

위 코드에서 해커가 입력 값으로 `100 OR 1=1`을 넣으면, `WHERE` 조건이 항상 참이 되어 **학생 테이블의 모든 데이터가 노출**됩니다. 더 나아가 `DELETE`, `UPDATE` 같은 명령어를 주입하면 데이터를 삭제하거나 변형시킬 수도 있습니다.

✅ **올바른 예시 — 파라미터 바인딩(Secure Coding)을 사용한 안전한 코드:**

```python
# 파라미터 바인딩을 사용하여 SQL Injection을 방지하는 안전한 방식
user_input = request.get("id")  # 사용자가 입력한 값을 받아옴
query = "SELECT * FROM 학생 WHERE id = %s"  # %s 자리에 값이 안전하게 바인딩됨
cursor.execute(query, (user_input,))  # 입력값을 파라미터로 전달 (직접 연결하지 않음)
# 해커가 "100 OR 1=1"을 넣어도 문자열 그대로 처리되어 SQL 구문으로 해석되지 않음
# → SQL Injection 차단 성공!
```

위 코드에서 `%s`는 **파라미터 플레이스홀더(자리 표시자)**입니다. 사용자 입력 값이 SQL 명령어로 해석되지 않고, 순수한 데이터 값으로만 처리됩니다. 이것이 바로 **시큐어 코딩(Secure Coding)**의 핵심입니다.

:::tip SQL Injection 방어의 핵심
SQL Injection을 막는 가장 중요한 원칙은 **사용자 입력 값을 절대 SQL 문자열에 직접 연결하지 않는 것**입니다. 반드시 파라미터 바인딩(Parameterized Query)을 사용하고, 입력 데이터를 필터링(Filtering)하거나 이스케이핑(Escaping)해야 합니다.
:::

> 은행 계좌에 100만 원이 있었는데, SQL Injection 공격으로 UPDATE 쿼리가 조작되면 잔액이 0원이 되어버리거나, 다른 계좌로 이체될 수도 있습니다. 실제로 이런 금융 사고가 발생하고 있기 때문에, SQL Injection 방어는 아무리 강조해도 지나치지 않습니다.

---

## 🛡️ 인증, 권한 부여, 접근 통제의 3단계 방어 체계

데이터베이스 보안은 단일 방법이 아니라 **여러 겹의 방어 체계**로 구성됩니다. 이를 이해하기 위해 **세 가지 핵심 개념**을 살펴보겠습니다.

### 1단계: Authentication(인증) — "당신은 누구인가?"

**Authentication(인증)**은 사용자가 본인이 맞는지 확인하는 절차입니다. 마치 공항에서 여권을 보여주는 것과 같습니다.

인증 방법의 종류:
- **패스워드 입력**: 가장 기본적인 방법
- **패턴 잠금**: 스마트폰에서 많이 사용
- **생체 인식**: 지문 인식, 홍채 인식, 안면 인식 등
- **인증서**: 공인인증서, 공동인증서 등

### 2단계: Authorization(권한 부여) — "당신은 무엇을 할 수 있는가?"

**Authorization(권한 부여)**은 인증된 사용자가 **어떤 데이터에 어떤 작업을 할 수 있는지** 결정하는 것입니다. 회사에서 사원은 자기 팀의 문서만 볼 수 있지만, 부장은 부서 전체의 문서를 볼 수 있는 것처럼, **사용자마다 할 수 있는 일의 범위가 다릅니다.**

- **조회(SELECT)** 권한만 있는 사용자
- **삽입(INSERT)**, **삭제(DELETE)** 권한까지 있는 사용자
- **수정(UPDATE)** 권한까지 있는 관리자

### 3단계: Access Control(접근 통제) — "그 데이터의 보안 등급은?"

**Access Control(접근 통제)**은 데이터 자체에 **보안 등급을 부여**하고, 사용자의 허가 등급과 비교하여 접근을 허용하거나 차단하는 방법입니다.

| 문서 등급 | 의미 | 접근 가능한 사람 |
|---|---|---|
| **극비(Top Secret)** | 국가 최고 기밀 | 최고 권한자만 |
| **비밀(Secret)** | 중요 기밀 | 고위 관리자 이상 |
| **대외비(Confidential)** | 내부 전용 | 내부 직원 |
| **일반(Unclassified)** | 공개 가능 | 누구나 |

이 외에도 **기밀성(Confidentiality)**을 위한 **데이터 암호화**, 문제 발생 시 복원을 위한 **백업/복구(Backup & Recovery)**, 그리고 불법 사용을 사후에 확인하는 **감사(Audit)** — 로그 파일을 통해 "누가, 언제, 어떤 PC에서, 어떤 데이터를 조회했는지" 기록을 남기고 검토하는 방법 — 도 중요한 보안 수단입니다.

---

## 🔑 접근제어의 세 가지 핵심 기법: DAC, MAC, RBAC

접근제어를 구현하는 방법은 크게 세 가지로 나뉩니다. 이 세 가지를 이해하면 데이터베이스 보안의 큰 그림이 보입니다.

### 📋 DAC(임의 접근 제어, Discretionary Access Control) — 권한을 부여하는 방식

**DAC(임의 접근 제어)**는 한마디로 **"권한을 부여하는 것"**입니다. 데이터의 **소유자(Owner)**가 다른 사용자에게 자신의 데이터에 대한 접근 권한을 직접 부여하거나 회수할 수 있는 방식입니다.

마치 여러분이 자기 집의 열쇠를 친구에게 줄 수 있는 것처럼, 데이터 소유자가 "너는 이 테이블을 조회할 수 있어", "너는 이 테이블에 데이터를 넣을 수 있어"라고 직접 결정합니다.

- **통제 주체**: 데이터의 소유자(객체 소유자)
- **주요 방법**: ID와 패스워드 기반 인증
- **특징**: 구현하기 쉬움
- **사용 환경**: 운영체제(Windows 로그인 등), 일반적인 데이터베이스 시스템

### 🏛️ MAC(강제 접근 제어, Mandatory Access Control) — 등급을 부여하는 방식

**MAC(강제 접근 제어)**는 **데이터(객체)에 보안 등급을 부여하고, 사용자(주체)에게 허가 등급을 부여**하여, 등급에 따라 접근을 강제적으로 통제하는 방식입니다.

앞서 설명한 극비/비밀/대외비/일반 문서 등급 분류가 바로 MAC의 대표적인 예입니다. 개인이 임의로 권한을 줄 수 없고, **시스템이 강제적으로 등급에 따라 접근을 통제**합니다.

- **통제 주체**: 시스템(중앙 관리자)
- **주요 방법**: 보안 등급(레이블) 기반
- **특징**: 보안성이 가장 높음
- **사용 환경**: 군사, 정부, 국가 기밀 기관

:::note 벨-라파듈라 모델 (Bell-LaPadula Model)
MAC의 대표적인 보안 모델로, **군사용 보안 구조**에서 만들어진 수학적 모델입니다. **기밀성(Confidentiality) 유지**에 초점을 두고 있으며, 세 가지 규칙이 있습니다:

1. **단순 보안 규칙(Simple Security Rule)**: 자신보다 **높은 등급의 문서는 읽을 수 없음** (No Read Up). 비밀 등급 사용자는 극비 문서를 볼 수 없습니다.
2. **스타 무결성 규칙(*-Integrity Rule)**: 자신보다 **낮은 등급의 객체에 정보를 쓸 수 없음** (No Write Down). 과장이 사원의 문서를 읽을 수는 있지만 임의로 수정할 수는 없습니다.
3. **강한 스타 무결성 규칙(Strong *-Rule)**: 자신과 **같은 등급의 객체만** 읽고 쓸 수 있음. 등급이 다르면 높든 낮든 접근 불가.
:::

### 👔 RBAC(역할 기반 접근 제어, Role-Based Access Control) — 역할을 부여하는 방식

**RBAC(역할 기반 접근 제어)**는 최근 기업 환경에서 가장 많이 사용되는 방식입니다. 사용자 개인에게 직접 권한을 주는 것이 아니라, **역할(Role)을 만들고, 그 역할에 권한을 부여한 다음, 사용자에게 역할을 할당**하는 방식입니다.

마치 회사에서 "대표이사", "부장", "과장", "사원" 같은 직책이 있고, 각 직책마다 할 수 있는 일이 정해져 있는 것과 같습니다. 새로운 사원이 입사하면 "사원" 역할만 부여하면 해당 역할에 맞는 모든 권한이 자동으로 적용됩니다.

- **통제 주체**: 관리자(역할 기반)
- **주요 방법**: 역할(Role)을 생성하고 부여
- **특징**: 구성 변경이 용이, 관리가 효율적
- **사용 환경**: 기업, 조직, 비즈니스 환경

```sql
-- 역할 생성하기
CREATE ROLE 개발자;   -- '개발자'라는 역할을 새로 만듦

-- 역할에 권한 부여하기
GRANT SELECT, INSERT ON 프로젝트 TO 개발자;  -- '개발자' 역할에 프로젝트 테이블의 조회/삽입 권한 부여

-- 사용자에게 역할 할당하기
GRANT 개발자 TO U1;   -- U1 사용자에게 '개발자' 역할을 부여

-- 역할 삭제하기
DROP ROLE 개발자;     -- '개발자' 역할을 삭제 (해당 역할을 가진 모든 사용자의 권한이 함께 사라짐)
```

### 세 가지 접근제어 비교 정리

| 구분 | DAC (임의 접근 제어) | MAC (강제 접근 제어) | RBAC (역할 기반 접근 제어) |
|---|---|---|---|
| **핵심 원리** | 권한 부여 | 등급 부여 | 역할 부여 |
| **통제 주체** | 데이터 소유자 | 시스템(중앙 관리) | 관리자(역할 기반) |
| **보안 수준** | 보통 | 가장 높음 | 높음 |
| **유연성** | 높음 | 낮음 | 매우 높음 |
| **주요 사용처** | 운영체제, 일반 DB | 군사, 정부 기관 | 기업, 조직 |
| **기반 기술** | ID/패스워드 | 보안 등급(레이블) | CREATE ROLE / DROP ROLE |

### 접근제어의 구성 요소

역할 보안 기법을 포함한 접근제어 시스템은 네 가지 핵심 구성 요소로 이루어집니다:

| 구성 요소 | 설명 | 예시 |
|---|---|---|
| **주체(Subject)** | DB를 사용하는 사람 또는 프로그램 | 사용자, 응용 프로그램, 원격 컴퓨터 |
| **객체(Object)** | 보안의 대상이 되는 데이터 | 데이터베이스, 테이블, 행(Row), 열(Column) |
| **조작(Operation)** | 주체가 객체에 할 수 있는 일 | 읽기(Read), 쓰기(Write), 실행(Execute) |
| **규칙(Rule)** | 조작에 대한 제약 조건 | "SELECT만 허용", "업무 시간에만 접근 가능" |

---

## 💻 GRANT와 REVOKE — 권한을 주고 뺏는 SQL 명령어

데이터베이스에서 권한을 실제로 관리할 때 사용하는 핵심 명령어가 바로 **GRANT(권한 부여)**와 **REVOKE(권한 회수)**입니다.

### GRANT — 권한을 부여하는 명령어

**GRANT**는 영어로 "승인하다, 부여하다"라는 뜻입니다. 특정 사용자에게 특정 테이블에 대한 특정 권한을 주는 명령어입니다.

**기본 문법:**

```sql
GRANT 권한종류 ON 테이블이름 TO 사용자계정 [WITH GRANT OPTION];
```

각 부분을 하나씩 살펴보겠습니다:
- `GRANT`: "권한을 부여하겠다"는 선언
- `권한종류`: SELECT, INSERT, DELETE, UPDATE 등
- `ON 테이블이름`: 어떤 테이블에 대한 권한인지 지정
- `TO 사용자계정`: 누구에게 줄 것인지 지정
- `WITH GRANT OPTION`: (선택사항) 받은 권한을 다른 사람에게도 줄 수 있는 권한

✅ **올바른 예시 — 기본 권한 부여:**

```sql
-- DBA(데이터베이스 관리자)가 U1에게 Student 테이블의 삽입, 삭제 권한을 부여
GRANT INSERT, DELETE ON Student TO U1;
-- U1은 이제 Student 테이블에 데이터를 넣거나(INSERT) 지울(DELETE) 수 있음
-- 하지만 WITH GRANT OPTION이 없으므로, U1은 이 권한을 다른 사람에게 줄 수 없음
```

✅ **올바른 예시 — WITH GRANT OPTION 포함:**

```sql
-- DBA가 U2에게 Student 테이블의 조회 권한을 부여 + 이 권한을 다른 사람에게도 줄 수 있는 권한까지 부여
GRANT SELECT ON Student TO U2 WITH GRANT OPTION;
-- U2는 Student 테이블을 조회(SELECT)할 수 있음
-- WITH GRANT OPTION이 있으므로, U2는 자신의 SELECT 권한을 다른 사용자에게도 줄 수 있음
```

```sql
-- U2가 자신이 받은 SELECT 권한을 U3에게 전달 (WITH GRANT OPTION 덕분에 가능)
GRANT SELECT ON Student TO U3;
-- U3도 이제 Student 테이블을 조회할 수 있게 됨
```

:::tip WITH GRANT OPTION vs WITH ADMIN OPTION
- **WITH GRANT OPTION**: 일반 객체(테이블 등)의 권한을 부여할 때 사용. 상위 권한이 회수되면 하위 권한도 **자동으로 함께 회수(CASCADE)** 됩니다.
- **WITH ADMIN OPTION**: 시스템 권한을 부여할 때 사용. 상위 권한이 회수되어도 하위 권한은 **유지**됩니다.
:::

### REVOKE — 권한을 회수하는 명령어

**REVOKE**는 영어로 "취소하다, 철회하다"라는 뜻입니다. 이미 부여된 권한을 다시 가져오는(뺏는) 명령어입니다.

**기본 문법:**

```sql
REVOKE 권한종류 ON 테이블이름 FROM 사용자계정 [CASCADE];
```

- `REVOKE`: "권한을 회수하겠다"는 선언
- `권한종류`: 회수할 권한 (SELECT, INSERT 등)
- `ON 테이블이름`: 어떤 테이블의 권한인지
- `FROM 사용자계정`: 누구로부터 회수할 것인지
- `CASCADE`: (선택사항) 연쇄적으로 하위 사용자의 권한도 함께 회수

✅ **올바른 예시 — 권한 회수:**

```sql
-- DBA가 U2로부터 Student 테이블의 SELECT 권한을 회수
REVOKE SELECT ON Student FROM U2 CASCADE;
-- U2의 SELECT 권한이 사라짐
-- CASCADE에 의해, U2가 U3에게 준 SELECT 권한도 자동으로 함께 사라짐
-- 마치 회사에서 부장의 권한이 없어지면, 부장이 부여한 과장/사원의 권한도 사라지는 것과 같음
```

> **CASCADE(연쇄)의 원리**: A가 B에게 권한을 주고, B가 C에게 권한을 줬을 때, A의 권한이 회수되면 B와 C의 권한도 **도미노처럼 연쇄적으로** 함께 회수됩니다. 이것은 WITH GRANT OPTION으로 부여된 권한의 특성입니다.

### 📝 GRANT/REVOKE 종합 예제 — 단계별 완전 분석

아래 예제를 통해 권한의 부여와 회수가 어떻게 연쇄적으로 작동하는지 꼼꼼하게 살펴보겠습니다. 모든 작업은 `Employee` 테이블을 대상으로 합니다.

```sql
-- ① U1이 U2에게 Employee 테이블의 INSERT, DELETE 권한을 부여
GRANT INSERT, DELETE ON Employee TO U2;
-- ✅ 성공: U2는 Employee 테이블에 데이터 삽입/삭제 가능
-- ⚠️ WITH GRANT OPTION이 없으므로 U2는 이 권한을 다른 사람에게 줄 수 없음
```

```sql
-- ② U1이 U3에게 Employee 테이블의 SELECT 권한을 부여 (WITH GRANT OPTION 포함)
GRANT SELECT ON Employee TO U3 WITH GRANT OPTION;
-- ✅ 성공: U3는 Employee 테이블 조회 가능
-- ✅ WITH GRANT OPTION이 있으므로 U3는 SELECT 권한을 다른 사람에게도 줄 수 있음
```

```sql
-- ③ U2가 U4에게 INSERT 권한을 부여하려고 시도
GRANT INSERT ON Employee TO U4;
-- ❌ 에러 발생! U2는 WITH GRANT OPTION이 없기 때문에
--    자신이 가진 권한을 다른 사람에게 줄 수 없음
```

```sql
-- ④ U3가 U5에게 Employee 테이블의 SELECT 권한을 부여
GRANT SELECT ON Employee TO U5;
-- ✅ 성공: U3는 WITH GRANT OPTION이 있으므로 권한 전달 가능
-- ⚠️ U5에게는 WITH GRANT OPTION을 주지 않았음
```

```sql
-- ⑤ U5가 U6에게 SELECT 권한을 부여하려고 시도
GRANT SELECT ON Employee TO U6;
-- ❌ 에러 발생! U5는 WITH GRANT OPTION이 없기 때문에
--    자신이 가진 권한을 다른 사람에게 줄 수 없음
```

```sql
-- ⑥ U1이 U6에게 직접 SELECT 권한을 부여
GRANT SELECT ON Employee TO U6;
-- ✅ 성공: U1은 데이터 소유자이므로 누구에게든 직접 권한 부여 가능
```

```sql
-- ⑦ U1이 U3의 권한을 회수
REVOKE SELECT ON Employee FROM U3 CASCADE;
-- ✅ U3의 SELECT 권한이 사라짐
-- ✅ CASCADE에 의해 U3가 U5에게 준 SELECT 권한도 자동으로 사라짐
-- ⚠️ U6의 권한은 U1이 직접 준 것이므로 영향 없음 (유지됨)
```

```sql
-- ⑧ U6가 Employee 테이블을 SELECT
SELECT * FROM Employee;
-- ✅ 성공: U6는 U1로부터 직접 받은 SELECT 권한이 아직 유효함
```

```sql
-- ⑨ U5가 어떤 작업을 시도
SELECT * FROM Employee;
-- ❌ 에러 발생! U5의 권한은 ⑦에서 CASCADE로 이미 회수됨
```

```sql
-- ⑩ U6가 Employee 테이블을 UPDATE하려고 시도
UPDATE Employee SET name = '홍길동' WHERE id = 1;
-- ❌ 에러 발생! U6는 SELECT 권한만 가지고 있음
--    UPDATE 권한은 부여받지 않았으므로 수정 불가
```

:::warning 권한 관리의 핵심 원칙
1. **WITH GRANT OPTION이 없으면** 받은 권한을 다른 사람에게 줄 수 없습니다.
2. **WITH GRANT OPTION으로 받은 권한**은 상위자의 권한이 회수되면 **연쇄적으로(CASCADE)** 함께 회수됩니다.
3. **부여받지 않은 권한의 작업은 불가능**합니다. SELECT만 있으면 UPDATE는 할 수 없습니다.
:::

아래 표로 위 예제의 결과를 정리합니다:

| 순서 | 명령어 | 결과 | 이유 |
|---|---|---|---|
| ① | U1→U2: INSERT, DELETE 부여 | ✅ 성공 | U1은 소유자 |
| ② | U1→U3: SELECT + WITH GRANT OPTION | ✅ 성공 | U1은 소유자 |
| ③ | U2→U4: INSERT 부여 시도 | ❌ 에러 | WITH GRANT OPTION 없음 |
| ④ | U3→U5: SELECT 부여 | ✅ 성공 | WITH GRANT OPTION 있음 |
| ⑤ | U5→U6: SELECT 부여 시도 | ❌ 에러 | WITH GRANT OPTION 없음 |
| ⑥ | U1→U6: SELECT 부여 | ✅ 성공 | U1은 소유자 |
| ⑦ | U1: U3 권한 회수 (CASCADE) | ✅ U3, U5 권한 소멸 | CASCADE 연쇄 회수 |
| ⑧ | U6: SELECT 실행 | ✅ 성공 | U1이 직접 부여한 권한 유효 |
| ⑨ | U5: SELECT 시도 | ❌ 에러 | ⑦에서 권한 회수됨 |
| ⑩ | U6: UPDATE 시도 | ❌ 에러 | SELECT 권한만 있음 |

---

## 🔒 View를 활용한 보안 관리와 권한 부여 테이블

### View — 가장 간단한 보안 기법

**View(뷰)**는 SQL에서 배우는 개념이지만, 사실 **가장 쉽고 간단하게 보안을 관리할 수 있는 방법** 중 하나입니다.

View는 테이블의 전체 데이터 중 **필요한 부분만 보여주고 나머지는 감추는** 가상 테이블입니다. 마치 커다란 서류 파일에서 특정 페이지만 복사해서 보여주고, 나머지는 금고에 넣어두는 것과 같습니다.

```sql
-- 학생 테이블에서 이름과 학과만 보여주는 View 생성
CREATE VIEW 학생_공개정보 AS
SELECT 이름, 학과 FROM 학생;
-- 이 View를 통해 접근하면 학번, 주소, 연락처 등 민감한 정보는 보이지 않음
-- → 전체 테이블의 일부분만 공개하여 나머지를 자연스럽게 보호
```

### 권한 부여 테이블 — 누가 무엇을 할 수 있는지 한눈에 관리

권한 부여 테이블은 **사용자별로 어떤 데이터에 어떤 권한이 있는지**를 체계적으로 정리한 표입니다.

| 사용자 | 데이터 1 | 데이터 2 | 데이터 3 |
|---|---|---|---|
| **U1** | SELECT만 가능 | 접근 불가 | SELECT, UPDATE 가능 |
| **U2** | 접근 불가 | 접근 불가 | 접근 불가 |
| **U3** | 접근 불가 | SELECT, UPDATE 가능 | 접근 불가 |
| **U4** | 접근 불가 | 접근 불가 | 접근 불가 |

이런 권한 부여 테이블을 통해 데이터베이스 관리자(DBA)는 전체 사용자의 권한 현황을 한눈에 파악하고 효율적으로 관리할 수 있습니다.

### 집계와 추론에 대한 보안 대응

| 개념 | 설명 | 대응 방법 |
|---|---|---|
| **집계(Aggregation)** | 낮은 등급의 정보들을 모아서 높은 등급의 정보를 알아내는 것 | 데이터 접근 범위를 제한, 통계 쿼리 결과 제어 |
| **추론(Inference)** | 보안 등급이 없는 공개 데이터로부터 비밀 정보를 유추하는 것 | 데이터 분할, 중요 데이터 감추기, 불필요한 데이터(노이즈) 삽입, 다중 사료화(Polyinstantiation) |

---

## 📌 핵심 정리

- **접근제어(Access Control)**는 사용자가 데이터베이스에 접근할 때 권한을 확인하고 통제하는 보안의 핵심 기술이다
- **정보 흐름 제어**는 데이터가 이동하는 경로에서 부당한 가로채기나 변조를 막는 기술이다
- **추론 제어**는 공개된 데이터(통계 등)를 분석하여 비밀 정보를 역추적하는 것을 방지하는 기술이다
- **DDoS 공격**은 좀비 PC를 동원하여 서버에 과부하를 일으켜 다운시키는 분산 서비스 거부 공격이다
- **SQL Injection**은 SQL 코드에 악성 코드를 주입하여 데이터를 탈취·변조하는 공격으로, 파라미터 바인딩으로 방어한다
- **Authentication(인증)**은 "당신은 누구인가?", **Authorization(권한 부여)**는 "무엇을 할 수 있는가?", **Access Control(접근 통제)**은 "데이터의 보안 등급은?"을 결정한다
- **DAC(임의 접근 제어)**는 소유자가 직접 권한을 부여하는 방식이다
- **MAC(강제 접근 제어)**는 문서에 등급을 부여하고 시스템이 강제 통제하는 방식으로, 보안성이 가장 높다
- **RBAC(역할 기반 접근 제어)**는 역할(Role)을 만들어 권한을 관리하며, 기업 환경에서 가장 많이 사용된다
- **GRANT**는 권한을 부여하는 명령어, **REVOKE**는 권한을 회수하는 명령어이다
- **WITH GRANT OPTION**이 있으면 받은 권한을 다른 사용자에게도 전달할 수 있으며, 상위 권한 회수 시 CASCADE로 하위 권한도 자동 회수된다
- **View(뷰)**는 테이블의 일부만 공개하여 나머지를 감추는, 가장 간단한 보안 관리 방법이다

작성일: 2026-02-21