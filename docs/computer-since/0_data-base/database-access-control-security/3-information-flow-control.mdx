---
title: "정보 흐름 제어: 데이터 전달 과정의 통제"
description: "정보 흐름 제어: 데이터 전달 과정의 통제에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/database-access-control-security/3-information-flow-control"
sidebar_label: "정보 흐름 제어"
date: "2026-02-21"
---

## 🛡️ 데이터베이스 보안, 왜 이렇게 중요할까?

우리가 매일 사용하는 인터넷 쇼핑, 은행 앱, SNS 메시지 — 이 모든 것의 뒤에는 **데이터베이스(DB)**가 있습니다. 데이터베이스에는 여러분의 이름, 주소, 계좌번호, 비밀번호 같은 민감한 정보가 고스란히 저장되어 있죠. 만약 이 데이터베이스가 해커에게 뚫린다면 어떻게 될까요? 내 은행 계좌에서 돈이 사라지거나, 개인정보가 유출되거나, 심지어 서비스 자체가 마비될 수도 있습니다.

보안(Security)이라는 기술은 매우 광범위합니다. **소프트웨어적인 보안**, **하드웨어적인 보안**, **네트워크 장비에 대한 보안**, 그리고 우리가 이번에 다룰 **데이터베이스와 관련된 보안** 등 영역에 따라 보안의 범위와 방법이 조금씩 달라집니다.

> 보안은 마치 집의 안전을 지키는 것과 같습니다. 현관문 잠금장치(접근제어), 택배 배송 경로 감시(정보 흐름 제어), CCTV 감시(감사) 등 여러 겹의 방어막이 필요합니다.

이번 문서에서는 데이터베이스 보안을 관리하는 **세 가지 핵심 방법**(접근제어, 정보 흐름 제어, 추론 제어)을 시작으로, 대표적인 보안 공격 유형(DDoS, SQL 인젝션 등), 접근제어 기법(DAC, MAC, RBAC), 그리고 권한 부여·회수 명령어(GRANT, REVOKE)까지 초보자도 이해할 수 있도록 아주 자세하게 풀어보겠습니다.

---

## 📚 데이터베이스 보안 관리의 세 가지 핵심 방법

데이터베이스 보안을 관리하는 방법은 크게 **세 가지**로 나눌 수 있습니다. 마치 보물상자를 지키기 위해 **문 앞의 경비원**, **운반 경로의 호위병**, **추리를 막는 암호**를 두는 것과 같습니다.

### 🔐 1. 접근제어 (Access Control)

**왜 필요한가?** 여러분이 회사 건물에 들어갈 때 사원증을 찍거나, 비밀번호를 입력하는 것을 떠올려 보세요. 아무나 들어올 수 없게 막는 것이 바로 접근제어의 핵심입니다.

사용자가 데이터베이스에 접근하는 경로는 다양합니다. **응용 프로그램**(앱)을 통해서, **웹 브라우저**를 통해서, **모바일 기기**를 통해서, 또는 **서버에 직접 연결**해서 접근할 수도 있죠. 접근제어는 이렇게 다양한 경로로 들어오려는 사용자가 **적절한 권한(아이디, 패스워드, 역할 등)을 갖추고 있는지 확인**한 뒤, 조건을 만족하면 "좋아, 들어와도 돼"라고 문을 열어주는 방식입니다.

> 마치 공항 출입국 심사처럼, 여권(아이디)과 비자(권한)를 확인한 후에야 입국을 허용하는 것과 같습니다.

### 🌊 2. 정보 흐름 제어 (Information Flow Control)

**왜 필요한가?** 접근이 허용된 이후에도 문제는 끝나지 않습니다. 여러분이 네이버에 로그인한 후 이메일을 확인하고, 쇼핑몰에서 상품을 주문하고, 카카오톡으로 친구에게 메시지를 보내는 모든 과정에서 **정보가 흘러다닙니다**. 내가 요청한 정보가 여러 서버를 거쳐 최종 서버에 도착하고, 그곳에서 데이터를 찾아 다시 나에게 돌아오는 여정이죠.

이 과정은 마치 **택배 배송**과 같습니다. 내가 주문한 물건이 물류센터 → 지역 허브 → 배송 기사를 거쳐 집 앞에 도착하는 것처럼, 데이터도 여러 중간 경유지를 거치며 이동합니다. 그런데 만약 이 배송 과정에서 누군가가 **택배 상자를 열어서 물건을 바꿔치기**한다면 어떨까요?

정보 흐름 제어는 바로 이 문제를 다룹니다. **권한이 부여되지 않은 데이터들 사이에서 부당한 데이터 전달을 통제하는 기술**입니다. 중간에 해커가 정보를 가로채서 **변조(내용을 바꿈)**하거나 **위조(가짜를 만듦)**해서 다시 집어넣는 것을 막아야 합니다. 이렇게 정보의 분배와 흐름을 적절하게 통제해야만 안전한 데이터가 클라이언트(사용자)에게 제대로 전달될 수 있습니다.

> 편지를 보낼 때 봉투를 밀봉하고, 등기우편으로 보내서 중간에 누가 열어보지 못하게 하는 것과 같은 원리입니다.

### 🔍 3. 추론 제어 (Inference Control)

**왜 필요한가?** 접근제어로 직접 접근을 막고, 정보 흐름 제어로 전달 과정을 보호했다 하더라도, 영리한 공격자는 **간접적인 방법**으로 비밀 정보를 알아낼 수 있습니다.

추론(Inference)이란 **기존에 공개된 자료를 분석해서 숨겨진 새로운 정보를 알아내는 것**입니다. 직접 데이터베이스에 접근하는 것이 아니라, 누구나 볼 수 있는 일반 자료를 통해 비밀 정보를 유추하는 방식이죠.

대표적인 예가 **통계 추론**입니다. 예를 들어, 어떤 회사의 부서별 평균 연봉 데이터(통계 정보)는 공개되어 있지만, 개별 직원의 연봉(로데이터, 즉 원시 데이터)은 비공개입니다. 그런데 만약 특정 부서에 직원이 **딱 한 명**밖에 없다면? 그 부서의 평균 연봉 = 그 직원의 실제 연봉이 되어버립니다. 이렇게 통계 데이터를 역으로 분석하면 세부 데이터를 알아낼 수 있는 것이죠.

추론을 막기 위해서는 다음과 같은 방법을 사용합니다:
- **데이터 분할**: 연관된 데이터를 서로 다른 곳에 나눠 저장
- **중요 데이터 감추기**: 추론의 단서가 될 수 있는 정보를 숨김
- **노이즈 데이터 삽입**: 의미 없는 데이터를 중간에 끼워 넣어 분석을 방해
- **다중 사례 방법**: 여러 겹의 보호 장치를 적용

:::info 세 가지 보안 방법 비교
| 방법 | 핵심 개념 | 비유 |
|------|----------|------|
| **접근제어** | 누가 들어올 수 있는지 통제 | 건물 출입문의 사원증 인식기 |
| **정보 흐름 제어** | 데이터 전달 과정을 통제 | 택배 배송 경로의 호위병 |
| **추론 제어** | 간접적 정보 유출을 차단 | 퍼즐 조각만으로 전체 그림을 못 맞추게 섞기 |
:::

---

## ⚔️ 데이터베이스를 위협하는 주요 공격 유형

데이터베이스를 노리는 보안 공격은 크게 **세 가지 도메인**으로 나눌 수 있습니다: **네트워크 관련 공격**, **인증 프로세스 관련 공격**, **SQL 인젝션**입니다.

### 💥 DDoS 공격 (분산 서비스 거부 공격)

**DDoS**는 **Distributed Denial of Service Attack**의 약자로, 우리말로는 **분산 서비스 거부 공격**이라고 합니다.

**왜 위험한가?** 모든 서버에는 동시에 처리할 수 있는 접속자 수의 한계가 있습니다. 1만 명, 5만 명, 10만 명 등 서버 용량에 따라 그 한계가 정해져 있죠. DDoS 공격은 이 한계를 의도적으로 초과시켜 서버를 마비시키는 공격입니다.

**공격 원리를 비유로 설명하면:** 식당에 좌석이 100개 있는데, 해커가 조종하는 가짜 손님 500명이 한꺼번에 들이닥쳐서 모든 좌석을 차지해 버리는 것과 같습니다. 진짜 손님은 들어갈 수 없게 되죠.

**좀비 PC의 역할:** DDoS 공격의 핵심 도구는 **좀비 PC**입니다. 여러분의 가정용 컴퓨터도 좀비 PC가 될 수 있습니다. 어떻게 감염될까요?

- 불법 사이트에서 무료 프로그램을 다운받아 설치했을 때
- 무료 영화를 다운받아 시청하는 과정에서
- 감염된 웹사이트에 접속했을 때
- SNS나 문자 메시지를 통해 악성코드가 전달될 때

이런 경로로 여러분의 컴퓨터에 **악성코드**가 몰래 심어집니다. 평소에는 아무 활동도 하지 않고 숨어 있다가, 해커가 "지금부터 특정 서버에 접속해서 정보를 요청해!"라고 명령을 내리면, 전 세계에 흩어져 있는 수만, 수십만 대의 좀비 PC가 동시에 한 서버를 공격합니다. 서버는 이 엄청난 트래픽을 감당하지 못하고 다운되어 버리는 것이죠.

:::warning DDoS 방어의 오해
"동시 접속자 수를 늘리면 되지 않나요?"라고 생각할 수 있지만, 이는 근본적인 해결책이 아닙니다. 접속자 수를 2만 명으로 늘리면 해커는 2만 명 이상을 동원할 뿐입니다. 근본적인 방어는 **좀비 PC의 비정상 세션을 탐지하여 강제 종료**시키거나, **블록체인**처럼 데이터를 전 세계에 분산 저장하여 특정 서버 하나를 공격해도 의미가 없게 만드는 방법이 필요합니다.
:::

### 🚪 인증 프로세스 공격

사용자가 서버에 접속할 때는 아이디와 패스워드를 입력하고, 서버가 이를 확인한 후 정상적인 사용자임이 확인되면 접속을 승인합니다. **인증 프로세스 공격**은 이 확인 절차 자체를 무력화시키는 공격입니다.

해커는 다음과 같은 방법을 사용합니다:
- 아이디나 패스워드가 없는데 **있는 것처럼 서버가 인식하게 만들기**
- 의도적으로 **오류를 발생시켜** 검증 과정을 건너뛰게 하기
- **백도어(뒷문)**를 만들어 인증 없이 우회 접근하기
- 직접 해킹 코드로 서버의 인증 시스템을 뚫기

> 마치 아파트 현관 비밀번호 입력기를 해킹해서, 비밀번호 없이도 문이 열리게 만드는 것과 같습니다.

### 💉 SQL 인젝션 (SQL Injection)

**SQL 인젝션**은 SQL 코드(데이터베이스 명령어)에 **악성 코드를 주입**해서 공격하는 방식입니다. 이름에서 알 수 있듯이 "인젝션(주입)"이라는 단어가 좋은 의미가 아닙니다. SQL 명령어 안에 해킹 코드를 끼워 넣는 것입니다.

**구체적인 예시로 살펴보겠습니다:**

```sql
-- 정상적인 SQL 쿼리: ID가 100번인 학생의 정보를 조회
SELECT * FROM 학생 WHERE id = 100;
```

위 쿼리에서 `100`이라는 입력 값이 있습니다. 해커는 이 **입력 값을 조작**합니다. 예를 들어 `100` 대신 다른 값을 넣어버리면, 원래 조회하려던 학생이 아닌 **다른 학생의 정보가 유출**되어 버립니다.

더 심각한 경우를 보겠습니다:

```sql
-- ❌ 해커가 조작한 SQL 인젝션 공격 예시
SELECT * FROM 학생 WHERE id = 100 OR 1=1;
-- 1=1은 항상 참(True)이므로, 모든 학생의 정보가 유출됨!
```

```sql
-- ❌ 더 치명적인 SQL 인젝션 공격
SELECT * FROM 학생 WHERE id = 100; DROP TABLE 학생;
-- 학생 테이블 자체를 삭제해 버리는 공격!
```

:::danger SQL 인젝션의 위험성
SQL 인젝션은 **공격 난이도는 낮지만 파괴력은 어마어마**합니다. 코드만 중간에 가로챌 수 있으면 UPDATE로 데이터를 변경하거나, DELETE로 삭제하거나, INSERT로 가짜 데이터를 넣을 수 있습니다. 은행 계좌에 100만 원이 있었는데 갑자기 0원이 되거나, 내 돈이 다른 곳으로 이체되어 버릴 수도 있는 것입니다.
:::

**SQL 인젝션을 막는 방법:**
- **시큐어 코딩(Secure Coding)**: 보안을 고려한 프로그래밍 기법 사용
- **입력 값 필터링**: 사용자가 입력한 데이터를 철저히 검증
- **이스케이핑(Escaping)**: 특수 문자를 무력화시켜 코드로 실행되지 않게 처리
- **스캐닝 툴**: 자동화된 도구로 취약점 탐지

---

## 🔑 인증·권한·접근제어의 체계

데이터베이스 보안에서 핵심적인 세 가지 개념이 있습니다. 이들을 영어 약자로 **AAA**라고 부르기도 합니다.

### Authentication (인증)

**인증(Authentication)**은 "당신이 누구인지 확인하는 것"입니다. 우리가 일상에서 사용하는 인증 방법을 생각해 보면 쉽습니다:

| 인증 방법 | 예시 |
|----------|------|
| **지식 기반** | 패스워드, PIN 번호, 패턴 |
| **소유 기반** | 공인인증서, OTP 토큰, 스마트카드 |
| **생체 기반** | 지문인식, 홍채인식, 안면인식 |

스마트폰을 예로 들면, 비밀번호 입력, 패턴 그리기, 지문 인식, 안면 인식 등이 모두 인증에 해당합니다. 이 모든 방법의 목적은 하나입니다: **"지금 이 사람이 진짜 주인이 맞는가?"**를 확인하는 것이죠.

### Authorization (권한 부여)

**권한 부여(Authorization)**는 인증이 완료된 후, "이 사용자가 무엇을 할 수 있는지"를 결정하는 것입니다. 같은 시스템에 로그인했더라도 **사용자마다 할 수 있는 일이 다릅니다**.

예를 들어 대학교 시스템에서:
- **학생**: 학생 테이블을 **조회(SELECT)**만 가능, 수강 등록 테이블은 **삽입(INSERT)·삭제(DELETE)** 가능
- **교수**: 성적 테이블을 **갱신(UPDATE)** 가능
- **관리자**: 모든 테이블에 대해 모든 작업 가능

### Access Control (접근제어)

**접근제어(Access Control)**는 데이터 자체에 **등급**을 부여하고, 사용자가 어느 등급까지 접근할 수 있는지를 관리하는 것입니다. 국가 기관의 문서 분류를 떠올리면 이해하기 쉽습니다:

| 문서 등급 | 접근 가능자 |
|----------|-----------|
| **극비(Top Secret)** | 최고위 권한자만 |
| **비밀(Secret)** | 비밀 등급 이상 허가자 |
| **대외비(Confidential)** | 대외비 등급 이상 허가자 |
| **일반(Unclassified)** | 모든 사용자 |

### 추가 보안 개념

- **기밀성(Confidentiality)**: 데이터 자체에 **암호를 걸어서** 해커가 중간에 가로채더라도 내용을 볼 수 없게 만드는 것
- **백업/리커버리(Backup/Recovery)**: 데이터가 손상되었을 때 복구할 수 있도록 사전에 복사본을 만들어 두는 것
- **감사(Audit)**: **로그 파일**을 통해 누가 언제 어떤 데이터에 접근했는지 기록하고, 나중에 불법적인 사용을 확인하는 것

:::tip 감사(Audit)의 실생활 예시
은행 직원이 고객의 계좌 정보를 불법적으로 조회하면, 그 기록이 로그에 남습니다. 감사팀이 나중에 이 로그를 확인하면 "몇 월 며칠 몇 시 몇 분에, 어느 PC에서, 어떤 데이터를 검색했는지" 알 수 있습니다. 이것이 바로 감사의 힘입니다.
:::

---

## 🏗️ 접근제어 기법 세 가지: DAC, MAC, RBAC

접근제어를 구현하는 기법은 크게 **세 가지**로 나뉩니다. 각각의 특징을 자세히 알아보겠습니다.

### 📋 DAC (임의 접근제어, Discretionary Access Control)

**핵심 개념:** **권한을 부여**하는 방식입니다. 데이터를 소유한 사람이 자신의 재량으로 다른 사용자에게 권한을 줄 수 있습니다.

- **통제 주체**: 객체(데이터)의 소유자
- **특징**: 구현이 **쉽고 간단**
- **주요 사용처**: 운영체제(Windows 로그인 등)
- **인증 방식**: 기본적으로 ID와 패스워드를 사용

> 마치 내 집의 열쇠를 내가 원하는 사람에게 자유롭게 나눠줄 수 있는 것과 같습니다.

### 🔒 MAC (강제 접근제어, Mandatory Access Control)

**핵심 개념:** 데이터에 **등급을 부여**하는 방식입니다. 사용자의 재량이 아니라 시스템이 강제적으로 접근을 통제합니다.

- **통제 주체**: 시스템(중앙 관리자)
- **특징**: **보안성이 가장 높음**
- **주요 사용처**: 정부, 군사 분야
- **등급 체계**: 극비 > 비밀 > 대외비 > 일반

MAC에서 사용하는 대표적인 모델이 **벨-라파둘라 모델(Bell-LaPadula Model)**입니다. 군사용 보안 구조에서 만들어진 수학적 모델로, **기밀성 유지**에 초점을 둡니다.

**벨-라파둘라 모델의 핵심 규칙:**

| 규칙 | 설명 | 비유 |
|------|------|------|
| **단순 보안 규칙** (No Read Up) | 자신보다 **높은** 등급의 문서는 **읽을 수 없음** | 사원이 대표의 극비문서를 열람 불가 |
| **스타 무결성 규칙** (No Write Down) | 자신보다 **낮은** 등급의 객체에 **쓸 수 없음** | 과장이 사원의 문서를 함부로 수정 불가 |
| **강한 스타 무결성 규칙** | 자신과 **같은** 등급만 읽고 쓸 수 있음 | 비밀 등급 보유자는 비밀 등급 문서만 처리 |

:::note 스타 무결성 규칙이 필요한 이유
사원이 작성한 문서를 과장이 결재는 할 수 있지만, 내용을 임의로 고쳐버리면 큰 문제가 생깁니다. "내가 분명히 10만 원이라고 썼는데 과장이 100만 원으로 바꿔버렸다"와 같은 상황을 방지하기 위한 규칙입니다.
:::

### 👥 RBAC (역할 기반 접근제어, Role-Based Access Control)

**핵심 개념:** 사용자에게 직접 권한을 주는 것이 아니라, **역할(Role)**을 부여하고 그 역할에 맞는 권한을 설정하는 방식입니다.

- **통제 주체**: 역할(직책, 직무)
- **특징**: 구성 변경이 **용이**, 조직 구조 변화에 유연하게 대응
- **주요 사용처**: 기업, 조직
- **관리 명령어**: `CREATE ROLE`(역할 생성), `DROP ROLE`(역할 삭제)

> 회사에서 "팀장"이라는 역할에는 팀원 관리, 프로젝트 승인 등의 권한이 묶여 있습니다. 새로운 사람이 팀장이 되면, 그 사람에게 일일이 권한을 설정하는 것이 아니라 "팀장" 역할만 부여하면 됩니다.

**세 가지 접근제어 기법 비교:**

| 구분 | DAC (임의) | MAC (강제) | RBAC (역할) |
|------|-----------|-----------|------------|
| **통제 기준** | 소유자 재량 | 시스템 강제 | 역할(직책) |
| **보안성** | 보통 | **가장 높음** | 높음 |
| **유연성** | 높음 | 낮음 | **가장 높음** |
| **주 사용처** | 운영체제 | 정부/군사 | 기업/조직 |
| **구현 난이도** | 쉬움 | 어려움 | 보통 |

### 역할 보안 기법의 구성 요소

RBAC를 좀 더 깊이 이해하기 위해 구성 요소를 살펴보겠습니다:

- **주체(Subject)**: DB를 사용하는 사람이 누구인지 — 사용자, 응용 프로그램, 원격 컴퓨터 등
- **객체(Object)**: 보안의 대상이 되는 것 — 데이터베이스 전체, 테이블, 행(튜플), 열(속성) 등
- **조치(Operation)**: 주체가 객체에 할 수 있는 일 — 읽기, 쓰기, 수정, 삭제 등
- **규칙(Rule)**: 조치에 대한 제약 조건 — 어떤 것은 허용, 어떤 것은 거부

---

## 💻 권한 부여와 회수: GRANT와 REVOKE 명령어

데이터베이스에서 권한을 실제로 관리할 때 사용하는 핵심 SQL 명령어가 **GRANT**(부여)와 **REVOKE**(회수)입니다.

### ✅ GRANT — 권한 부여하기

GRANT 명령어의 기본 형식은 다음과 같습니다:

```sql
-- GRANT 기본 문법
GRANT 권한 ON 테이블이름 TO 사용자계정 [WITH GRANT OPTION];
-- GRANT: 권한을 부여하는 명령어
-- 권한: INSERT, DELETE, SELECT, UPDATE 등
-- ON: 어떤 테이블에 대한 것인지 지정
-- TO: 누구에게 권한을 줄 것인지 지정
-- WITH GRANT OPTION: (선택) 받은 권한을 다른 사람에게도 줄 수 있는 옵션
```

**실제 예시를 단계별로 살펴보겠습니다:**

```sql
-- ✅ 예시 1: DBA가 U1에게 Student 테이블의 삽입·삭제 권한을 부여
GRANT INSERT, DELETE ON Student TO U1;
-- 설명: U1은 Student 테이블에 데이터를 삽입(INSERT)하고 삭제(DELETE)할 수 있게 됨
-- 주의: WITH GRANT OPTION이 없으므로 U1은 이 권한을 다른 사람에게 줄 수 없음
```

```sql
-- ✅ 예시 2: DBA가 U2에게 Student 테이블의 검색 권한을 부여 (+ 전달 가능)
GRANT SELECT ON Student TO U2 WITH GRANT OPTION;
-- 설명: U2는 Student 테이블을 검색(SELECT)할 수 있게 됨
-- WITH GRANT OPTION 덕분에 U2는 자신의 SELECT 권한을 다른 사용자에게도 줄 수 있음!
```

```sql
-- ✅ 예시 3: U2가 U3에게 자신이 받은 권한을 전달
GRANT SELECT ON Student TO U3;
-- 설명: U2가 WITH GRANT OPTION을 가지고 있으므로,
-- 자신이 가진 SELECT 권한을 U3에게 줄 수 있음
-- U3는 WITH GRANT OPTION 없이 받았으므로 더 이상 다른 사람에게 전달 불가
```

:::tip WITH GRANT OPTION이란?
**WITH GRANT OPTION**은 "내가 받은 권한을 다른 사람에게도 줄 수 있는 능력"입니다. 마치 회사에서 팀장이 부장에게 받은 결재 권한을 대리에게 위임할 수 있는 것과 같습니다. 이 옵션이 없으면 받은 권한을 혼자만 사용할 수 있고, 다른 사람에게 전달할 수 없습니다.
:::

### ❌ REVOKE — 권한 회수하기

REVOKE 명령어의 기본 형식은 다음과 같습니다:

```sql
-- REVOKE 기본 문법
REVOKE 권한 ON 테이블이름 FROM 사용자계정 [CASCADE];
-- REVOKE: 권한을 회수하는 명령어
-- 권한: 회수할 권한 종류 (INSERT, DELETE, SELECT, UPDATE 등)
-- ON: 어떤 테이블에 대한 것인지 지정
-- FROM: 누구에게서 권한을 빼앗을 것인지 지정
-- CASCADE: (선택) 연쇄적으로 하위 사용자의 권한도 함께 회수
```

**실제 예시:**

```sql
-- ✅ 예시: DBA가 U2에게서 Student 테이블의 SELECT 권한을 회수
REVOKE SELECT ON Student FROM U2 CASCADE;
-- 설명: U2가 가지고 있던 Student 테이블의 검색 권한이 사라짐
-- CASCADE 때문에: U2가 U3에게 준 권한도 자동으로 함께 사라짐!
```

:::warning CASCADE의 연쇄 효과
**WITH GRANT OPTION**으로 부여된 권한은 상위 권한이 회수되면 **자동으로(CASCADE 없이도)** 하위 권한도 함께 사라집니다. 부장 → 과장 → 대리 순서로 권한이 전달되었는데 부장의 권한이 사라지면, 과장과 대리의 권한도 자동으로 소멸됩니다.

반면 **WITH ADMIN OPTION**(시스템 권한용)으로 부여된 권한은 상위 권한이 회수되어도 **하위 권한은 유지**됩니다.
:::

### 📝 종합 실습: 권한 부여·회수 시나리오 완전 분석

아래는 여러 사용자 간의 권한 흐름을 단계별로 따라가는 종합 예제입니다. 각 명령어가 실행 가능한지, 불가능한지를 하나씩 분석해 보겠습니다.

```sql
-- 1️⃣ U1이 U2에게 Employee 테이블의 INSERT, DELETE 권한을 부여
GRANT INSERT, DELETE ON Employee TO U2;
-- ✅ 실행 가능
-- U2는 Employee 테이블에 삽입·삭제 가능
-- 주의: WITH GRANT OPTION 없음 → U2는 이 권한을 다른 사람에게 줄 수 없음
```

```sql
-- 2️⃣ U1이 U3에게 Employee 테이블의 SELECT 권한을 부여 (+ 전달 가능)
GRANT SELECT ON Employee TO U3 WITH GRANT OPTION;
-- ✅ 실행 가능
-- U3는 Employee 테이블을 검색 가능
-- WITH GRANT OPTION 있음 → U3는 SELECT 권한을 다른 사람에게 줄 수 있음
```

```sql
-- 3️⃣ U2가 U4에게 Employee 테이블의 INSERT 권한을 부여하려는 시도
GRANT INSERT ON Employee TO U4;
-- ❌ 실행 불가! 에러 발생!
-- 이유: U2는 WITH GRANT OPTION 없이 권한을 받았기 때문에
-- 자신의 권한을 다른 사람에게 전달할 수 없음
```

```sql
-- 4️⃣ U3가 U5에게 Employee 테이블의 SELECT 권한을 부여
GRANT SELECT ON Employee TO U5;
-- ✅ 실행 가능
-- U3는 WITH GRANT OPTION이 있으므로 SELECT 권한을 U5에게 줄 수 있음
-- U5는 WITH GRANT OPTION 없이 받았으므로 더 이상 전달 불가
```

```sql
-- 5️⃣ U5가 U6에게 Employee 테이블의 SELECT 권한을 부여하려는 시도
GRANT SELECT ON Employee TO U6;
-- ❌ 실행 불가! 에러 발생!
-- 이유: U5는 WITH GRANT OPTION 없이 받았으므로 전달 불가
```

```sql
-- 6️⃣ U1이 U6에게 Employee 테이블의 SELECT 권한을 직접 부여
GRANT SELECT ON Employee TO U6;
-- ✅ 실행 가능
-- U1은 원래 소유자이므로 누구에게든 권한을 줄 수 있음
```

```sql
-- 7️⃣ U1이 U3의 권한을 회수
REVOKE SELECT ON Employee FROM U3 CASCADE;
-- ✅ 실행 가능
-- U3의 SELECT 권한이 사라짐
-- CASCADE 효과: U3가 U5에게 준 권한도 자동으로 함께 사라짐!
-- 즉, U5의 SELECT 권한도 없어짐
```

```sql
-- 8️⃣ U6가 Employee 테이블을 SELECT (검색)
SELECT * FROM Employee;
-- ✅ 실행 가능
-- U6는 6️⃣에서 U1에게 직접 권한을 받았으므로 U3의 회수와 무관
```

```sql
-- 9️⃣ U5가 Employee 테이블을 SELECT하려는 시도
SELECT * FROM Employee;
-- ❌ 실행 불가!
-- 이유: 7️⃣에서 U3의 권한이 회수되면서 U5의 권한도 CASCADE로 함께 사라졌기 때문
```

```sql
-- 🔟 U6가 Employee 테이블을 UPDATE하려는 시도
UPDATE Employee SET salary = 5000 WHERE id = 1;
-- ❌ 실행 불가!
-- 이유: U6는 SELECT 권한만 가지고 있음. UPDATE 권한은 받은 적 없음!
```

> **핵심 포인트:** 권한 부여·회수 명령어를 다룰 때는 ① **누가 누구에게** 줬는지, ② **WITH GRANT OPTION이 있는지** 없는지, ③ **어떤 종류의 권한**인지를 꼼꼼하게 확인해야 합니다.

---

## 🛡️ 뷰(View)를 활용한 보안

**뷰(View)**는 가장 쉽고 간단하게 보안을 관리할 수 있는 방법 중 하나입니다. 뷰는 전체 테이블에서 **필요한 부분만 골라서 보여주고, 나머지는 감추는** 역할을 합니다.

```sql
-- 원본 테이블: 전체 직원 정보 (급여 포함)
-- Employee(id, name, department, salary, ssn)

-- ✅ 뷰를 만들어서 민감 정보(급여, 주민번호)를 숨김
CREATE VIEW Employee_Public AS
SELECT id, name, department  -- 급여(salary)와 주민번호(ssn)는 제외!
FROM Employee;

-- 일반 사용자에게는 이 뷰만 조회할 수 있는 권한을 부여
GRANT SELECT ON Employee_Public TO 일반사용자;
-- 일반사용자는 id, name, department만 볼 수 있고
-- salary와 ssn은 아예 보이지 않음!
```

뷰 자체가 **데이터의 일부분만 보여주는 창문** 역할을 하기 때문에, 전체 데이터를 보호하면서 필요한 정보만 제공할 수 있습니다. 마치 사무실 유리창에 블라인드를 쳐서 외부에서는 일부분만 보이게 하는 것과 같습니다.

### 권한 부여 테이블

실무에서는 사용자별로 어떤 데이터에 어떤 권한이 있는지를 **표 형태**로 관리합니다:

| 사용자 | 데이터1 | 데이터2 | 데이터3 |
|--------|---------|---------|---------|
| U1 | 검색(R) | - | 검색+갱신(R/W) |
| U2 | - | - | - |
| U3 | - | 검색+갱신(R/W) | - |
| U4 | - | - | 접근불가(X) |

이 표를 통해 한눈에 "누가 어떤 데이터에 무엇을 할 수 있는지"를 파악할 수 있습니다.

---

## ⚠️ 주의사항과 실무 팁

### 보안 설계 시 주의할 점

:::warning 흔히 하는 실수들
1. **모든 사용자에게 과도한 권한 부여**: "귀찮으니까 전부 다 열어주자"는 가장 위험한 발상입니다. **최소 권한의 원칙**(필요한 만큼만 부여)을 지켜야 합니다.
2. **WITH GRANT OPTION 남발**: 권한 전달 옵션을 무분별하게 주면 통제 불가능한 상황이 됩니다. 꼭 필요한 경우에만 사용하세요.
3. **CASCADE 효과 미고려**: 상위 사용자의 권한을 회수할 때, 하위 사용자들에게 미치는 연쇄 효과를 반드시 확인해야 합니다.
4. **SQL 인젝션 대비 미흡**: 사용자 입력값을 그대로 SQL에 넣지 말고, 반드시 **파라미터화된 쿼리(Parameterized Query)**를 사용하세요.
:::

### SQL 인젝션 방어 코드 예시

```python
# ❌ 잘못된 방법: 사용자 입력을 직접 SQL에 삽입 (SQL 인젝션에 취약!)
user_id = input("학생 ID를 입력하세요: ")
query = "SELECT * FROM 학생 WHERE id = " + user_id  # 위험!
# 해커가 user_id에 "100 OR 1=1" 같은 값을 넣으면 모든 데이터가 유출됨
cursor.execute(query)
```

```python
# ✅ 올바른 방법: 파라미터화된 쿼리 사용 (SQL 인젝션 방어!)
user_id = input("학생 ID를 입력하세요: ")
query = "SELECT * FROM 학생 WHERE id = %s"  # %s는 자리표시자(placeholder)
cursor.execute(query, (user_id,))  # 사용자 입력이 자동으로 이스케이핑됨
# 해커가 "100 OR 1=1"을 넣어도, 문자열로 처리되어 공격이 무력화됨
```

위 코드를 한 줄씩 설명하겠습니다:
- `user_id = input(...)`: 사용자로부터 학생 ID를 입력받습니다.
- `query = "SELECT * FROM 학생 WHERE id = %s"`: SQL 쿼리에 **자리표시자(%s)**를 사용합니다. 직접 값을 넣지 않는 것이 핵심입니다.
- `cursor.execute(query, (user_id,))`: 데이터베이스 드라이버가 `user_id` 값을 **안전하게 이스케이핑**하여 쿼리에 삽입합니다. 특수 문자가 포함되어 있어도 코드로 실행되지 않고 순수한 문자열로 처리됩니다.

### DDoS 방어 팁

- **비정상 트래픽 탐지 시스템** 도입: 갑자기 특정 IP에서 비정상적으로 많은 요청이 들어오면 자동 차단
- **세션 강제 종료**: 좀비 PC로 판단되는 접속을 즉시 끊어버리기
- **블록체인 기술 활용**: 데이터를 전 세계에 분산 저장하여 한 곳을 공격해도 서비스가 유지되도록 구성
- **CDN(Content Delivery Network) 활용**: 트래픽을 여러 서버로 분산시켜 한 곳에 집중되지 않게 처리

---

## 📌 핵심 정리

- **데이터베이스 보안 관리 방법**은 크게 **접근제어**, **정보 흐름 제어**, **추론 제어** 세 가지로 나뉜다
- **접근제어**는 사용자가 DB에 들어올 수 있는 자격이 있는지 확인하는 것이다 (출입문 경비원)
- **정보 흐름 제어**는 데이터가 전달되는 과정에서 중간에 변조·위조되지 않도록 통제하는 것이다 (택배 호위병)
- **추론 제어**는 공개된 데이터를 분석해 비밀 정보를 알아내는 것을 방지하는 기술이다 (노이즈 데이터 삽입 등)
- **DDoS 공격**은 좀비 PC를 이용해 서버의 동시 접속 한계를 초과시켜 마비시키는 분산 서비스 거부 공격이다
- **SQL 인젝션**은 SQL 코드에 악성 코드를 주입하는 공격으로, 난이도는 낮지만 파괴력이 매우 크다
- **DAC(임의 접근제어)**는 소유자가 재량으로 권한을 부여하는 방식이다 (ID/패스워드 기반)
- **MAC(강제 접근제어)**는 문서에 등급을 부여하고 시스템이 강제로 통제하는 방식이다 (극비/비밀/대외비/일반)
- **RBAC(역할 기반 접근제어)**는 역할(직책)에 따라 권한을 관리하는 방식으로, 기업에서 주로 사용된다
- **GRANT**는 권한을 부여하는 명령어, **REVOKE**는 권한을 회수하는 명령어이다
- **WITH GRANT OPTION**이 있으면 받은 권한을 다른 사람에게도 전달할 수 있다
- **CASCADE**로 상위 권한이 회수되면 하위 사용자의 권한도 연쇄적으로 사라진다
- **뷰(View)**는 테이블의 일부분만 보여줌으로써 가장 간단하게 보안을 구현하는 방법이다
- **벨-라파둘라 모델**은 "위로 읽기 불가(No Read Up), 아래로 쓰기 불가(No Write Down)" 규칙의 군사용 보안 모델이다
- SQL 인젝션 방어를 위해 **파라미터화된 쿼리**와 **시큐어 코딩** 기법을 반드시 사용해야 한다

작성일: 2026-02-21