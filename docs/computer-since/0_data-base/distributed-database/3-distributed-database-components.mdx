---
title: "분산 데이터베이스의 구성 요소"
description: "분산 데이터베이스의 구성 요소에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/distributed-database/3-distributed-database-components"
sidebar_label: "구성 요소"
date: "2026-02-21"
---

# 🌐 분산 데이터베이스의 구성 요소

여러분은 매일 네이버나 구글을 사용하면서 단 한 번도 "서버가 어디 있지?"라고 생각해 본 적이 없을 겁니다. 그냥 주소창에 `naver.com`을 입력하면 바로 접속이 되죠. 이 당연해 보이는 현상 뒤에는 **분산 데이터베이스**라는 복잡하고 정교한 기술이 숨어 있습니다. 이 문서에서는 분산 데이터베이스가 무엇인지, 어떤 구성 요소로 이루어져 있는지, 그리고 어떻게 데이터를 쪼개고 저장하는지를 입문자도 이해할 수 있도록 아주 친절하게 설명합니다.

---

## 🏛️ 분산 데이터베이스란 무엇인가?

### 개념 소개

**분산 데이터베이스(Distributed Database)**란, 지리적으로 그리고 물리적으로 서로 다른 곳에 나뉘어 있는 여러 데이터베이스들을, 사용자 입장에서는 마치 **하나의 중앙 집중 데이터베이스처럼** 사용할 수 있도록 만든 시스템입니다.

조금 더 쉽게 비유해 볼까요? 전국에 수십 개의 지점을 가진 은행이 있다고 생각해 보세요. 서울 지점, 부산 지점, 광주 지점 각각에 금고가 따로 있고, 각 지점이 자기 고객의 정보를 관리합니다. 그런데 고객 입장에서는 어느 지점을 방문하든 자신의 계좌 잔액을 확인하고, 돈을 뽑을 수 있습니다. 실제 데이터는 여러 곳에 분산되어 있지만, 고객은 그것을 전혀 알 필요가 없는 것이죠. 이것이 바로 분산 데이터베이스의 핵심 개념입니다.

> 💡 **핵심 정의**: 분산 데이터베이스는 물리적으로는 여러 곳에 나뉘어 있지만, 사용자에게는 하나의 통합된 시스템처럼 보이는 데이터베이스 시스템이다.

### 왜 분산 데이터베이스가 필요한가?

중앙 집중 방식의 데이터베이스(Central Database)는 서버 한 대에 모든 데이터를 저장하고, 모든 사용자가 그 서버에 접속하는 구조입니다. 마치 도서관이 딱 한 곳에만 있어서, 전국 모든 사람이 그 도서관 하나만 이용해야 하는 상황과 같습니다. 사람이 많아지면 줄이 길어지고, 도서관이 불타면 책이 모두 사라지겠죠.

이런 문제를 해결하기 위해 등장한 것이 분산 데이터베이스입니다. 네이버, 구글, 카카오 같은 대형 서비스들은 전 세계 수억 명의 사용자를 감당하기 위해 서버를 전 세계 여러 곳에 분산시켜 운영합니다. 사용자는 서버가 서울에 있는지, 미국에 있는지 전혀 몰라도 됩니다. 시스템이 알아서 가장 가까운, 가장 빠른 서버로 연결해 주니까요.

:::info 투명성(Transparency)이란?
분산 데이터베이스에서 **투명성**이라는 단어는 일상적인 의미와 반대입니다. 일상에서 투명하다 = 속이 다 보인다는 뜻이지만, 데이터베이스에서 투명성은 **"사용자가 알 필요가 없다"**, **"사용자에게 숨겨져 있다"**는 뜻입니다. 즉, 시스템이 복잡한 작업을 뒤에서 처리해 주기 때문에 사용자는 그 복잡함을 인식하지 않아도 된다는 의미입니다.
:::

---

## ⚙️ 분산 데이터베이스의 핵심 구성 요소

분산 데이터베이스 시스템은 크게 세 가지 핵심 구성 요소로 이루어져 있습니다. 각각의 역할을 이해하면 전체 시스템이 어떻게 동작하는지 쉽게 파악할 수 있습니다.

### 🖥️ 1. 분산 처리기 (Distributed Processor)

**분산 처리기**란 각 지역(사이트)에 있는 서버 컴퓨터를 말합니다. 쉽게 말해, 서울에 있는 서버, 부산에 있는 서버, 광주에 있는 서버가 각각 분산 처리기입니다. 각 처리기는 자기 지역의 데이터베이스를 직접 관리하고 처리합니다.

이 개념은 마치 **지방자치제**와 같습니다. 서울시는 서울의 일을 서울 예산으로 처리하고, 부산시는 부산의 일을 부산이 관리합니다. 각 지역이 자체적으로 처리할 수 있기 때문에, 우리는 이것을 **자치 처리기**라고도 부릅니다. 서울의 일을 굳이 부산에 가서 처리할 필요가 없는 것처럼, 각 지역 처리기는 자기 지역 데이터를 자체적으로 처리합니다.

### 🗄️ 2. 분산 데이터베이스 (Distributed Database)

**분산 데이터베이스**는 각 지역의 처리기에 연결된 실제 데이터 저장소입니다. 서울 처리기에는 서울의 데이터베이스가, 부산 처리기에는 부산의 데이터베이스가 연결되어 있습니다. 하나의 거대한 데이터베이스가 지리적으로 나뉘어 각 지역에 저장된 형태입니다.

예를 들어, 전국 체인 편의점의 판매 데이터베이스를 생각해보면, 서울 지역 판매 데이터는 서울 데이터베이스에, 부산 지역 판매 데이터는 부산 데이터베이스에 저장될 수 있습니다. 전체를 보면 하나의 거대한 판매 데이터베이스이지만, 물리적으로는 여러 곳에 나뉘어져 있는 것이죠.

### 🌐 3. 통신 네트워크 (Communication Network)

**통신 네트워크**는 서울, 부산, 광주에 흩어져 있는 분산 처리기와 분산 데이터베이스들을 하나로 연결하는 인터넷 망입니다. 마치 전국 도로망처럼, 각 지역을 연결하는 고속도로 역할을 합니다.

사용자는 특정 서버에 직접 접속하는 것이 아니라, 이 네트워크 망에 연결만 하면 됩니다. 그러면 시스템이 **라우팅(최적 경로 탐색)**을 통해 자동으로 가장 적합한 서버로 연결해 줍니다. 네비게이션이 목적지까지 최적 경로를 알아서 찾아주는 것처럼요.

| 구성 요소 | 역할 | 실생활 비유 |
|---|---|---|
| **분산 처리기** | 각 지역의 데이터를 처리하는 서버 | 지방자치단체 (시청, 구청) |
| **분산 데이터베이스** | 각 지역에 저장된 실제 데이터 | 지역 도서관의 장서 |
| **통신 네트워크** | 모든 사이트를 연결하는 인터넷 망 | 전국 고속도로망 |

:::tip 분산 DBMS의 역할
분산 데이터베이스를 효율적으로 관리하기 위해서는 **분산 DBMS(Distributed Database Management System)**가 필요합니다. 이 소프트웨어는 복잡한 분산 구조를 사용자에게 투명하게(숨겨서) 처리해 줍니다. 여러 서버에 데이터가 어떻게 나뉘어 있는지, 어떤 서버에서 처리할지 등을 모두 분산 DBMS가 알아서 처리해 주기 때문에, 사용자는 그냥 데이터를 요청하면 됩니다.
:::

---

## ✅ 분산 데이터베이스의 장점과 단점

### 👍 장점

#### 1. 지역 자치성
각 지역의 데이터베이스는 해당 지역의 처리기가 자체적으로 관리합니다. 서울의 데이터는 서울 서버가, 부산의 데이터는 부산 서버가 책임지고 관리하면 되므로, 의사결정과 처리가 빠르고 효율적입니다. 중앙에서 모든 것을 통제할 필요가 없어 독립적인 운영이 가능합니다.

#### 2. 용량 확장의 용이성
새로운 지역에 서비스가 필요할 때, 기존 시스템을 건드리지 않고 새 서버와 데이터베이스를 네트워크에 연결하기만 하면 됩니다. 예를 들어, 대전에 새로운 공장이 생겨서 생산 데이터베이스가 필요해졌다면, 대전에 서버를 설치하고 네트워크에 연결만 하면 끝입니다. 반대로 필요 없어지면 네트워크에서 분리하면 되죠. 마치 멀티탭에 콘센트를 꽂고 뽑는 것처럼 간단합니다.

#### 3. 신뢰성과 가용성 향상
**가용성(Availability)**이란 시스템이 얼마나 지속적으로 사용 가능한 상태를 유지하는가를 나타냅니다. 같은 데이터를 서울, 부산, 광주 여러 곳에 복제해 두면, 만약 지진이나 해킹으로 서울과 부산 서버가 손상되더라도 광주 서버에 남아 있는 데이터로 서비스를 계속할 수 있습니다. 중앙 집중 방식이었다면 그 하나의 서버가 고장났을 때 전체 서비스가 중단되었겠지만, 분산 방식에서는 일부 서버가 다운되어도 나머지 서버들이 그 역할을 대신합니다.

#### 4. 효율성과 융통성
부산에 갑자기 백화점이 생겨서 판매 트래픽이 급증했다면, 부산 서버에 판매 데이터베이스를 추가하면 됩니다. 해당 지역에서 가장 많이 요청되는 데이터를 그 지역 서버에 저장함으로써 네트워크 비용을 줄이고, 데이터 이동 거리를 최소화해 처리 속도를 높일 수 있습니다.

#### 5. 자료 공유와 분산 제어 (연산 속도 향상)
같은 데이터를 여러 곳에서 동시에 병렬(Parallel)로 처리할 수 있습니다. 만약 어떤 대용량 데이터를 처리하는데 혼자 하면 30분이 걸린다고 가정해 보세요. 이것을 서울, 부산, 광주 세 군데로 나눠서 동시에 처리하면 약 10분이면 완료됩니다. 이것이 바로 분산 제어를 통한 연산 속도 향상입니다.

### 👎 단점

#### 1. 비용 증가
중앙 집중 방식이라면 서버 하나, DBMS 하나만 있으면 됩니다. 하지만 분산 방식은 각 지역마다 서버, 분산 DBMS, 네트워크 장비, 관리 인력이 필요합니다. 소프트웨어 개발 비용, 서버 구축 비용, 네트워크 망 구축 비용 모두 증가할 수밖에 없습니다.

#### 2. 숨겨진 오류와 보안 위험
인터넷 네트워크는 전 세계 수십만 개의 서버가 거미줄처럼 복잡하게 연결된 구조입니다. 이처럼 복잡한 구조에서는 어느 지점에서 오류가 발생할지, 어디를 통해 해킹 공격이 들어올지 완벽하게 예측하고 통제하기 어렵습니다. 복잡함 속에 항상 잠재적인 위험이 숨어 있는 것이죠.

| 구분 | 내용 |
|---|---|
| ✅ **지역 자치성** | 각 지역이 자체적으로 데이터 관리 가능 |
| ✅ **용량 확장** | 새 서버 추가/제거가 쉬움 |
| ✅ **신뢰성·가용성** | 일부 서버 장애에도 서비스 유지 |
| ✅ **효율성·융통성** | 지역별 최적화된 데이터 배치 |
| ✅ **연산 속도** | 병렬 처리로 빠른 연산 |
| ❌ **비용 증가** | 구축·운영 비용이 높음 |
| ❌ **숨겨진 오류** | 복잡한 네트워크로 인한 잠재적 위험 |

---

## 🎯 분산 데이터베이스의 투명성 목표

분산 데이터베이스가 반드시 달성해야 하는 목표들이 있습니다. 이 목표들은 모두 **"사용자가 복잡한 내부 구조를 몰라도 된다"**는 투명성과 관련이 있습니다.

### 📍 위치 투명성 (Location Transparency)

사용자는 원하는 데이터가 **어느 서버에 저장되어 있는지 알 필요가 없습니다**. 시스템이 알아서 찾아줍니다.

여러분이 `naver.com`을 입력할 때 뒤에 서버 위치를 붙여 `naver.com/server=seoul`이라고 쓸 필요가 없죠. 그냥 `naver.com`만 입력하면 됩니다. 지하철을 탈 때 목적지 역 이름만 알면 되고, 그 역이 몇 번 터널을 지나 어떤 경로로 연결되어 있는지 몰라도 되는 것과 같습니다.

데이터의 위치 정보는 **분산 시스템 카탈로그(Distributed System Catalog)**라는 곳에서 관리됩니다. 이 카탈로그가 "이 데이터는 서울에 있다", "저 데이터는 부산에 있다"는 정보를 기록하고 있어서, 사용자 대신 시스템이 적절한 서버로 요청을 라우팅(경로 지정)합니다.

### 🔁 중복 투명성 (Replication Transparency)

분산 데이터베이스에서는 가용성과 처리 속도를 높이기 위해 같은 데이터를 여러 곳에 **중복 저장**합니다. 예를 들어 학생 데이터베이스가 서울에도, 부산에도 동일하게 복사되어 있을 수 있습니다.

이때 사용자는 이 데이터가 몇 군데에 복사되어 있는지, 어느 곳의 복사본을 읽어오는지 알 필요가 없습니다. 분산 DBMS가 알아서 가장 빠른 곳에서 데이터를 가져오고, 데이터를 수정할 때는 모든 복사본에 동일하게 반영해 줍니다. 이것이 **중복 투명성**입니다.

중복 저장 방식에는 두 가지가 있습니다:

- **완전 중복(Full Replication)**: 전체 데이터베이스를 서울, 부산, 광주 모두에 100% 동일하게 복사. 가용성이 가장 높지만 저장 공간 낭비가 심합니다.
- **부분 중복(Partial Replication)**: 데이터베이스를 쪼개서 일부는 서울에, 일부는 부산에 저장하고 일부만 겹치게 중복. 효율적이지만 관리가 복잡합니다.

:::note 중복이 왜 필수인가?
중복 저장 없이 데이터를 딱 한 곳에만 저장한다면, 그 서버가 고장났을 때 해당 데이터에 접근이 불가능해집니다. 가용성이 급격히 떨어지는 것이죠. 중복 저장이 있어야만 서버 장애 시에도 다른 서버에서 같은 데이터를 제공할 수 있고, 병렬 처리도 가능해집니다.
:::

---

## 🔪 단편화(Fragmentation): 데이터를 어떻게 쪼개는가?

### 단편화란 무엇인가?

**단편화(Fragmentation)**는 하나로 되어 있는 큰 테이블을 여러 개의 조각(단편)으로 쪼개는 작업입니다. 피자 한 판을 여러 조각으로 나누듯이, 하나의 데이터베이스 테이블을 여러 부분으로 나눠서 각 지역에 분산 저장하는 것이죠.

단편화를 하는 이유는 분산 저장의 효율을 높이기 위해서입니다. 서울 사람들에게 필요한 데이터는 서울 서버에, 부산 사람들에게 필요한 데이터는 부산 서버에 저장하면 불필요한 네트워크 트래픽 없이 빠르게 데이터를 가져올 수 있습니다. 단편화는 **관계대수(Relational Algebra)**의 셀렉션(Selection)과 프로젝션(Projection) 연산을 통해 수행됩니다.

### 📐 분산 데이터베이스의 4가지 스키마

단편화와 저장 과정을 이해하기 위해 4가지 스키마(Schema, 구조 설계도) 개념을 알아야 합니다.

```
[전역 스키마] → [단편화 스키마] → [할당 스키마] → [지역 사상 스키마]
    ↓                 ↓                  ↓                   ↓
전체 테이블       쪼개진 단편들       어느 지역에?        실제 저장
```

| 스키마 이름 | 역할 | 비유 |
|---|---|---|
| **전역 스키마** | 원본 전체 테이블 (쪼개기 전) | 원본 피자 한 판 |
| **단편화 스키마** | 테이블을 여러 단편으로 쪼갬 | 피자를 조각으로 나눔 |
| **할당 스키마** | 각 단편을 어느 지역에 배치할지 결정 | 조각을 각 접시에 배분 |
| **지역 사상 스키마** | 실제 물리적 저장소에 매핑(저장) | 접시를 각 자리에 실제로 놓음 |

### ↔️ 수평 단편화 (Horizontal Fragmentation)

**수평 단편화**는 테이블을 **행(Row) 단위**로 쪼개는 방식입니다. 테이블을 가로로 잘라서 위쪽 절반, 아래쪽 절반으로 나누는 것을 상상하면 됩니다. 이때 **셀렉션(Selection)** 연산을 사용합니다.

예를 들어, 학생 테이블을 학과 기준으로 쪼개보겠습니다:

```sql
-- 🔴 원본 학생 테이블 (전역 릴레이션)
-- 학번 | 이름 | 학년 | 학과
-- 1001 | 김철수 | 2 | 컴퓨터공학
-- 1002 | 이영희 | 3 | 경영학
-- 1003 | 박민준 | 1 | 컴퓨터공학
-- 1004 | 최수진 | 4 | 경영학

-- ✅ 수평 단편화 1번: 컴퓨터공학과 학생만 선택 (서울 서버에 할당)
SELECT * FROM 학생 WHERE 학과 = '컴퓨터공학';
-- 결과: 김철수, 박민준 행

-- ✅ 수평 단편화 2번: 경영학과 학생만 선택 (부산 서버에 할당)
SELECT * FROM 학생 WHERE 학과 = '경영학';
-- 결과: 이영희, 최수진 행
```

수평 단편화의 특징:
- **합집합(UNION)** 연산으로 원래 테이블을 복원할 수 있습니다. (1번 단편 ∪ 2번 단편 = 원본 테이블)
- 두 단편 사이의 **교집합은 공집합**입니다. (컴퓨터공학이면서 경영학인 학생은 없음)
- 데이터의 **값이 바뀌면 단편의 위치가 바뀔 수 있어** 이를 **동적 단편화**라고 합니다. (학과가 바뀌면 다른 단편으로 이동)

### ↕️ 수직 단편화 (Vertical Fragmentation)

**수직 단편화**는 테이블을 **열(Column, 속성) 단위**로 쪼개는 방식입니다. 테이블을 세로로 잘라서 왼쪽 절반, 오른쪽 절반으로 나누는 것입니다. 이때 **프로젝션(Projection)** 연산을 사용합니다.

```sql
-- 🔴 원본 학생 테이블 (전역 릴레이션)
-- 학번 | 이름 | 학년 | 학과 | 성적 | 지도교수

-- ✅ 수직 단편화 1번: 기본 신상 정보 (서울 서버)
-- 학번(기본키 포함 필수!) | 이름 | 학년 | 학과
SELECT 학번, 이름, 학년, 학과 FROM 학생;

-- ✅ 수직 단편화 2번: 학업 정보 (부산 서버)
-- 학번(기본키 포함 필수!) | 성적 | 지도교수
SELECT 학번, 성적, 지도교수 FROM 학생;
```

:::warning 수직 단편화 시 기본키 필수 포함!
수직 단편화를 할 때는 반드시 **모든 단편에 기본키(Primary Key)를 포함**시켜야 합니다. 나중에 단편들을 다시 합칠 때(조인할 때) 기본키를 기준으로 연결하기 때문입니다. 기본키 없이 쪼개면 나중에 원본 테이블을 복원할 수 없습니다!
:::

수직 단편화의 특징:
- **자연 조인(Natural Join)** 연산으로 원래 테이블을 복원합니다. (학번을 기준으로 두 단편을 조인)
- 두 단편의 속성을 합치면 원래 속성이 모두 나옵니다.
- 값이 바뀌어도 어느 단편에 속하는지는 변하지 않아 **정적 단편화**라고 합니다.

### 🔀 혼합 단편화 (Mixed Fragmentation)

**혼합 단편화**는 수평 단편화와 수직 단편화를 함께 사용하는 방식입니다. 테이블을 먼저 행으로 쪼개고, 다시 열로 쪼갤 수도 있고, 반대 순서도 가능합니다. 원본 테이블을 복원하려면 **자연 조인과 합집합을 모두** 사용해야 합니다.

```
혼합 단편화 원본 복원 방법:
단편A + 단편B (합집합) → 수평 복원
수평 복원된 것 JOIN 단편C (자연 조인) → 최종 원본 테이블
```

### 📦 할당 (Allocation): 단편을 어디에 배치할까?

단편화가 끝나면 만들어진 단편들을 각 지역 사이트에 **할당(배치)**해야 합니다. 어느 지역 서버에 어느 단편을 저장할 것인지 결정하는 단계입니다.

예를 들어 단편 1번, 2번, 3번이 있다면:
- 서울 서버: 단편 1번, 2번
- 부산 서버: 단편 1번, 2번, 3번 (1번, 2번은 중복)
- 광주 서버: 단편 3번

이렇게 중복 저장도 가능하고, 특정 단편만 저장하는 것도 가능합니다. 할당이 완료되면 **지역 사상 스키마**를 통해 실제 물리적 저장소에 데이터가 매핑(저장)됩니다.

---

## 🔄 트랜잭션 관리: 2단계 완료 규약과 3단계 완료 규약

### 트랜잭션 관리자와 조정자

분산 데이터베이스에서는 데이터 무결성을 유지하기 위해 두 가지 중요한 역할이 있습니다.

**트랜잭션 관리자(Transaction Manager)**는 각 지역 사이트마다 존재하며, 자기 지역의 데이터베이스 작업을 관리합니다. 병행 제어(동시 접근 관리), 회복(장애 복구), 권한 검사, 무결성 검사 등을 담당합니다. 중앙 집중 데이터베이스에도 있는 개념입니다.

**트랜잭션 조정자(Transaction Coordinator, Coordinator)**는 분산 데이터베이스에만 필요한 특별한 역할입니다. 여러 지역에 걸쳐 있는 트랜잭션(작업 묶음)을 중간에서 통제하고 조정합니다. 예를 들어 서울, 부산, 광주 세 곳의 데이터를 동시에 수정해야 할 때, 세 곳 모두 정상적으로 처리되도록 조율하는 역할입니다.

### 🤝 2단계 완료 규약 (2-Phase Commit Protocol)

분산 환경에서 여러 서버에 동일한 트랜잭션을 적용할 때, 모든 서버가 동시에 성공해야 합니다. 일부만 성공하고 일부는 실패하면 데이터 일관성이 깨집니다. 이를 방지하기 위한 것이 **2단계 완료 규약**입니다.

예를 들어, 학생 데이터의 값 A를 B로 바꾸는 작업이 서울, 부산, 광주 세 곳에 동시에 적용되어야 한다고 가정해 보겠습니다.

**1단계: 준비(Prepare) 단계**

```
[조정자] → [서울] : "A를 B로 바꿀 준비 됐습니까?"
[조정자] → [부산] : "A를 B로 바꿀 준비 됐습니까?"
[조정자] → [광주] : "A를 B로 바꿀 준비 됐습니까?"

[서울]  → [조정자] : "OK, 준비 완료!"
[부산]  → [조정자] : "OK, 준비 완료!"
[광주]  → [조정자] : "OK, 준비 완료!"
```

**2단계: 커밋(Commit) 또는 롤백(Rollback) 단계**

```
모든 참여자가 준비 완료라고 응답한 경우:
[조정자] → [서울, 부산, 광주] : "커밋(COMMIT) 하세요!" → 모두 변경 반영

하나라도 준비 안 됐다고 응답한 경우:
[조정자] → [서울, 부산, 광주] : "롤백(ROLLBACK) 하세요!" → 모두 작업 취소
```

:::danger 부분 커밋은 절대 안 됩니다!
서울과 부산은 A→B로 변경됐는데 광주는 아직 A인 상태로 남아 있다면, 같은 데이터가 세 서버에서 서로 다른 값을 갖게 됩니다. 이것은 **데이터 무결성(Data Integrity) 위반**이며, 시스템 전체의 신뢰성을 무너뜨립니다. 2단계 완료 규약은 이런 상황을 원천 차단하기 위해 **"모두 성공하거나, 모두 실패하거나"** 원칙(원자성, Atomicity)을 보장합니다.
:::

### 🛡️ 3단계 완료 규약 (3-Phase Commit Protocol)

2단계 완료 규약에는 한 가지 치명적인 약점이 있습니다. 만약 **조정자 자체가 장애를 일으켜 응답을 못하면** 어떻게 될까요? 서울, 부산, 광주의 참여자들은 커밋해야 할지 롤백해야 할지 알 수 없어 무한정 기다리게 됩니다. 이 상태를 **봉쇄(Blocking)** 상태라고 합니다.

이 문제를 해결하기 위해 등장한 것이 **3단계 완료 규약**입니다. 핵심 아이디어는 조정자가 알고 있는 정보를 참여자들도 공유하게 만드는 것입니다.

**3단계 완료 규약의 구조:**
1. **준비(Prepare) 단계**: 2단계와 동일하게 준비 여부 확인
2. **예비 완료(Pre-Commit) 단계**: 조정자가 커밋하겠다는 의사를 미리 참여자들에게 전달. 참여자들은 이 정보를 기록해 둠.
3. **커밋(Commit) 단계**: 최종 커밋 명령

만약 2단계와 3단계 사이에 조정자가 장애를 일으키더라도, 참여자들은 **예비 완료 단계에서 받은 정보**를 기반으로 트랜잭션의 운명을 스스로 결정할 수 있습니다. 단, 이를 위해서는 최소한 하나의 참여자 사이트는 정상적으로 작동하고 있어야 합니다.

> 💡 **요약**: 2단계 완료 규약은 데이터 일관성을 보장하고, 3단계 완료 규약은 조정자 장애 시에도 시스템이 멈추지 않도록 보장합니다.

---

## 🏗️ 클라이언트-서버 구조: 2티어와 3티어

### 2티어 모델 (2-Tier Model)

**클라이언트-서버(Client-Server)** 구조는 1980년대부터 지금까지 사용되어 온 기본적인 네트워크 구조입니다. 2티어 모델은 **클라이언트**와 **서버** 두 계층으로만 구성됩니다.

2티어 구조에서 클라이언트는 두 가지 일을 모두 담당합니다:
- **프레젠테이션 로직(Presentation Logic)**: 화면에 표시하고 사용자 입력을 받는 역할
- **비즈니스 로직(Business Logic)**: 실제 업무 처리 로직 (계산, 규칙 적용 등)

클라이언트가 일을 너무 많이 하기 때문에 이런 클라이언트를 **팻 클라이언트(Fat Client, 뚱뚱한 클라이언트)**라고 부릅니다. 문제점은 비즈니스 로직이 변경될 때마다 모든 클라이언트 프로그램을 일일이 업데이트해야 한다는 것입니다. 클라이언트 수가 수천 대라면 유지보수 비용이 엄청납니다.

```
❌ 2티어 구조 (클라이언트가 너무 많은 일을 함)

[클라이언트]                    [데이터베이스 서버]
 - 프레젠테이션 로직     ←→      - 데이터 저장/조회
 - 비즈니스 로직
 (클라이언트 성능 저하, 유지보수 어려움)
```

### 3티어 모델 (3-Tier Model)

**3티어 모델**은 2티어의 단점을 개선한 구조입니다. 클라이언트가 담당하던 **비즈니스 로직을 별도의 중간 서버(미들웨어 서버, Middleware Server)**로 분리합니다.

```
✅ 3티어 구조 (역할이 명확하게 분리됨)

[클라이언트]      [애플리케이션 서버]      [데이터베이스 서버]
 - 프레젠테이션  ←→  - 비즈니스 로직   ←→   - 데이터 저장/조회
   로직만 담당         (Tomcat, 웹 서버)
```

3티어 구조의 장점:
- 클라이언트는 화면 표시만 하면 되므로 **가볍고(Thin Client) 성능이 좋아집니다**
- 비즈니스 로직이 서버에 있으므로 변경 시 **서버 한 곳만 수정하면 됩니다**
- **현재 대부분의 웹 서비스**가 이 구조를 사용합니다 (Apache Tomcat, Nginx + Spring Boot 등)

:::tip 웹 개발에서 3티어 구조
여러분이 JSP, Spring, Node.js 등으로 웹 개발을 해보셨다면 이미 3티어 구조를 사용한 것입니다. 브라우저(클라이언트) → Tomcat/Spring(애플리케이션 서버) → MySQL/Oracle(데이터베이스 서버)의 구조가 바로 3티어 모델입니다.
:::

---

## 🧩 객체 지향 데이터베이스와 객체 관계 데이터베이스

### 기존 관계형 데이터베이스의 한계

기존의 **관계형 데이터베이스(RDBMS)**는 정형화된 테이블 구조로 데이터를 저장합니다. 학생 정보, 주문 정보처럼 구조가 명확한 데이터는 잘 처리하지만, 다음과 같은 한계가 있습니다:
- **멀티미디어 데이터**(이미지, 동영상, 음성)처럼 비구조적인 데이터 저장이 어렵습니다
- **다중값 속성** 처리가 불가능합니다 (하나의 칸에 여러 값을 넣기 어려움)
- **상속(Inheritance), 일반화, 집단화** 같은 객체 지향 개념을 사용할 수 없습니다

### 객체 지향 데이터베이스 (Object-Oriented Database)

**객체 지향 데이터베이스(OODB)**는 객체 지향 프로그래밍의 개념을 데이터베이스에 적용한 것입니다. 주요 개념들을 살펴보겠습니다.

#### 다형성 (Polymorphism)

**다형성**이란 서로 다른 객체가 동일한 메시지(메서드 호출)에 대해 각자 다른 방식으로 응답하는 특성입니다.

```java
// ✅ 다형성 예시
class 도형 {
    void 그리기() { } // 부모 클래스의 메서드
}

class 삼각형 extends 도형 {
    void 그리기() { System.out.println("△ 삼각형을 그립니다"); }
}

class 사각형 extends 도형 {
    void 그리기() { System.out.println("□ 사각형을 그립니다"); }
}

class 원 extends 도형 {
    void 그리기() { System.out.println("○ 원을 그립니다"); }
}

// "그리기"라는 동일한 메시지에 각 객체가 다르게 반응
도형[] 도형들 = {new 삼각형(), new 사각형(), new 원()};
for (도형 d : 도형들) {
    d.그리기(); // 같은 메서드 호출이지만 결과가 다름
}
```

#### 오버로딩 (Overloading)과 오버라이딩 (Overriding)

```java
// ✅ 오버로딩: 같은 이름의 메서드, 매개변수만 다르게
class 계산기 {
    int 더하기(int a, int b) { return a + b; }           // 2개 입력
    int 더하기(int a, int b, int c) { return a + b + c; } // 3개 입력
    // 같은 이름이지만 매개변수 개수가 다름 → 오버로딩
}

// ✅ 오버라이딩: 부모 메서드를 자식이 완전히 재정의
class 부모계산기 {
    int 계산(int a, int b) { return a + b; } // 더하기
}

class 자식계산기 extends 부모계산기 {
    @Override
    int 계산(int a, int b) { return a * b; } // 곱하기로 재정의 → 오버라이딩
}
```

#### 캡슐화 (Encapsulation)와 정보 은닉 (Information Hiding)

**캡슐화**는 속성(데이터)과 메서드(기능)를 하나의 클래스로 묶고, 내부 구현을 외부에 숨기는 것입니다. 마치 TV의 내부 회로를 몰라도 리모컨 버튼만 누르면 작동하는 것처럼, 사용자는 사용 방법만 알면 됩니다.

```java
// ✅ 캡슐화 예시
class 학생 {
    private String 이름;  // 외부에서 직접 접근 불가 (정보 은닉)
    private int 성적;     // 외부에서 직접 접근 불가

    // 사용자는 이 메서드만 알면 됨 (사용법만 공개)
    public String 이름가져오기() { return 이름; }
    public void 이름설정하기(String 이름) { this.이름 = 이름; }
}
```

#### 객체 식별자 (Object Identifier, OID)

관계형 데이터베이스에서는 기본키(Primary Key)로 레코드를 식별하지만, 객체 지향 데이터베이스에서는 **OID(Object Identifier)**로 객체를 식별합니다.

OID의 특징:
- **시스템이 자동으로 생성·부여**합니다. 사용자가 지정하지 않습니다.
- **절대 변경되지 않습니다**. 객체의 속성 값이 바뀌어도 OID는 그대로입니다.
- **객체마다 유일(Unique)**합니다. 같은 OID를 가진 두 객체는 존재할 수 없습니다.
- **객체가 삭제될 때만** OID도 삭제됩니다. 삭제된 OID는 재사용 불가합니다.

이는 사람의 지문이나 홍채처럼, 태어날 때부터 정해지며 죽을 때까지 변하지 않고, 어떤 두 사람도 동일한 지문을 가질 수 없는 것과 같은 원리입니다.

| 구분 | 관계형 DB | 객체 지향 DB |
|---|---|---|
| 식별 방법 | 기본키 (사용자 지정) | OID (시스템 자동 부여) |
| 변경 가능 여부 | 변경 가능 | 절대 변경 불가 |
| 재사용 | 가능 | 불가능 |
| 비유 | 학번, 사원번호 | 지문, 홍채 |

### 객체 지향 DB vs 객체 관계 DB 비교

**객체 관계 데이터베이스(Object-Relational Database)**는 기존 관계형 데이터베이스의 편리함과 객체 지향의 강력함을 합친 하이브리드 방식입니다.

| 비교 항목 | 관계형 DB | 객체 지향 DB | 객체 관계 DB |
|---|---|---|---|
| **데이터 구조** | 테이블 | 객체 | 테이블 + 객체 |
| **처리 데이터** | 정형 데이터 | 비정형 데이터 | 둘 다 가능 |
| **질의 언어** | SQL | ODL, OQL | 확장된 SQL |
| **상속·캡슐화** | 지원 안 함 | 완전 지원 | 지원 |
| **기반** | 집합론, 관계대수 | 객체 지향 프로그래밍 | 관계형 + 객체 지향 |
| **대용량 처리** | 탁월 | 보통 | 관계형에 근거해 탁월 |
| **표준화** | 잘 정립됨 | 미비 | 진행 중 |

:::note ODL과 OQL이란?
- **ODL(Object Definition Language, 객체 정의어)**: 관계형 DB의 DDL(테이블 정의)에 해당하는 것으로, 객체 클래스와 속성, 메서드 등을 정의하는 언어입니다.
- **OQL(Object Query Language, 객체 질의어)**: 관계형 DB의 SQL에 해당하는 것으로, 객체 데이터베이스에서 데이터를 조회하는 언어입니다.
:::

---

## ⚠️ 주의사항과 핵심 팁

### 단편화 시 주의사항

:::warning 수직 단편화 시 기본키 빠뜨리지 마세요!
수직 단편화를 할 때 각 단편에 반드시 기본키를 포함해야 합니다. 나중에 자연 조인으로 원본을 복원할 때 기본키가 없으면 올바른 조인이 불가능합니다.
:::

:::warning 단편화 후 원본 복원 방법 혼동 주의!
- **수평 단편화** 복원: **합집합(UNION)** 사용
- **수직 단편화** 복원: **자연 조인(NATURAL JOIN)** 사용
- **혼합 단편화** 복원: 합집합 **AND** 자연 조인 모두 사용

이 두 가지를 혼동하면 복원된 데이터가 엉망이 됩니다!
:::

### 2단계 완료 규약의 한계 인식

:::warning 2단계 완료 규약의 봉쇄 문제
2단계 완료 규약은 조정자가 장애를 일으키면 참여자 전체가 봉쇄(Blocking) 상태에 빠질 수 있습니다. 대규모 실제 시스템에서는 이 문제를 해결하기 위해 3단계 완료 규약이나 다른 보완 기법을 함께 사용해야 합니다.
:::

### 분산 데이터베이스 도입 전 고려사항

:::tip 분산 데이터베이스가 항상 정답은 아닙니다
소규모 서비스나 데이터 규모가 작은 경우, 중앙 집중 방식이 훨씬 간단하고 비용이 적습니다. 분산 데이터베이스는 다음 상황에서 도입을 고려하세요:
- 대용량 데이터와 높은 트래픽이 예상될 때
- 지리적으로 분산된 사용자를 빠르게 서비스해야 할 때
- 서비스 중단 없는 높은 가용성이 필수일 때
- 데이터 규모가 지속적으로 증가할 것이 예상될 때
:::

---

## 📌 핵심 정리

- **분산 데이터베이스**는 물리적으로 여러 곳에 나뉜 데이터베이스를 사용자에게 하나처럼 보이게 하는 시스템이다.
- **분산 DBMS**는 분산 구조를 사용자에게 투명하게 숨기고 효율적으로 관리하는 소프트웨어다.
- **구성 요소**는 분산 처리기, 분산 데이터베이스, 통신 네트워크 세 가지다.
- **장점**: 지역 자치성, 용량 확장 용이, 신뢰성·가용성 향상, 효율성·융통성, 연산 속도 향상
- **단점**: 구축·운영 비용 증가, 복잡한 네트워크로 인한 잠재적 오류 위험
- **위치 투명성**은 사용자가 데이터의 저장 위치를 몰라도 접근 가능한 특성이다.
- **중복 투명성**은 데이터가 여러 곳에 중복 저장되어도 사용자가 이를 신경 쓰지 않아도 되는 특성이다.
- **단편화**는 전역 릴레이션을 여러 단편으로 쪼개는 작업이며, 수평·수직·혼합 단편화로 구분된다.
- **수평 단편화**는 행(Row) 단위로 셀렉션 연산을 사용하며, 합집합으로 복원한다.
- **수직 단편화**는 열(Column) 단위로 프로젝션 연산을 사용하며, 자연 조인으로 복원한다.
- **4가지 스키마**: 전역 스키마 → 단편화 스키마 → 할당 스키마 → 지역 사상 스키마
- **2단계 완료 규약**은 모든 참여자가 준비됐을 때만 커밋, 하나라도 실패하면 전체 롤백하는 원자성 보장 프로토콜이다.
- **3단계 완료 규약**은 조정자 장애 시 봉쇄 문제를 예비 완료 단계를 추가해 해결한 프로토콜이다.
- **2티어 모델**은 클라이언트가 프레젠테이션과 비즈니스 로직 모두 처리하는 팻 클라이언트 구조다.
- **3티어 모델**은 비즈니스 로직을 중간 서버(미들웨어)로 분리해 클라이언트 부담을 줄인 구조다.
- **OID(객체 식별자)**는 객체 지향 DB에서 시스템이 자동 부여하며, 변경 불가·재사용 불가·유일한 식별자다.
- **객체 관계 데이터베이스**는 관계형 DB의 테이블 구조와 객체 지향의 개념을 결합한 하이브리드 방식이다.

---

작성일: 2026-02-21