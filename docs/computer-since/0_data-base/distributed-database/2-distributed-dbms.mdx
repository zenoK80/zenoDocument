---
title: "분산 DBMS의 역할과 기능"
description: "분산 DBMS의 역할과 기능에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/distributed-database/2-distributed-dbms"
sidebar_label: "분산 DBMS"
date: "2026-02-21"
---

# 🌐 분산 DBMS의 역할과 기능

데이터베이스를 공부하다 보면 "분산 데이터베이스"라는 말을 종종 듣게 됩니다. 처음 듣는 분들은 "분산? 데이터가 흩어진다는 건가?" 하고 막막하게 느낄 수 있습니다. 하지만 사실 여러분은 이미 매일 분산 데이터베이스를 사용하고 있습니다. 네이버를 열고, 카카오톡을 쓰고, 유튜브를 보는 그 순간 모두 분산 데이터베이스가 뒤에서 조용히 일하고 있는 것이죠. 이 문서에서는 분산 데이터베이스가 무엇인지, 그것을 관리하는 **분산 DBMS**가 어떤 역할을 하는지, 그리고 데이터가 어떻게 쪼개지고 어디에 저장되는지까지 아주 친절하게, 처음 접하는 분도 이해할 수 있도록 설명해 드리겠습니다.

---

## 📦 분산 데이터베이스란 무엇인가?

### 개념 한 줄 정리

**분산 데이터베이스(Distributed Database)** 란, 지리적·물리적으로 여러 곳에 나뉘어 있는 데이터베이스를 사용자가 마치 하나의 중앙 집중 데이터베이스처럼 사용할 수 있도록 만든 시스템입니다.

쉽게 말하면, 실제 데이터는 서울, 부산, 광주, 심지어 미국이나 유럽에 분산되어 저장돼 있지만, 사용자 눈에는 "그냥 하나의 데이터베이스"처럼 보이도록 만들어진 시스템입니다.

### 실생활 비유로 이해하기

여러분이 `naver.com`을 주소창에 입력할 때를 생각해보세요. 네이버 서버가 서울에 있는지, 부산에 있는지, 아니면 해외에 있는지 알고 접속하시나요? 전혀 모르죠. 그냥 `naver.com`만 치면 네이버가 짠! 하고 나타납니다. 구글은 미국에 서버가 있는지 유럽에 있는지 몰라도 `google.com`만 입력하면 바로 연결됩니다.

이게 바로 분산 데이터베이스의 핵심입니다. **실제 데이터는 전 세계에 물리적으로 분산되어 있지만, 사용자는 그것을 전혀 인식하지 못하고 하나의 시스템처럼 편리하게 사용합니다.**

### 중앙 집중 vs 분산 데이터베이스

중앙 집중 형태의 데이터베이스는 마치 도서관의 중앙 열람실처럼, 모든 책(데이터)이 한 곳에 모여 있고 사람들이 거기에 몰려가서 이용하는 구조입니다. 반면 분산 데이터베이스는 전국 각 지역에 도서관 분관을 두고, 가까운 분관에서 책을 빌릴 수 있게 하면서도 중앙 시스템으로 통합 관리되는 구조라고 생각하시면 됩니다.

| 구분 | 중앙 집중 데이터베이스 | 분산 데이터베이스 |
|---|---|---|
| 데이터 위치 | 한 곳에 집중 | 여러 지역에 분산 |
| 사용자 경험 | 단순, 하나의 서버 접속 | 단순 (투명성 제공) |
| 장애 발생 시 | 전체 서비스 중단 | 일부 서버로 서비스 유지 가능 |
| 확장성 | 확장이 어려움 | 확장이 용이 |
| 비용 | 상대적으로 저렴 | 구축 비용이 높음 |

---

## 🔧 분산 DBMS란 무엇이고, 왜 필요한가?

### 분산 DBMS의 정의

**분산 DBMS(Distributed Database Management System)** 는 지리적·물리적으로 분산되어 있는 데이터베이스를 **효율적으로 관리**하고, 사용자에게는 그 복잡한 내부 구조를 **투명하게(눈에 보이지 않게)** 만들어주는 소프트웨어입니다.

여기서 **"투명하다(Transparency)"** 라는 말이 처음에는 좀 헷갈릴 수 있습니다. 일상에서 "투명하다"고 하면 속이 다 보인다는 의미잖아요? 하지만 데이터베이스에서 투명성은 정반대의 개념입니다.

> 💡 **투명성(Transparency)** = 사용자가 알 필요 없는 복잡한 내부 구조를 시스템이 알아서 처리해줘서, 사용자는 신경 쓰지 않아도 되는 상태

즉, 네이버 서버가 어디에 있고, 데이터가 어떻게 쪼개져서 어디에 중복 저장되어 있는지 우리는 알 필요도 없고 알아서도 안 됩니다. 그걸 알아서 처리해주는 소프트웨어가 바로 분산 DBMS입니다.

### 분산 DBMS가 없으면 어떻게 될까?

분산 DBMS가 없다면 사용자가 직접 "서울 서버에서 이 데이터를 가져오고, 부산 서버에서 저 데이터를 가져오고, 광주 서버에서는 저걸 업데이트해라"라는 식으로 모든 것을 직접 지정해야 합니다. 마치 배달 음식을 시킬 때 직접 트럭을 몰고 식당에 가서 재료를 사고 직접 요리해서 집에 가져오는 것만큼 불편한 일이죠. 분산 DBMS는 이 모든 복잡한 과정을 대신해줍니다.

### 분산 DBMS의 세 가지 구성 요소

분산 데이터베이스 시스템을 구성하기 위해서는 반드시 세 가지 핵심 요소가 필요합니다.

**1️⃣ 분산 처리기 (Distributed Processor)**

각 지역(서울, 부산, 광주 등)에 위치한 서버 컴퓨터입니다. 마치 지방자치단체처럼, 자기 지역에 있는 데이터는 자기가 관리합니다. 서울 서버는 서울 데이터를, 부산 서버는 부산 데이터를 각자 처리합니다. 이렇게 자기 구역을 스스로 관리한다고 해서 **자치 처리기**라고도 부릅니다.

**2️⃣ 분산 데이터베이스 (Distributed Database)**

각 지역에 실제로 저장되어 있는 데이터베이스입니다. 서울에는 서울의 데이터베이스가, 부산에는 부산의 데이터베이스가 각각 존재합니다. 이 데이터베이스들이 모여 하나의 거대한 분산 데이터베이스 시스템을 이룹니다.

**3️⃣ 통신 네트워크 (Communication Network)**

서울, 부산, 광주에 있는 분산 처리기들을 하나로 연결해주는 인터넷 네트워크입니다. 사용자는 이 네트워크에 접속하면 라우팅(최적 경로 탐색)을 통해 자동으로 가장 적절한 서버에 연결됩니다. 마치 내비게이션처럼 가장 빠른 길을 알아서 찾아주는 것이죠.

```
[서울 서버] ──────────────┐
   └── 서울 DB           │
                         ├── 통신 네트워크 (인터넷) ── 사용자
[부산 서버] ──────────────┤
   └── 부산 DB           │
                         │
[광주 서버] ──────────────┘
   └── 광주 DB
```

---

## 🎯 분산 데이터베이스의 장점과 단점

### ✅ 장점

**1. 지역 자치성**

서울에 있는 데이터베이스는 서울 서버가 책임지고 관리합니다. 부산 데이터는 부산 서버가, 광주 데이터는 광주 서버가 각자 관리합니다. 마치 지방자치제처럼 "우리 지역 일은 우리가 알아서"라는 원칙으로 운영됩니다. 이렇게 하면 중앙 서버에 모든 부담이 집중되지 않고, 각 지역이 자율적으로 효율적인 운영을 할 수 있습니다.

**2. 용량 확장이 용이**

예를 들어, 대전에 새로운 공장이 들어서서 생산 데이터가 갑자기 폭발적으로 늘어났다고 가정해봅시다. 중앙 집중 시스템이라면 중앙 서버의 용량을 통째로 늘려야 합니다. 하지만 분산 데이터베이스에서는 대전에 새 서버와 데이터베이스를 추가하고 네트워크에 연결하기만 하면 됩니다. 반대로 필요가 없어지면 그냥 연결을 해제하면 그만입니다. 마치 전기 콘센트에 멀티탭을 꽂고 빼듯이 유연하게 확장하고 축소할 수 있습니다.

**3. 신뢰성(Reliability)과 가용성(Availability)**

가용성이란 "시스템이 얼마나 안정적으로 계속 서비스를 제공할 수 있는가"를 의미합니다. 분산 데이터베이스에서는 똑같은 데이터를 여러 서버에 중복 저장할 수 있습니다. 서울, 부산, 광주, 대전 네 곳에 같은 데이터가 있다면, 지진이나 해킹으로 서울, 부산, 광주의 서버가 모두 망가지더라도 대전 서버가 살아있는 한 서비스는 계속됩니다. 중앙 집중식이라면 서버 하나가 망가지는 순간 전체 서비스가 멈추는 것과 대조적입니다.

**4. 효율성과 융통성**

부산에 갑자기 대형 백화점이 생겨서 판매 데이터가 급증한다면, 기존에 서울에만 있던 판매 데이터베이스를 부산에도 추가 배치할 수 있습니다. 이처럼 특정 지역에서 자주 사용하는 데이터를 그 지역에 가까운 서버에 저장해두면 네트워크 트래픽 비용을 줄이고 데이터 이동을 최소화할 수 있어 효율적입니다.

**5. 자료 공유와 분산 제어(병렬 처리)**

데이터가 여러 서버에 중복 저장되어 있기 때문에 자료 공유가 자연스럽게 이루어집니다. 또한 하나의 작업을 처리하는 데 30분이 걸린다면, 이것을 서울·부산·광주 세 서버가 나눠서 동시에(병렬로) 처리하면 10분으로 줄일 수 있습니다. 이처럼 **분산 제어를 통한 병렬 처리**로 연산 속도를 크게 향상시킬 수 있습니다.

### ❌ 단점

**1. 소프트웨어 개발 비용 및 구축 비용 증가**

분산 DBMS 소프트웨어도 개발해야 하고, 각 지역에 서버와 데이터베이스를 구축해야 하며, 이를 연결하는 네트워크 장비도 설치해야 합니다. 하나의 중앙 서버만 운영할 때와 비교하면 초기 구축 비용과 유지 관리 비용이 훨씬 크게 증가합니다. 단순하게 하나로 운영할 것을 굳이 복잡하게 나눠놓으니, 그만큼 돈이 더 드는 것이죠.

**2. 숨겨진 오류와 보안 위험**

전 세계의 수십만 개 서버가 거미줄처럼 복잡하게 연결된 인터넷 망은 그 복잡성 때문에 어느 부분에서 오류가 발생할지, 어느 경로로 해킹 공격이 들어올지 예측하기 매우 어렵습니다. 복잡한 구조 속에 항상 잠재적인 위험이 숨어 있으며, 이것을 완벽하게 통제하는 것은 현실적으로 쉽지 않습니다.

:::warning 단점을 무시하지 마세요
분산 데이터베이스는 분명히 강력한 장점을 가지고 있지만, 구축 비용과 보안 위험이라는 단점도 함께 가집니다. 서비스 규모와 예산을 고려해 중앙 집중식과 분산식 중 어떤 방식이 적합한지 신중하게 선택해야 합니다.
:::

---

## 🔍 분산 데이터베이스의 투명성 목표

분산 데이터베이스가 반드시 제공해야 하는 특성들을 **투명성 목표**라고 부릅니다. 사용자가 복잡한 내부 구조를 몰라도 편리하게 쓸 수 있도록 시스템이 "알아서" 처리해야 하는 것들입니다.

### 1️⃣ 위치 투명성 (Location Transparency)

사용자가 데이터가 **어느 위치**에 저장되어 있는지 알 필요 없이 사용할 수 있는 성질입니다.

예를 들어 여러분이 지하철을 타고 어딘가를 가려면 목적지 위치를 알아야 합니다. 그런데 인터넷에서 `naver.com`을 입력할 때 "네이버 서버가 서울 어느 건물 몇 층에 있는지"를 알아야 할 필요가 없잖아요? 그냥 `naver.com`만 입력하면 시스템이 알아서 라우터와 게이트웨이를 거쳐 최적의 경로로 연결해줍니다.

이때 데이터의 위치 정보는 **분산 시스템 카탈로그(Distributed System Catalog)** 라는 곳에서 유지·관리됩니다. 사용자 대신 시스템이 "이 데이터는 부산 서버에 있구나, 그리로 연결해줘야지"를 자동으로 처리하는 것입니다.

### 2️⃣ 중복 투명성 (Replication Transparency)

데이터가 **여러 곳에 중복 저장**되어 있더라도 사용자는 그 사실을 알 필요 없이 사용할 수 있는 성질입니다.

학생 데이터베이스가 서울에도 있고 부산에도 똑같이 복사되어 있다고 가정해봅시다. 사용자가 학생 정보를 조회할 때 "서울 데이터를 봐야 하나, 부산 데이터를 봐야 하나"를 고민할 필요가 전혀 없습니다. 분산 DBMS가 알아서 가장 빠르게 응답할 수 있는 서버에서 데이터를 가져와 보여줍니다.

> 중복이 필수인 이유: 데이터가 여러 곳에 중복 저장되어 있어야 병렬 처리가 가능하고, 일부 서버 장애 시에도 서비스를 유지할 수 있으며, 가용성과 신뢰성이 높아집니다.

중복에는 두 가지 방식이 있습니다.

| 구분 | 설명 | 예시 |
|---|---|---|
| **완전 중복** | 데이터베이스 전체를 여러 곳에 똑같이 복사 | 학생 테이블 전체를 서울·부산·광주에 모두 저장 |
| **부분 중복** | 데이터베이스를 쪼개서 일부만 특정 사이트에 저장 | 학생 기본정보는 서울에, 성적정보는 부산에 저장 |

---

## ✂️ 단편화(Fragmentation)와 분산 저장 구조

### 단편화란 무엇인가?

부분 중복을 구현하려면 하나의 데이터베이스를 잘게 **쪼개야** 합니다. 이렇게 하나의 전역 릴레이션(테이블 전체)을 여러 개의 조각으로 나누는 것을 **단편화(Fragmentation)** 라고 합니다.

마치 피자 한 판을 여러 조각으로 나눠서 각자 가져가는 것처럼, 하나의 테이블을 여러 단편(조각)으로 나눠서 각 지역 서버에 배치하는 것이죠.

단편화는 **관계 대수(Relational Algebra)** 의 셀렉션(Selection)과 프로젝션(Projection) 연산을 이용해 수행합니다.

### 분산 저장의 4단계 스키마 구조

```
전역 스키마 (Global Schema)
    ↓ [단편화]
단편화 스키마 (Fragmentation Schema)
    ↓ [할당]
할당 스키마 (Allocation Schema)
    ↓ [매핑]
지역 사상 스키마 (Local Mapping Schema)
```

**전역 스키마**: 쪼개기 전의 원본 테이블 전체를 말합니다. "학생 테이블"이 학번, 이름, 학년, 학과, 성적, 지도교수 등 모든 컬럼을 가진 하나의 완전한 테이블인 상태입니다.

**단편화 스키마**: 전역 스키마를 여러 단편으로 쪼갠 결과입니다. 학생 테이블을 "기본정보 단편"과 "성적정보 단편"으로 나눈 것이 단편화 스키마입니다.

**할당 스키마**: 쪼개진 단편들을 어느 사이트(서울, 부산, 광주 등)에 배치할 것인지를 결정하는 계획입니다. "1번 단편은 서울에, 2번 단편은 부산에, 1번과 2번 모두 광주에 중복 저장"하는 식으로 배치 계획을 세웁니다.

**지역 사상 스키마**: 할당 계획에 따라 실제로 각 물리적 사이트에 데이터를 매핑하여 저장하는 단계입니다. 실제로 서울 서버 디스크에 1번 단편이 저장되는 바로 그 과정입니다.

### 단편화의 세 가지 방법

#### 수평 단편화 (Horizontal Fragmentation)

테이블을 **행(Row)** 단위로 쪼개는 방법입니다. 마치 학생 명단을 "남학생 명단"과 "여학생 명단"으로 나누거나, "컴퓨터학과"와 "다른 학과"로 나누는 것처럼 **셀렉션(Selection, σ) 연산**을 사용합니다.

```
[원본 학생 테이블]
학번 | 이름 | 학과     | 성별
-----|------|---------|----
001  | 김철수 | 컴퓨터  | 남
002  | 이영희 | 경영    | 여
003  | 박민준 | 컴퓨터  | 남
004  | 최지은 | 경영    | 여

↓ 수평 단편화 (학과 기준)

[단편 1: 컴퓨터학과]       [단편 2: 컴퓨터학과 아닌 것]
학번 | 이름  | 학과   | 성별   학번 | 이름  | 학과  | 성별
-----|-------|-------|----   -----|-------|------|----
001  | 김철수 | 컴퓨터 | 남    002  | 이영희 | 경영  | 여
003  | 박민준 | 컴퓨터 | 남    004  | 최지은 | 경영  | 여
```

수평 단편화의 특징:

- 값이 바뀌면(학과가 변경되면) 소속 단편이 바뀔 수 있어 **동적 단편화**라고 합니다.
- 원래 테이블을 복원하려면 단편들을 **합집합(UNION)** 하면 됩니다.
- 단편들 간의 **교집합은 공집합**입니다. (컴퓨터학과이면서 동시에 컴퓨터학과가 아닌 학생은 없으니까요.)

#### 수직 단편화 (Vertical Fragmentation)

테이블을 **열(Column, 속성)** 단위로 쪼개는 방법입니다. 마치 학생 정보를 "기본 신상정보"와 "학업 관련 정보"로 분리하는 것처럼 **프로젝션(Projection, π) 연산**을 사용합니다. 단, 나뉜 단편들을 나중에 합칠 수 있도록 **기본키(Primary Key)는 양쪽 단편 모두에 반드시 포함**해야 합니다.

```
[원본 학생 테이블]
학번 | 이름 | 학년 | 학과 | 성적 | 지도교수
-----|------|------|------|------|--------
001  | 김철수 | 3   | 컴퓨터| A+  | 홍길동교수

↓ 수직 단편화 (속성 기준)

[단편 1: 기본정보]           [단편 2: 학업정보]
학번 | 이름 | 학년 | 학과    학번 | 성적 | 지도교수
-----|------|------|----    -----|------|--------
001  | 김철수 | 3  | 컴퓨터  001  | A+  | 홍길동교수
          ↑                   ↑
       기본키 포함          기본키 포함
```

수직 단편화의 특징:

- 속성 값이 바뀐다고 해서 소속 단편이 바뀌지 않으므로 **정적 단편화**라고 합니다.
- 원래 테이블을 복원하려면 기본키를 기준으로 **자연 조인(Natural Join)** 을 수행합니다.
- 단편들의 **공통 속성은 기본키**입니다.

#### 혼합 단편화 (Mixed Fragmentation)

수평 단편화와 수직 단편화를 **함께 사용**하는 방법입니다. 먼저 수평으로 행을 나눈 다음, 다시 수직으로 열을 나누거나 그 반대로 적용합니다. 원래 테이블을 복원하려면 **자연 조인**과 **합집합(UNION)** 을 모두 사용해야 합니다.

:::tip 단편화 선택 기준
- 특정 지역에서 특정 **조건의 행**을 자주 조회한다 → **수평 단편화** 적합
- 특정 지역에서 특정 **컬럼만** 자주 조회한다 → **수직 단편화** 적합
- 두 가지 조건이 모두 해당된다 → **혼합 단편화** 적합
:::

### 할당 (Allocation)

단편화로 쪼개진 단편들을 어느 사이트에 배치할 것인지를 결정하는 과정입니다. 예를 들어:

- 1번 단편 → 서울, 광주 (중복 할당)
- 2번 단편 → 부산, 광주 (중복 할당)
- 3번 단편 → 서울 (단독 할당)

이처럼 중복 할당도 가능하고, 단독 할당도 가능합니다. 중복 할당은 가용성을 높이지만 저장 공간이 더 필요하고, 단독 할당은 공간을 절약하지만 해당 서버 장애 시 접근이 불가능해집니다.

---

## 🔄 분산 트랜잭션 관리: 조정자와 2단계/3단계 완료 규약

### 트랜잭션 관리자 vs 트랜잭션 조정자

분산 데이터베이스에서는 두 가지 중요한 관리 주체가 있습니다.

**트랜잭션 관리자(Transaction Manager)**: 각 사이트(서울, 부산, 광주 등)마다 개별적으로 존재하며, 자기 사이트의 병행 제어, 회복, 권한 검사, 무결성 검사 등을 담당합니다. 중앙 집중 시스템에서도 필요한 기본 요소입니다.

**트랜잭션 조정자(Transaction Coordinator, 코디네이터)**: 분산 데이터베이스에서만 필요한 요소입니다. 여러 사이트에 걸쳐진 트랜잭션을 중간에서 통제하고 조정하는 역할을 합니다. 각 트랜잭션 관리자는 자기 사이트 것만 알지만, 조정자는 모든 사이트를 넘나들며 전체를 조율합니다.

조정자가 필요한 이유를 예로 들어볼까요? 서울, 부산, 광주 세 사이트에 모두 저장된 데이터 `A`를 `B`로 변경하는 작업을 한다고 가정합시다. 서울과 부산에서는 성공적으로 `A`를 `B`로 바꿨는데 광주에서는 네트워크 문제로 변경이 안 됐다면? 세 곳의 데이터가 달라져 **무결성(데이터의 정확성과 일관성)** 이 깨집니다. 이런 상황을 방지하는 것이 조정자의 핵심 역할입니다.

### 2단계 완료 규약 (2-Phase Commit Protocol, 2PC)

2단계 완료 규약은 분산 트랜잭션의 **원자성(Atomicity, 모두 성공 아니면 모두 실패)** 을 보장하기 위한 프로토콜입니다. 마치 군대에서 "전진 준비!"를 외치고 모든 병사가 "준비 완료!"를 보고한 다음에야 "전진!"을 명령하는 것과 같습니다.

**1단계: 준비 단계 (Prepare Phase)**

조정자가 모든 참여자(서울, 부산, 광주 사이트)에게 묻습니다.
"커밋(변경 사항을 확정)할 준비가 됐습니까?"

각 참여자는 자신의 상태를 확인하고 응답합니다.
- 준비됐으면 → "OK (준비 완료)"
- 문제가 있으면 → "Abort (취소 필요)"

**2단계: 커밋 단계 (Commit Phase)**

- 모든 참여자가 "OK"를 보냈으면 → 조정자가 **커밋 명령**을 내리고, 모든 사이트가 변경사항을 확정합니다.
- 단 하나의 참여자라도 "Abort"를 보냈거나 응답이 없으면 → 조정자가 **롤백 명령**을 내리고, 모든 사이트가 변경사항을 취소합니다.

```
조정자 → 서울: "커밋 준비됐어?"  서울 → 조정자: "OK"
조정자 → 부산: "커밋 준비됐어?"  부산 → 조정자: "OK"
조정자 → 광주: "커밋 준비됐어?"  광주 → 조정자: "OK"

모두 OK → 조정자: "전원 커밋하세요!" → 데이터 무결성 유지 ✅

만약 광주가 "Abort" 응답 시:
조정자: "전원 롤백하세요!" → 변경사항 모두 취소 ✅
```

### 3단계 완료 규약 (3-Phase Commit Protocol, 3PC)

2단계 완료 규약의 치명적인 약점이 있습니다. 바로 **조정자가 장애를 일으키면** 어떻게 할 것인가의 문제입니다. 조정자가 "커밋하세요" 혹은 "롤백하세요" 명령을 내리기 직전에 망가져버리면, 참여자들은 무한정 기다릴 수밖에 없습니다.

이런 **조정자 단일 장애점(Single Point of Failure)** 문제를 해결하기 위해 등장한 것이 **3단계 완료 규약**입니다.

핵심 아이디어: 조정자가 알고 있는 정보(커밋을 결정했는지 롤백을 결정했는지)를 미리 참여자들도 공유해두어, 조정자가 망가지더라도 참여자들이 스스로 결정을 내릴 수 있게 합니다. 이 중간 단계를 **예비 완료(Pre-Commit) 단계**라고 합니다.

| 단계 | 2PC | 3PC |
|---|---|---|
| 1단계 | 준비 (Prepare) | 준비 (Prepare) |
| 2단계 | 커밋/롤백 (Commit/Abort) | 예비 완료 (Pre-Commit) |
| 3단계 | — | 커밋/롤백 (Commit/Abort) |
| 조정자 장애 시 | 참여자 무한 대기 | 참여자가 스스로 결정 가능 |

:::info 3PC의 전제 조건
3단계 완료 규약이 동작하려면 최소 하나의 사이트(참여자)는 정상적으로 작동해야 합니다. 모든 사이트가 동시에 망가지는 상황은 막을 수 없습니다.
:::

---

## 🖥️ 클라이언트-서버 구조: 2티어와 3티어

### 2티어 구조 (Two-Tier Architecture)

1980년대부터 사용되어 온 전통적인 구조입니다. **클라이언트(Client)** 와 **서버(Server)** 두 계층으로만 이루어져 있습니다.

이 구조에서 클라이언트는 두 가지 역할을 모두 담당합니다:
- **프레젠테이션 로직**: 화면에 데이터를 표시하고 사용자 입력을 받는 것
- **비즈니스 로직**: 데이터를 처리하고 계산하는 핵심 로직

클라이언트가 일을 많이 하기 때문에 이런 클라이언트를 **팻 클라이언트(Fat Client)** 라고 부릅니다. 마치 모든 요리를 손님 테이블에서 직접 해야 하는 것처럼, 클라이언트 성능에 큰 부담이 가해집니다.

2티어 구조의 치명적 단점: **비즈니스 로직이 변경되면 모든 클라이언트를 일일이 업데이트**해야 합니다. 클라이언트가 100대라면 100대를 모두 수정해야 하는 것이죠. 유지보수 비용이 엄청납니다.

### 3티어 구조 (Three-Tier Architecture)

2티어의 문제를 해결하기 위해 등장한 구조입니다. 클라이언트에서 처리하던 **비즈니스 로직을 별도의 서버(미들웨어, 앱 서버)로 분리**하여 세 계층으로 만든 것입니다.

```
[클라이언트]           [앱 서버 (미들웨어)]      [데이터베이스 서버]
프레젠테이션 로직  →  비즈니스 로직 처리   →   데이터 저장/조회
(화면 표시, 입력)    (Tomcat, 웹 서버 등)      (DB)
```

3티어 구조의 장점:

- **클라이언트 성능 향상**: 화면 표시만 담당하므로 클라이언트의 부담이 크게 줄어듭니다.
- **유지보수 용이**: 비즈니스 로직이 변경되면 **앱 서버 하나만** 수정하면 됩니다. 클라이언트를 건드릴 필요가 없습니다.
- **확장성**: 각 계층을 독립적으로 확장할 수 있습니다.

:::note 실제 웹 개발과의 연결
Java의 Tomcat, JSP, Node.js 등이 바로 3티어 구조의 **가운데 계층(앱 서버, 미들웨어)** 에 해당합니다. 우리가 웹 개발을 할 때 자연스럽게 사용하는 MVC 패턴도 이 3티어 사상을 반영한 것입니다.
:::

---

## 🧩 객체 지향 데이터베이스와 객체 관계 데이터베이스

### 관계형 데이터베이스의 한계

기존의 관계형 데이터베이스(테이블 기반)는 정형화된 데이터를 처리하는 데는 탁월하지만 다음과 같은 한계가 있습니다:

- 이미지, 동영상, 음성 같은 **멀티미디어(비정형) 데이터** 저장이 어렵습니다.
- 하나의 셀에 여러 값을 저장하는 **다중값(Multi-Value)** 처리가 불가능합니다.
- 객체 지향 개념인 **상속, 일반화, 다형성** 등을 표현할 수 없습니다.

이런 한계를 극복하기 위해 **객체 지향 데이터베이스(Object-Oriented Database)** 와 **객체 관계 데이터베이스(Object-Relational Database)** 가 등장했습니다.

### 객체 지향 데이터베이스의 핵심 개념

**객체 식별자(OID, Object Identifier)**

관계형 DB에서는 기본키(Primary Key)로 각 레코드를 식별하지만, 객체 지향 DB에서는 **OID**로 각 객체를 식별합니다. OID는 우리 사람의 지문이나 홍채처럼, 태어날 때부터 시스템이 자동으로 부여하는 고유한 식별자입니다.

OID의 특징:
- 시스템이 자동으로 부여 (사용자가 지정 불가)
- 절대로 변경 불가
- 객체마다 유일한 값
- 객체가 삭제될 때만 OID도 삭제됨
- 재사용 불가

**캡슐화(Encapsulation)**

속성(데이터)과 메서드(기능)를 하나의 클래스로 묶어 내부를 감추는 것입니다. 마치 자판기처럼, 안에 음료수가 어떻게 보관되고 버튼을 누르면 어떤 기계 장치가 동작하는지 몰라도, 버튼만 누르면 음료수가 나오는 사용법만 알면 됩니다. 이것이 **정보 은닉(Information Hiding)** 입니다.

**다형성(Polymorphism)**

동일한 메서드 이름이 객체에 따라 다르게 동작하는 성질입니다. `draw()`라는 하나의 메서드가 삼각형 객체에서는 삼각형을 그리고, 사각형 객체에서는 사각형을 그리고, 원 객체에서는 원을 그립니다.

**오버로딩(Overloading)과 오버라이딩(Overriding)**

| 구분 | 설명 |
|---|---|
| **오버로딩** | 같은 이름의 메서드를 매개변수의 타입이나 개수를 다르게 하여 여러 개 정의 |
| **오버라이딩** | 부모 클래스의 메서드를 상속받아 내용을 완전히 새로 재정의 |

**동적 바인딩(Dynamic Binding)**

값이 입력될 때 실시간으로 데이터 타입이 결정되어 처리되는 방식입니다. 컴파일 시점이 아닌 실행 시점에 타입이 결정됩니다.

**메시지 패싱(Message Passing)**

객체와 객체 사이에 메서드 호출을 통해 데이터를 주고받는 것입니다. Java에서 메서드를 호출하고 반환값을 받는 것이 바로 메시지 패싱입니다.

### 세 가지 데이터베이스 비교

| 구분 | 관계형 DB | 객체 지향 DB | 객체 관계 DB |
|---|---|---|---|
| **저장 구조** | 테이블(Table) | 객체(Object) | 테이블 + 객체 |
| **데이터 유형** | 정형 데이터만 | 비정형 데이터 가능 | 둘 다 가능 |
| **질의 언어** | SQL | ODL, OQL | 확장된 SQL |
| **상속/캡슐화** | 미지원 | 지원 | 지원 |
| **표준화** | 높음 | 낮음 | 중간 |
| **활용 분야** | 일반 업무 | 특수 분야 | 다목적 |

**ODL(Object Definition Language)**: 객체 지향 데이터베이스에서 객체의 구조(클래스, 속성, 메서드 등)를 정의하는 언어입니다.

**OQL(Object Query Language)**: 객체 지향 데이터베이스에서 데이터를 질의(조회)하기 위한 언어입니다.

:::info 객체 지향 DB vs 객체 관계 DB의 핵심 차이
- **객체 지향 DB**: 객체 지향 프로그래밍 언어에 데이터베이스 기능을 일부 추가한 것. 즉, 프로그래밍이 먼저이고 DB가 나중.
- **객체 관계 DB**: 기존의 관계형 DB를 더 풍부하게 만들기 위해 객체 개념을 추가한 것. 즉, DB가 먼저이고 객체가 나중.
:::

---

## ⚠️ 주의사항과 핵심 팁

### 자주 하는 실수들

:::danger 투명성의 의미 혼동 금지
"투명성"을 "속이 다 보인다"로 해석하면 안 됩니다. 분산 데이터베이스에서 투명성은 **사용자가 알 필요 없는 복잡한 내부를 시스템이 숨겨주는 것**입니다. 즉, 복잡성을 사용자에게 **보이지 않게** 만드는 것입니다.
:::

:::danger 2PC와 3PC 혼동 주의
2단계 완료 규약은 조정자가 장애를 일으키면 참여자들이 무한 대기 상태에 빠집니다. 3단계 완료 규약은 이 문제를 예비 완료(Pre-Commit) 단계를 추가해 해결합니다. 시험에서 "조정자 장애 처리"를 묻는다면 3PC가 답입니다.
:::

:::warning 수평/수직 단편화 복원 방법 구분
- **수평 단편화** 복원: **합집합(UNION)**
- **수직 단편화** 복원: **자연 조인(Natural Join)**
- **혼합 단편화** 복원: **합집합 + 자연 조인** 모두 필요

이 차이를 정확히 기억해두세요.
:::

:::tip OID vs 기본키 기억법
- **기본키(Primary Key)**: 사용자가 직접 지정, 변경 가능 (예: 학번, 주민번호)
- **OID(Object Identifier)**: 시스템이 자동 부여, 절대 변경 불가 (예: 지문, 홍채)
:::

:::tip 2티어 vs 3티어 핵심 차이
비즈니스 로직이 어디에 있느냐가 핵심입니다.
- **2티어**: 비즈니스 로직이 **클라이언트**에 있음 → 팻 클라이언트, 유지보수 어려움
- **3티어**: 비즈니스 로직이 **앱 서버(미들웨어)**에 있음 → 씬 클라이언트, 유지보수 용이
:::

---

## 📝 핵심 정리

- **분산 데이터베이스**는 물리적으로 여러 곳에 분산된 DB를 하나의 시스템처럼 사용하게 해주는 시스템이다.
- **분산 DBMS**는 분산된 DB를 효율적으로 관리하고 사용자에게 복잡한 내부를 투명하게 숨겨주는 소프트웨어다.
- 분산 DB의 구성 요소는 **분산 처리기**, **분산 데이터베이스**, **통신 네트워크** 세 가지다.
- 분산 DB의 장점: **지역 자치성, 용량 확장 용이, 신뢰성/가용성, 효율성/융통성, 병렬 처리**
- 분산 DB의 단점: **구축 비용 증가, 숨겨진 오류 및 보안 위험**
- **위치 투명성**은 데이터 위치를 사용자가 몰라도 시스템이 자동으로 찾아주는 성질이다.
- **중복 투명성**은 데이터가 여러 곳에 중복 저장돼 있어도 사용자가 신경 쓰지 않아도 되는 성질이다.
- **단편화(Fragmentation)**: 전역 릴레이션을 여러 단편으로 쪼개는 것 (수평/수직/혼합)
- **수평 단편화**는 행 단위로 쪼개며(셀렉션), 복원은 합집합(UNION)으로 한다.
- **수직 단편화**는 열 단위로 쪼개며(프로젝션), 복원은 자연 조인(Natural Join)으로 한다.
- 분산 DB의 4단계 스키마: **전역 스키마 → 단편화 스키마 → 할당 스키마 → 지역 사상 스키마**
- **트랜잭션 조정자(코디네이터)**는 분산 DB에서만 필요하며 여러 사이트의 트랜잭션을 중간에서 조율한다.
- **2단계 완료 규약(2PC)**: 준비 → 커밋/롤백으로 원자성을 보장하지만 조정자 장애 시 취약하다.
- **3단계 완료 규약(3PC)**: 예비 완료 단계를 추가해 조정자 장애 시에도 참여자가 스스로 결정 가능하다.
- **2티어 구조**는 클라이언트가 비즈니스 로직까지 처리하는 팻 클라이언트 구조다.
- **3티어 구조**는 비즈니스 로직을 앱 서버(미들웨어)로 분리해 유지보수를 용이하게 한 구조다.
- **객체 식별자(OID)**는 시스템이 자동 부여하는 객체의 고유 식별자로, 변경 및 재사용 불가다.
- **객체 지향 DB**는 객체 개념 중심, ODL/OQL 사용하며 특수 분야에 적합하다.
- **객체 관계 DB**는 관계형 DB에 객체 개념을 추가한 것으로 확장된 SQL을 사용한다.

---

작성일: 2026-02-21