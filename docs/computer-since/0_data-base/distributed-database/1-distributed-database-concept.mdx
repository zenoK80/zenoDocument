---
title: "분산 데이터베이스의 개념과 투명성"
description: "분산 데이터베이스의 개념과 투명성에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/distributed-database/1-distributed-database-concept"
sidebar_label: "개념과 투명성"
date: "2026-02-21"
---

# 🌐 분산 데이터베이스의 개념과 투명성

여러분은 매일 네이버, 구글, 카카오 같은 서비스를 아무런 어려움 없이 사용하고 있습니다. 그런데 한 번이라도 "네이버 서버가 지금 어느 건물 몇 층에 있는 걸까?", "구글 데이터베이스는 미국에 있는 건지 유럽에 있는 건지 어떻게 아는 거지?" 같은 궁금증을 가져보신 적 있으신가요?

사실 우리는 그 위치를 전혀 몰라도 됩니다. 몰라도 완벽하게 서비스를 이용할 수 있죠. 이것이 바로 오늘 배울 **분산 데이터베이스(Distributed Database)** 의 핵심 철학입니다.

이번 문서에서는 분산 데이터베이스가 무엇인지, 왜 필요한지, 어떤 원리로 동작하는지, 그리고 투명성이라는 개념이 무엇인지를 초보자도 완벽히 이해할 수 있도록 하나하나 풀어서 설명하겠습니다.

---

## 🗂️ 분산 데이터베이스란 무엇인가?

### 중앙 집중식 vs 분산 방식, 무엇이 다를까?

먼저 우리가 일반적으로 알고 있는 **중앙 집중식 데이터베이스(Centralized Database)** 를 생각해봅시다. 이 방식은 마치 학교의 교무실과 같습니다. 모든 학생의 성적표, 출석부, 서류가 교무실 한 곳에 모여 있고, 선생님들은 모두 그 교무실에 와서 필요한 서류를 꺼내가는 방식입니다. 단순하고 관리하기는 편리하지만, 교무실에 문제가 생기면 아무도 서류를 열람할 수 없습니다.

반면에 **분산 데이터베이스(Distributed Database)** 는 전국에 여러 지점이 있는 은행을 생각하시면 됩니다. 서울 지점, 부산 지점, 광주 지점에 각각 관련 데이터가 저장되어 있지만, 고객 입장에서는 어느 지점 ATM에서든 자신의 계좌 잔액을 조회하고 입출금을 할 수 있습니다. 데이터가 어디에 있는지 고객은 전혀 몰라도 됩니다.

> **분산 데이터베이스의 정의:** 지리적으로, 물리적으로는 여러 곳에 분산되어 있는 데이터베이스 시스템을, 사용자는 마치 하나의 중앙 집중 데이터베이스 시스템처럼 사용할 수 있는 시스템

핵심은 이 두 가지입니다.
- **실제로는** 데이터베이스가 여러 지역에 물리적으로 분산되어 있다.
- **사용자 눈에는** 하나의 통합된 시스템처럼 느껴진다.

### 실생활 예시로 더 쉽게 이해하기

여러분이 브라우저 주소창에 `naver.com` 이라고만 입력해도 네이버에 접속할 수 있습니다. 그런데 실제로 네이버의 서버와 데이터베이스는 서울, 춘천, 그리고 해외 여러 곳에 분산되어 있습니다. 구글은 더욱 복잡해서 전 세계 수십 개 나라에 데이터센터가 있습니다.

만약 분산 데이터베이스 기술이 없다면, 우리는 이렇게 입력해야 했을지도 모릅니다:

```
naver.com/seoul-datacenter-building3-floor5
```

이렇게 구체적인 위치를 명시해야만 접속이 가능했을 것입니다. 하지만 분산 데이터베이스와 관련 소프트웨어 덕분에 우리는 그냥 `naver.com` 만 입력하면 됩니다. 시스템이 알아서 가장 적합한 서버로 연결해줍니다.

---

## ⚙️ 분산 데이터베이스의 구성 요소

### 왜 구성 요소를 알아야 할까?

분산 데이터베이스가 동작하려면 단순히 데이터를 여러 곳에 복사해두는 것만으로는 부족합니다. 마치 여러 지점이 있는 편의점 체인에서 각 지점이 재고를 관리하고, 본사와 통신하고, 고객에게 서비스를 제공하는 각자의 역할이 있듯이, 분산 데이터베이스도 명확한 구성 요소가 필요합니다.

분산 데이터베이스를 구성하는 세 가지 핵심 요소는 다음과 같습니다.

| 구성 요소 | 역할 | 실생활 비유 |
|---|---|---|
| **분산 처리기 (Distributed Processor)** | 각 지역의 데이터베이스를 처리하고 관리 | 각 지점의 지점장 |
| **분산 데이터베이스 (Distributed Database)** | 각 지역에 실제로 저장된 데이터 | 각 지점의 창고 |
| **통신 네트워크 (Communication Network)** | 모든 지역을 연결하는 인터넷 망 | 지점 간 물류 배송망 |

### 각 구성 요소를 자세히 살펴보자

**① 분산 처리기**

분산 처리기는 각 지역에 있는 서버 컴퓨터라고 생각하면 됩니다. 서울에는 서울의 데이터베이스를 처리하는 서버가 있고, 부산에는 부산의 데이터베이스를 처리하는 서버가 있습니다. 각자 자기 지역의 데이터는 자기가 책임지고 처리합니다.

이것은 마치 지방자치제(지자체)와 비슷합니다. 서울시는 서울의 행정을 서울시 예산으로 서울시가 처리하고, 부산시는 부산의 행정을 부산시가 처리하듯이, 각 지역의 분산 처리기는 자기 지역의 데이터를 **자치적으로** 처리합니다. 그래서 이를 **자치 처리기**라고도 부릅니다.

**② 분산 데이터베이스**

각 지역에 실제로 저장되어 있는 데이터베이스입니다. 서울, 부산, 광주에 각각 데이터베이스가 있으며, 이 데이터베이스들이 모여서 하나의 거대한 분산 데이터베이스 시스템을 이룹니다.

**③ 통신 네트워크**

각 지역의 자치 처리기들을 연결하는 인터넷 망입니다. 이 네트워크를 통해 서울, 부산, 광주의 처리기들이 서로 자원을 공유하고, 사용자는 어느 곳에 접속하더라도 마치 하나의 시스템처럼 느낄 수 있습니다.

### 분산 DBMS란?

분산 데이터베이스를 실제로 관리해주는 소프트웨어를 **분산 DBMS(Distributed Database Management System)** 라고 합니다. 일반 DBMS가 하나의 중앙 데이터베이스를 관리한다면, 분산 DBMS는 인터넷상에 연결된 여러 개의 데이터베이스를 효율적으로 관리하는 역할을 합니다.

:::info 분산 DBMS의 역할
분산 DBMS는 다음과 같은 일을 합니다:
- 어느 서버에 어떤 데이터가 있는지 위치 정보를 관리한다
- 사용자 요청을 적절한 서버로 라우팅한다
- 여러 서버에 분산된 데이터를 하나의 결과로 합쳐서 돌려준다
- 데이터의 일관성과 무결성을 유지한다
:::

---

## ✅ 분산 데이터베이스의 장단점

### 장점: 왜 분산 데이터베이스를 쓰는가?

분산 데이터베이스의 장점은 크게 다섯 가지로 정리할 수 있습니다.

**① 지역 자치성 (Local Autonomy)**

각 지역의 데이터는 그 지역의 서버가 책임지고 관리합니다. 서울에 있는 데이터는 서울 서버가, 부산에 있는 데이터는 부산 서버가 처리합니다. 이렇게 하면 각 지역이 독립적으로 운영될 수 있어서 한 곳에 문제가 생겨도 다른 지역은 정상 운영이 가능합니다.

**② 용량 확장의 용이성 (Scalability)**

새로운 지역이 필요하면 그냥 새 서버를 추가해서 네트워크에 연결하면 됩니다. 예를 들어 대전에 공장이 새로 생겨서 생산 데이터를 관리해야 할 필요가 생겼다면, 대전에 새 서버와 데이터베이스를 설치하고 네트워크에 연결하기만 하면 됩니다. 반대로 공장이 철수해서 더 이상 필요 없어지면 그냥 끊어버리면 됩니다. 마치 레고 블록처럼 필요에 따라 추가하고 제거할 수 있습니다.

**③ 신뢰성과 가용성 (Reliability & Availability)**

이것은 분산 데이터베이스의 가장 강력한 장점 중 하나입니다. 같은 데이터가 서울, 부산, 광주에 모두 복사되어 저장되어 있다고 생각해보세요. 만약 지진이나 해킹으로 서울과 부산의 서버가 동시에 손상되더라도, 광주에 데이터가 살아있기 때문에 서비스를 계속 제공할 수 있습니다.

중앙 집중식 데이터베이스라면 그 하나가 고장났을 때 전체 서비스가 멈추지만, 분산 데이터베이스는 일부 서버에 장애가 발생해도 나머지 서버들이 역할을 대신할 수 있습니다.

> **가용성(Availability):** 시스템이 장애 없이 정상적으로 사용 가능한 상태를 유지하는 능력. 99.9% 가용성이라면 1년 중 8.76시간만 서비스가 중단될 수 있다는 의미입니다.

**④ 효율성과 융통성 (Efficiency & Flexibility)**

부산에 갑자기 대형 백화점이 생겨서 판매 데이터가 폭발적으로 증가했다면, 기존에 서울에만 있던 판매 데이터베이스를 부산에도 복사해서 저장할 수 있습니다. 이렇게 하면 부산 사용자들은 멀리 서울 서버까지 데이터를 요청하러 갈 필요 없이 가까운 부산 서버에서 빠르게 데이터를 받아볼 수 있습니다. 네트워크 트래픽 비용도 줄고, 응답 속도도 빨라집니다.

**⑤ 자료 공유와 분산 제어, 연산 속도 향상**

하나의 작업을 처리하는 데 30분이 걸린다고 가정해봅시다. 이 작업을 서울, 부산, 광주 세 곳이 나눠서 병렬로 처리하면 10분 만에 끝낼 수 있습니다. 이것이 **분산 제어(Distributed Control)** 의 핵심입니다. 동시에 여러 서버가 협력해서 처리하기 때문에 연산 속도가 비약적으로 향상됩니다.

### 단점: 분산 데이터베이스의 어두운 면

세상에 완벽한 시스템은 없습니다. 장점이 있으면 반드시 단점도 있습니다.

**① 소프트웨어 개발 비용 증가**

중앙 집중식으로 하나만 만들면 될 것을 여러 곳에 쪼개서 관리해야 하기 때문에, 분산 DBMS를 구축하고 유지하는 비용이 훨씬 많이 듭니다. 각 지역마다 서버도 설치해야 하고, 네트워크 장비도 구축해야 하며, 분산 DBMS 소프트웨어도 각각 설치해야 합니다.

**② 숨겨진 오류와 복잡성**

전 세계에 수십만 개의 서버가 복잡하게 연결된 인터넷망은 그 복잡성 때문에 어디서 오류가 발생할지, 어떤 경로로 해킹 공격이 들어올지 완벽하게 통제하기가 매우 어렵습니다. 마치 아주 복잡하게 얽힌 거미줄처럼, 전체 구조가 복잡할수록 그 안에 잠재된 위험성도 커집니다.

| 구분 | 중앙 집중식 DB | 분산 DB |
|---|---|---|
| **장애 대응** | 하나가 고장나면 전체 마비 | 일부 장애에도 서비스 유지 |
| **확장성** | 한계가 있음 | 유연하게 확장 가능 |
| **비용** | 초기 구축 비용 낮음 | 구축/유지 비용 높음 |
| **복잡성** | 단순하고 관리 쉬움 | 복잡하고 오류 추적 어려움 |
| **연산 속도** | 단일 처리 | 병렬 처리로 빠름 |

---

## 🔍 분산 데이터베이스의 투명성 (Transparency)

### "투명하다"는 것이 무슨 뜻일까?

:::warning 용어 주의
일반적으로 "투명하다"라고 하면 "속이 다 보인다"는 뜻입니다. 하지만 데이터베이스에서 **투명성(Transparency)** 은 정반대의 의미입니다!
:::

분산 데이터베이스에서 투명성이란 **"사용자가 알 필요가 없는 것을 시스템이 알아서 처리해줌으로써, 사용자가 쉽게 사용할 수 있게 만드는 것"** 을 의미합니다.

마치 자동차 운전과 같습니다. 우리는 엔진의 구조, 연료 분사 메커니즘, 변속기의 작동 원리를 몰라도 자동차를 운전할 수 있습니다. 엔진이 "투명하게" 처리해주기 때문입니다. 분산 데이터베이스의 투명성도 마찬가지입니다. 데이터가 어디에 저장되어 있는지, 어떻게 중복 관리되는지를 사용자는 알 필요가 없습니다.

분산 데이터베이스가 제공해야 하는 주요 투명성은 다음과 같습니다.

### 📍 위치 투명성 (Location Transparency)

**왜 필요한가?**

만약 위치 투명성이 없다면, 네이버에 접속하기 위해 이렇게 입력해야 할 수도 있습니다:

```
# 위치 투명성이 없는 가상의 세계에서...
# 서울 데이터센터에 있는 네이버에 접속하려면:
naver.com/seoul/datacenter-3/db-server-12

# LA 데이터센터에 있는 구글에 접속하려면:
google.com/LA/main-datacenter/db-cluster-5
```

이렇게 서버의 정확한 위치를 알아야만 접속할 수 있다면 얼마나 불편할까요? 게다가 서버 위치가 바뀌면 우리가 외우고 있던 주소도 모두 바꿔야 합니다.

**위치 투명성이 있다면?**

```
# 우리가 실제로 하는 것
naver.com
```

이것만 입력하면 됩니다! 시스템이 자동으로 현재 내 위치에서 가장 가까운, 가장 최적화된 서버를 찾아서 연결해줍니다. 사용하려는 데이터가 어느 서버에 저장되어 있는지 사용자는 전혀 알 필요가 없고, 그 위치 정보는 **분산 시스템 카탈로그(Distributed System Catalog)** 라는 곳에서 유지되고 관리됩니다.

> **분산 시스템 카탈로그:** 분산 데이터베이스 시스템에서 각 데이터가 어느 서버에 저장되어 있는지를 기록해둔 목록. 마치 도서관의 책 목록처럼, "이 데이터는 서울 서버에 있다"는 정보를 저장합니다.

### 🔁 중복 투명성 (Replication Transparency)

**왜 중복이 필요한가?**

앞서 살펴본 것처럼, 분산 데이터베이스의 가용성과 신뢰성, 빠른 처리 속도를 위해서는 **데이터의 중복 저장이 필수**입니다. 학생 데이터베이스가 서울, 부산, 광주에 모두 복사되어 있어야 서울 서버가 고장나도 부산이나 광주에서 접근할 수 있습니다.

**중복 투명성이란?**

학생 데이터베이스가 서울, 부산, 광주 세 곳에 모두 중복 저장되어 있다고 합시다. 사용자가 학생 정보를 조회하려 할 때, 어느 서버에서 데이터를 가져오는지 사용자는 전혀 모릅니다. 분산 DBMS가 알아서 가장 적합한 서버에서 데이터를 가져와줍니다.

또한 학생 정보를 수정했을 때, 세 곳의 복사본이 모두 동일하게 업데이트되어야 합니다. 이것도 사용자가 직접 신경 쓸 필요 없이 분산 DBMS가 알아서 처리합니다. 이것이 바로 **중복 투명성**입니다.

중복의 종류는 두 가지가 있습니다:

- **완전 중복:** 전체 데이터베이스를 100% 동일하게 여러 곳에 복사
- **부분 중복:** 데이터베이스를 쪼개서 일부만 각 지역에 저장

:::tip 중복 저장의 핵심
중복이 있어야:
- 한 서버가 고장나도 다른 서버로 서비스 가능 → **가용성 향상**
- 여러 서버가 동시에 나눠서 처리 가능 → **처리 속도 향상**
- 가까운 서버에서 데이터를 받아볼 수 있음 → **응답 속도 향상**
:::

---

## 🗄️ 분산 데이터베이스의 구조와 단편화

### 4개의 스키마 계층

분산 데이터베이스는 데이터를 저장하고 관리하기 위해 4개의 계층적인 스키마(Schema, 구조 설계도)를 사용합니다.

전체 구조를 먼저 그림으로 이해해봅시다:

```
[전역 스키마] → 하나의 완전한 테이블 (원본)
      ↓
[단편화 스키마] → 테이블을 여러 조각으로 쪼갬
      ↓
[할당 스키마] → 각 조각을 어느 지역 서버에 배치할지 결정
      ↓
[지역 사상 스키마] → 실제로 해당 서버에 저장(매핑)
```

| 스키마 이름 | 역할 | 비유 |
|---|---|---|
| **전역 스키마** | 전체 데이터베이스의 원본 구조 | 원본 레시피 |
| **단편화 스키마** | 원본을 여러 조각으로 나누는 방법 | 레시피를 파트별로 나누기 |
| **할당 스키마** | 각 조각을 어느 지역에 배치할지 결정 | 각 파트를 어느 주방에 맡길지 결정 |
| **지역 사상 스키마** | 실제로 해당 서버에 물리적으로 저장 | 각 주방에서 실제로 요리하기 |

### 단편화 (Fragmentation): 데이터를 쪼개는 방법

단편화는 하나로 되어있는 원본 테이블을 **관계 대수(Relational Algebra, 데이터베이스에서 테이블을 조작하는 연산)** 를 이용해서 여러 개의 조각(단편)으로 나누는 것입니다.

단편화의 방법에는 세 가지가 있습니다.

#### 📊 수평 단편화 (Horizontal Fragmentation)

테이블을 **행(Row, 가로줄)** 단위로 나누는 방식입니다. 마치 명단을 남학생 명단과 여학생 명단으로 나누듯이, 데이터의 값을 기준으로 테이블을 가로로 잘라냅니다.

```sql
-- 예시: 학생 테이블을 수평 단편화
-- 원본 학생 테이블
-- | 학번 | 이름 | 학과    | 성별 |
-- | 001  | 김철수 | 컴퓨터 | 남   |
-- | 002  | 이영희 | 경영   | 여   |
-- | 003  | 박민수 | 컴퓨터 | 남   |
-- | 004  | 정수진 | 수학   | 여   |

-- 단편 1: 컴퓨터 학과 학생들 (셀렉션 연산 사용)
SELECT * FROM 학생 WHERE 학과 = '컴퓨터';
-- 결과: 김철수, 박민수 → 서울 서버에 저장

-- 단편 2: 컴퓨터 학과가 아닌 학생들 (셀렉션 연산 사용)
SELECT * FROM 학생 WHERE 학과 != '컴퓨터';
-- 결과: 이영희, 정수진 → 부산 서버에 저장
```

수평 단편화의 특징:
- **셀렉션(Selection) 연산** 으로 구현
- 값이 바뀌면 해당 튜플(행)이 속하는 단편이 바뀔 수 있으므로 **동적 단편화**라고 함
- 원래 테이블을 복원하려면: **합집합(UNION)** 연산 사용
- 각 단편의 교집합: **공집합** (컴퓨터이면서 컴퓨터가 아닌 학생은 없음)

#### 📋 수직 단편화 (Vertical Fragmentation)

테이블을 **열(Column, 세로줄, 속성)** 단위로 나누는 방식입니다. 마치 학생 정보를 기본 인적사항 카드와 성적 카드로 분리하듯이, 속성을 기준으로 테이블을 세로로 잘라냅니다.

```sql
-- 예시: 학생 테이블을 수직 단편화
-- 원본 학생 테이블
-- | 학번 | 이름 | 학년 | 학과 | 성적 | 지도교수 |
-- (학번이 기본키)

-- 단편 1: 기본 인적사항 (프로젝션 연산 사용)
-- 기본키(학번)는 반드시 양쪽에 포함되어야 함!
SELECT 학번, 이름, 학년, 학과 FROM 학생;
-- → 서울 서버에 저장

-- 단편 2: 학업 정보 (프로젝션 연산 사용)
SELECT 학번, 성적, 지도교수 FROM 학생;
-- → 부산 서버에 저장
```

수직 단편화의 특징:
- **프로젝션(Projection) 연산** 으로 구현
- 기본키(Primary Key)는 반드시 모든 단편에 포함되어야 함 (나중에 합칠 때 필요)
- 값이 바뀌어도 어느 단편에 속하는지는 바뀌지 않으므로 **정적 단편화**라고 함
- 원래 테이블을 복원하려면: **자연 조인(Natural Join)** 연산 사용

#### 🔀 혼합 단편화 (Mixed Fragmentation)

수평 단편화와 수직 단편화를 함께 사용하는 방식입니다. 더 복잡하지만 더 세밀한 데이터 분산이 가능합니다. 원래 테이블을 복원하려면 자연 조인과 합집합을 함께 사용해야 합니다.

### 할당 (Allocation): 조각을 어디에 배치할까?

단편화로 데이터를 쪼갰으면, 이제 각 조각을 어느 지역 서버에 배치할지 결정해야 합니다. 이것이 **할당**입니다.

```
단편 1 → 서울 서버 (배치)
단편 2 → 부산 서버 (배치)
단편 1 + 단편 2 → 광주 서버 (중복 배치)
```

이처럼 단편을 중복해서 여러 서버에 배치할 수도 있고, 하나의 서버에만 배치할 수도 있습니다. 어떻게 할당하느냐에 따라 가용성, 처리 속도, 스토리지 비용이 달라집니다.

---

## 🔐 분산 트랜잭션 관리: 2단계 완료 규약

### 트랜잭션 관리자와 조정자

분산 데이터베이스에서는 각 지역 사이트마다 **트랜잭션 관리자(Transaction Manager)** 가 있습니다. 이 관리자는 자기 지역의 병행 제어(동시 접근 처리), 회복(장애 복구), 권한 검사, 무결성 검사 등을 담당합니다.

그런데 문제가 있습니다. 서울, 부산, 광주에 걸쳐 있는 하나의 작업을 처리할 때, 서울의 트랜잭션 관리자는 서울 것만 알고, 부산의 관리자는 부산 것만 압니다. 서울에서 처리가 완료됐는데 광주에서 실패하면 데이터 불일치가 생깁니다.

이를 해결하기 위해 등장한 것이 **트랜잭션 조정자(Transaction Coordinator/Coordinator)** 입니다. 조정자는 중간에서 모든 지역 사이트의 트랜잭션 실행을 통제하고 조정하는 역할을 합니다. 분산 데이터베이스에서만 필요한 핵심 구성 요소입니다.

### 2단계 완료 규약 (2-Phase Commit Protocol)

**문제 상황 이해하기**

서울, 부산, 광주 세 서버 모두에 저장된 데이터 `A`를 `B`로 변경하려고 합니다. 서울과 부산은 성공적으로 변경했는데, 광주는 네트워크 문제로 변경에 실패했습니다. 그 결과:

- 서울: `B` ✅
- 부산: `B` ✅
- 광주: `A` ❌ (변경 실패)

이제 세 서버에 같은 데이터인데 서로 다른 값이 저장되어 있습니다. **데이터 무결성(Data Integrity, 데이터가 정확하고 일관성 있게 유지되는 것)** 이 깨진 것입니다!

**2단계 완료 규약의 해결 방법**

```
[1단계: 준비 단계 (Prepare Phase)]
조정자 → 서울: "A를 B로 바꿀 준비가 됐습니까?"
조정자 → 부산: "A를 B로 바꿀 준비가 됐습니까?"
조정자 → 광주: "A를 B로 바꿀 준비가 됐습니까?"

서울 → 조정자: "준비 완료!" (OK)
부산 → 조정자: "준비 완료!" (OK)
광주 → 조정자: "준비 완료!" (OK)

[2단계: 커밋 단계 (Commit Phase)]
모든 참여자가 OK → 조정자가 커밋(Commit) 명령
서울: 커밋 실행 ✅
부산: 커밋 실행 ✅
광주: 커밋 실행 ✅
```

만약 광주가 "준비 완료"를 보내지 못했다면:

```
서울 → 조정자: "준비 완료!" (OK)
부산 → 조정자: "준비 완료!" (OK)
광주 → 조정자: "준비 불가!" (FAIL) ← 하나라도 실패

조정자 → 서울, 부산, 광주 전체: "전부 롤백(취소)하세요!"
→ 모든 서버가 원래 A 값으로 되돌아감
```

> **핵심 원칙:** 모든 참여자가 커밋할 준비가 됐을 때만 커밋한다. 하나라도 실패 신호를 보내면 전체를 롤백한다. 이것이 **원자성(Atomicity)** 을 보장하는 방법입니다.

### 3단계 완료 규약 (3-Phase Commit Protocol)

2단계 완료 규약에는 치명적인 약점이 있습니다. 조정자 자체가 고장나면 어떻게 될까요? 참여자들은 조정자로부터 커밋/롤백 명령을 기다리고 있는데, 조정자가 응답이 없으면 영원히 기다려야 하는 **봉쇄(Blocking)** 상태가 됩니다.

**3단계 완료 규약**은 이 문제를 해결하기 위해 등장했습니다. 핵심 아이디어는 조정자가 알고 있는 정보를 다른 참여자들도 알게 하는 것입니다. 이를 **예비 완료 결정 단계**라고 합니다.

조정자가 일정 시간 동안 응답이 없으면, 참여자들이 "조정자에게 문제가 생겼구나"라고 판단하고, 조정자가 가지고 있던 정보를 바탕으로 스스로 결정을 내릴 수 있게 됩니다. 이렇게 하면 조정자가 장애를 일으키더라도 트랜잭션의 운명을 스스로 결정할 수 있습니다.

:::note 2단계 vs 3단계 완료 규약 비교
- **2단계:** 조정자가 멈추면 참여자들이 봉쇄됨 (응답 대기 상태 지속)
- **3단계:** 조정자가 멈춰도 참여자들이 스스로 결정 가능 (봉쇄 방지)
:::

---

## 🏗️ 클라이언트-서버 구조: 2티어와 3티어

### 2티어 모델 (Two-Tier Model)

클라이언트-서버 구조는 오래전부터 사용해온 컴퓨팅 환경입니다. 2티어 모델에서는 **클라이언트**와 **서버**, 두 계층으로 구성됩니다.

문제는 2티어 모델에서 클라이언트가 해야 할 일이 너무 많다는 것입니다:

```
[2티어 모델]
클라이언트 = 프레젠테이션 처리 + 비즈니스 로직 처리 (모두 담당)
서버 = 데이터베이스만 처리
```

- **프레젠테이션 처리:** 화면에 무언가를 보여주고, 입력을 받는 것
- **비즈니스 로직 처리:** 계산하고, 판단하고, 알고리즘을 수행하는 것

클라이언트가 이 두 가지를 모두 처리하니 클라이언트의 성능이 부담을 받습니다. 이런 클라이언트를 **팻 클라이언트(Fat Client, 뚱뚱한 클라이언트)** 라고 부릅니다. 일이 너무 많아서 "뚱뚱하다"는 표현을 씁니다.

또 다른 문제는 **유지보수**입니다. 비즈니스 로직이 변경되면, 클라이언트 수만큼 전부 업데이트해야 합니다. 사용자가 10만 명이면 10만 개의 클라이언트를 모두 수정해야 합니다.

### 3티어 모델 (Three-Tier Model)

3티어 모델은 2티어의 단점을 해결하기 위해 등장했습니다. 클라이언트에서 비즈니스 로직 부분을 떼어내서 별도의 **미들웨어 서버(Middleware Server, 중간 서버)** 로 이동시킨 것입니다.

```
[3티어 모델]
클라이언트 = 프레젠테이션 처리만 담당 (화면 표시, 입력 처리)
미들웨어 서버(웹 서버) = 비즈니스 로직 처리 (계산, 알고리즘)
데이터베이스 서버 = 데이터 저장 및 조회
```

현재 우리가 사용하는 거의 모든 웹 서비스가 이 3티어 구조를 기반으로 합니다. 톰캣(Tomcat), JSP(Java Server Pages) 같은 웹 서버가 바로 가운데 미들웨어 서버에 해당합니다.

3티어의 장점:
- 클라이언트가 가벼워짐 → 성능 향상
- 비즈니스 로직 변경 시 미들웨어 서버만 수정하면 됨 → 유지보수 용이
- 보안성 향상 (데이터베이스가 직접 외부에 노출되지 않음)

| 구분 | 2티어 | 3티어 |
|---|---|---|
| **클라이언트 역할** | 프레젠테이션 + 비즈니스 로직 | 프레젠테이션만 |
| **중간 서버** | 없음 | 미들웨어(웹 서버) |
| **유지보수** | 클라이언트 모두 수정 필요 | 미들웨어만 수정 |
| **클라이언트 성능** | 부하 큼 (팻 클라이언트) | 부하 적음 |

---

## 🧩 객체 지향 데이터베이스와 객체 관계 데이터베이스

### 왜 관계형 데이터베이스만으로는 부족했나?

기존의 관계형 데이터베이스는 표(테이블) 형태의 정형화된 데이터만 다룰 수 있었습니다. 숫자, 텍스트 같은 단순한 데이터 타입은 잘 처리하지만, 다음과 같은 것들은 처리하기 어렵습니다:

- **멀티미디어 데이터:** 이미지, 동영상, 오디오 파일
- **비구조적 데이터:** 형태가 정해지지 않은 데이터
- **복잡한 관계:** 상속(부모-자식 관계), 참조 포인터 등

이러한 한계를 극복하기 위해 등장한 것이 **객체 지향 데이터베이스(Object-Oriented Database)** 입니다.

### 객체 지향의 핵심 개념들

**① 다형성 (Polymorphism)**

하나의 메시지(명령)에 대해 서로 다른 객체가 각자 다른 방법으로 반응하는 것입니다.

```python
# 다형성 예시
class 삼각형:
    def draw(self):  # 같은 이름의 메서드
        print("△ 삼각형을 그립니다")  # 삼각형 방식으로 반응

class 사각형:
    def draw(self):  # 같은 이름의 메서드
        print("□ 사각형을 그립니다")  # 사각형 방식으로 반응

class 원:
    def draw(self):  # 같은 이름의 메서드
        print("○ 원을 그립니다")  # 원 방식으로 반응

# "draw"라는 동일한 메시지를 보내도 각 객체가 다르게 반응
도형들 = [삼각형(), 사각형(), 원()]
for 도형 in 도형들:
    도형.draw()  # 각자 다른 방식으로 그림을 그림
```

**② 오버로딩 (Overloading)**

같은 이름의 메서드를 여러 개 정의하되, 매개변수(입력 값)의 개수나 타입을 다르게 해서 다양한 상황에서 사용할 수 있게 하는 것입니다.

```python
# 오버로딩 개념 예시 (파이썬은 기본적으로 오버로딩 미지원이지만 개념 설명)
# 계산기 클래스 - 입력 값 2개를 더하기
def add(a, b):
    return a + b  # 두 수를 더함

# 오버로드 - 입력 값 4개를 더하기 (같은 이름, 다른 매개변수)
def add(a, b, c, d):
    return a + b + c + d  # 네 수를 더함
```

**③ 오버라이딩 (Overriding)**

부모 클래스에서 상속받은 메서드의 겉모양(이름, 매개변수)은 그대로 두고, 내부 내용만 완전히 새로 작성하는 것입니다. 구조만 가져오고 내용은 자신에 맞게 재정의합니다.

**④ 동적 바인딩 (Dynamic Binding)**

값이 입력되는 시점(실행 시간)에 데이터 타입이 결정되고 처리되는 것입니다. 컴파일(번역) 시점이 아닌 실행 시점에 타입이 결정됩니다.

**⑤ 메시지 패싱 (Message Passing)**

객체와 객체 사이에 통신하는 방식입니다. 한 객체가 다른 객체의 메서드를 호출하면, 그 객체가 처리한 결과를 반환하는 것입니다.

### 객체 식별자 (OID: Object Identifier)

관계형 데이터베이스에서는 **기본키(Primary Key)** 로 데이터를 식별하지만, 객체 지향 데이터베이스에서는 **OID(Object Identifier, 객체 식별자)** 를 사용합니다.

OID는 마치 사람의 지문이나 홍채와 같습니다. 사람은 주민등록번호로도 식별하지만, 생체 정보(지문, 홍채, 안면 등)는 태어날 때부터 자동으로 결정되며 절대 바꿀 수 없습니다.

OID의 특징:
- **시스템이 자동으로 지정** (사용자가 직접 설정하지 않음)
- **절대 변경 불가능** (한번 부여되면 바꿀 수 없음)
- **객체마다 유일** (같은 OID를 가진 객체는 존재하지 않음)
- **객체가 삭제될 때만 제거** (삭제된 OID는 재사용 불가)

### 캡슐화 (Encapsulation)

캡슐화는 속성(데이터)과 메서드(기능)를 하나의 클래스 안에 묶어서, 내부 구현을 숨기고 사용 방법만 외부에 공개하는 것입니다.

```python
class 계산기:
    # 내부 구현 (숨겨져 있음)
    def __add_internal(self, a, b):
        # 복잡한 내부 계산 로직...
        return a + b

    # 외부에 공개된 사용법만 제공
    def add(self, a, b):
        return self.__add_internal(a, b)

# 사용자는 내부가 어떻게 되어있는지 모르고
# 그냥 add(5, 2) 라고만 호출하면 7이 나온다는 것만 알면 됨
계산기 = 계산기()
결과 = 계산기.add(5, 2)  # 내부 구현은 몰라도 됨!
print(결과)  # 7 출력
```

이것이 바로 **정보 은익(Information Hiding)** 입니다. 사용 방법만 알면 내부 구현을 몰라도 쓸 수 있게 만드는 것입니다.

### 세 가지 데이터베이스 비교

| 구분 | 관계형 DB | 객체 지향 DB | 객체 관계 DB |
|---|---|---|---|
| **데이터 구조** | 테이블 | 객체 | 테이블 + 객체 |
| **저장 데이터** | 정형 데이터 | 비정형 데이터 | 정형 + 비정형 |
| **질의 언어** | SQL | ODL, OQL | 확장 SQL |
| **장점** | 사용 편리, 대용량 처리 | 복잡한 데이터 처리 | 두 가지 장점 모두 |
| **단점** | 멀티미디어 처리 어려움 | 표준화 미비, 접근 어려움 | 복잡성 증가 |

:::info 객체 관계 데이터베이스란?
관계형 데이터베이스의 편리함과 SQL 사용성을 유지하면서, 객체 지향의 상속, 캡슐화, 복잡한 데이터 타입 처리 능력을 추가한 것입니다. 즉, 두 가지의 장점을 합친 하이브리드 방식입니다.
:::

:::danger 절대 혼동하지 말 것
- **객체 지향 데이터베이스:** 객체 지향 프로그래밍 언어에 데이터베이스 기능을 추가한 것. ODL/OQL 사용.
- **객체 관계 데이터베이스:** 관계형 데이터베이스에 객체 개념을 추가해서 풍부하게 만든 것. 확장 SQL 사용.
출발점이 다릅니다. 전자는 객체 지향에서 출발, 후자는 관계형에서 출발.
:::

---

## ⚠️ 주의사항과 핵심 팁

### 분산 데이터베이스 설계 시 주의할 점

**단편화할 때 기본키를 빠뜨리면 안 됩니다**

수직 단편화를 할 때 기본키는 반드시 모든 단편에 포함되어야 합니다. 기본키가 없으면 나중에 단편들을 다시 합칠 때(자연 조인) 어떤 행끼리 매칭되어야 하는지 알 수 없습니다.

```sql
-- ❌ 잘못된 수직 단편화 (기본키 누락)
-- 단편 1: 이름, 학년, 학과 (학번 없음!)
-- 단편 2: 성적, 지도교수 (학번 없음!)
-- → 나중에 조인할 때 어떤 행끼리 연결해야 할지 모름!

-- ✅ 올바른 수직 단편화 (기본키 포함)
-- 단편 1: 학번(기본키), 이름, 학년, 학과
-- 단편 2: 학번(기본키), 성적, 지도교수
-- → 학번을 기준으로 자연 조인하면 원본 복원 가능!
```

**2단계 완료 규약에서 하나라도 실패하면 전체를 롤백해야 합니다**

일부만 커밋하고 일부는 실패한 상태로 두면 데이터 불일치가 발생합니다. 이것이 바로 트랜잭션의 **원자성(Atomicity, 모두 성공하거나 모두 실패하거나)** 원칙입니다.

```
# ❌ 잘못된 처리: 일부만 커밋
서울: 커밋 ✅
부산: 커밋 ✅
광주: 실패했지만 그냥 진행... ❌
→ 데이터 불일치 발생! 무결성 위반!

# ✅ 올바른 처리: 하나라도 실패하면 전체 롤백
서울: 준비됨
부산: 준비됨
광주: 실패 → 조정자가 서울, 부산에도 롤백 명령
→ 모두 원래 상태로 돌아감. 무결성 유지!
```

:::warning 분산 데이터베이스의 핵심 주의사항
- 데이터 중복은 가용성을 높이지만, 동기화(모든 복사본을 일치시키는 것) 비용도 높아집니다.
- 분산 환경에서 트랜잭션은 네트워크 지연, 부분 장애 등 다양한 이슈가 발생할 수 있습니다.
- 시스템이 복잡할수록 오류 추적과 디버깅이 어렵습니다.
:::

:::tip 학습 팁
분산 데이터베이스를 공부할 때 가장 중요한 개념들:
1. **투명성:** 사용자가 내부 복잡성을 몰라도 쉽게 사용 가능
2. **단편화:** 수평(행 기준, 셀렉션), 수직(열 기준, 프로젝션)
3. **2단계 완료 규약:** 모두 준비됐을 때만 커밋, 하나라도 실패면 롤백
4. **4개의 스키마:** 전역 → 단편화 → 할당 → 지역 사상
이 네 가지를 확실히 이해하면 분산 데이터베이스의 핵심을 잡은 것입니다!
:::

---

## 📝 핵심 정리

- **분산 데이터베이스**는 물리적으로 여러 곳에 분산된 DB를 사용자가 하나의 시스템처럼 사용할 수 있게 해주는 시스템이다.
- **분산 DBMS**는 분산된 여러 데이터베이스를 효율적으로 관리해주는 소프트웨어다.
- 분산 데이터베이스의 구성 요소는 **분산 처리기, 분산 데이터베이스, 통신 네트워크** 세 가지다.
- **장점:** 지역 자치성, 용량 확장 용이, 신뢰성/가용성 향상, 효율성/융통성, 병렬 처리로 연산 속도 향상.
- **단점:** 소프트웨어 개발 비용 증가, 복잡한 네트워크로 인한 숨겨진 오류 위험.
- **투명성**은 사용자가 내부 구조를 몰라도 쉽게 사용할 수 있게 하는 것 (속이 다 보인다는 뜻이 아님!).
- **위치 투명성**: 데이터가 어느 서버에 있는지 사용자는 몰라도 된다.
- **중복 투명성**: 데이터가 어떻게 중복 저장되어 있는지 사용자는 몰라도 된다.
- 분산 DB의 4개 스키마: **전역 스키마 → 단편화 스키마 → 할당 스키마 → 지역 사상 스키마**.
- **수평 단편화**는 행(Row) 기준으로 쪼개며 셀렉션 연산 사용, 복원 시 합집합 사용.
- **수직 단편화**는 열(Column) 기준으로 쪼개며 프로젝션 연산 사용, 복원 시 자연 조인 사용.
- **2단계 완료 규약**: 준비 단계에서 모두 OK면 커밋, 하나라도 FAIL이면 전체 롤백.
- **3단계 완료 규약**: 조정자가 장애를 일으켜도 참여자들이 스스로 트랜잭션 운명을 결정할 수 있게 한다.
- **2티어 모델**은 클라이언트가 프레젠테이션과 비즈니스 로직 모두 처리 (팻 클라이언트).
- **3티어 모델**은 비즈니스 로직을 미들웨어 서버로 분리, 클라이언트는 프레젠테이션만 담당.
- **OID**는 시스템이 자동 부여하는 객체의 고유 식별자로, 변경 및 재사용 불가.
- **객체 지향 DB**는 객체 지향에서 출발, ODL/OQL 사용; **객체 관계 DB**는 관계형에서 출발, 확장 SQL 사용.

---

작성일: 2026-02-21