---
title: "데이터베이스란 무엇인가"
description: "데이터베이스란 무엇인가에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/database-history-and-dbms/1-database-introduction"
sidebar_label: "데이터베이스 소개"
date: "2026-02-20"
---

# 데이터베이스란 무엇인가 🗄️

안녕하세요! 이번 시간부터 **데이터베이스(Database)** 라는 주제를 함께 공부해 나갑니다. 데이터베이스는 IT 분야에서 일하는 분이라면 직무에 상관없이 반드시 이해하고 있어야 하는 핵심 기술입니다. 개발자는 물론, 시스템 설계자, 운영자, 데이터 분석가까지 사실상 IT 종사자라면 99.9%가 데이터베이스를 매일 사용합니다. 이 문서에서는 데이터베이스가 **왜 등장했는지**, **어떤 역사를 거쳐 발전했는지**, 그리고 **데이터베이스를 관리하는 시스템인 DBMS가 무엇인지**를 초보자도 쉽게 이해할 수 있도록 하나씩 풀어서 설명합니다.

---

## 🗂️ 데이터베이스 이전의 세계 — 파일 시스템

### 파일 시스템이란 무엇인가?

데이터베이스를 이해하려면 먼저 데이터베이스가 등장하기 **이전에 어떤 방식으로 데이터를 저장하고 관리했는지**부터 알아야 합니다. 컴퓨터가 처음 등장한 1960년대 이전부터 사람들은 데이터를 **파일(File)** 이라는 형태로 컴퓨터에 저장했습니다. 이 방식을 **파일 시스템(File System)** 이라고 부릅니다.

파일 시스템은 지금도 우리 주변에서 쉽게 볼 수 있습니다. 윈도우 탐색기를 열면 문서 파일, 사진 파일, 동영상 파일 등 수많은 파일들이 폴더 안에 정리되어 있죠. 이것이 바로 파일 시스템입니다. 파일 시스템은 **운영체제(OS, Operating System) 수준에서 기본적으로 지원**되는 방식으로, 오라클(Oracle)이나 MySQL 같은 별도의 소프트웨어 없이도 운영체제의 커널(Kernel, 운영체제의 핵심 부분)이 직접 파일을 저장하고 관리합니다.

:::info 파일 시스템은 지금도 쓰인다
파일 시스템은 지금도 컴퓨터에서 여전히 사용됩니다. 데이터베이스와 파일 시스템은 서로 다른 목적으로 공존하며 사용됩니다. 데이터베이스가 파일 시스템을 완전히 대체한 것이 아니라, 파일 시스템이 가진 **한계를 보완하기 위해** 데이터베이스가 등장한 것입니다.
:::

### 파일 시스템의 두 가지 치명적 문제점

파일 시스템은 혼자 사용하는 경우에는 전혀 문제가 없습니다. 하지만 **여러 사람이 동시에 같은 데이터를 사용해야 하는 환경**에서는 치명적인 문제가 발생합니다. 이 문제는 크게 두 가지로 정리할 수 있습니다.

#### 🔴 문제 1: 중복성 (Redundancy, 데이터가 여러 곳에 중복 저장되는 문제)

예를 들어 생각해 봅시다. 회사에 A, B, C 세 명의 직원이 있고, 이들이 모두 `고객정보.xlsx`라는 똑같은 파일을 사용한다고 가정합니다. 파일 시스템에서는 이 파일이 A의 컴퓨터에도 있고, B의 컴퓨터에도 있고, C의 컴퓨터에도 따로 저장되어 있습니다.

어느 날 A가 고객의 주소를 수정했습니다. 그런데 B와 C는 자기 컴퓨터에 있는 파일을 아직 수정하지 않았습니다. 이제 세 사람이 가진 데이터가 서로 달라졌습니다. **어떤 파일의 주소가 정확한 최신 주소인지 알 수 없는 상황**이 된 것입니다. 이것을 **데이터 불일치(Data Inconsistency)** 라고 하며, 중복성의 가장 큰 부작용입니다.

#### 🔴 문제 2: 종속성 (Dependency, 데이터 구조와 프로그램이 서로 엮여 있는 문제)

파일 시스템에서는 파일의 구조(예: 컬럼 순서, 데이터 타입 등)가 바뀌면, 그 파일을 사용하는 **프로그램도 반드시 함께 수정해야** 합니다. 마치 집의 문 크기가 바뀌면 그 문에 맞게 만들어진 문틀도 전부 다시 제작해야 하는 것처럼, 데이터 구조와 프로그램이 서로 강하게 묶여(종속되어) 있어서 유지보수가 매우 어렵습니다.

> 💡 **결론:** 파일 시스템은 여러 사람이 동시에 데이터를 공유하는 환경에서 **중복성**과 **종속성**이라는 두 가지 치명적 문제를 가지고 있습니다. 이 문제를 해결하기 위해 **데이터베이스**라는 개념이 탄생했습니다.

---

## 📅 데이터베이스의 발전 역사 — 어떻게 진화해 왔는가?

데이터베이스는 파일 시스템의 문제점을 해결하기 위해 1960년대부터 개발되기 시작했으며, 이후 수십 년에 걸쳐 꾸준히 발전해 왔습니다. 각 시대별로 어떤 형태의 데이터베이스가 등장했는지 살펴보겠습니다.

### 1960년대 — 계층형 DBMS (Hierarchical DBMS)

파일 시스템의 한계를 극복하기 위해 처음 등장한 데이터베이스 관리 시스템이 바로 **계층형 DBMS**입니다. 계층형이라는 이름처럼, 데이터가 **트리(Tree) 구조**로 저장됩니다.

트리 구조는 회사의 **조직도**를 생각하면 쉽게 이해할 수 있습니다. 회사의 최고경영자(CEO)가 맨 위에 있고, 그 아래에 각 부서장이 있고, 부서장 아래에 팀장, 팀장 아래에 팀원이 있는 형태입니다. 계층형 DBMS에서는 위에 있는 노드(Node, 데이터 저장 단위)를 **부모(Parent)**, 아래에 있는 노드를 **자식(Child)** 이라고 부릅니다.

| 특징 | 설명 |
|------|------|
| 구조 | 트리(Tree) 구조 |
| 관계 | 부모(Parent) — 자식(Child) 관계 |
| 정보 흐름 | 위에서 아래로만 가능 (단방향) |
| 사이클 | 사이클(순환) 불가 |

계층형 DBMS의 가장 큰 특징은 **사이클(Cycle, 순환)이 발생하지 않는다**는 것입니다. 자식이 부모가 될 수 없고, 정보는 반드시 위에서 아래 방향으로만 흐릅니다. 이는 단순한 데이터 표현에는 효과적이었지만, 복잡한 현실 세계의 관계를 표현하기에는 한계가 있었습니다.

### 1970년대 — 네트워크형 DBMS (Network DBMS)

계층형 DBMS의 단방향 정보 흐름 문제를 해결하기 위해 등장한 것이 **네트워크형 DBMS**입니다. 네트워크형 DBMS는 **그래프(Graph) 구조**를 사용합니다.

계층형에서 부모-자식으로 불렸던 관계가 네트워크형에서는 **오너(Owner) — 멤버(Member)** 관계로 표현됩니다. 중요한 차이점은, 네트워크형에서는 하나의 멤버가 여러 오너를 가질 수 있고, 멤버가 다른 관계에서는 오너가 될 수도 있다는 점입니다.

| 구분 | 계층형 DBMS | 네트워크형 DBMS |
|------|-------------|-----------------|
| 구조 | 트리 구조 | 그래프 구조 |
| 관계 표현 | 부모-자식 | 오너-멤버 |
| 사이클 | 불가 | 허용 |
| 복잡성 | 낮음 | 높음 |

네트워크형 DBMS는 **사이클을 허용**하기 때문에 복잡한 데이터 관계를 표현할 수 있었지만, 그만큼 구조가 복잡해졌습니다.

### 1970년대 후반 ~ 현재 — 관계형 DBMS (Relational DBMS) ⭐

지금 우리가 가장 많이 사용하는 데이터베이스가 바로 **관계형 DBMS(RDBMS, Relational Database Management System)** 입니다. 관계형 DBMS는 데이터를 **표(Table) 형태**로 저장합니다. 우리가 학교에서 보는 성적표, 출석부, 회사의 직원 명단처럼 행(Row)과 열(Column)로 구성된 표 형태입니다.

:::tip 관계형 DBMS의 대표적인 제품들
- **Oracle**: 대기업, 금융권에서 주로 사용하는 상용 DBMS
- **MySQL**: 웹 개발에서 가장 많이 쓰이는 오픈소스 DBMS
- **MS SQL Server**: 마이크로소프트가 만든 윈도우 환경에 최적화된 DBMS
- **PostgreSQL**: 확장성이 뛰어난 오픈소스 DBMS
:::

관계형 DBMS가 전 세계적으로 가장 많이 사용되는 이유는 다음과 같습니다.

- **이해하기 쉬운 표 구조**: 누구나 직관적으로 이해할 수 있는 행과 열의 표 형태
- **표준화된 개발 방법**: SQL(Structured Query Language, 구조화된 질의 언어)이라는 표준 언어 사용
- **개발과 유지보수 용이**: 오랜 시간 동안 검증된 안정적인 구조

> 🏆 **IT 직무를 수행할 때 사용하게 될 데이터베이스의 99.9%는 관계형 DBMS입니다.** Oracle, MySQL, MS SQL 등 여러분이 앞으로 접하게 될 대부분의 데이터베이스 제품이 모두 관계형 DBMS입니다.

### 1990년대 — 객체지향 DBMS (Object-Oriented DBMS)

관계형 DBMS가 널리 사용되면서, 한 가지 한계가 드러났습니다. 표 구조는 숫자나 문자 같은 **정형 데이터(Structured Data)** 를 저장하는 데는 탁월하지만, **동영상, 이미지, 음악, 지도 정보**와 같은 복잡한 멀티미디어 데이터를 저장하기에는 적합하지 않다는 것입니다.

유튜브의 동영상 파일, 스마트폰으로 찍은 사진, 네비게이션의 지도 데이터(GIS, Geographic Information System) 같은 것들은 테이블의 셀(Cell) 안에 집어넣기가 어렵습니다. 이런 데이터들은 **객체(Object)** 형태로 표현하는 것이 훨씬 자연스럽습니다.

그래서 등장한 것이 **객체지향 DBMS**입니다. 객체지향 DBMS는 Java나 C++ 같은 **객체지향 프로그래밍(OOP, Object-Oriented Programming)** 의 개념에 데이터베이스의 기본 기능을 추가한 것입니다. 이를 통해 동영상 객체, 이미지 객체, 지도 객체 등 복잡한 데이터를 효율적으로 관리할 수 있게 됩니다.

하지만 객체지향 DBMS에는 다음과 같은 단점이 있었습니다.

- **배우기 어렵다**: 클래스, 상속, 다형성 등 OOP 개념을 이해해야 함
- **호환성 문제**: 다른 시스템과의 호환이 쉽지 않음
- **대중화 실패**: 특정 분야에서만 사용되고 일반적으로 널리 보급되지 못함

### 객체관계형 DBMS (Object-Relational DBMS)

객체지향 DBMS의 단점을 극복하기 위해 등장한 것이 **객체관계형 DBMS**입니다. 이름 그대로 **관계형 DBMS + 객체지향 DBMS** 의 장점을 결합한 형태입니다.

관계형 데이터베이스의 **표준화, 대중성, 사용 편의성**에 객체지향의 **복잡한 데이터 처리 능력**을 더한 것이기 때문에, 쉬우면서도 다양한 형태의 데이터를 처리할 수 있습니다. 이 객체관계형 DBMS의 등장과 함께 데이터베이스는 본격적으로 발전의 가속도를 붙이게 됩니다.

### 2000년대 이후 — 빅데이터와 데이터 마이닝

인터넷이 폭발적으로 성장하면서 데이터의 양도 상상을 초월할 정도로 늘어났습니다. 이제 데이터베이스는 단순히 정보를 저장하는 것을 넘어, **24시간 × 7일 = 365일 무중단으로 운영**되어야 하며, 방대한 양의 데이터를 분석해서 **의사결정(Decision Making)** 에 활용하는 역할까지 맡게 됩니다. 이러한 흐름 속에서 **빅데이터(Big Data)** 와 **데이터 마이닝(Data Mining, 데이터에서 의미 있는 패턴을 찾아내는 기술)** 이 데이터베이스의 핵심 활용 분야로 부상하고 있습니다.

```
파일 시스템
    ↓
계층형 DBMS (1960년대)
    ↓
네트워크형 DBMS (1970년대)
    ↓
관계형 DBMS (1970년대 후반 ~ 현재) ⭐ 가장 널리 사용
    ↓
객체지향 DBMS (1990년대)
    ↓
객체관계형 DBMS
    ↓
빅데이터 / 데이터 마이닝 (2000년대 이후)
```

---

## 📖 데이터베이스의 정의와 구성 요소

### 데이터베이스를 한 문장으로 정의한다면?

만약 데이터베이스를 전혀 모르는 친구가 "데이터베이스가 뭐야?"라고 묻는다면, 어떻게 대답해야 할까요? 막연하게 "정보를 저장하는 것"이라고 말하면 충분하지 않습니다. 정확한 정의를 내릴 수 있어야 합니다.

> **데이터베이스(Database)란**, 어느 조직(기업, 학교 등)에서 업무와 의사결정에 활용하기 위해, 여러 사람이 **공동으로 사용**할 수 있도록 **중복을 최소화하여 통합**하고, **하드디스크에 저장**한 **운영 데이터의 집합**입니다.

이 정의를 구성하는 네 가지 핵심 키워드를 하나씩 살펴보겠습니다.

### 🔑 키워드 1: 통합된 데이터 (Integrated Data)

**통합**이란, 여러 곳에 흩어져 있는 데이터를 한 곳으로 모으는 것입니다. 여러 사람이 각자 가지고 있던 중복된 데이터를 하나로 합치면서, 중복된 내용은 제거합니다.

:::warning 중복을 100% 제거하는 것은 아닙니다
"통합된 데이터"는 모든 중복을 완전히 제거한다는 뜻이 아닙니다. 이를 **최소한의 중복, 통제된 중복**이라고 표현합니다. 100% 중복 제거는 오히려 성능(데이터 조회 속도 등)에 문제를 일으킬 수 있습니다. 이 개념은 나중에 **정규화(Normalization)** 와 **역정규화(Denormalization)** 를 공부할 때 더 자세히 다루게 됩니다.
:::

### 🔑 키워드 2: 저장된 데이터 (Stored Data)

데이터베이스의 데이터는 **하드디스크(Hard Disk)와 같은 저장 장치에 디지털 형태로 저장**됩니다. 과거처럼 종이 서류를 파일 철에 끼워서 캐비넷에 보관하는 것이 아니라, 컴퓨터가 읽을 수 있는 디지털 형태로 저장된다는 것이 핵심입니다.

### 🔑 키워드 3: 운영 데이터 (Operational Data)

데이터베이스에 담기는 데이터는 **그 조직의 고유한 기능을 수행하기 위해 반드시 필요한 데이터**입니다. 예를 들어, 대학교의 학사 관리 시스템에는 학번, 이름, 수강 과목, 성적 등의 데이터가 담기고, 공장의 생산 관리 시스템에는 생산량, 불량률, 원자재 재고 등의 데이터가 담깁니다. 임시적이거나 불필요한 데이터가 아닌, 실제 운영에 필요한 데이터만을 의미합니다.

### 🔑 키워드 4: 공용 데이터 (Shared Data)

데이터베이스는 **나 혼자 사용하는 것이 아니라 여러 사용자가 공동으로 소유하고 이용**합니다. 네이버나 구글 같은 웹 서비스를 생각해 보세요. 수천만 명의 사용자가 동시에 접속해서 같은 데이터베이스를 이용하고 있습니다. 이처럼 하나의 데이터베이스를 여러 사람이 함께 사용하는 것이 공용 데이터의 의미입니다.

### 데이터베이스의 일반적 특징 4가지

데이터베이스는 위의 정의 외에도 실제 운영되는 시스템으로서 다음과 같은 특징을 가집니다.

| 특징 | 설명 | 예시 |
|------|------|------|
| **실시간 접근성** | 언제든지 원하는 즉시 데이터에 접근 가능 | 네이버에서 검색하면 즉시 결과가 나옴 |
| **계속적인 변화** | 데이터가 실시간으로 삽입, 수정, 삭제됨 | 날씨 정보, 주가 정보가 실시간 업데이트 |
| **동시 공용** | 여러 사용자가 동시에 같은 데이터를 이용 가능 | 수백만 명이 동시에 유튜브에 접속 |
| **내용에 의한 참조** | 데이터의 위치가 아닌 내용(값)으로 데이터를 찾음 | "점수가 90점 이상인 학생"으로 검색 |

---

## 🏗️ 데이터베이스의 핵심 특성 3가지

데이터베이스에는 특별히 강조해야 할 세 가지 핵심적인 특성이 있습니다. 이 특성들이 데이터베이스를 파일 시스템과 구별 짓는 중요한 요소입니다.

### 특성 1: 자료 추상화 (Data Abstraction) — 복잡함을 숨겨라

**자료 추상화**는 **개념화, 일반화**라고도 부릅니다. 이 개념은 "복잡한 내부 구조를 사용자에게 감춰서, 사용자가 쉽게 데이터베이스를 이용할 수 있게 해주는 것"입니다.

실제로 하드디스크 안에는 데이터가 **0과 1로 구성된 2진수, 16진수 형태의 기계어**로 저장되어 있습니다. 트랙(Track)과 섹터(Sector)라는 복잡한 물리적 구조로 나뉘어 저장됩니다. 만약 데이터베이스가 이 모든 것을 사용자에게 노출한다면, 우리는 데이터베이스를 쓰기 위해 하드웨어 구조와 기계어를 먼저 공부해야 할 것입니다.

하지만 데이터베이스는 이 복잡한 내용을 전부 감추고, 사용자에게는 `SELECT * FROM 학생 WHERE 점수 >= 90` 같은 **사람이 이해하기 쉬운 언어**로 데이터를 다룰 수 있게 해줍니다. 이것이 바로 자료 추상화입니다.

:::tip 자료 추상화를 자동차에 비유하면
자동차를 운전할 때 우리는 엔진의 폭발 원리, 변속기의 톱니바퀴 맞물림 방식을 알 필요가 없습니다. 그냥 핸들을 돌리고 페달을 밟으면 됩니다. 데이터베이스의 자료 추상화도 이와 같습니다. 내부의 복잡한 저장 방식을 몰라도 SQL이라는 간단한 명령어로 데이터를 다룰 수 있습니다.
:::

### 특성 2: 자료 독립성 (Data Independence) — 서로 독립적으로 움직여라

파일 시스템의 가장 큰 문제 중 하나가 **종속성**, 즉 데이터 구조가 바뀌면 프로그램도 함께 바꿔야 한다는 것이었습니다. 데이터베이스는 이 문제를 **자료 독립성**으로 해결합니다.

자료 독립성이란 **데이터의 구조(저장 방식, 형태 등)가 변경되더라도, 그 데이터를 사용하는 응용 프로그램(Application)은 수정하지 않아도 된다**는 특성입니다. 마치 도로가 새로 포장되어도 자동차의 설계를 바꿀 필요가 없는 것처럼, 데이터베이스의 내부 구조가 바뀌어도 그것을 사용하는 프로그램은 그대로 유지됩니다. 이 특성 덕분에 시스템 유지보수가 훨씬 쉬워집니다.

### 특성 3: 자기 정의 (Self-Description) — 나 자신을 스스로 설명한다

데이터베이스는 단순히 데이터만 저장하는 것이 아니라, **자기 자신에 대한 정보(메타데이터, Metadata)도 스스로 저장하고 관리**합니다.

**메타데이터(Metadata)** 란 "데이터에 대한 데이터"를 의미합니다. 예를 들어, 학생 테이블을 만들면 데이터베이스는 자동으로 다음과 같은 정보를 별도로 저장합니다.

- 이 테이블은 누가 만들었는가?
- 언제 만들어졌는가?
- 어떤 속성(컬럼)들이 있는가?
- 각 속성의 데이터 타입은 무엇인가?
- 테이블의 크기는 얼마인가?
- 접근 권한은 어떻게 설정되어 있는가?

이 메타데이터는 **데이터 사전(Data Dictionary)** 또는 **카탈로그(Catalog)** 라는 별도의 저장 공간에 보관됩니다. 이것이 바로 **자기 정의** 특성입니다.

---

## 🧩 데이터베이스의 구성 요소 — 개체, 속성, 관계, 도메인

데이터베이스를 이루는 기본적인 구성 요소를 이해하면, 앞으로 데이터베이스를 설계하고 사용할 때 훨씬 쉽게 개념을 잡을 수 있습니다.

### 개체 (Entity) — 데이터로 표현하려는 대상

**개체(Entity)** 는 데이터베이스에서 표현하고자 하는 **현실 세계의 대상**입니다. 예를 들어, 대학교 학사 관리 시스템에서는 `학생`, `교수`, `강의실`, `수업` 등이 각각 하나의 개체가 됩니다. 개체는 다른 개체와 **구별될 수 있어야** 하며, 단독으로 존재할 수 있습니다. 데이터베이스에서 개체는 보통 테이블의 **한 행(Row), 즉 레코드(Record)** 에 해당합니다.

### 속성 (Attribute) — 개체를 설명하는 특성

**속성(Attribute)** 은 개체가 가지는 **특성이나 상태**를 나타내는 것입니다. 예를 들어 `학생`이라는 개체는 `학번`, `이름`, `주소`, `전화번호`, `학과` 등의 속성을 가집니다. 속성은 개체를 구성하는 **가장 작은 논리적 단위**이며, 개체 없이 속성만 단독으로는 존재할 수 없습니다. 파일 시스템에서는 이를 **항목(Item)** 또는 **필드(Field)** 라고 부르기도 합니다.

### 도메인 (Domain) — 속성이 가질 수 있는 값의 범위

**도메인(Domain)** 은 하나의 속성이 취할 수 있는 **값의 범위**입니다. 예를 들어 `점수`라는 속성의 도메인은 0부터 100까지의 정수입니다. 100점 이상이나 음수는 입력되어서는 안 되는 것처럼, 속성에 들어올 수 있는 값의 종류와 범위를 제한하는 것이 도메인입니다. 마치 점수란에 "사과"라는 단어를 쓸 수 없는 것과 같습니다.

### 관계 (Relationship) — 개체와 개체 사이의 연결

**관계(Relationship)** 는 두 개 이상의 개체 사이에 존재하는 **연결 또는 연관성**을 의미합니다. 예를 들어 `교수`와 `학생` 사이에는 `지도`라는 관계가 있을 수 있습니다(한 명의 교수가 여러 학생을 지도한다). 관계에는 다음과 같은 유형이 있습니다.

| 관계 유형 | 설명 | 예시 |
|-----------|------|------|
| **1:1 (일대일)** | A 하나가 B 하나와 연결 | 직원 한 명이 사원증 하나를 가짐 |
| **1:N (일대다)** | A 하나가 B 여러 개와 연결 | 교수 한 명이 여러 학생을 지도함 |
| **M:N (다대다)** | A 여러 개가 B 여러 개와 연결 | 학생 여러 명이 여러 수업을 수강함 |

### 스키마와 인스턴스 — 구조와 실제 값

데이터베이스에서는 **구조(틀)**와 **실제 값(데이터)**을 구분하는 것이 중요합니다.

- **개체 타입(Entity Type) = 스키마(Schema) = 인텐션(Intension)**: 데이터의 **구조**를 의미합니다. 예를 들어 `학생(학번, 이름, 학과)`처럼 어떤 속성들로 구성되어 있는지를 정의한 틀입니다.
- **개체 집합(Entity Set) = 인스턴스(Instance) = 튜플(Tuple)의 집합**: 스키마에 실제로 **저장된 데이터 값들의 집합**입니다. 예를 들어 "2024001, 홍길동, 컴퓨터공학과" 같은 실제 데이터 행들이 인스턴스에 해당합니다.

```sql
-- 스키마(구조) 정의 예시
-- 이것은 학생 테이블의 '틀'을 만드는 것입니다
CREATE TABLE 학생 (
    학번 VARCHAR(10),  -- 학생을 고유하게 식별하는 학번 속성
    이름 VARCHAR(20),  -- 학생의 이름 속성
    학과 VARCHAR(30)   -- 학생이 속한 학과 속성
);

-- 인스턴스(실제 데이터) 삽입 예시
-- 이것은 위에서 만든 틀에 실제 데이터를 채워 넣는 것입니다
INSERT INTO 학생 VALUES ('2024001', '홍길동', '컴퓨터공학과');
INSERT INTO 학생 VALUES ('2024002', '김영희', '소프트웨어공학과');
```

### 논리적 구조와 물리적 구조

동일한 데이터를 바라보는 관점에도 두 가지가 있습니다.

- **논리적 구조(Logical Structure)**: **사용자의 관점**에서 본 데이터의 구조입니다. 사용자에게는 테이블, 컬럼, 행 같은 형태로 보입니다. 이때 사용하는 데이터 단위를 **논리적 레코드(Logical Record)** 라고 합니다.
- **물리적 구조(Physical Structure)**: **저장 장치(하드디스크)의 관점**에서 본 데이터의 구조입니다. 실제로 비트와 바이트가 어떤 방식으로 디스크에 저장되어 있는지를 의미합니다. 이때 사용하는 데이터 단위를 **저장 레코드(Stored Record)** 라고 합니다.

중요한 것은, 논리적 구조와 물리적 구조가 **별개로 존재하는 것이 아니라**, 같은 데이터를 어느 관점에서 바라보느냐의 차이라는 점입니다. 두 구조는 서로 1대 1로 대응됩니다.

---

## ⚠️ 파일 시스템의 중복성과 종속성 — 더 자세히 살펴보기

앞서 간단히 살펴본 파일 시스템의 두 가지 문제점을 좀 더 구체적으로 이해해 봅시다.

### 중복성이 일으키는 구체적인 문제들

❌ **잘못된 상황 예시 (파일 시스템의 중복):**

```
사용자 A의 컴퓨터: 고객_홍길동_주소 = "서울시 강남구 테헤란로 100"
사용자 B의 컴퓨터: 고객_홍길동_주소 = "서울시 강남구 테헤란로 100"
사용자 C의 컴퓨터: 고객_홍길동_주소 = "서울시 강남구 테헤란로 100"

→ A가 주소를 "서울시 서초구 서초대로 200"으로 수정
→ B와 C는 아직 수정하지 않음

결과:
사용자 A의 컴퓨터: "서울시 서초구 서초대로 200" (최신)
사용자 B의 컴퓨터: "서울시 강남구 테헤란로 100" (과거 정보) ← 불일치!
사용자 C의 컴퓨터: "서울시 강남구 테헤란로 100" (과거 정보) ← 불일치!
```

이처럼 데이터가 중복되면 다음과 같은 문제들이 연쇄적으로 발생합니다.

1. **일관성 결여**: 같은 데이터가 서로 다른 값을 가지게 되어 어떤 것이 정확한지 알 수 없음
2. **보안 유지 어려움**: 중복된 모든 파일에 동일한 수준의 보안을 적용하기 어려움
3. **경제성 저하**: 한 번만 갱신하면 될 것을 중복된 수만큼 반복해야 하고, 저장 공간도 낭비됨
4. **무결성(데이터 정확성) 유지 어려움**: 위 모든 문제로 인해 데이터의 정확성을 보장할 수 없음

:::note 중복에도 장점이 있다?
중복이 무조건 나쁜 것만은 아닙니다. 중복된 데이터가 있으면, 한 곳의 데이터가 손상되었을 때 다른 곳의 복사본을 사용할 수 있어서 **가용성(Availability, 시스템이 계속 사용 가능한 상태를 유지하는 능력)** 이 높아집니다. 또한 데이터를 멀리 있는 서버에서 가져올 필요 없이 가까운 곳에서 바로 사용할 수 있어 **지역 처리가 원활**해집니다. 하지만 데이터의 **무결성(정확성)**을 지키기가 어렵다는 단점이 훨씬 크기 때문에, 동시에 여러 사람이 사용하는 시스템에서는 중복을 최소화해야 합니다.
:::

### 종속성이 일으키는 문제

❌ **잘못된 상황 예시 (종속성):**

```
기존 파일 구조: 학생정보 = [학번, 이름, 주소]
                            ↓
기존 프로그램이 이 구조에 맞게 개발됨

→ 파일 구조 변경: 학생정보 = [학번, 이름, 주소, 전화번호] (전화번호 추가)
                            ↓
프로그램도 반드시 수정해야 함 → 시간, 비용, 인력 낭비!
```

✅ **데이터베이스의 자료 독립성으로 해결:**

```
데이터베이스 구조 변경 → 응용 프로그램은 그대로 유지 가능
(DBMS가 중간에서 차이를 흡수해 줌)
```

---

## 🛠️ DBMS — 데이터베이스 관리 시스템

### DBMS란 무엇인가?

**DBMS(Database Management System, 데이터베이스 관리 시스템)** 는 사용자와 데이터베이스 사이에서 **중재자 역할을 하는 소프트웨어**입니다.

사용자가 데이터베이스에 직접 접근해서 데이터를 저장하거나 조회하는 것은 매우 복잡하고 위험합니다. 그래서 중간에 DBMS라는 소프트웨어를 두어, 사용자의 요청을 받아서 안전하고 효율적으로 데이터베이스를 다루는 역할을 합니다.

마치 은행에서 직접 금고에 들어가서 돈을 꺼낼 수 없고, 창구 직원(또는 ATM기)을 통해야 하는 것처럼, 데이터베이스도 DBMS를 통해서만 접근합니다.

```
[사용자 / 응용 프로그램]
         ↕
      [DBMS] ← 중재자 역할 (소프트웨어)
         ↕
    [데이터베이스] ← 실제 데이터 저장소 (하드디스크)
```

DBMS는 **파일 시스템의 종속성과 중복성 문제를 해결**하기 위해 개발되었으며, Oracle, MySQL, MS SQL Server 등이 대표적인 DBMS 제품입니다.

### DBMS의 필수 기능 3가지

DBMS가 반드시 제공해야 하는 세 가지 핵심 기능이 있습니다.

#### 📌 정의 기능 (Definition) — 구조를 만든다

데이터베이스의 **구조(Schema)를 생성하는 기능**입니다. 어떤 테이블을 만들고, 그 테이블에는 어떤 속성(컬럼)이 있으며, 각 속성의 데이터 타입은 무엇인지를 정의합니다. 또한 기본키(Primary Key, 각 행을 유일하게 식별하는 속성) 같은 제약 조건도 여기서 설정합니다.

```sql
-- ✅ 정의 기능 예시: 학생 테이블 구조 생성
CREATE TABLE 학생 (
    학번 VARCHAR(10) PRIMARY KEY,  -- 학번을 기본키로 설정 (각 학생을 유일하게 식별)
    이름 VARCHAR(20) NOT NULL,      -- 이름은 반드시 입력해야 함 (NULL 불허)
    학과 VARCHAR(30),               -- 학과명 저장
    점수 INT CHECK (점수 >= 0 AND 점수 <= 100)  -- 점수는 0~100 사이만 허용 (도메인 제약)
);
```

#### 📌 조작 기능 (Manipulation) — 데이터를 다룬다

구조를 만들었으면 이제 실제 데이터를 **삽입(Insert), 검색(Select), 수정(Update), 삭제(Delete)** 하는 기능입니다. 이 네 가지 연산을 통해 데이터베이스에 저장된 데이터를 원하는 대로 다룰 수 있습니다.

```sql
-- ✅ 조작 기능 예시

-- 데이터 삽입 (학생 추가)
INSERT INTO 학생 (학번, 이름, 학과, 점수)
VALUES ('2024001', '홍길동', '컴퓨터공학과', 95);  -- 학생 정보를 테이블에 추가

-- 데이터 검색 (점수가 90점 이상인 학생 조회)
SELECT 학번, 이름, 점수
FROM 학생
WHERE 점수 >= 90;  -- 내용(점수 값)으로 데이터를 참조하는 예시

-- 데이터 수정 (홍길동의 점수 수정)
UPDATE 학생
SET 점수 = 98
WHERE 학번 = '2024001';  -- 학번으로 특정 학생을 찾아서 점수 수정

-- 데이터 삭제 (특정 학생 삭제)
DELETE FROM 학생
WHERE 학번 = '2024001';  -- 해당 학번의 학생 정보 삭제
```

#### 📌 제어 기능 (Control) — 데이터를 보호하고 관리한다

데이터가 **정확하고 안전하게 유지**될 수 있도록 제어하는 기능입니다. 데이터의 무결성(정확성), 보안(권한 관리), 병행 제어(여러 사용자가 동시에 접근할 때의 충돌 방지), 회복(장애 발생 시 데이터 복구) 등이 이 기능에 포함됩니다.

### DBMS의 장단점

#### ✅ DBMS의 장점

- **중복 통제**: 데이터의 중복을 최소화하여 일관성 유지
- **동시 접근 지원**: 여러 사용자가 동시에 데이터베이스를 사용 가능
- **데이터 일관성 유지**: 어느 사용자가 보더라도 항상 같은 최신 데이터를 봄
- **무결성 보장**: 데이터의 정확성을 시스템 차원에서 보장
- **보안 기능**: 권한에 따라 접근 제어 가능
- **백업 및 회복**: 장애 발생 시 데이터를 복구할 수 있는 기능 제공
- **표준화**: SQL이라는 표준 언어로 개발 효율성 향상

#### ❌ DBMS의 단점

- **높은 초기 비용**: 하드웨어 구입, 소프트웨어 라이선스, 네트워크 구축 등 비용이 많이 듦
- **복잡성**: 시스템이 복잡하여 장애 발생 시 문제 원인을 파악하기 어려움
- **단일 장애점 위험**: 일부 구성요소의 오류가 전체 시스템을 마비시킬 수 있음
- **보안 취약성**: 복잡한 네트워크 구조로 인해 일부 해킹이 전체 데이터를 위협할 수 있음

:::danger 단일 장애점에 주의하세요
DBMS는 잘못 설계하거나 관리하면, 일부의 오류가 **전체 시스템을 정지**시킬 수 있습니다. 대규모 서비스에서는 이를 방지하기 위해 이중화(Replication), 클러스터링(Clustering) 등의 기술을 반드시 적용해야 합니다.
:::

---

## ⚙️ DBMS의 내부 구조와 동작 원리

DBMS는 내부적으로 여러 모듈(Module, 특정 기능을 담당하는 독립적인 부품)로 구성되어 있습니다. 각 모듈이 어떤 역할을 하는지 이해하면 데이터베이스가 실제로 어떻게 동작하는지 파악할 수 있습니다.

### 사용자의 종류와 사용하는 언어

DBMS를 사용하는 사람들은 크게 세 종류로 나뉩니다.

| 사용자 유형 | 사용 언어 | 역할 |
|-------------|-----------|------|
| **일반 사용자** | 질의어(Query Language) | 데이터 조회, 간단한 데이터 입력 |
| **응용 프로그래머** | 데이터 조작어(DML, Data Manipulation Language) | Java, Python 등 프로그램에 DB 코드 포함하여 개발 |
| **데이터베이스 관리자(DBA)** | 데이터 정의어(DDL, Data Definition Language) | 테이블 생성, 권한 관리, 백업 등 DB 전체 관리 |

### DBMS 내부 구성 모듈

```
[일반 사용자]          [응용 프로그래머]          [DBA]
     ↓ 질의어                ↓ DML                  ↓ DDL
[질의 처리기]     [DML 예비 컴파일러]        [DDL 컴파일러]
     ↓                      ↓                       ↓
                  [DML 컴파일러]              [카탈로그/데이터 사전]
                      ↓
            [런타임 DB 처리기]
                      ↓
            [트랜잭션 관리자]
         (무결성 검사, 권한 검사,
          병행 제어, 회복 처리)
                      ↓
            [저장 데이터 관리자]
                      ↓
                [데이터베이스]
              (하드디스크에 저장)
```

각 모듈의 역할을 자세히 설명하겠습니다.

#### 📦 질의 처리기 (Query Processor)

일반 사용자가 입력한 **질의문(Query, "점수가 90점 이상인 학생을 보여줘" 같은 요청)을 분석**합니다. 파싱(Parsing, 문장을 토큰 단위로 쪼개어 의미를 분석하는 과정)을 통해 사용자가 입력한 명령어가 어떤 의미인지 확인하고, 처리 가능한 형태로 변환합니다.

#### 📦 DML 예비 컴파일러 (DML Pre-Compiler)

응용 프로그래머가 Java나 Python 같은 프로그래밍 언어 코드 안에 SQL 문장을 섞어 쓸 때, 이 두 가지 언어를 **분리**하는 역할을 합니다. Java 코드는 Java 컴파일러가 처리하고, SQL 코드는 DML 컴파일러가 처리해야 하기 때문에, 예비 컴파일러가 먼저 이 두 언어를 나눠줍니다.

```java
// Java 코드 안에 SQL이 섞여 있는 예시
// DML 예비 컴파일러가 아래 두 부분을 분리합니다

// [Java 코드 부분]
String query = "SELECT * FROM 학생 WHERE 점수 >= ?";
PreparedStatement pstmt = conn.prepareStatement(query); // Java 코드
pstmt.setInt(1, 90);  // Java 코드: 점수 기준값 설정

// [SQL(DML) 코드 부분 - 별도로 처리됨]
// SELECT * FROM 학생 WHERE 점수 >= 90
```

#### 📦 DDL 컴파일러 (DDL Compiler)

DBA가 입력한 **테이블 생성, 수정, 삭제 등의 DDL 명령어를 컴파일**합니다. 컴파일 결과로 생성된 메타데이터(테이블 구조, 속성 정보 등)는 **데이터 사전(Data Dictionary)** 또는 **카탈로그(Catalog)** 에 저장됩니다. 이것이 앞서 설명한 **자기 정의(Self-Description)** 특성과 연결됩니다.

#### 📦 런타임 데이터베이스 처리기 (Runtime Database Processor)

컴파일된 명령어를 **실제로 실행**하는 모듈입니다. 사용자가 요청한 데이터를 실제로 읽거나 저장하는 작업이 이 모듈에서 이루어집니다.

#### 📦 트랜잭션 관리자 (Transaction Manager)

**트랜잭션(Transaction, 데이터베이스에서 하나의 작업 단위)을 관리**하는 매우 중요한 모듈입니다. 구체적으로는 다음과 같은 역할을 수행합니다.

- **무결성 검사**: 데이터가 정확하게 유지되고 있는지 확인
- **권한 검사**: 해당 사용자가 이 데이터에 접근할 권한이 있는지 확인
- **병행 제어(Concurrency Control)**: 여러 사용자가 동시에 같은 데이터를 수정하려 할 때 충돌을 방지
- **회복(Recovery)**: 시스템 장애로 데이터가 손상되었을 때 정상 상태로 복구

#### 📦 저장 데이터 관리자 (Stored Data Manager)

최종적으로 운영체제에 **저장 명령을 전달**하여 데이터를 하드디스크에 실제로 저장하게 하는 모듈입니다.

---

## 💡 주의사항과 핵심 팁

### 🔔 용어 혼용에 주의하세요

데이터베이스 분야에서는 같은 개념을 다양한 용어로 부르는 경우가 많습니다. 처음 배울 때 혼란스러울 수 있으므로, 중요한 용어 대응표를 정리해 드립니다.

| 파일 시스템 용어 | 데이터베이스 용어 | 의미 |
|-----------------|-----------------|------|
| 파일 (File) | 테이블 (Table) | 데이터를 담는 표 |
| 레코드 (Record) | 행/튜플 (Row/Tuple) | 테이블의 가로 한 줄 |
| 항목/필드 (Field) | 속성/컬럼 (Attribute/Column) | 테이블의 세로 한 줄 |
| — | 개체 타입 = 스키마 = 인텐션 | 데이터의 구조(틀) |
| — | 개체 집합 = 인스턴스 = 외연 | 실제로 저장된 데이터 값들 |

### 🔔 DBMS와 데이터베이스는 다릅니다

초보자들이 자주 헷갈리는 개념입니다.

- **데이터베이스(Database)**: 실제 데이터가 저장된 **창고** (예: 하드디스크에 저장된 데이터)
- **DBMS**: 그 창고를 관리하는 **관리 소프트웨어** (예: Oracle, MySQL, MS SQL)

Oracle을 설