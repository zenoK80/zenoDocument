---
title: "파일 시스템의 구조와 문제점"
description: "파일 시스템의 구조와 문제점에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/database-history-and-dbms/2-file-system"
sidebar_label: "파일 시스템"
date: "2026-02-20"
---

# 🗂️ 파일 시스템의 구조와 문제점

데이터베이스를 처음 공부하다 보면 "왜 데이터베이스가 필요한가?"라는 질문에 맞닥뜨리게 됩니다. 이 질문에 제대로 답하려면, **데이터베이스가 등장하기 이전에 데이터를 어떻게 관리했는지**부터 이해해야 합니다. 바로 그 이전 시대의 주인공이 **파일 시스템(File System)** 입니다.

이번 문서에서는 파일 시스템이 무엇인지, 어떤 구조로 되어 있는지, 그리고 왜 결국 데이터베이스라는 새로운 개념이 등장할 수밖에 없었는지를 **초보자도 완전히 이해할 수 있도록** 아주 자세하게 풀어서 설명합니다.

---

## 📁 파일 시스템이란 무엇인가?

### 파일 시스템의 정의

**파일 시스템(File System)** 이란, 컴퓨터 운영체제(Windows, Linux, macOS 등)가 데이터를 **파일(File)** 이라는 단위로 저장하고 관리하는 방식을 말합니다. 쉽게 말하면, 우리가 윈도우 탐색기를 열었을 때 보이는 `.hwp`, `.xlsx`, `.txt`, `.jpg` 같은 수많은 파일들이 폴더에 담겨서 운영체제에 의해 관리되고 있는 구조, 그것이 바로 파일 시스템입니다.

마치 **서류 캐비닛**에 비유할 수 있습니다. 캐비닛 안에는 여러 개의 서랍(폴더)이 있고, 각 서랍 안에는 종이 문서(파일)들이 들어 있죠. 담당자가 필요한 서류를 꺼내서 읽거나, 새 서류를 추가하거나, 낡은 서류를 버리는 방식으로 정보를 관리하는 것과 똑같은 구조입니다.

:::info 파일 시스템은 지금도 사용됩니다
파일 시스템은 과거의 유물이 아닙니다. 지금 이 순간에도 여러분의 컴퓨터에서 운영체제가 파일 시스템을 통해 모든 데이터를 관리하고 있습니다. 윈도우의 NTFS, 리눅스의 ext4, macOS의 APFS 등이 모두 파일 시스템의 종류입니다.
:::

### 파일 시스템의 핵심 특징

파일 시스템은 **별도의 전용 소프트웨어 없이** 운영체제가 기본적으로 제공하는 기능입니다. 오라클(Oracle), MySQL, MSSQL 같은 전문 데이터베이스 소프트웨어가 따로 필요하지 않습니다. 운영체제의 커널(Kernel, 운영체제의 핵심 부분) 수준에서 기본적으로 지원해 주기 때문에, 컴퓨터를 사용하는 순간부터 자동으로 파일 시스템이 동작하고 있는 것입니다.

이 때문에 파일 시스템은 **컴퓨터가 처음 등장한 1960년대 이전부터** 사용되어 온 가장 오래된 데이터 저장 방식입니다. 초창기에는 한두 명의 사용자가 각자의 파일을 관리하는 용도로 충분했고, 당시에는 아무런 문제가 없었습니다.

> **파일 시스템은 운영체제가 기본으로 제공하는 데이터 저장·관리 구조로, 파일과 폴더의 계층 구조를 통해 데이터를 관리합니다.**

---

## ⚠️ 파일 시스템의 구조적 문제점

### 왜 문제가 생겼을까?

처음에는 아무 문제가 없던 파일 시스템이 왜 문제가 되었을까요? 핵심은 **"혼자 쓸 때"와 "여럿이 함께 쓸 때"의 차이**에 있습니다. 1960년대 들어서면서 컴퓨터가 점점 더 많은 조직에 도입되고, 한 파일을 여러 사람이 동시에 사용해야 하는 상황이 생기면서 파일 시스템의 구조적 한계가 드러나기 시작했습니다.

파일 시스템이 갖는 가장 큰 두 가지 문제점은 바로 **중복성(Redundancy)** 과 **종속성(Dependency)** 입니다. 이 두 가지 문제가 왜 발생하고, 어떤 결과를 낳는지 하나씩 아주 자세히 살펴보겠습니다.

---

### 🔴 문제점 1: 데이터 중복성 (Data Redundancy)

**중복성**이란, 똑같은 내용의 데이터가 여러 곳에 각각 따로 저장되어 있는 상태를 말합니다.

예를 들어 설명해 봅시다. 회사에 사용자 A, B, C 세 명이 있고, 이들이 모두 `고객정보.txt`라는 파일을 업무에 활용한다고 가정합니다. 파일 시스템 환경에서는 중앙에 하나의 파일만 있는 것이 아니라, **A도 자신의 컴퓨터에 `고객정보.txt`를 가지고, B도, C도 각자 자신의 컴퓨터에 같은 파일을 복사해서 보관하고 사용합니다.** 마치 회사에 공용 서류가 있는데, 직원마다 그걸 복사해서 자기 책상 서랍에 따로 넣어두고 쓰는 것과 같습니다.

```
[파일 시스템 환경에서 파일 공유 방식]

  사용자 A의 컴퓨터          사용자 B의 컴퓨터          사용자 C의 컴퓨터
  ┌─────────────┐           ┌─────────────┐           ┌─────────────┐
  │ 고객정보.txt │           │ 고객정보.txt │           │ 고객정보.txt │
  │  (복사본 A) │           │  (복사본 B) │           │  (복사본 C) │
  └─────────────┘           └─────────────┘           └─────────────┘
       ↓ A가 수정                  ↓ B는 그대로               ↓ C도 그대로
  "홍길동 → 홍길순"          "홍길동" (구버전)          "홍길동" (구버전)
```

이 상황에서 A가 고객 이름을 "홍길동"에서 "홍길순"으로 수정했다고 합시다. 그런데 B와 C는 자신의 파일을 수정하지 않았습니다. 이제 세 사람의 파일에는 서로 다른 내용이 담기게 됩니다. A의 파일에는 "홍길순", B와 C의 파일에는 "홍길동". **이것이 바로 데이터 불일치(Inconsistency)** 입니다.

이 불일치로 인해 발생하는 구체적인 문제들을 하나씩 정리하면 다음과 같습니다.

| 문제 유형 | 설명 |
|---|---|
| **일관성 결여** | 같은 정보인데 사람마다 다른 값을 가지고 있어 어떤 것이 정확한지 알 수 없음 |
| **보안 취약성** | 파일이 여러 곳에 분산되어 있어 모든 복사본에 동일한 수준의 보안을 적용하기 어려움 |
| **경제성 저하** | 하나의 데이터를 바꾸면 모든 복사본을 일일이 찾아서 다 바꿔야 하므로 갱신 비용이 증가 |
| **저장 공간 낭비** | 똑같은 내용이 여러 곳에 중복 저장되어 불필요한 저장 공간을 소모 |
| **무결성 훼손** | 데이터의 정확성(무결성)을 유지하기가 근본적으로 어려움 |

:::warning 중복은 단순히 "비효율"의 문제가 아닙니다
중복된 데이터는 단순히 공간 낭비에 그치지 않습니다. 잘못된 정보로 업무 결정이 내려지거나, 고객에게 틀린 정보가 전달되는 등 **심각한 비즈니스 문제**로 이어질 수 있습니다.
:::

#### 중복의 장점도 있다?

그렇다면 중복이 무조건 나쁜 것일까요? 사실 중복에도 장점이 있습니다. 한 곳의 데이터가 망가지거나 시스템이 고장 나도, 다른 곳에 똑같은 복사본이 있기 때문에 계속 서비스를 이어갈 수 있습니다. 이를 **가용성(Availability)** 이 높다고 표현합니다. 또한 여러 장소에 데이터가 분산되어 있으면 사이트 간 데이터 이동을 최소화할 수 있고, 고장 시 복구도 빠릅니다.

하지만 이러한 장점에도 불구하고, **데이터의 정확성(무결성)을 유지하기 어렵다는 치명적인 단점** 때문에 여러 사람이 동시에 사용하는 시스템 환경에서는 파일 시스템의 중복 구조를 그대로 유지하기가 불가능했습니다.

---

### 🔴 문제점 2: 데이터 종속성 (Data Dependency)

**종속성**이란, 데이터를 저장하는 파일의 구조나 저장 방식이 바뀌면, 그 파일을 사용하는 프로그램도 반드시 함께 수정해야 하는 문제를 말합니다.

좀 더 쉽게 비유해볼까요? 오래된 카세트테이프 플레이어를 생각해보세요. 카세트테이프에 음악이 담겨 있고, 플레이어는 그 테이프 형식에 딱 맞춰서 만들어져 있습니다. 만약 테이프의 규격이 바뀌면? 플레이어도 바꿔야 합니다. 테이프(데이터)와 플레이어(프로그램)가 **종속 관계**에 있는 것입니다.

파일 시스템에서도 마찬가지입니다. 예를 들어, 학생 성적을 관리하는 파일이 있고 그 파일을 읽어서 처리하는 프로그램이 있다고 합시다. 처음에는 `학번, 이름, 점수` 세 개의 항목으로 구성되어 있었는데, 나중에 `학번, 이름, 점수, 학과` 네 개로 항목이 늘어났다고 합시다. 그러면 그 파일을 사용하는 **모든 프로그램을 찾아서 일일이 수정**해야 합니다. 파일 구조에 프로그램이 종속되어 있기 때문입니다.

```
[종속성 문제 예시]

파일 구조 변경 전:
학번(4자리) | 이름(10자리) | 점수(3자리)

파일 구조 변경 후:
학번(4자리) | 이름(10자리) | 점수(3자리) | 학과(10자리)  ← 항목 추가!

→ 이 파일을 사용하는 프로그램 A, B, C, D... 모두 수정 필요 ❌
```

프로그래머는 파일의 **물리적 데이터 구조(실제 저장 방식)** 를 정확히 알고 있어야만 프로그램을 만들 수 있었습니다. 데이터가 어떤 순서로, 몇 바이트씩, 어떤 형식으로 저장되어 있는지를 모두 코드에 직접 기술해야 했기 때문입니다. 이렇게 되면 데이터 구조가 조금이라도 바뀌면 그것을 참조하는 수십, 수백 개의 프로그램을 모두 수정해야 하는 엄청난 유지보수 비용이 발생하게 됩니다.

> **종속성의 핵심: 데이터의 저장 구조나 방법이 변경되면, 그 데이터를 사용하는 프로그램도 반드시 함께 변경해야 한다.**

---

## 🏛️ 데이터베이스의 등장 배경과 발전 역사

### 파일 시스템의 한계를 넘어서

파일 시스템의 중복성과 종속성 문제를 해결하기 위해 등장한 것이 바로 **데이터베이스(Database)** 입니다. 데이터베이스는 "데이터를 한 곳에 통합해서 저장하고, 여러 사람이 함께 안전하게 사용할 수 있도록 관리하는 시스템"이라고 정의할 수 있습니다. 데이터베이스의 발전은 크게 다음과 같은 단계를 거쳐왔습니다.

### 1단계: 계층형 DBMS (1960년대)

파일 시스템의 문제를 해결하기 위해 가장 먼저 개발된 것이 **계층형 DBMS(Hierarchical DBMS)** 입니다. 계층형 구조는 마치 **회사 조직도** 처럼 트리(Tree) 구조로 데이터를 표현합니다. 위에 있는 것이 **부모(Parent)**, 아래에 있는 것이 **자식(Child)** 이 되는 구조입니다.

```
[계층형 DBMS 구조 예시]

              [대학교]
             /        \
        [공학부]      [인문대]
        /     \         |
  [컴퓨터]  [전기]    [영문]
```

이 구조의 특징은 정보의 흐름이 **위에서 아래로만** 내려간다는 것입니다. 자식이 부모가 될 수 없고, 아래에서 위로 역방향으로 정보가 흐르는 것이 불가능합니다. 즉, **사이클(순환)이 발생하지 않는 단방향 구조**입니다. 트리 구조의 특성상, 한 자식 노드는 반드시 하나의 부모 노드만 가질 수 있습니다.

:::note 계층형 DBMS의 한계
정보가 위에서 아래로만 흐르다 보니, 서로 다른 계층에 있는 데이터 사이의 관계를 표현하는 데 한계가 있었습니다. 이 문제를 해결하기 위해 네트워크형 DBMS가 등장하게 됩니다.
:::

### 2단계: 네트워크형 DBMS (1970년대)

계층형 DBMS의 한계를 극복하기 위해 **네트워크형 DBMS(Network DBMS)** 가 등장했습니다. 네트워크형 구조는 **그래프(Graph)** 형태로 데이터를 표현합니다. 계층형에서는 부모-자식 관계만 있었다면, 네트워크형에서는 **오너(Owner)-멤버(Member)** 관계를 사용합니다.

가장 큰 차이점은 **사이클(순환)을 허용한다**는 것입니다. 하나의 멤버가 다른 관계에서는 오너가 될 수도 있고, 여러 오너가 하나의 멤버를 공유할 수도 있습니다. 이렇게 되면 더욱 복잡한 데이터 관계를 표현할 수 있게 됩니다.

```
[네트워크형 DBMS 구조 예시]

  [학생A] ←──────────────┐
     ↓                    │
  [수강] → [과목1]       │
     ↓                    │
  [과목2] ───────────→ [교수B]
```

| 구분 | 계층형 DBMS | 네트워크형 DBMS |
|---|---|---|
| **구조** | 트리(Tree) 구조 | 그래프(Graph) 구조 |
| **관계 표현** | 부모-자식 (1:N) | 오너-멤버 (N:M 가능) |
| **사이클 허용** | ❌ 불가 | ✅ 가능 |
| **정보 흐름** | 위→아래 단방향 | 양방향 가능 |
| **등장 시기** | 1960년대 | 1970년대 |

### 3단계: 관계형 DBMS (현재 가장 많이 사용)

계층형과 네트워크형의 뒤를 이어 등장한 것이 바로 **관계형 DBMS(Relational DBMS, RDBMS)** 입니다. 우리가 지금 가장 흔하게 접하는 **표(Table) 형태**로 데이터를 관리하는 방식입니다. 학교 성적표, 엑셀 시트처럼 행(Row)과 열(Column)로 구성된 테이블에 데이터를 저장합니다.

```
[관계형 DBMS - 학생 테이블 예시]

┌────────┬────────┬──────┬─────────────┐
│  학번  │  이름  │ 학과 │    주소     │
├────────┼────────┼──────┼─────────────┤
│  1001  │ 홍길동 │ 컴공 │  서울시 강남 │
│  1002  │ 김철수 │ 전기 │  부산시 해운 │
│  1003  │ 이영희 │ 영문 │  대전시 중구 │
└────────┴────────┴──────┴─────────────┘
```

관계형 DBMS의 대표적인 제품으로는 **Oracle, MySQL, MSSQL(Microsoft SQL Server)** 등이 있으며, 현재 IT 업계에서 가장 널리 사용되는 데이터베이스 구조입니다. 실무에서 개발자로, 시스템 설계자로, 운영자로 일하게 되면 99.9%의 확률로 관계형 데이터베이스를 사용하게 됩니다.

### 4단계: 객체 지향 DBMS (1990년대)

관계형 DBMS가 완벽한 것은 아니었습니다. 테이블 구조는 숫자, 문자 같은 **정형 데이터(Structured Data)** 를 저장하기에는 매우 적합하지만, **동영상, 이미지, 음악, 지도 정보** 같은 **멀티미디어 데이터**를 저장하고 관리하기에는 한계가 있었습니다. 테이블의 한 칸에 동영상 파일을 집어넣는다고 상상해보세요. 구조적으로 맞지 않는 느낌이 들죠?

이 문제를 해결하기 위해 **객체 지향 DBMS(Object-Oriented DBMS)** 가 등장했습니다. Java나 C++에서 사용하는 **객체 지향 프로그래밍(OOP, Object-Oriented Programming)** 의 개념을 데이터베이스에 접목한 것입니다. 동영상 하나를 하나의 "객체"로, 이미지 하나를 하나의 "객체"로 저장하고 관리할 수 있게 된 것입니다.

그러나 객체 지향 DBMS는 **호환성 문제**와 **높은 학습 난이도**로 인해 대중화에 실패했습니다. 클래스, 객체, 다형성, 상속 같은 개념들이 배우기 어려워 개발 비용이 높았고, 관계형 DBMS와의 호환도 쉽지 않았기 때문에 특정 전문 분야에서만 제한적으로 사용되었습니다.

### 5단계: 객체 관계형 DBMS

객체 지향 DBMS의 단점을 보완하여 **관계형 DBMS의 장점**과 **객체 지향의 장점**을 결합한 **객체 관계형 DBMS(Object-Relational DBMS)** 가 등장했습니다. 관계형 데이터베이스의 사용 편의성, 표준화, 대중성을 그대로 유지하면서 객체 지향의 기능까지 추가한 것입니다. 이를 통해 멀티미디어 데이터도 다루면서 기존의 테이블 기반 데이터도 함께 관리할 수 있게 되었습니다.

> **데이터베이스의 발전 흐름: 파일 시스템 → 계층형 DBMS → 네트워크형 DBMS → 관계형 DBMS → 객체 지향 DBMS → 객체 관계형 DBMS → 빅데이터/데이터 마이닝 시대**

---

## 🔍 파일 시스템 중복성·종속성 문제 상세 분석

### 중복성이 일으키는 4가지 구체적 문제

앞서 간단히 언급한 중복성 문제를 이번에는 더욱 구체적으로 파고들어 보겠습니다.

#### ① 일관성 결여 (Inconsistency)

똑같은 데이터 `고객정보`가 A, B, C 세 사용자 각자의 컴퓨터에 따로 저장되어 있다고 합시다. A가 자신의 복사본에서 "홍길동"을 "홍길순"으로 바꿨지만, B와 C는 모릅니다. 이 상태에서 세 사람이 각자의 데이터를 기반으로 업무를 처리하면, 서로 다른 정보를 가지고 일하는 셈이 됩니다. **어떤 것이 올바른 데이터인지 알 수 없는 혼란 상태**, 이것이 일관성 결여입니다.

#### ② 보안 유지의 어려움

데이터가 여러 곳에 분산되어 있으면, 모든 복사본에 동일한 수준의 보안 정책을 적용하기가 매우 어렵습니다. A의 컴퓨터에는 철저한 보안이 적용되어 있더라도, B나 C의 컴퓨터에 허술한 보안이 적용되어 있으면 그 구멍으로 데이터가 유출될 수 있습니다. 마치 튼튼한 금고가 여러 개 있는데, 그 중 하나의 자물쇠가 고장 나 있는 상황과 같습니다.

#### ③ 경제성 저하

하나의 데이터를 수정하려면 그 데이터의 **모든 복사본을 찾아서 하나씩 수정**해야 합니다. 3명이 사용한다면 3번 갱신, 30명이라면 30번 갱신해야 합니다. 이렇게 불필요하게 반복되는 갱신 작업에 드는 시간과 비용, 그리고 동일한 내용을 여러 곳에 저장하는 데 드는 저장 공간 비용이 모두 낭비됩니다.

#### ④ 무결성 훼손 (Integrity Violation)

**무결성(Integrity)** 이란 쉽게 말해 **데이터의 정확성**입니다. 데이터가 현실 세계를 올바르게 반영하고 있어야 한다는 의미입니다. 중복으로 인해 불일치가 발생하면 데이터의 정확성이 깨지고, 이는 곧 잘못된 정보를 기반으로 의사결정이 이루어지는 상황을 만들어 냅니다.

```
[무결성 훼손 시나리오]

원래 데이터: 홍길동 고객의 연락처 = 010-1234-5678

사용자 A가 수정: 010-9876-5432 (새 번호)
사용자 B의 파일: 010-1234-5678 (구 번호, 미수정)
사용자 C의 파일: 010-1234-5678 (구 번호, 미수정)

→ B가 구 번호로 고객에게 연락 시도 → 연락 불가 → 업무 차질 발생! ❌
```

### 종속성이 일으키는 문제

종속성 문제는 유지보수 비용을 폭발적으로 증가시킵니다. 파일의 구조가 단 하나라도 바뀌면, 그 파일을 참조하는 모든 프로그램의 소스 코드를 뒤져서 해당 부분을 수정해야 합니다. 대형 시스템에는 수천 개의 프로그램이 있을 수 있는데, 이 모든 것을 하나하나 수정한다는 것은 현실적으로 매우 어렵고 실수가 발생하기 쉽습니다.

```c
// ❌ 파일 시스템 방식: 파일 구조가 하드코딩되어 있음
// 학번(4바이트) + 이름(10바이트) + 점수(3바이트) = 총 17바이트

// 파일에서 데이터를 읽는 C 프로그램 예시
#include <stdio.h>

// 파일 구조를 프로그램 안에 직접 정의 (종속성 발생 지점!)
typedef struct {
    char hakbun[4];    // 학번 4자리
    char irum[10];     // 이름 10자리
    char score[3];     // 점수 3자리
} StudentRecord;       // 이 구조가 바뀌면 이 프로그램도 바꿔야 함!

int main() {
    FILE *fp = fopen("students.dat", "rb");
    StudentRecord record;
    
    // 파일 구조에 딱 맞게 17바이트씩 읽음
    // 만약 파일 구조에 "학과" 항목이 추가되면?
    // → 이 코드 전체를 수정해야 함!
    while (fread(&record, 17, 1, fp) == 1) {
        printf("학번: %s, 이름: %s\n", record.hakbun, record.irum);
    }
    fclose(fp);
    return 0;
}
```

```sql
-- ✅ 데이터베이스 방식: 데이터 구조와 프로그램이 분리되어 있음
-- 테이블 구조가 바뀌어도 아래 SQL 쿼리(명령어)는 그대로 사용 가능

-- 학생 정보를 조회하는 SQL
SELECT hakbun, irum, score
FROM students
WHERE score >= 90;  -- 점수 90점 이상인 학생 조회

-- 만약 테이블에 "학과" 컬럼이 추가되어도,
-- 이 SQL은 수정할 필요가 없음! (자료 독립성 확보)
```

:::tip 자료 독립성의 핵심
데이터베이스에서는 데이터의 물리적 저장 구조가 바뀌어도 프로그램을 수정할 필요가 없습니다. 이를 **자료 독립성(Data Independence)** 이라고 하며, 파일 시스템의 종속성 문제를 해결한 핵심 개념입니다.
:::

---

## 💡 데이터베이스의 정의와 특성

### 데이터베이스란 무엇인가?

파일 시스템의 문제를 해결하기 위해 등장한 데이터베이스를 한마디로 정의하면 다음과 같습니다.

> **데이터베이스란, 어느 조직(기업, 학교 등)에서 업무와 의사결정에 활용하기 위해, 여러 사람이 공동으로 사용할 수 있도록 통합·저장된 운영 데이터의 집합입니다.**

이 정의에는 네 가지 핵심 키워드가 들어 있습니다.

#### 1) 통합된 데이터 (Integrated Data)

**통합**이란 여러 곳에 흩어져 있는 데이터를 한 곳으로 모으는 것을 말합니다. 이 과정에서 중복된 데이터는 최대한 제거됩니다. 단, 100% 완전한 중복 제거는 성능 문제를 일으킬 수 있기 때문에, **최소한의 중복(통제된 중복)** 은 허용합니다. 이것을 **"최소 중복, 통제된 중복"** 원칙이라고 합니다.

나중에 배우게 될 **정규화(Normalization)** 와 **역정규화(Denormalization)** 개념이 바로 이 통제된 중복의 원칙을 다루는 내용입니다.

#### 2) 저장된 데이터 (Stored Data)

데이터베이스의 데이터는 종이 문서가 아니라 **하드디스크(Disk)** 와 같은 디지털 저장 장치에 저장됩니다. 파일 캐비닛에 서류를 보관하는 것이 아니라, 디지털 형태로 컴퓨터의 저장 장치에 기록되어 있다는 뜻입니다.

#### 3) 운영 데이터 (Operational Data)

데이터베이스에는 해당 조직의 **고유한 기능을 수행하기 위해 반드시 필요한 데이터**가 저장됩니다. 대학교의 학사 관리 데이터베이스라면 학생 정보, 수강 정보, 성적 정보가 저장되고, 제조회사의 생산 관리 데이터베이스라면 생산 계획, 재고 정보, 출고 정보 등이 저장됩니다. 목적 없는 데이터가 아닌, **조직 운영에 필수적인 데이터**의 집합이라는 것입니다.

#### 4) 공용 데이터 (Shared Data)

데이터베이스는 **나 혼자만 쓰는 것이 아닙니다.** 조직의 모든 구성원이 공동으로 소유하고, 함께 유지하며, 함께 이용하는 것이 데이터베이스의 근본 목적입니다. 네이버에 수천만 명이 동시에 접속해서 정보를 이용하는 것, 그것이 공용 데이터의 대표적인 예입니다.

### 데이터베이스의 4가지 일반적 특성

| 특성 | 설명 |
|---|---|
| **실시간 접근성** | 언제 어디서나 원하는 순간에 데이터에 접근 가능 |
| **계속적인 변화** | 데이터는 항상 최신 상태로 갱신되며 현재 상태를 정확히 반영 |
| **동시 공유** | 여러 사용자가 동시에 같은 데이터에 접근하여 이용 가능 |
| **내용에 의한 참조** | 저장 위치(주소)가 아닌 데이터의 값(내용)을 기준으로 검색 가능 |

---

## 🛡️ 파일 시스템 vs 데이터베이스: 핵심 비교

### 구조적 차이 한눈에 보기

지금까지 배운 내용을 바탕으로 파일 시스템과 데이터베이스를 명확하게 비교해 보겠습니다.

| 비교 항목 | 파일 시스템 | 데이터베이스 (DBMS) |
|---|---|---|
| **데이터 관리 주체** | 운영체제 (OS) | 전용 DBMS 소프트웨어 |
| **중복성** | 높음 (각 사용자가 개별 복사본 보유) | 낮음 (중앙 집중 관리, 최소 중복) |
| **종속성** | 높음 (파일 구조 변경 시 프로그램 수정 필요) | 낮음 (자료 독립성 제공) |
| **동시 접근** | 어려움 (충돌 발생 위험) | 가능 (병행제어 기법 사용) |
| **데이터 일관성** | 유지 어려움 | DBMS가 자동으로 유지 |
| **보안** | 파일 단위 보안 (취약) | 세밀한 접근 권한 제어 가능 |
| **무결성** | 유지 어려움 | 무결성 제약 조건으로 자동 관리 |
| **비용** | 낮음 (추가 소프트웨어 불필요) | 높음 (DBMS 소프트웨어 구매 필요) |
| **복잡성** | 단순 | 복잡 (장애 시 원인 파악 어려움) |

### 올바른 선택은?

파일 시스템이 무조건 나쁘고, 데이터베이스가 무조건 좋은 것은 아닙니다. 단순히 개인이 혼자 사용하는 소규모 데이터라면 파일 시스템으로 충분할 수 있습니다. 하지만 **여러 사람이 동시에 접근하고, 데이터의 정확성이 중요하며, 대량의 데이터를 체계적으로 관리해야 하는 환경**이라면 반드시 데이터베이스를 사용해야 합니다.

:::danger 파일 시스템으로 절대 해서는 안 되는 것
은행 계좌 이체, 의료 기록 관리, 항공 예약 시스템처럼 **데이터의 정확성이 생명과 재산에 직결되는 시스템**에서 파일 시스템을 사용하는 것은 절대 안 됩니다. 중복과 불일치로 인한 오류가 치명적인 결과를 낳을 수 있습니다.
:::

---

## 🔧 DBMS(데이터베이스 관리 시스템)의 역할과 필수 기능

### DBMS란?

**DBMS(Database Management System, 데이터베이스 관리 시스템)** 는 사용자와 데이터베이스 사이에서 **중재자 역할**을 하는 소프트웨어입니다. 사용자가 데이터베이스에 직접 접근하는 것이 아니라, 반드시 DBMS를 통해서 접근하도록 설계되어 있습니다.

마치 은행 창구 직원과 같습니다. 고객(사용자)이 금고(데이터베이스)에 직접 들어가는 것이 아니라, 창구 직원(DBMS)을 통해 입출금을 요청하고 처리받는 것처럼 말이죠. DBMS는 요청이 올바른지 확인하고(권한 검사), 처리하고, 결과를 돌려주는 모든 과정을 담당합니다.

```
[DBMS의 위치와 역할]

사용자/응용프로그램
        ↓ 요청 (SQL 쿼리)
   ┌──────────┐
   │   DBMS   │  ← 중재자 역할 (권한 확인, 처리, 반환)
   └──────────┘
        ↓ 저장/조회
   ┌──────────┐
   │ Database │  ← 실제 데이터 저장소 (하드디스크)
   └──────────┘
```

### DBMS의 3가지 필수 기능

DBMS가 반드시 갖춰야 하는 기능은 크게 세 가지입니다.

#### 1) 정의 기능 (Definition Function) - DDL

**정의 기능**이란 데이터베이스의 **구조(Schema)를 만들고 변경하는** 기능입니다. 테이블을 새로 만들거나, 컬럼을 추가하거나, 테이블을 삭제하는 작업이 여기에 해당합니다. 이때 사용하는 언어를 **DDL(Data Definition Language, 데이터 정의 언어)** 이라고 합니다.

비유하자면 **빈 서류 양식을 만드는 것**과 같습니다. "이 양식에는 이름, 나이, 주소를 적는 칸이 있습니다"라고 구조를 정의하는 것이죠.

```sql
-- ✅ 정의 기능 예시: 학생 테이블 생성 (DDL)
CREATE TABLE students (
    hakbun   VARCHAR(10) PRIMARY KEY,  -- 학번 (기본키, 유일한 식별자)
    irum     VARCHAR(50) NOT NULL,      -- 이름 (NULL 불허)
    score    INT DEFAULT 0,             -- 점수 (기본값 0)
    hakgwa   VARCHAR(30)                -- 학과
);
-- 이 명령으로 "students"라는 빈 테이블 구조가 생성됨
-- 마치 빈 서류 양식을 만드는 것과 같음
```

#### 2) 조작 기능 (Manipulation Function) - DML

**조작 기능**이란 정의된 구조 안에 **실제 데이터를 삽입, 수정, 삭제, 검색하는** 기능입니다. 이때 사용하는 언어를 **DML(Data Manipulation Language, 데이터 조작 언어)** 이라고 합니다.

비유하자면 **양식에 내용을 채워 넣거나, 내용을 고치거나, 원하는 내용을 찾아보는 것**과 같습니다.

```sql
-- ✅ 조작 기능 예시 (DML)

-- 데이터 삽입 (INSERT)
INSERT INTO students (hakbun, irum, score, hakgwa)
VALUES ('1001', '홍길동', 95, '컴퓨터공학');
-- "1001번 학생 홍길동, 95점, 컴퓨터공학과"를 테이블에 추가

-- 데이터 검색 (SELECT)
SELECT irum, score
FROM students
WHERE score >= 90;
-- 점수가 90점 이상인 학생의 이름과 점수를 조회

-- 데이터 수정 (UPDATE)
UPDATE students
SET score = 98
WHERE hakbun = '1001';
-- 학번 1001번 학생의 점수를 98점으로 수정

-- 데이터 삭제 (DELETE)
DELETE FROM students
WHERE hakbun = '1001';
-- 학번 1001번 학생의 데이터를 삭제
```

#### 3) 제어 기능 (Control Function) - DCL

**제어 기능**이란 데이터의 **정확성, 보안, 무결성, 동시 접근 제어** 등을 관리하는 기능입니다. 데이터를 사용하는 과정에서 데이터가 망가지거나 유출되지 않도록 보호하는 역할을 합니다. 이때 사용하는 언어를 **DCL(Data Control Language, 데이터 제어 언어)** 이라고 합니다.

무결성 검사, 권한 관리, 병행 제어(여러 사람이 동시에 작업할 때 충돌 방지), 장애 복구 등이 모두 제어 기능에 해당합니다.

```sql
-- ✅ 제어 기능 예시 (DCL)

-- 사용자에게 권한 부여 (GRANT)
GRANT SELECT, INSERT ON students TO user_kim;
-- user_kim이라는 사용자에게 students 테이블의
-- 조회(SELECT)와 삽입(INSERT) 권한을 줌

-- 권한 회수 (REVOKE)
REVOKE INSERT ON students FROM user_kim;
-- user_kim에게서 삽입 권한을 다시 회수
```

### DBMS의 장점과 단점

#### 장점 ✅

DBMS를 사용하면 다음과 같은 이점을 얻을 수 있습니다.

- **중복 제어**: 데이터를 중앙에서 통합 관리하므로 불필요한 중복을 최소화
- **동시 공유**: 병행 제어 기법으로 여러 사용자가 동시에 안전하게 접근 가능
- **데이터 일관성**: 한 곳에서 관리되므로 모든 사용자가 항상 동일한 데이터를 조회
- **무결성 유지**: 제약 조건을 통해 잘못된 데이터 입력을 자동으로 방지
- **보안 강화**: 사용자별 접근 권한을 세밀하게 제어 가능
- **백업과 복구**: 효율적인 백업 및 장애 복구 기능 제공
- **개발 생산성 향상**: 표준화된 개발 방법론으로 개발 기간 단축

#### 단점 ❌

DBMS에도 단점이 있습니다.

- **높은 도입 비용**: 하드웨어, 네트워크 인프라, DBMS 소프트웨어 구매 비용이 큼
- **높은 운영 비용**: 전문 관리자(DBA) 인력과 지속적인 유지보수 비용 필요
- **복잡성**: 시스템이 복잡하여 장애 발생 시 원인 파악이 어려움
- **단일 장애점 위험**: 일부 구성 요소의 고장이 전체 시스템을 마비시킬 수 있음
- **보안 위협**: 중앙 집중형 구조이므로 해킹 등의 공격으로 전체 데이터가 한꺼번에 손상될 위험

:::warning DBMS 운영 시 주의사항
DBMS는 강력하지만, 중앙 집중 구조 특성상 **재해 복구 계획(DRP, Disaster Recovery Plan)** 과 **정기적인 백업** 이 필수입니다. 대형 데이터베이스 서버 하나가 망가지면 해당 시스템 전체가 멈출 수 있습니다.
:::

---

## 📌 핵심 정리

- **파일 시스템**은 운영체제가 기본 제공하는 파일·폴더 기반의 데이터 저장·관리 구조이다.
- 파일 시스템의 가장 큰 문제점은 **중복성(Redundancy)** 과 **종속성(Dependency)** 이다.
- **중복성**은 같은 데이터가 여러 곳에 저장되어 데이터 불일치, 무결성 훼손, 비용 낭비를 일으킨다.
- **종속성**은 파일 구조가 바뀌면 그것을 사용하는 모든 프로그램도 수정해야 하는 문제이다.
- 이 두 문제를 해결하기 위해 **데이터베이스(Database)** 가 등장했다.
- 데이터베이스의 발전 순서는 **파일 시스템 → 계층형 → 네트워크형 → 관계형 → 객체지향형 → 객체관계형** 이다.
- **계층형 DBMS**는 트리 구조로 부모-자식 관계를 표현하며, 단방향 정보 흐름을 가진다.
- **네트워크형 DBMS**는 그래프 구조로 오너-멤버 관계를 표현하며, 사이클을 허용한다.
- **관계형 DBMS**는 테이블(표) 형태로 데이터를 관리하며, 현재 가장 널리 사용된다.
- 데이터베이스는 **통합된 데이터, 저장된 데이터, 운영 데이터, 공용 데이터**의 네 가지 요소로 정의된다.
- **DBMS(데이터베이스 관리 시스템)** 는 사용자와 데이터베이스 사이의 중재자 역할을 하는 소프트웨어이다.
- DBMS의 3가지 필수 기능은 **정의 기능(DDL), 조작 기능(DML), 제어 기능(DCL)** 이다.
- DBMS는 중복 제어, 동시 공유, 무결성 유지, 보안 강화 등의 장점을 가지지만, 높은 비용과 복잡성이라는 단점도 있다.

---

작성일: 2026-02-20