---
title: "장애와 회복의 개념"
description: "장애와 회복의 개념에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/transaction-overview-and-recovery/6-recovery-concept"
sidebar_label: "장애와 회복"
date: "2026-02-21"
---

## 🎯 트랜잭션이란 무엇인가?

데이터베이스를 공부하다 보면 **트랜잭션(Transaction)**이라는 단어를 정말 자주 만나게 됩니다. 이 개념을 제대로 이해하지 못하면 장애와 회복, 병행 제어 등 이후의 모든 내용이 모래 위의 성처럼 무너져 내립니다. 그래서 가장 먼저, 트랜잭션이 정확히 무엇인지 확실하게 짚고 넘어가겠습니다.

### 📖 트랜잭션의 정의

> **트랜잭션(Transaction)**이란 **하나의 논리적 기능을 수행하기 위한 작업의 단위**입니다. 더 이상 쪼갤 수 없는, 데이터베이스 연산들의 묶음을 의미합니다.

"더 이상 쪼갤 수 없는 단위"라는 말이 핵심입니다. 마치 원자(Atom)가 물질의 가장 작은 기본 단위인 것처럼, 트랜잭션은 데이터베이스 작업의 가장 작은 기본 단위입니다. 이 안에 포함된 작업들은 **전부 함께 성공하거나, 전부 함께 취소**되어야 합니다. "절반만 처리하고 나머지는 나중에"라는 것은 절대 허용되지 않습니다.

예를 들어볼까요? 여러분이 은행 앱에서 A 계좌에서 B 계좌로 50만 원을 이체한다고 상상해 보세요. 이 이체 작업은 내부적으로 다음과 같은 단계로 이루어집니다:

1. A 계좌의 잔액을 조회한다
2. A 계좌에서 50만 원을 차감한다
3. B 계좌에 50만 원을 추가한다
4. 양쪽 계좌의 최종 잔액을 확인한다

이 네 가지 단계가 하나의 트랜잭션입니다. 만약 2번까지 실행되고 3번에서 오류가 발생했다면, 2번에서 차감된 50만 원도 **반드시 원래대로 돌려놓아야** 합니다. "내 통장에서는 돈이 빠져나갔는데 상대방 통장에는 안 들어갔다"라는 상황이 벌어지면 큰일이겠죠? 이것이 바로 트랜잭션이 존재하는 이유입니다.

### 🔗 트랜잭션과 응용 프로그램의 관계

하나의 **응용 프로그램(Application)**은 여러 개의 트랜잭션들을 모아놓은 것입니다. 예를 들어 은행 앱이라는 응용 프로그램 안에는 "이체 트랜잭션", "잔액 조회 트랜잭션", "대출 신청 트랜잭션" 등 수많은 트랜잭션들이 존재합니다. 각각의 트랜잭션은 하나 이상의 SQL 명령어(INSERT, UPDATE, DELETE, SELECT 등)로 구성되어 있습니다.

또한 트랜잭션은 **물리적 개념이 아니라 논리적 개념**입니다. 하드디스크에 어떤 형태로 저장되느냐가 아니라, "이 작업들은 하나의 묶음으로 취급해야 한다"는 논리적인 약속입니다.

:::info 병행 제어와 회복에서의 트랜잭션
트랜잭션은 **병행 제어(Concurrency Control)**와 **회복(Recovery)** 작업의 기본 단위이기도 합니다. 병행 제어란 여러 사용자가 동시에 데이터베이스를 사용할 때 충돌이 발생하지 않도록 관리하는 것이고, 회복이란 데이터베이스에 장애가 발생했을 때 정상 상태로 복구하는 것입니다. 이 두 가지 모두 트랜잭션 단위로 수행됩니다.
:::

---

## 🧬 트랜잭션의 ACID 성질

트랜잭션에는 반드시 지켜져야 하는 네 가지 핵심 성질이 있습니다. 이 네 가지의 영문 첫 글자를 따서 **ACID**라고 부릅니다. 데이터베이스의 정확성과 신뢰성을 보장하는 가장 근본적인 원칙이므로, 하나하나 꼼꼼히 살펴보겠습니다.

| 성질 | 영문 | 의미 | 책임 컴포넌트 |
|------|------|------|---------------|
| **원자성** | Atomicity | 전부 실행 또는 전부 취소 | 트랜잭션 관리 컴포넌트 |
| **일관성** | Consistency | 실행 결과가 항상 일관적 | 응용 프로그램(프로그래머) |
| **격리성** | Isolation | 중간 결과에 다른 트랜잭션 접근 불가 | 동시성 제어 컴포넌트 |
| **영속성** | Durability | 성공한 결과는 영구 보존 | 회복 관리 컴포넌트 |

### ⚛️ 원자성 (Atomicity) — 가장 중요한 성질

> **원자성**이란, 트랜잭션에 포함된 모든 연산이 **한꺼번에 완료(All)**되거나 **한꺼번에 취소(Nothing)**되어야 한다는 성질입니다.

"All or Nothing"이라는 표현을 기억하세요. 마치 스위치를 켜면 방 안의 모든 전등이 한꺼번에 켜지고, 끄면 모든 전등이 한꺼번에 꺼지는 것과 같습니다. 전등 3개 중 2개만 켜지고 1개는 안 켜지는 "부분적 처리"는 허용되지 않습니다.

앞서 들었던 은행 이체 예시를 다시 떠올려 보겠습니다. 내 통장에서 돈이 빠져나갔는데 상대방 서버에 문제가 생겨서 상대방 계좌로 이체가 안 된 상황을 상상해 보세요. 중간에 돈이 사라져 버리는 것이죠. 원자성이 이런 문제를 방지합니다. 상대방 서버까지 포함하여 전체 이체 과정이 하나의 트랜잭션이므로, 상대방 서버에서 "정상적으로 잘 받았어"라는 확인 메시지를 돌려받아야만 비로소 하나의 트랜잭션이 완료됩니다. 만약 중간에 어디서든 오류가 발생하면, 이미 실행된 부분까지 전부 원래대로 되돌립니다.

이 원자성을 구현하기 위해 두 가지 핵심 명령어가 사용됩니다:

- **COMMIT**: 트랜잭션이 성공적으로 완료되었음을 선언하고, 결과를 확정(저장)하는 명령
- **ROLLBACK**: 트랜잭션이 실패했을 때, 그동안 수행한 모든 작업을 취소하고 원래 상태로 되돌리는 명령

:::tip COMMIT과 ROLLBACK을 쉽게 이해하는 비유
여러분이 한글(HWP) 프로그램에서 문서 작업을 열심히 하고 있다고 상상해 보세요. 작업을 다 끝내고 **저장 버튼**을 누르는 것이 바로 **COMMIT**입니다. 저장 버튼을 누르기 전에 컴퓨터가 꺼져 버리면? 작업했던 내용이 모두 사라져 버리죠. 이것이 바로 **ROLLBACK**과 같은 상황입니다. 저장 버튼을 눌러야만 하드디스크에 영구적으로 보관되는 것입니다.
:::

원자성은 DBMS의 **트랜잭션 관리 컴포넌트**가 책임지고 지켜줍니다. 트랜잭션의 네 가지 성질 중에서도 원자성은 **가장 핵심적인 성질**입니다. 원자성이 지켜져야만 데이터의 정확성과 무결성이 완벽하게 보장될 수 있기 때문입니다.

### 🔄 일관성 (Consistency)

> **일관성**이란, 트랜잭션이 성공적으로 완료되면 데이터베이스가 **일관된 상태**를 유지해야 한다는 성질입니다.

쉽게 말하면, 같은 조건으로 같은 데이터를 조회했을 때 **항상 같은 결과**가 나와야 한다는 것입니다. 예를 들어 쇼핑몰에서 상품 A의 가격을 조회했더니 100원이었습니다. 아무도 가격을 변경하지 않았는데, 같은 상품을 다시 조회했더니 갑자기 200원으로 바뀌어 있다면? 이것은 일관성이 깨진 것입니다.

물론 관리자가 가격을 올렸다면 값이 바뀌는 것은 당연합니다. 하지만 **아무런 변경 없이** 같은 질의에 대해 다른 결과가 나오는 것은 심각한 문제입니다.

여기서 중요한 포인트가 있습니다. **실행 중에는 일관성이 일시적으로 무시될 수 있습니다.** 1 + 2 + 3의 계산을 생각해 보세요. 어떤 순서로 계산하든 최종 결과는 반드시 6이어야 합니다. 하지만 1 + 2를 먼저 계산하면 중간 결과는 3이고, 2 + 3을 먼저 계산하면 중간 결과는 5입니다. 중간 결과는 순서에 따라 다를 수 있지만, **최종 결과만큼은 반드시 동일**해야 합니다.

따라서 우리가 말하는 일관성은 **최종 결과에 대한 일관성**을 의미합니다. 이 일관성이 제대로 지켜지려면 **프로그램이 올바르게 작성**되어야 합니다. 알고리즘에 오류가 없어야 실행 결과의 일관성을 보장할 수 있습니다.

### 🔒 격리성 (Isolation)

> **격리성**이란, 실행 중인 트랜잭션의 **중간 결과**에 다른 트랜잭션이 접근할 수 없도록 차단하는 성질입니다.

방금 일관성에서 설명한 것처럼, 실행 순서에 따라 중간 결과는 얼마든지 달라질 수 있습니다. 만약 다른 사용자가 이 중간 결과를 읽어간다면 어떻게 될까요? 한 사용자는 중간 결과 3을 읽어가고, 다른 사용자는 중간 결과 5를 읽어가게 됩니다. "나는 3이다!", "아니, 나는 5다!" 이렇게 서로 다른 값을 가지게 되어 혼란이 발생합니다.

실생활로 비유하면 이렇습니다. 쇼핑몰 관리자가 상품 가격을 지금 한창 변경하고 있는 중이에요. 이 와중에 고객이 접속해서 주문을 넣으면 안 되겠죠? 가격이 아직 확정되지 않았으니까요. 관리자가 가격 변경을 완료하고 "저장" 버튼을 눌러서 성공적으로 완료된 다음에야 고객이 접근할 수 있어야 합니다. 이것이 격리성입니다.

격리성은 **연쇄 취소(Cascading Abort)**를 방지하기 위해서도 필요합니다. 만약 다른 트랜잭션이 중간 결과를 읽어갔는데, 원래 트랜잭션이 실패하여 취소되어야 한다면? 중간 결과를 읽어간 트랜잭션도 함께 취소해야 하는데, 이미 그 데이터를 기반으로 다른 작업이 진행되었다면 취소가 불가능한 상황이 발생할 수 있습니다.

격리성은 DBMS의 **동시성 제어 컴포넌트**가 책임지고 관리합니다. 여러 사용자가 동시에 접근할 때 중간 결과에 접근하지 못하도록 막아주는 역할을 합니다.

### 💾 영속성 (Durability)

> **영속성**이란, 트랜잭션이 성공적으로 완료(COMMIT)되면 그 결과가 **영구적으로 보존**되어야 한다는 성질입니다.

트랜잭션이 성공하면 그 결과는 하드디스크에 저장됩니다. 만약 메모리에만 저장된다면 어떻게 될까요? 컴퓨터를 껐다 켜면 메모리는 초기화되므로 모든 데이터가 사라져 버립니다. 메모리는 **휘발성(전원이 꺼지면 내용이 사라지는 성질)** 저장 장치이기 때문입니다.

따라서 COMMIT 명령이 실행되면, 그 결과는 반드시 **비휘발성 저장 장치(하드디스크 등)**에 기록되어야 합니다. 컴퓨터를 껐다 켜도, 심지어 시스템에 장애가 발생하더라도, 한 번 COMMIT된 데이터는 안전하게 보존되어야 합니다.

영속성은 DBMS의 **회복 관리 컴포넌트**가 책임지고 관리합니다.

---

## 🔀 트랜잭션의 상태 흐름

트랜잭션은 시작부터 끝까지 여러 상태를 거치며 진행됩니다. 마치 우리가 요리를 할 때 "재료 준비 → 조리 중 → 거의 다 됨 → 완성(또는 실패)"의 단계를 거치듯, 트랜잭션도 정해진 상태 흐름을 따릅니다.

### 📊 5가지 상태

| 상태 | 설명 | 비유 |
|------|------|------|
| **활동(Active)** | 트랜잭션이 시작되어 실행 중인 상태 | 한글에서 문서를 작성하고 있는 중 |
| **부분 완료(Partially Committed)** | 마지막 명령문까지 실행했지만, 아직 COMMIT 전인 상태 | 문서 작성은 끝났고, 저장 버튼만 누르면 되는 상태 |
| **완료(Committed)** | COMMIT 명령이 실행되어 결과가 영구 저장된 상태 | 저장 버튼을 눌러 하드디스크에 저장 완료 |
| **실패(Failed)** | 실행 도중 오류가 발생하여 더 이상 진행할 수 없는 상태 | 작업 중 프로그램이 오류를 일으킴 |
| **철회(Aborted)** | ROLLBACK이 실행되어 모든 작업이 취소된 상태 | 작업했던 내용을 모두 지우고 원래 상태로 돌아감 |

### 🔄 상태 전이 흐름

트랜잭션의 상태 전이는 다음과 같은 흐름을 따릅니다:

```
활동(Active) ──→ 부분 완료(Partially Committed) ──→ 완료(Committed)
    │                        │
    │                        │ (저장 실패 시)
    │                        ▼
    └──────────→ 실패(Failed) ──→ 철회(Aborted)
```

여기서 주의할 점은 **부분 완료 상태에서도 실패로 갈 수 있다**는 것입니다. 한글에서 문서 작성을 다 끝내고 저장 버튼을 눌렀는데, "저장 공간이 부족합니다", "읽기 전용 파일입니다", "파일 이름이 중복됩니다" 같은 오류 메시지가 뜨는 경우를 생각해 보세요. 작업은 다 끝났지만 저장에 실패한 것이죠. 이 경우 부분 완료 상태에서 실패 상태로 전환됩니다.

:::warning 중요한 방향성 규칙
**실패 상태에서 부분 완료 상태로는 갈 수 없습니다.** 한 번 실패하면 다시 부분 완료로 돌아가는 것은 불가능하며, 반드시 철회(ROLLBACK) 과정을 거쳐야 합니다. 상태 흐름은 단방향으로만 진행됩니다.
:::

---

## 💾 데이터 저장과 처리의 기본 구조

장애와 회복을 제대로 이해하려면, 데이터가 실제로 어떻게 저장되고 처리되는지 그 구조를 먼저 알아야 합니다.

### 🗄️ 저장 장치의 종류

| 구분 | 특징 | 예시 |
|------|------|------|
| **소멸성(Volatile) 저장 장치** | 전원이 꺼지면 내용이 사라짐 | RAM(메모리) |
| **비소멸성(Non-volatile) 저장 장치** | 전원이 꺼져도 내용이 유지됨 | 하드디스크, USB, SSD |
| **안정성(Stable) 저장 장치** | 별도로 백업하여 안전하게 보관 | 외장하드 백업, 클라우드 백업 |

소멸성 저장 장치인 메모리는 속도가 매우 빠르지만, 컴퓨터를 끄면 그 안의 데이터가 모두 날아갑니다. 비소멸성 저장 장치인 하드디스크는 한번 저장하면 컴퓨터를 꺼도 데이터가 남아있습니다. 안정성 저장 장치는 중요한 데이터를 별도로 복사(백업)하여 보관하는 것입니다. 마치 중요한 서류를 복사해서 금고에 보관해 두는 것과 같습니다.

### 🔄 데이터 처리 흐름: Input, Read, Write, Output

데이터는 하드디스크에서 바로 CPU로 갈 수 없습니다. 하드디스크는 너무 느리고, CPU는 너무 빠르기 때문에, 중간에 **버퍼(완충) 역할**을 해주는 **메모리**가 필요합니다. 마치 공장(CPU)에 원재료(데이터)를 공급할 때, 창고(하드디스크)에서 직접 가져오지 않고 작업대(메모리) 위에 먼저 올려놓고 사용하는 것과 같습니다.

```
하드디스크  ←──input──→  메모리  ←──read──→  CPU
           ←──output─→          ←──write─→
```

각 연산을 정리하면 다음과 같습니다:

- **Input**: 하드디스크에서 메모리로 데이터를 읽어오는 것
- **Read**: 메모리에서 CPU로 데이터를 읽어오는 것
- **Write**: CPU에서 처리된 결과를 메모리에 기록하는 것
- **Output**: 메모리에 있는 데이터를 하드디스크로 저장하는 것

:::note 갱신 방식: 제자리 갱신 vs 간접 갱신
데이터를 수정(갱신)할 때 두 가지 방식이 있습니다.
- **제자리 갱신(In-place Update)**: 원래 데이터가 저장된 바로 그 위치에 새 데이터를 덮어쓰는 방식입니다.
- **간접 갱신(Out-of-place Update)**: 원래 위치가 아닌 다른 위치에 새 데이터를 저장하는 방식입니다. 이 경우 기존 위치의 데이터는 더 이상 필요 없는 **쓰레기(Garbage)**가 되며, 이를 정리하는 작업을 **가비지 컬렉션(Garbage Collection, 쓰레기 수집)**이라고 합니다.
:::

---

## 🚨 장애의 유형

데이터베이스를 사용하다 보면 다양한 원인으로 장애가 발생할 수 있습니다. 우리 몸이 아플 수 있는 것처럼, 데이터베이스도 "아플" 수 있습니다. 장애의 유형을 정확히 알아야 각 상황에 맞는 적절한 회복 방법을 선택할 수 있습니다.

### 1️⃣ 행동 장애 (Action Failure)

가장 가벼운 수준의 장애입니다. 데이터를 처리하는 과정에서 논리적인 문제가 발생하는 경우를 말합니다.

- 찾으려는 데이터 항목이 데이터베이스에 **존재하지 않는** 경우
- **무결성 규정을 위반**하는 경우: 예를 들어, 기본키에 NULL 값이 들어간다거나, 시험 점수 필드에 0~100 범위를 벗어나는 값이 입력된다거나, 학년 필드에 1~6까지만 허용되는데 7이 입력되는 경우 등

이런 상황에서는 해당 트랜잭션이 실패하게 됩니다. 비유하자면, 냉장고에서 우유를 꺼내려고 했는데 우유가 없는 상황이나, 레시피에 소금 1g을 넣어야 하는데 1kg을 넣으려고 하는 상황과 비슷합니다.

### 2️⃣ 트랜잭션 장애 (Transaction Failure)

시스템 자원(CPU, 메모리 등)을 과도하게 사용하거나, 입력 데이터 자체가 불량이어서 발생하는 장애입니다.

- **입력 데이터가 불량**이라서 아예 입력 자체를 받지 못하는 경우
- 중간에 데이터가 예기치 않게 **삭제**되어 버리는 경우
- CPU 사용률이 100%까지 치솟거나, 메모리가 꽉 차서 **시스템이 멈춰** 버리는 경우

비유하자면, 주방에서 요리를 하다가 가스가 떨어지거나, 조리대가 음식 재료로 꽉 차서 더 이상 요리를 진행할 수 없는 상황과 비슷합니다.

### 3️⃣ 시스템 장애 (System Failure)

컴퓨터 하드웨어 자체에 문제가 생기는 경우입니다.

- **전원이 갑자기 꺼져** 버리는 경우
- CPU, 메모리, 그래픽카드 등 **하드웨어가 고장** 나는 경우
- 운영체제에 치명적인 오류가 발생하는 경우

비유하자면, 요리를 하고 있는데 갑자기 정전이 되어 모든 조리 기구가 멈춰 버리는 상황입니다.

### 4️⃣ 미디어 장애 (Media Failure) — 가장 치명적

> **미디어 장애**는 데이터베이스 관점에서 **가장 위험하고 치명적인** 장애입니다.

**하드디스크 자체가 물리적으로 망가져 버리는** 경우를 말합니다. 다른 장애들은 운영체제를 다시 설치하거나 부품을 교체하면 해결되지만, 하드디스크가 망가지면 그 안에 저장된 **데이터 자체가 직접적으로 손실**됩니다. 복구하는 데 상당히 많은 비용과 시간이 소요되며, 경우에 따라서는 복구가 불가능할 수도 있습니다.

비유하자면, 요리를 하다가 불이 나서 냉장고(하드디스크)까지 타버린 상황입니다. 냉장고 안에 보관하던 모든 식재료(데이터)가 사라져 버리는 것이죠.

:::danger 미디어 장애에 대비하세요!
하드디스크 장애는 언제든 발생할 수 있습니다. 중요한 데이터는 반드시 **정기적으로 백업**하고, 가능하다면 물리적으로 다른 장소에 백업 사본을 보관해야 합니다. 클라우드 백업, 외장하드 백업, RAID 구성 등 다양한 방법을 활용하세요.
:::

---

## 🔧 회복(Recovery)의 기본 원리

### 🏥 회복이란?

> **회복(Recovery)**이란, 장애로 인해 손상된 데이터베이스를 **손상되기 이전의 정상적인 상태로 복구시키는 것**을 말합니다.

우리가 아프면 병원에 가서 치료를 받고 건강한 상태로 회복하듯이, 데이터베이스도 장애가 발생하면 적절한 회복 절차를 통해 정상 상태로 되돌려야 합니다.

### 📋 회복의 기본 방법: Dump와 Log

회복의 핵심은 두 가지 도구를 활용하는 것입니다:

**1. Dump(덤프) = 백업 파일**

장애가 발생하기 이전에, 마지막으로 정상 상태였던 데이터베이스 전체를 별도의 안전한 저장 장치에 **통째로 복사**해 놓는 것입니다. 여러분이 집 컴퓨터의 중요한 파일들을 USB, 외장하드, 클라우드 등에 복사해 놓는 것과 똑같은 개념입니다.

**2. Log(로그) 파일 = 변경 기록부**

Dump 이후에 데이터베이스에서 발생하는 모든 변경 사항을 **하나하나 기록**해 놓는 파일입니다. 마치 가계부처럼, "언제, 어떤 데이터가, 어떤 값에서, 어떤 값으로 바뀌었는지"를 빠짐없이 기록합니다.

회복 과정을 비유하면 이렇습니다. 여러분이 일기장을 쓰고 있다고 상상해 보세요:
1. 매월 1일에 일기장을 통째로 복사해서 금고에 넣어둡니다 (**Dump**)
2. 그 이후 매일 쓴 일기 내용을 별도의 메모지에 기록합니다 (**Log**)
3. 일기장이 훼손되면, 금고에서 복사본을 꺼내고(**Dump 복원**), 메모지를 보면서 이후의 내용을 다시 써 넣습니다(**Log 적용**)

### 📝 Log 파일의 구조

Log 파일의 각 레코드는 다음 정보를 포함합니다:

| 항목 | 설명 | 예시 |
|------|------|------|
| 트랜잭션 이름 | 어떤 트랜잭션인지 식별 | T1 |
| 데이터 아이템 이름 | 어떤 데이터가 변경되었는지 | X |
| 변경 전 값(Old Value) | 변경되기 이전의 값 | 100 |
| 변경 후 값(New Value) | 변경된 이후의 값 | 200 |

Log 레코드의 유형을 정리하면 다음과 같습니다:

```
[T1, start]           -- T1 트랜잭션이 시작됨
[T1, X, 100, 200]     -- T1이 X 값을 100에서 200으로 변경
[T1, read, X]          -- T1이 X 값을 읽음 (생략 가능)
[T1, commit]           -- T1이 성공적으로 완료됨
[T1, abort]            -- T1이 중단(ROLLBACK)됨
```

:::info Log 파일의 크기
데이터 변경이 일어날 때마다 Log 레코드가 생성되므로, 100만 개의 데이터를 변경하면 Log가 100만 줄 이상 생깁니다. 따라서 Log 파일은 매우 큰 규모가 될 수 있습니다. 읽기(Read) 연산은 데이터를 변경하지 않으므로, 파일 크기를 줄이기 위해 일반적으로 생략합니다.
:::

---

## 🔁 회복 연산: Redo와 Undo

장애 발생 후 회복을 수행할 때, Log 파일을 분석하여 각 트랜잭션에 대해 **Redo** 또는 **Undo** 연산을 수행합니다.

### ✅ Redo (재실행) — Forward Recovery

> **Redo**란, COMMIT이 완료된 트랜잭션의 작업을 **다시 수행**하여 데이터베이스에 반영하는 것입니다.

Dump(백업) 파일을 불러온 후, Log 파일에서 COMMIT이 있는 트랜잭션들의 변경 내용을 **순방향(앞으로)**으로 하나씩 다시 적용합니다. 마치 녹화된 영상을 **재생(Play)**하듯이, 성공한 작업들을 처음부터 끝까지 다시 수행하는 것입니다.

**Redo를 수행하는 이유**: 백업 파일은 과거의 상태이므로, COMMIT되어 확정된 변경 사항들을 다시 적용해야 최신 상태로 복구할 수 있습니다.

### ❌ Undo (취소) — Backward Recovery

> **Undo**란, COMMIT이 없는(미완료된) 트랜잭션의 작업을 **취소**하여 원래 상태로 되돌리는 것입니다.

COMMIT 없이 장애가 발생한 트랜잭션은, 이미 데이터베이스에 반영된 변경 사항이 있다면 이를 **역방향(뒤로)**으로 하나씩 취소합니다. 마치 영상을 **되감기(Rewind)**하듯이, 잘못된 작업들을 끝에서부터 처음으로 하나씩 원래대로 돌려놓는 것입니다.

**Undo를 수행하는 이유**: 원자성(All or Nothing)을 지키기 위해서입니다. COMMIT이 없다는 것은 트랜잭션이 완료되지 않았다는 뜻이므로, 부분적으로 적용된 변경 사항은 전부 취소해야 합니다.

```
Redo (순방향, Forward Recovery):  ──────→ (처음부터 끝으로)
Undo (역방향, Backward Recovery): ←────── (끝에서 처음으로)
```

:::tip 핵심 요약
- **COMMIT이 있는 트랜잭션** → **Redo** (다시 실행)
- **COMMIT이 없는 트랜잭션** → **Undo** (취소)
:::

---

## 📘 지연 갱신 기법 (Deferred Update)

회복 기법에는 크게 **지연 갱신 기법**과 **즉시 갱신 기법** 두 가지가 있습니다. 먼저 지연 갱신 기법부터 살펴보겠습니다.

### 🔍 지연 갱신 기법이란?

> **지연 갱신 기법**이란, COMMIT 명령을 만나기 전까지는 **모든 변경 사항을 메모리에서만 처리**하고, 하드디스크로의 저장(Output)을 지연시키는 방식입니다.

한글 프로그램에서 저장 버튼을 누르기 전까지는 절대로 자동 저장이 되지 않는 방식이라고 생각하면 됩니다. 열심히 타이핑을 해도 저장 버튼을 누르기 전에는 하드디스크에 아무것도 기록되지 않습니다. 이러한 방식을 **No-Steal 방식**이라고도 부릅니다.

### ✨ 지연 갱신의 핵심 특징

**Undo 연산이 필요 없습니다!**

이것이 지연 갱신 기법의 가장 큰 특징입니다. 왜 그럴까요? COMMIT 전에는 하드디스크에 아무것도 저장되지 않으므로, 에러가 발생해도 하드디스크에 반영된 것이 하나도 없습니다. 되돌릴 것 자체가 없으니 Undo를 할 필요가 없는 것이죠.

- **COMMIT이 있는 트랜잭션** → **Redo** 수행 (변경 사항을 다시 적용)
- **COMMIT이 없는 트랜잭션** → **아무 작업도 하지 않음** (하드디스크에 반영된 것이 없으므로)

Log 파일에도 **변경 후 값(New Value)만** 기록하면 됩니다. Undo를 하지 않으므로 변경 전 값(Old Value)이 필요 없기 때문입니다.

```
지연 갱신 기법의 Log 형식:
[T1, X, 150]     -- T1이 X 값을 150으로 변경 (이전 값 불필요)
```

### 📊 지연 갱신 기법 예제

다음 세 가지 시나리오를 통해 지연 갱신 기법이 어떻게 동작하는지 살펴보겠습니다. 초기 데이터 값은 A=1000, B=2000, C=3000이라고 가정합니다.

**시나리오 1: COMMIT이 없는 경우 (장애 발생)**

```sql
-- Log 파일 내용
[T1, start]        -- T1 시작
[T1, A, 900]       -- A를 900으로 변경
[T1, B, 2100]      -- B를 2100으로 변경
-- ❌ 여기서 장애 발생! (COMMIT 없음)
```

COMMIT이 없으므로 하드디스크에 반영된 것이 전혀 없습니다. 따라서 **아무 회복 작업도 필요 없습니다.**

| 데이터 | 최종 값 | 설명 |
|--------|---------|------|
| A | 1000 | 원래 값 유지 |
| B | 2000 | 원래 값 유지 |
| C | 3000 | 원래 값 유지 |

**시나리오 2: T1은 COMMIT 있음, T2는 COMMIT 없음**

```sql
-- Log 파일 내용
[T1, start]        -- T1 시작
[T1, A, 900]       -- A를 900으로 변경
[T1, B, 2100]      -- B를 2100으로 변경
[T1, commit]        -- ✅ T1 성공적으로 완료!
[T2, start]        -- T2 시작
[T2, C, 2800]      -- C를 2800으로 변경
-- ❌ 여기서 장애 발생! (T2의 COMMIT 없음)
```

T1은 COMMIT이 있으므로 **Redo** 수행, T2는 COMMIT이 없으므로 **아무 작업도 하지 않음**.

| 데이터 | 최종 값 | 설명 |
|--------|---------|------|
| A | **900** | T1의 Redo로 변경 적용 |
| B | **2100** | T1의 Redo로 변경 적용 |
| C | 3000 | T2는 무시, 원래 값 유지 |

**시나리오 3: T1도 COMMIT, T2도 COMMIT**

```sql
-- Log 파일 내용
[T1, start]        -- T1 시작
[T1, A, 900]       -- A를 900으로 변경
[T1, B, 2100]      -- B를 2100으로 변경
[T1, commit]        -- ✅ T1 완료
[T2, start]        -- T2 시작
[T2, C, 2800]      -- C를 2800으로 변경
[T2, commit]        -- ✅ T2 완료
-- 여기서 장애 발생
```

T1, T2 모두 COMMIT이 있으므로 둘 다 **Redo** 수행.

| 데이터 | 최종 값 | 설명 |
|--------|---------|------|
| A | **900** | T1의 Redo |
| B | **2100** | T1의 Redo |
| C | **2800** | T2의 Redo |

:::warning 지연 갱신 기법의 단점
COMMIT 전까지 모든 데이터가 메모리에 머물러 있으므로, **메모리 공간이 매우 커야** 합니다. 또한 바로바로 하드디스크에 저장되지 않기 때문에 다른 사용자가 최신 데이터를 읽어올 수 없어 **동시성(여러 사용자가 동시에 작업하는 능력)**이 떨어지는 단점이 있습니다.
:::

---

## ⚡ 즉시 갱신 기법 (Immediate Update)

### 🔍 즉시 갱신 기법이란?

> **즉시 갱신 기법**이란, COMMIT 여부와 관계없이 변경 사항이 **즉시 하드디스크에 반영**되는 방식입니다.

지연 갱신 기법과 정반대입니다. 데이터가 변경되면 COMMIT을 기다리지 않고 바로바로 하드디스크에 저장해 버립니다. 한글 프로그램이 글자를 입력할 때마다 자동으로 저장하는 것과 비슷합니다.

### ✨ 즉시 갱신의 핵심 특징

**Undo와 Redo 연산이 모두 필요합니다!**

COMMIT이 없는 트랜잭션의 변경 사항도 이미 하드디스크에 기록되어 버렸으므로, 이를 **Undo(취소)**해야 합니다. COMMIT이 있는 트랜잭션은 장애로 인해 일부 데이터가 손상되었을 수 있으므로 **Redo(재실행)**가 필요합니다.

- **COMMIT이 없는 트랜잭션** → **Undo** 수행 (이미 저장된 변경 사항을 취소)
- **COMMIT이 있는 트랜잭션** → **Redo** 수행 (변경 사항을 다시 적용)

**실행 순서도 중요합니다:**
1. 먼저 **Undo 연산을 역방향(뒤에서 앞으로)**으로 수행하여 취소할 것을 모두 취소합니다.
2. 그 다음 **Redo 연산을 순방향(앞에서 뒤로)**으로 수행하여 반영할 것을 반영합니다.

왜 Undo를 먼저 할까요? Undo와 Redo가 섞여 있는 상태에서 취소할 것을 먼저 깔끔하게 정리한 후, 다시 적용할 것을 순서대로 적용하는 것이 논리적으로 안전하기 때문입니다.

Log 파일에는 **변경 전 값(Old Value)과 변경 후 값(New Value)을 모두** 기록해야 합니다. Undo를 위해서는 변경 전 값이, Redo를 위해서는 변경 후 값이 필요하기 때문입니다.

```
즉시 갱신 기법의 Log 형식:
[T1, X, 100, 200]  -- T1이 X 값을 100(이전)에서 200(이후)으로 변경
```

### 📊 즉시 갱신 기법 예제

초기 데이터 값은 동일하게 A=1000, B=2000, C=3000입니다.

**시나리오 1: COMMIT이 없는 경우 (장애 발생)**

```sql
-- Log 파일 내용
[T1, start]              -- T1 시작
[T1, A, 1000, 900]       -- A를 1000에서 900으로 변경 (이미 하드디스크에 저장됨!)
[T1, B, 2000, 2100]      -- B를 2000에서 2100으로 변경 (이미 하드디스크에 저장됨!)
-- ❌ 여기서 장애 발생! (COMMIT 없음)
```

COMMIT이 없지만, 즉시 갱신이므로 이미 A=900, B=2100이 하드디스크에 저장되어 있습니다. 이를 **Undo(취소)**해야 합니다. 역방향으로 수행합니다:

1. B를 2100 → **2000**으로 되돌림 (역방향이므로 B부터)
2. A를 900 → **1000**으로 되돌림

| 데이터 | 최종 값 | 설명 |
|--------|---------|------|
| A | 1000 | Undo로 원래 값 복원 |
| B | 2000 | Undo로 원래 값 복원 |
| C | 3000 | 변경 없음, 원래 값 유지 |

**시나리오 2: T1은 COMMIT 있음, T2는 COMMIT 없음**

```sql
-- Log 파일 내용
[T1, start]              -- T1 시작
[T1, A, 1000, 900]       -- A를 1000에서 900으로 변경
[T1, B, 2000, 2100]      -- B를 2000에서 2100으로 변경
[T1, commit]              -- ✅ T1 완료
[T2, start]              -- T2 시작
[T2, C, 3000, 2800]      -- C를 3000에서 2800으로 변경
-- ❌ 여기서 장애 발생! (T2의 COMMIT 없음)
```

T1은 COMMIT이 있으므로 **Redo**, T2는 COMMIT이 없으므로 **Undo**.

먼저 Undo(역방향)를 수행합니다:
1. T2의 C를 2800 → **3000**으로 되돌림

그 다음 Redo(순방향)를 수행합니다:
1. T1의 A를 **900**으로 변경
2. T1의 B를 **2100**으로 변경

| 데이터 | 최종 값 | 설명 |
|--------|---------|------|
| A | **900** | T1의 Redo |
| B | **2100** | T1의 Redo |
| C | 3000 | T2의 Undo로 원래 값 복원 |

**시나리오 3: T1도 COMMIT, T2도 COMMIT**

```sql
-- Log 파일 내용
[T1, start]              -- T1 시작
[T1, A, 1000, 900]       -- A를 1000에서 900으로 변경
[T1, B, 2000, 2100]      -- B를 2000에서 2100으로 변경
[T1, commit]              -- ✅ T1 완료
[T2, start]              -- T2 시작
[T2, C, 3000, 2800]      -- C를 3000에서 2800으로 변경
[T2, commit]              -- ✅ T2 완료
-- 여기서 장애 발생
```

둘 다 COMMIT이 있으므로 모두 **Redo** 수행.

| 데이터 | 최종 값 | 설명 |
|--------|---------|------|
| A | **900** | T1의 Redo |
| B | **2100** | T1의 Redo |
| C | **2800** | T2의 Redo |

---

## ⚖️ 지연 갱신 vs 즉시 갱신 비교

두 기법의 차이를 한눈에 비교해 보겠습니다:

| 구분 | 지연 갱신 기법 | 즉시 갱신 기법 |
|------|---------------|---------------|
| **하드디스크 저장 시점** | COMMIT 이후에만 저장 | 변경 즉시 저장 |
| **COMMIT 없는 트랜잭션** | 아무 작업 안 함 | **Undo** 수행 |
| **COMMIT 있는 트랜잭션** | **Redo** 수행 | **Redo** 수행 |
| **Log에 기록하는 값** | 변경 후 값(New)만 | 변경 전(Old) + 변경 후(New) 값 모두 |
| **No-Steal 방식** | ✅ 해당 | ❌ 해당 없음 |
| **메모리 요구량** | 큼 (COMMIT 전까지 메모리에 보관) | 상대적으로 작음 |
| **동시성** | 낮음 | 상대적으로 높음 |

:::tip 잘못된 예시(❌)와 올바른 예시(✅) 한눈에 보기

**❌ 잘못된 이해:**
"지연 갱신에서 COMMIT이 없는 트랜잭션도 Undo를 해야 한다"

**✅ 올바른 이해:**
"지연 갱신에서 COMMIT이 없는 트랜잭션은 하드디스크에 반영된 것이 없으므로, 아무 작업도 하지 않는다"

---

**❌ 잘못된 이해:**
"즉시 갱신에서는 Redo만 하면 된다"

**✅ 올바른 이해:**
"즉시 갱신에서는 COMMIT 없는 것은 Undo, COMMIT 있는 것은 Redo를 수행한다. Undo를 먼저 역방향으로 처리한 후 Redo를 순방향으로 처리한다"
:::

---

## 💡 COMMIT과 ROLLBACK 정리

이 문서에서 가장 많이 등장한 두 명령어를 최종 정리하겠습니다.

### ✅ COMMIT — 성공적 완료 선언

```sql
-- 이체 트랜잭션 예시
BEGIN TRANSACTION;                    -- 트랜잭션 시작

UPDATE 계좌 SET 잔액 = 잔액 - 500000  -- A 계좌에서 50만원 차감
WHERE 계좌번호 = 'A001';

UPDATE 계좌 SET 잔액 = 잔액 + 500000  -- B 계좌에 50만원 추가
WHERE 계좌번호 = 'B001';

COMMIT;                               -- ✅ 모든 작업 성공! 하드디스크에 영구 저장
```

- `BEGIN TRANSACTION`: 트랜잭션을 시작합니다. 이 시점부터 하나의 작업 단위가 시작됩니다.
- 첫 번째 `UPDATE`: A 계좌에서 50만 원을 차감합니다. 아직 확정되지 않은 상태입니다.
- 두 번째 `UPDATE`: B 계좌에 50만 원을 추가합니다. 역시 아직 확정되지 않은 상태입니다.
- `COMMIT`: 위의 모든 작업이 성공적으로 완료되었음을 선언합니다. 이 시점에서 변경 사항이 하드디스크에 영구적으로 저장되어 영속성을 갖게 됩니다.

### ❌ ROLLBACK — 실패 시 전체 취소

```sql
-- 이체 트랜잭션 예시 (오류 발생 시)
BEGIN TRANSACTION;                    -- 트랜잭션 시작

UPDATE 계좌 SET 잔액 = 잔액 - 500000  -- A 계좌에서 50만원 차감
WHERE 계좌번호 = 'A001';

-- ❌ 여기서 오류 발생! (예: B 계좌가 존재하지 않음)
-- UPDATE 계좌 SET 잔액 = 잔액 + 500000
-- WHERE 계좌번호 = 'B001';

ROLLBACK;                             -- ❌ 오류 발생! A 계좌 차감도 취소하여 원래 상태로 복구
```

- `BEGIN TRANSACTION`: 트랜잭션을 시작합니다.
- 첫 번째 `UPDATE`: A 계좌에서 50만 원을 차감했습니다.
- 두 번째 `UPDATE`에서 오류가 발생했습니다 (예: B 계좌가 존재하지 않음).
- `ROLLBACK`: 트랜잭션이 실패했으므로, 이미 실행된 A 계좌 차감까지 포함하여 **모든 작업을 취소**합니다. A 계좌의 잔액은 원래대로 돌아갑니다.

:::danger 절대 하면 안 되는 것
오류가 발생했는데 ROLLBACK을 하지 않고 부분적으로 처리된 상태를 방치하면, 데이터의 정합성(일관성)이 완전히 깨집니다. 위 예시에서 A 계좌에서는 돈이 빠져나갔는데 B 계좌에는 돈이 안 들어간 상태가 되어, 50만 원이 증발해 버리는 심각한 문제가 발생합니다.
:::

---

## 📌 핵심 정리

- **트랜잭션**은 더 이상 쪼갤 수 없는 데이터베이스 작업의 논리적 기본 단위이다
- **ACID 성질**: 원자성(All or Nothing), 일관성(결과의 동일성), 격리성(중간 결과 접근 차단), 영속성(성공 결과의 영구 보존)
- **COMMIT**은 트랜잭션의 성공적 완료를 선언하여 하드디스크에 영구 저장하는 명령이다
- **ROLLBACK**은 트랜잭션 실패 시 모든 작업을 취소하고 이전 상태로 되돌리는 명령이다
- **트랜잭션 상태 흐름**: 활동 → 부분 완료 → 완료(COMMIT) 또는 활동/부분 완료 → 실패 → 철회(ROLLBACK)
- **장애 유형**: 행동 장애(논리 오류) < 트랜잭션 장애(자원 부족) < 시스템 장애(하드웨어 고장) < 미디어 장애(디스크 파괴, 가장 치명적)
- **회복의 기본 도구**: Dump(전체 백업)와 Log(변경 기록)를 조합하여 복구한다
- **Redo(Forward Recovery)**: COMMIT이 있는 트랜잭션을 순방향으로 다시 수행한다
- **Undo(Backward Recovery)**: COMMIT이 없는 트랜잭션을 역방향으로 취소한다
- **지연 갱신 기법**: COMMIT 전까지 하드디스크 저장을 지연하므로, Undo가 필요 없고 Redo만 수행한다
- **즉시 갱신 기법**: 변경 즉시 하드디스크에 저장하므로, Undo와 Redo를 모두 수행한다 (Undo 먼저, Redo 다음)

작성일: 2026-02-21