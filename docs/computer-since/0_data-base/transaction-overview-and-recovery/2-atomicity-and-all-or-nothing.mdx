---
title: "원자성(Atomicity)과 All or Nothing 원칙"
description: "원자성(Atomicity)과 All or Nothing 원칙에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/transaction-overview-and-recovery/2-atomicity-and-all-or-nothing"
sidebar_label: "원자성"
date: "2026-02-21"
---

## 🎯 트랜잭션이란 무엇인가?

데이터베이스를 공부하다 보면 가장 먼저 만나게 되는 핵심 개념 중 하나가 바로 **트랜잭션(Transaction)**입니다. 트랜잭션이라는 단어가 어렵게 느껴질 수 있지만, 사실 우리 일상생활에서도 매일 경험하고 있는 개념입니다.

### 트랜잭션의 정의

트랜잭션이란 **하나의 논리적 기능을 수행하기 위한 작업의 단위**입니다. 여기서 "작업의 단위"라는 말은, **더 이상 쪼개질 수 없는 가장 작은 단위**를 의미합니다. 마치 물질을 계속 쪼개다 보면 더 이상 쪼갤 수 없는 "원자(Atom)"에 도달하는 것처럼, 데이터베이스에서도 더 이상 나눌 수 없는 작업 묶음이 바로 트랜잭션인 것입니다.

> **트랜잭션 = 더 이상 쪼개질 수 없는, 하나로 묶인 데이터베이스 작업 단위**

예를 들어, 여러분이 은행에서 "A 계좌에서 B 계좌로 10만 원 이체"를 한다고 해봅시다. 이 작업은 내부적으로 다음과 같이 여러 단계로 이루어져 있습니다:

1. A 계좌의 잔액을 조회한다
2. A 계좌에서 10만 원을 차감한다
3. B 계좌에 10만 원을 추가한다
4. 이체 완료를 확인한다

이 네 단계는 **반드시 한꺼번에 모두 성공하거나, 한꺼번에 모두 취소**되어야 합니다. "A 계좌에서는 돈이 빠져나갔는데 B 계좌에는 입금이 안 됐어요"라는 상황이 벌어지면 큰 문제가 되겠죠? 이렇게 **부분적인 처리를 허용하지 않는 작업 묶음**이 바로 트랜잭션입니다.

### 트랜잭션과 응용 프로그램의 관계

하나의 트랜잭션은 **하나 이상의 데이터베이스 명령어**(삽입, 삭제, 갱신, 검색 등)로 구성됩니다. 예를 들어 "데이터를 삽입하고 검색하는 일"이 하나의 작업 단위라면, 그 삽입과 검색을 합친 것이 하나의 트랜잭션이 되는 것입니다. 그리고 **응용 프로그램(Application)은 여러 개의 트랜잭션들을 모아놓은 것**이라고 이해하면 됩니다.

:::info 트랜잭션은 물리적 단위가 아닌 논리적 단위입니다
트랜잭션은 하드디스크에 몇 바이트를 쓰느냐 같은 물리적 개념이 아닙니다. "은행 이체"처럼 **비즈니스 로직 관점에서 하나로 묶여야 하는 작업**을 뜻하는 논리적 개념입니다. 같은 물리적 작업이라도 비즈니스 요구사항에 따라 트랜잭션의 범위가 달라질 수 있습니다.
:::

### 병행제어와 회복에서의 트랜잭션

트랜잭션이라는 개념이 특히 중요한 이유는 **병행제어(Concurrency Control)**와 **회복(Recovery)** 때문입니다.

**병행제어**란 여러 사용자가 동시에 하나의 데이터베이스를 사용할 때 충돌이 발생하지 않도록 관리하는 것입니다. 마치 하나의 강의실을 여러 교수님이 사용하려 할 때 시간표를 짜서 충돌을 방지하는 것과 같습니다. 수백 명, 수만 명이 동시에 데이터베이스 서버에 접속해도 문제없이 운영되어야 하니까요. 이때 권한을 주고 뺏는 **기본 단위가 트랜잭션**입니다.

**회복**이란 데이터베이스에 문제가 생겨서 데이터가 깨지거나 고장 난 상황에서 **원래 정상적인 상태로 복구**하는 것입니다. 이때도 복구의 **기본 단위가 트랜잭션**입니다.

---

## 🧬 ACID: 트랜잭션의 4가지 핵심 성질

트랜잭션에는 반드시 지켜져야 하는 4가지 중요한 성질이 있습니다. 이 4가지의 영문 앞 글자를 따서 **ACID**라고 부릅니다.

| 약자 | 성질 | 영문 | 핵심 의미 | 책임 컴포넌트 |
|:---:|:---:|:---:|:---|:---|
| **A** | 원자성 | Atomicity | 전부 완료하거나 전부 취소 | 트랜잭션 관리 컴포넌트 |
| **C** | 일관성 | Consistency | 동일 조건 → 동일 결과 | 응용 프로그램(알고리즘) |
| **I** | 격리성 | Isolation | 중간 결과에 다른 트랜잭션 접근 불가 | 동시성 제어 컴포넌트 |
| **D** | 영속성 | Durability | 성공 결과는 영구 저장 | 회복 관리 컴포넌트 |

이 중에서 이번 문서의 주인공은 바로 **A — 원자성(Atomicity)**입니다. 하지만 나머지 세 가지도 간략히 이해하고 넘어가겠습니다.

### 일관성(Consistency)

일관성이란 **동일한 조건으로 질의(Query)했을 때 항상 동일한 결과**가 나와야 한다는 성질입니다. 예를 들어, 상품 A의 가격이 100원인데 아무도 가격을 변경하지 않았는데 한 번 조회하면 100원, 다시 조회하면 200원이 나온다면? 이건 일관성이 깨진 것입니다.

> 실행 중에는 일관성이 무시될 수 있지만, **최종 결과의 일관성**이 반드시 보장되어야 합니다.

마치 `1+2+3`을 계산할 때, `(1+2)+3`으로 하든 `(2+3)+1`로 하든 중간 결과는 다를 수 있지만 **최종 결과는 반드시 6**이어야 하는 것과 같습니다. 이 일관성은 **프로그램을 올바르게 작성해야** 보장됩니다.

### 격리성(Isolation)

격리성이란 **실행 중인 트랜잭션의 중간 결과에 다른 트랜잭션이 접근할 수 없도록** 차단하는 성질입니다. 위의 `1+2+3` 예시에서 중간 결과가 3일 수도, 5일 수도 있는데, 다른 사용자가 이 중간 결과를 읽어가면 서로 다른 값을 갖게 되어 문제가 발생합니다.

예를 들어, 관리자가 상품 가격을 변경하고 있는 도중에 고객이 접근해서 주문을 넣으면 안 되겠죠? 가격 변경이 **완전히 완료(Commit)된 후에야** 다른 사용자가 접근할 수 있어야 합니다. 이것을 통해 **연쇄적 중단(Cascading Abort)**을 방지할 수 있습니다.

### 영속성(Durability)

영속성이란 트랜잭션이 **성공적으로 완료되면 그 결과가 하드디스크에 영구적으로 저장**되어야 한다는 성질입니다. 만약 결과가 메모리(RAM)에만 저장되어 있다면, 컴퓨터를 껐다 켜면 데이터가 사라져 버립니다. 메모리는 **휘발성(전원이 꺼지면 데이터가 사라지는 특성)**이니까요. 성공한 트랜잭션의 결과는 반드시 비휘발성 저장장치인 하드디스크에 기록되어야 합니다.

---

## ⚛️ 원자성(Atomicity) — All or Nothing 원칙

이제 본격적으로 이번 문서의 핵심 주제인 **원자성(Atomicity)**에 대해 깊이 알아보겠습니다.

### 원자성이란?

"원자(Atom)"라는 단어는 그리스어로 "더 이상 쪼갤 수 없는 것"을 의미합니다. 트랜잭션의 원자성도 같은 맥락입니다. 하나의 트랜잭션은 **더 이상 쪼갤 수 없는 하나의 단위**이며, 따라서:

- ✅ **한꺼번에 모두 완료**되거나 (All)
- ✅ **한꺼번에 모두 취소**되어야 합니다 (Nothing)

> **원자성 = All or Nothing**
> 부분적인 처리는 절대 허용되지 않습니다!

마치 피자를 주문했을 때, 피자 한 판이 통째로 배달되거나 아예 배달이 안 되거나 둘 중 하나여야지, 피자의 반쪽만 배달되는 일은 있어서는 안 되는 것과 같습니다.

### 은행 이체 예시로 이해하기

원자성이 왜 중요한지 은행 이체 예시로 자세히 살펴보겠습니다.

**정상적인 시나리오:**
1. A 계좌 잔액 조회 → 100만 원 확인
2. A 계좌에서 10만 원 차감 → A 잔액: 90만 원
3. B 계좌에 10만 원 추가 → B 잔액: 60만 원
4. 상대방 서버에서 "정상 수신" 메시지 수신
5. **모든 과정이 성공** → Commit(저장) → 트랜잭션 완료!

**문제가 발생하는 시나리오:**
1. A 계좌 잔액 조회 → 100만 원 확인
2. A 계좌에서 10만 원 차감 → A 잔액: 90만 원
3. ❗ 상대방 은행 서버에 문제 발생! → B 계좌에 입금 실패!

이 상황에서 만약 원자성이 지켜지지 않는다면 어떻게 될까요? A 계좌에서는 10만 원이 빠져나갔는데, B 계좌에는 입금이 안 된 겁니다. **10만 원이 공중에서 사라져 버린 셈**이죠! 이런 일이 발생하면 금융 시스템 전체의 신뢰가 무너집니다.

원자성이 지켜진다면, 3번 단계에서 에러가 발생한 순간 **2번에서 차감했던 10만 원도 원래대로 복구**됩니다. A 계좌는 다시 100만 원으로 돌아가고, 마치 이체를 시도한 적이 없는 것처럼 깨끗하게 원상복구됩니다.

:::warning 원자성이 깨지면 일어나는 일
- 내 통장에서 돈이 빠져나갔는데 상대방 통장에는 입금이 안 됨
- 온라인 쇼핑몰에서 결제는 됐는데 주문은 안 들어감
- 재고에서 차감은 됐는데 출하 기록은 안 남음

이런 상황이 바로 원자성이 깨졌을 때 발생하는 **데이터 불일치** 문제입니다.
:::

### 원자성은 ACID 중 가장 중요합니다

트랜잭션의 4가지 성질 중에서 **원자성이 가장 핵심적인 성질**입니다. 원자성이 지켜져야만 데이터의 **정확성(Accuracy)**과 **무결성(Integrity, 데이터가 정확하고 완전한 상태를 유지하는 것)**이 완벽하게 보장될 수 있기 때문입니다. 원자성을 담당하는 것은 DBMS(데이터베이스 관리 시스템)의 **트랜잭션 관리 컴포넌트**입니다.

---

## 🔑 Commit과 Rollback — 원자성을 지키는 두 가지 명령어

원자성의 "All or Nothing" 원칙을 실현하기 위해 데이터베이스에는 두 가지 핵심 명령어가 있습니다. 바로 **Commit**과 **Rollback**입니다.

### ✅ Commit — "저장 버튼을 누르다"

**Commit**은 트랜잭션이 **성공적으로 완료**되었을 때 사용하는 명령어입니다. Commit을 만나면 그동안 수행한 모든 작업이 **하드디스크에 영구적으로 저장**됩니다.

여러분이 한글(HWP)이나 워드(Word)로 문서 작업을 하는 상황을 떠올려 보세요. 열심히 문서를 작성하고, 마지막에 **"저장" 버튼을 누르는 것**이 바로 Commit입니다. 저장 버튼을 눌러야 작업한 내용이 하드디스크에 기록되고, 컴퓨터를 껐다 켜도 내용이 보존됩니다.

```sql
-- ✅ 올바른 예시: 모든 작업이 성공한 후 Commit
BEGIN TRANSACTION;  -- 트랜잭션 시작

-- A 계좌에서 10만 원 차감
UPDATE 계좌 SET 잔액 = 잔액 - 100000 WHERE 계좌번호 = 'A';

-- B 계좌에 10만 원 추가
UPDATE 계좌 SET 잔액 = 잔액 + 100000 WHERE 계좌번호 = 'B';

COMMIT;  -- 모든 작업이 성공했으므로 저장! (All)
```

위 코드를 한 줄씩 살펴보겠습니다:

1. **`BEGIN TRANSACTION;`** — 트랜잭션이 시작됩니다. "지금부터 하나의 작업 묶음이 시작된다"고 선언하는 것입니다.
2. **`UPDATE 계좌 SET 잔액 = 잔액 - 100000 WHERE 계좌번호 = 'A';`** — A 계좌의 잔액에서 10만 원을 차감합니다.
3. **`UPDATE 계좌 SET 잔액 = 잔액 + 100000 WHERE 계좌번호 = 'B';`** — B 계좌의 잔액에 10만 원을 추가합니다.
4. **`COMMIT;`** — 위의 모든 작업이 성공적으로 완료되었으므로, 변경 사항을 하드디스크에 **영구적으로 저장**합니다. 이 순간 트랜잭션은 완료됩니다.

Commit 명령을 만나면 하나의 트랜잭션이 끝나고, 이후에 새로운 트랜잭션을 다시 시작할 수 있습니다.

:::tip Commit의 핵심 포인트
- Commit은 **성공적으로 완료되었을 때만** 수행할 수 있습니다
- Commit을 만나야만 데이터가 하드디스크에 저장됩니다
- Commit 이전에는 데이터가 메모리에만 존재할 수 있습니다
- Commit = 한글 문서의 "저장 버튼"이라고 기억하세요!
:::

### ❌ Rollback — "Ctrl+Z를 끝까지 누르다"

**Rollback**은 트랜잭션 실행 중에 **에러가 발생**했을 때, 그동안 수행한 **모든 작업을 취소(Undo)**시키는 명령어입니다. 트랜잭션을 강제로 종료하고, 데이터베이스를 **작업하기 이전의 상태로 되돌리는 것**입니다.

마치 문서 작업 중에 실수가 생겨서 `Ctrl+Z`를 끝까지 눌러 처음 상태로 돌아가는 것과 같습니다. 다만 일반적인 `Ctrl+Z`는 한 단계씩 되돌리지만, Rollback은 **트랜잭션 시작 시점까지 모든 것을 한 번에 되돌립니다**.

```sql
-- ❌ 잘못된 상황: 중간에 에러가 발생하면 Commit 불가
BEGIN TRANSACTION;  -- 트랜잭션 시작

-- A 계좌에서 10만 원 차감 (성공)
UPDATE 계좌 SET 잔액 = 잔액 - 100000 WHERE 계좌번호 = 'A';

-- B 계좌에 10만 원 추가 (실패! 상대방 서버 장애!)
UPDATE 계좌 SET 잔액 = 잔액 + 100000 WHERE 계좌번호 = 'B';
-- ⚠️ 여기서 에러 발생!

ROLLBACK;  -- 에러 발생! A 계좌 차감도 취소! (Nothing)
-- A 계좌의 잔액이 원래대로 복구됩니다
```

위 코드를 한 줄씩 살펴보겠습니다:

1. **`BEGIN TRANSACTION;`** — 트랜잭션이 시작됩니다.
2. **`UPDATE ... WHERE 계좌번호 = 'A';`** — A 계좌에서 10만 원이 차감됩니다. 이 단계는 성공했습니다.
3. **`UPDATE ... WHERE 계좌번호 = 'B';`** — B 계좌에 10만 원을 추가하려 했으나 **상대방 서버 장애로 실패**했습니다!
4. **`ROLLBACK;`** — 에러가 발생했으므로 Commit을 할 수 없습니다. Rollback을 통해 **A 계좌 차감 작업까지 모두 취소**합니다. 데이터베이스는 트랜잭션 시작 전의 상태로 돌아갑니다.

> **핵심:** 중간에 에러가 발생하면 Commit은 절대 수행할 수 없습니다. 오직 **Rollback만 수행**할 수 있습니다.

:::danger Commit 없이 에러가 발생하면
열심히 한글 문서 작업을 하고 저장(Commit)을 안 한 채 컴퓨터가 꺼져 버리면? 작업했던 것이 **전부 없어져 버립니다**. 이것이 바로 Nothing — Rollback의 개념입니다. 부분적으로 저장되는 것이 아니라, 전부 사라지는 것입니다.
:::

### Commit vs Rollback 비교 정리

| 구분 | Commit | Rollback |
|:---:|:---|:---|
| **의미** | 트랜잭션 성공적 완료 | 트랜잭션 강제 종료 및 취소 |
| **수행 조건** | 모든 작업이 성공했을 때만 | 에러가 발생했을 때 |
| **결과** | 하드디스크에 영구 저장 (All) | 모든 변경 사항 취소 (Nothing) |
| **비유** | 한글 문서의 "저장 버튼" | `Ctrl+Z`를 끝까지 누르기 |
| **Undo 연산** | 불필요 | 수행 (했던 작업을 되돌림) |

---

## 🔄 트랜잭션의 상태 흐름도

트랜잭션은 시작부터 끝까지 여러 상태를 거칩니다. 이 흐름을 이해하면 Commit과 Rollback이 어느 시점에서 사용되는지 명확히 알 수 있습니다.

### 5가지 상태

**1. 활동(Active) 상태**
트랜잭션이 시작되어 **작업이 진행되고 있는 중**인 상태입니다. 한글 문서에서 열심히 타이핑을 치고 있는 중이라고 생각하면 됩니다. 화면에 글씨가 쫙 써지고 있는 바로 그 상태입니다.

**2. 부분 완료(Partially Committed) 상태**
작업은 다 끝났지만 **아직 Commit 명령을 만나지 않은 상태**입니다. 한글 문서에서 타이핑은 다 쳤는데 **저장 버튼만 남은 상태**라고 생각하면 됩니다. 마지막 명령문을 실행한 직후, 더 이상 할 작업은 없고 저장만 남은 단계입니다.

**3. 완료(Committed) 상태**
부분 완료 상태에서 **Commit 명령을 만나서 하드디스크에 영구 저장**된 상태입니다. 한글 문서에서 저장 버튼을 눌러서 파일이 하드디스크에 안전하게 기록된 상태입니다. 이제 영속성이 보장됩니다.

**4. 실패(Failed) 상태**
활동 중이거나 부분 완료 상태에서 **에러가 발생하여 더 이상 진행할 수 없는 상태**입니다. 문법 오류, 시스템 장애, 저장 공간 부족 등 다양한 이유로 실패할 수 있습니다. 중요한 것은, **부분 완료 상태에서도 실패로 갈 수 있다**는 점입니다. 작업은 다 끝났는데 저장 버튼을 눌렀더니 "디스크 공간 부족", "읽기 전용 파일", "파일 이름 중복" 같은 에러가 뜰 수 있으니까요.

**5. 철회(Aborted) 상태**
실패한 트랜잭션에 대해 **Rollback을 수행**하여 모든 작업을 취소하고, 데이터베이스를 트랜잭션 시작 전의 상태로 되돌린 상태입니다.

### 상태 전이 흐름

```
활동(Active) ──→ 부분 완료(Partially Committed) ──→ 완료(Committed)
    │                        │
    │                        │ (저장 실패 시)
    │                        ▼
    └──────────→ 실패(Failed) ──→ 철회(Aborted)
```

- **활동 → 부분 완료:** 모든 명령어 실행 완료 (저장만 남음)
- **부분 완료 → 완료:** Commit 명령 수행 성공
- **부분 완료 → 실패:** Commit 시도했으나 에러 발생 (디스크 오류 등)
- **활동 → 실패:** 실행 중 에러 발생 (문법 오류, 시스템 장애 등)
- **실패 → 철회:** Rollback 수행으로 모든 작업 취소

:::warning 부분 완료 ≠ 완료
부분 완료 상태는 "작업은 다 끝났지만 아직 저장은 안 된 상태"입니다. 이 상태에서도 에러가 발생하면 **실패 상태로 전이**될 수 있습니다. 그리고 주의할 점은, **실패 상태에서 부분 완료 상태로는 돌아갈 수 없다**는 것입니다. 한번 실패하면 철회(Rollback)만 가능합니다.
:::

---

## 💾 데이터 저장과 회복의 기본 원리

원자성을 이해했다면, 이제 실제로 데이터가 어떻게 저장되고 문제가 생겼을 때 어떻게 회복되는지 알아보겠습니다.

### 데이터 저장 장치의 종류

| 종류 | 특성 | 예시 | 데이터 보존 |
|:---:|:---|:---|:---:|
| **소멸성 저장 장치** | 전원이 꺼지면 데이터 소멸 | RAM(메모리) | ❌ |
| **비소멸성 저장 장치** | 전원이 꺼져도 데이터 유지 | HDD, SSD, USB | ✅ |
| **안정성 저장 장치** | 별도로 백업해 놓은 저장 장치 | 외장 하드, 클라우드, 백업 테이프 | ✅✅ |

### 데이터 처리 흐름: Input, Read, Write, Output

데이터베이스에서 데이터가 처리되는 흐름은 **하드디스크 → 메모리 → CPU** 순서입니다. 하드디스크는 속도가 느리고 CPU는 속도가 빠르기 때문에, 중간에 **메모리가 버퍼(완충재) 역할**을 합니다.

```
하드디스크  ←──output──  메모리  ←──write──  CPU
하드디스크  ──input──→  메모리  ──read──→   CPU
```

- **Input:** 하드디스크 → 메모리로 데이터를 읽어오는 것
- **Read:** 메모리 → CPU로 데이터를 읽어서 처리 준비하는 것
- **Write:** CPU → 메모리로 처리 결과를 기록하는 것
- **Output:** 메모리 → 하드디스크로 최종 저장하는 것

### 회복(Recovery)의 기본 원리

회복이란 **장애로 인해 손상된 데이터베이스를 정상적인 상태로 복구**시키는 것입니다. 마치 아플 때 병원에서 치료받고 건강한 상태로 돌아가는 것과 같습니다.

회복의 기본 방법은 두 가지 도구를 사용합니다:

1. **덤프(Dump, 백업):** 마지막으로 정상 상태였던 데이터베이스 전체를 **별도의 안전한 저장장치에 복사**해 놓는 것입니다. 여러분이 집 컴퓨터의 중요한 파일들을 USB나 클라우드에 복사해 놓는 것과 같습니다.

2. **로그(Log) 파일:** 덤프 이후에 발생한 **모든 변경 사항을 하나하나 기록**해 놓는 파일입니다. "T1 트랜잭션이 X값을 100에서 200으로 변경했다" 같은 정보가 자동으로 기록됩니다.

> **장애 발생 시:** 마지막 덤프(백업) 파일을 불러온 후, 로그 파일을 참조하여 변경 사항을 다시 반영(Redo)하거나 취소(Undo)하여 복구합니다.

### Redo와 Undo 연산

회복 작업에서 가장 핵심이 되는 두 가지 연산입니다:

| 연산 | 의미 | 수행 조건 | 방향 | 별칭 |
|:---:|:---|:---|:---:|:---|
| **Redo** | 성공한 작업을 다시 수행 | Commit이 있는 트랜잭션 | 순방향(→) | Forward Recovery |
| **Undo** | 실패한 작업을 취소 | Commit이 없는 트랜잭션 | 역방향(←) | Backward Recovery |

- **Redo(다시 실행):** 로그 파일을 보니 Commit이 있는 트랜잭션이 있다면, 백업 파일에 해당 변경 사항을 **다시 반영**합니다. **순방향(앞으로)**으로 수행합니다.
- **Undo(실행 취소):** 로그 파일을 보니 Commit이 없는 트랜잭션이 있다면, 이미 반영되어 버린 변경 사항을 **원래대로 되돌립니다**. **역방향(뒤로)**으로 수행합니다.

:::note 왜 Undo는 역방향이고 Redo는 순방향일까요?
Undo는 "되돌리기"이므로 **마지막에 한 작업부터 거꾸로** 취소해 나갑니다. 마치 블록을 쌓았다가 무너뜨릴 때 맨 위부터 치우는 것과 같습니다. Redo는 "다시 하기"이므로 **처음부터 순서대로** 다시 수행합니다. 만약 Undo와 Redo가 섞여 있다면, **Undo를 먼저 역방향으로 수행한 후** Redo를 순방향으로 수행합니다.
:::

---

## 📊 갱신 기법: 지연 갱신 vs 즉시 갱신

원자성을 지키면서 데이터를 갱신하는 방법에는 크게 두 가지가 있습니다. **지연 갱신(Deferred Update)**과 **즉시 갱신(Immediate Update)**입니다. 이 두 기법은 "Commit 전에 하드디스크에 저장하느냐 안 하느냐"에 따라 나뉩니다.

### 지연 갱신 기법 (Deferred Update) — No-Steal 방식

지연 갱신은 **Commit 명령을 만나기 전까지 모든 데이터 변경을 메모리에서만 처리**하고, 하드디스크에는 절대 저장하지 않는 방식입니다.

한글 문서 작업에서 "자동 저장 기능이 꺼져 있는 상태"라고 생각하면 됩니다. 저장 버튼을 누르기 전까지는 아무리 많은 작업을 해도 하드디스크에는 아무것도 기록되지 않습니다.

**지연 갱신의 핵심 특징:**
- Commit 전까지 하드디스크(Output) 연산이 **지연**됨
- 에러 발생 시 하드디스크에 반영된 것이 없으므로 **Undo가 필요 없음**
- Commit이 있는 트랜잭션만 **Redo 수행**
- Commit이 없는 트랜잭션은 **아무 작업도 하지 않음** (이미 메모리에만 있었으므로)
- 로그 파일에 **이후 값만** 기록 (이전 값이 필요 없음 — Undo를 안 하니까)

```sql
-- 지연 갱신 기법의 로그 파일 형식
-- 이전 값이 필요 없으므로 이후 값만 기록

-- ✅ 로그 예시 (이후 값만 기록)
[T1, start]
[T1, A, 900]       -- A값이 900으로 변경됨 (이전 값 기록 안 함)
[T1, B, 2100]      -- B값이 2100으로 변경됨
[T1, commit]        -- Commit 있음 → Redo 대상!
```

위 로그를 한 줄씩 살펴보겠습니다:

1. **`[T1, start]`** — 트랜잭션 T1이 시작되었습니다.
2. **`[T1, A, 900]`** — T1이 A값을 900으로 변경했습니다. 지연 갱신이므로 이전 값(1000)은 기록하지 않습니다. Undo를 할 필요가 없으니까요.
3. **`[T1, B, 2100]`** — T1이 B값을 2100으로 변경했습니다.
4. **`[T1, commit]`** — T1이 성공적으로 완료되었습니다. Redo 대상입니다.

### 지연 갱신 — 실전 예제

초기값: A=1000, B=2000, C=3000

**예제 1: Commit이 없는 경우**

```
[T1, start]
[T1, A, 900]      -- A를 900으로 변경
[T1, B, 2100]     -- B를 2100으로 변경
-- ⚠️ 여기서 에러 발생! Commit 없음!
```

Commit이 없으므로 하드디스크에 반영된 것이 아무것도 없습니다. **아무 작업도 수행하지 않습니다.** 최종 결과: A=1000, B=2000, C=3000 (원래 값 그대로)

**예제 2: T1만 Commit, T2는 Commit 없음**

```
[T1, start]
[T1, A, 900]      -- A를 900으로 변경
[T1, B, 2100]     -- B를 2100으로 변경
[T1, commit]       -- ✅ T1 Commit 있음!
[T2, start]
[T2, C, 2800]     -- C를 2800으로 변경
-- ⚠️ 여기서 에러 발생! T2는 Commit 없음!
```

- T1: Commit 있음 → **Redo 수행** (A=900, B=2100으로 다시 반영)
- T2: Commit 없음 → **아무 작업 안 함** (C는 원래 값 3000 유지)
- 최종 결과: **A=900, B=2100, C=3000**

**예제 3: T1, T2 모두 Commit 있음**

```
[T1, start]
[T1, A, 900]
[T1, B, 2100]
[T1, commit]       -- ✅ T1 Commit
[T2, start]
[T2, C, 2800]
[T2, commit]       -- ✅ T2 Commit
-- ⚠️ 이후에 에러 발생!
```

- T1: Commit 있음 → **Redo 수행**
- T2: Commit 있음 → **Redo 수행**
- 최종 결과: **A=900, B=2100, C=2800**

:::tip 지연 갱신 기법 요약 공식
- Commit 있음 → **Redo** (다시 반영)
- Commit 없음 → **아무것도 안 함** (Undo 불필요)
:::

**지연 갱신의 단점:**
- Commit 전까지 모든 데이터가 메모리에 머물러 있으므로 **메모리 공간이 매우 커야** 합니다
- 바로바로 하드디스크에 저장되지 않으므로 **다른 사용자가 변경된 데이터를 즉시 읽을 수 없어** 동시성(여러 사용자가 동시에 사용하는 능력)이 떨어집니다

### 즉시 갱신 기법 (Immediate Update) — Steal 방식

즉시 갱신은 **Commit 여부와 관계없이 변경된 데이터를 바로바로 하드디스크에 저장**하는 방식입니다. 한글 문서에서 "자동 저장 기능이 켜져 있는 상태"라고 생각하면 됩니다. 타이핑할 때마다 실시간으로 저장이 됩니다.

**즉시 갱신의 핵심 특징:**
- Commit 여부에 관계없이 **즉시 하드디스크에 반영**(Output)
- Commit이 없는 트랜잭션의 데이터도 이미 하드디스크에 저장되어 있으므로 → **Undo 필요**
- Commit이 있는 트랜잭션은 **Redo** 수행
- 로그 파일에 **이전 값과 이후 값 모두** 기록 (Undo를 위해 이전 값이 필요하므로)
- 회복 시 **Undo를 먼저 역방향으로 수행한 후**, Redo를 순방향으로 수행

```sql
-- 즉시 갱신 기법의 로그 파일 형식
-- Undo를 위해 이전 값도 함께 기록

-- ✅ 로그 예시 (이전 값 + 이후 값 모두 기록)
[T1, start]
[T1, A, 1000, 900]    -- A값이 1000에서 900으로 변경됨
[T1, B, 2000, 2100]   -- B값이 2000에서 2100으로 변경됨
[T1, commit]           -- Commit 있음 → Redo 대상!
```

위 로그를 한 줄씩 살펴보겠습니다:

1. **`[T1, start]`** — 트랜잭션 T1이 시작되었습니다.
2. **`[T1, A, 1000, 900]`** — T1이 A값을 **1000(이전 값)**에서 **900(이후 값)**으로 변경했습니다. 즉시 갱신이므로 Undo가 필요할 수 있어 이전 값도 기록합니다.
3. **`[T1, B, 2000, 2100]`** — T1이 B값을 **2000(이전 값)**에서 **2100(이후 값)**으로 변경했습니다.
4. **`[T1, commit]`** — T1이 성공적으로 완료되었습니다.

### 즉시 갱신 — 실전 예제

초기값: A=1000, B=2000, C=3000

**예제 1: Commit이 없는 경우**

```
[T1, start]
[T1, A, 1000, 900]     -- A를 1000→900으로 변경 (즉시 저장됨!)
[T1, B, 2000, 2100]    -- B를 2000→2100으로 변경 (즉시 저장됨!)
-- ⚠️ 여기서 에러 발생! Commit 없음!
```

Commit이 없지만 데이터가 이미 하드디스크에 저장되어 있습니다! **Undo를 수행**해야 합니다. 역방향으로 되돌립니다:
- B를 2100 → **2000**으로 되돌림
- A를 900 → **1000**으로 되돌림
- 최종 결과: **A=1000, B=2000, C=3000** (원래 값으로 복원)

**예제 2: T1만 Commit, T2는 Commit 없음**

```
[T1, start]
[T1, A, 1000, 900]
[T1, B, 2000, 2100]
[T1, commit]             -- ✅ T1 Commit 있음
[T2, start]
[T2, C, 3000, 2800]
-- ⚠️ 여기서 에러 발생! T2는 Commit 없음!
```

- T2: Commit 없음 → **Undo 수행** (C를 2800 → 3000으로 되돌림) — 역방향 먼저!
- T1: Commit 있음 → **Redo 수행** (A=900, B=2100으로 다시 반영) — 순방향 나중에!
- 최종 결과: **A=900, B=2100, C=3000**

**예제 3: T1, T2 모두 Commit 있음**

```
[T1, start]
[T1, A, 1000, 900]
[T1, B, 2000, 2100]
[T1, commit]             -- ✅ T1 Commit
[T2, start]
[T2, C, 3000, 2800]
[T2, commit]             -- ✅ T2 Commit
-- ⚠️ 이후에 에러 발생!
```

- 둘 다 Commit 있음 → **모두 Redo 수행**
- 최종 결과: **A=900, B=2100, C=2800**

:::tip 즉시 갱신 기법 요약 공식
- Commit 있음 → **Redo** (다시 반영)
- Commit 없음 → **Undo** (이전 값으로 되돌림)
- **Undo를 먼저(역방향)** 수행한 후 **Redo(순방향)** 수행
:::

### 지연 갱신 vs 즉시 갱신 비교

| 구분 | 지연 갱신 | 즉시 갱신 |
|:---:|:---|:---|
| **하드디스크 저장 시점** | Commit 후에만 저장 | Commit 여부와 무관하게 즉시 저장 |
| **방식 이름** | No-Steal 방식 | Steal 방식 |
| **Commit 없을 때** | 아무 작업 안 함 | **Undo** 수행 |
| **Commit 있을 때** | **Redo** 수행 | **Redo** 수행 |
| **로그 파일 내용** | 이후 값만 기록 | 이전 값 + 이후 값 모두 기록 |
| **메모리 부담** | 큼 (Commit 전까지 메모리에 보관) | 작음 (바로 저장) |
| **동시성** | 낮음 | 높음 |
| **회복 복잡도** | 단순 (Redo만) | 복잡 (Undo + Redo) |

---

## ⚠️ 장애의 유형과 주의사항

데이터베이스를 사용하다 보면 다양한 장애가 발생할 수 있습니다. 장애의 유형을 알아야 적절한 회복 전략을 세울 수 있습니다.

### 장애의 4가지 유형

**1. 행동 장애 (Transaction Failure - 논리적 오류)**
가장 가벼운 유형의 장애입니다. 데이터 항목을 찾지 못하거나, **무결성 규정을 위반**하는 경우에 발생합니다.

- 기본키에 NULL 값이 들어간 경우
- 점수 필드(0~100)에 150이 입력된 경우
- 학년 필드(1~6)에 7이 입력된 경우

**2. 트랜잭션 장애 (Transaction Failure - 시스템 리소스)**
시스템 자원을 과다 사용하거나 입력 데이터 자체가 불량일 때 발생합니다. CPU가 100%까지 올라가거나, 메모리가 가득 차서 시스템이 멈추는 경우가 이에 해당합니다. 중간에 데이터가 사라지거나 원치 않는 삭제가 발생하기도 합니다.

**3. 시스템 장애 (System Failure)**
전원이 꺼지거나, CPU/메모리/그래픽카드 등 **하드웨어가 고장** 나는 경우입니다. 운영체제를 다시 설치하거나 하드웨어를 교체하면 대체로 해결됩니다.

**4. 미디어 장애 (Media Failure) — 가장 치명적!**
**하드디스크 자체가 물리적으로 손상**된 경우입니다. 데이터베이스 관점에서 가장 위험하고 복구 비용이 가장 많이 드는 장애입니다. 데이터가 직접적으로 손실되기 때문에, 평소에 **철저한 백업(Dump) 관리**가 필수입니다.

:::danger 미디어 장애는 예방이 최선입니다
하드디스크가 물리적으로 손상되면 복구에 막대한 비용이 들고, 경우에 따라 데이터를 영영 잃을 수도 있습니다. 정기적인 백업(Dump)과 로그 파일 관리는 선택이 아닌 **필수**입니다. 백업은 USB, 외장 하드, 클라우드 등 **별도의 안전한 저장장치**에 보관하세요.
:::

### 로그(Log) 파일의 구조

로그 파일은 트랜잭션이 실패할 경우를 대비하여, **데이터베이스 복구용으로 자동 생성**되는 기록입니다. 로그 파일의 각 레코드는 다음과 같은 정보를 담고 있습니다:

| 항목 | 설명 | 예시 |
|:---:|:---|:---|
| 트랜잭션 이름 | 어떤 트랜잭션이 수행했는지 | T1 |
| 데이터 아이템 이름 | 어떤 데이터를 변경했는지 | X |
| 변경 전 값 | 변경 이전의 값 (Undo용) | 100 |
| 변경 후 값 | 변경 이후의 값 (Redo용) | 200 |

```
-- 로그 레코드 유형 예시
[T1, start]              -- T1 트랜잭션 시작
[T1, X, 100, 200]        -- T1이 X값을 100에서 200으로 변경
[T1, read, X]            -- T1이 X값을 읽음 (보통 생략 가능)
[T1, commit]             -- T1 트랜잭션 성공적 완료
[T2, start]              -- T2 트랜잭션 시작
[T2, Y, 300, 400]        -- T2가 Y값을 300에서 400으로 변경
-- (commit 없이 끝남)    -- T2는 실패 → Rollback 대상
```

:::note 로그 파일의 크기
100만 개의 데이터를 변경하면 **로그가 100만 줄** 생깁니다. 레코드 하나하나에 대해 로그가 만들어지기 때문에, 로그 파일은 **엄청나게 큰 규모**가 될 수 있습니다. 이것이 로그 관리가 중요한 이유입니다.
:::

---

## 📌 핵심 정리

- **트랜잭션**은 더 이상 쪼갤 수 없는 데이터베이스 작업의 논리적 단위이다
- **ACID**는 트랜잭션의 4가지 핵심 성질로, 원자성(A), 일관성(C), 격리성(I), 영속성(D)으로 구성된다
- **원자성(Atomicity)**은 ACID 중 가장 중요한 성질로, "All or Nothing" 원칙을 의미한다
- **Commit**은 트랜잭션이 성공적으로 완료되었을 때 결과를 하드디스크에 영구 저장하는 명령이다
- **Rollback**은 에러 발생 시 그동안의 모든 작업을 취소하고 이전 상태로 되돌리는 명령이다
- 에러가 발생하면 Commit은 수행할 수 없고, **Rollback만 수행** 가능하다
- 트랜잭션의 5가지 상태: 활동 → 부분 완료 → 완료(성공 시) 또는 실패 → 철회(실패 시)
- **Redo**는 Commit이 있는 트랜잭션을 다시 반영하는 순방향 회복 연산이다
- **Undo**는 Commit이 없는 트랜잭션을 취소하는 역방향 회복 연산이다
- **지연 갱신**: Commit 전까지 하드디스크 저장을 지연하며, Undo가 필요 없고 Redo만 수행한다
- **즉시 갱신**: Commit 여부와 무관하게 즉시 저장하며, Undo와 Redo를 모두 수행한다 (Undo 먼저)
- **로그 파일**은 트랜잭션의 변경 이력을 기록하며, 장애 시 Redo/Undo 회복의 근거가 된다
- **덤프(백업)**와 로그 파일을 함께 활용하여 데이터베이스를 복구한다

작성일: 2026-02-21