---
title: "트랜잭션의 개념과 정의"
description: "트랜잭션의 개념과 정의에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/transaction-overview-and-recovery/1-transaction-concept"
sidebar_label: "트랜잭션 개념"
date: "2026-02-21"
---

## 🎯 트랜잭션이란 무엇인가?

데이터베이스를 공부하다 보면 **트랜잭션(Transaction)**이라는 단어를 정말 자주 만나게 됩니다. 이 개념은 데이터베이스의 안전성과 정확성을 지키는 핵심 중의 핵심이기 때문에, 확실하게 이해하고 넘어가야 합니다.

트랜잭션의 정의를 한 문장으로 표현하면 이렇습니다:

> **트랜잭션이란, 하나의 논리적 기능을 수행하기 위한 작업의 단위**입니다. 이 단위는 **더 이상 쪼갤 수 없는 최소 단위**이며, 한꺼번에 모두 완료되거나 한꺼번에 모두 취소되어야 합니다.

### 🧩 "작업의 단위"가 무슨 뜻인가요?

비유를 들어보겠습니다. 여러분이 편의점에서 도시락을 사는 상황을 생각해 보세요.

1. 도시락을 고른다
2. 계산대에서 돈을 낸다
3. 영수증을 받는다

이 세 가지 행동이 모여서 "도시락 구매"라는 하나의 작업이 됩니다. 만약 돈을 냈는데 영수증을 안 주거나, 도시락을 안 주면 어떨까요? 그건 **정상적인 구매가 아닙니다.** 도시락 구매는 세 단계가 모두 완료되어야 "구매 성공"이고, 중간에 하나라도 문제가 생기면 전부 취소(환불)해야 합니다.

데이터베이스의 트랜잭션도 정확히 이와 같습니다. 예를 들어 사용자가 데이터베이스에 **"데이터를 삽입하고, 검색하는 작업"**을 요청했다면, 삽입과 검색이 모두 합쳐져서 하나의 트랜잭션이 됩니다. 이 작업은 부분적으로만 처리되면 안 됩니다. 삽입은 됐는데 검색은 안 됐다? 그런 상황은 허용하지 않습니다.

### 📦 응용 프로그램과 트랜잭션의 관계

하나의 트랜잭션은 **하나 이상의 SQL 명령어**(삽입 INSERT, 삭제 DELETE, 갱신 UPDATE, 검색 SELECT)로 구성됩니다. 그리고 우리가 만드는 **응용 프로그램(Application)**은 이런 트랜잭션 여러 개를 모아놓은 것이라고 볼 수 있습니다.

```
응용 프로그램 = 트랜잭션1 + 트랜잭션2 + 트랜잭션3 + ...
트랜잭션1 = INSERT + SELECT (하나의 작업 단위)
트랜잭션2 = UPDATE + DELETE (하나의 작업 단위)
```

또한 트랜잭션은 **물리적 개념의 단위가 아니라 논리적 개념의 단위**입니다. 하드디스크에 물리적으로 저장되는 블록 같은 것이 아니라, "이 작업들은 하나로 묶여야 한다"는 논리적인 약속입니다.

:::info 트랜잭션이 사용되는 대표적인 장면
- **병행제어(Concurrency Control)**: 수백, 수만 명이 동시에 데이터베이스에 접속할 때 충돌 없이 운영하기 위해 권한을 주고 빼는 단위가 트랜잭션입니다. 마치 하나의 강의실을 여러 교수님이 시간표에 따라 나눠 쓰는 것처럼요.
- **회복(Recovery)**: 데이터베이스에 장애가 발생했을 때 정상 상태로 복구하는 기본 단위도 트랜잭션입니다.
:::

---

## 🔐 트랜잭션의 4가지 성질 (ACID)

트랜잭션에는 반드시 지켜져야 하는 4가지 핵심 성질이 있습니다. 이것을 앞글자를 따서 **ACID**라고 부릅니다. 데이터베이스의 정확성과 무결성(데이터에 오류가 없는 상태)을 보장하는 기둥이라고 생각하시면 됩니다.

| 약자 | 영문 | 한국어 | 핵심 키워드 | 책임 컴포넌트 |
|------|------|--------|-------------|---------------|
| **A** | Atomicity | 원자성 | All or Nothing | 트랜잭션 관리 컴포넌트 |
| **C** | Consistency | 일관성 | 동일 조건 → 동일 결과 | 응용 프로그램(알고리즘) |
| **I** | Isolation | 격리성 | 중간 결과 접근 차단 | 동시성 제어 컴포넌트 |
| **D** | Durability | 영속성 | 성공 결과 영구 보존 | 회복 관리 컴포넌트 |

### ⚛️ A - 원자성 (Atomicity)

**원자(Atom)**라는 단어는 "더 이상 쪼갤 수 없는 가장 작은 단위"를 의미합니다. 트랜잭션의 원자성도 같은 뜻입니다.

> **원자성이란, 트랜잭션에 포함된 모든 작업이 한꺼번에 모두 완료되거나(All), 한꺼번에 모두 취소되어야(Nothing) 한다는 성질입니다.** 부분적인 처리는 절대 허용하지 않습니다.

#### 🏦 은행 이체 예시로 이해하기

가장 대표적인 예시가 **은행 계좌 이체**입니다.

A가 B에게 50만 원을 이체한다고 합시다. 이 작업은 내부적으로 이렇게 진행됩니다:

1. A의 잔액을 조회한다 → 충분한 잔액이 있는지 확인
2. A의 계좌에서 50만 원을 차감한다
3. B의 계좌에 50만 원을 추가한다
4. 상대방 은행 서버에서 "정상 수신" 확인 메시지를 받는다

만약 2번까지는 성공했는데 3번에서 상대방 은행 서버에 문제가 생겨서 이체가 안 되면 어떻게 될까요? A의 통장에서 돈은 빠져나갔는데 B의 통장에는 들어가지 않은 것입니다. **돈이 공중에서 사라져 버린 셈**이죠!

이런 일이 일어나면 안 되기 때문에, 트랜잭션은 원자성을 통해 **1~4번 전체가 성공해야만 완료(Commit)**로 처리하고, **중간에 하나라도 실패하면 전부 취소(Rollback)**시킵니다. A의 계좌에서 빠져나간 50만 원도 원상복구됩니다.

:::warning 원자성이 가장 중요한 이유
ACID 4가지 성질 중에서 **원자성이 가장 중요합니다.** 원자성이 지켜져야 데이터의 정확성과 무결성이 완벽하게 보장될 수 있기 때문입니다. 원자성이 깨지면 데이터가 중간 상태에서 멈춰버려, 전체 시스템의 신뢰가 무너집니다.
:::

원자성은 **DBMS(데이터베이스 관리 시스템)의 트랜잭션 관리 컴포넌트**가 책임지고 관리합니다.

### 🔄 C - 일관성 (Consistency)

**일관성이란, 동일한 조건으로 동일한 데이터를 조회하면 항상 동일한 결과가 나와야 한다는 성질**입니다.

예를 들어볼까요? 어떤 쇼핑몰에서 상품 A의 가격이 100원입니다. 관리자가 가격을 변경한 적이 없는데, 첫 번째 조회에서는 100원이라고 나오고 두 번째 조회에서는 갑자기 200원이라고 나온다면? 이것은 일관성이 깨진 것입니다.

물론 관리자가 가격을 100원에서 200원으로 변경했다면 당연히 결과가 바뀌어야 합니다. 하지만 **아무도 데이터를 변경하지 않았는데 결과가 달라지면**, 그 데이터베이스는 신뢰할 수 없게 됩니다.

#### 🧮 실행 중 일관성은 무시해도 괜찮다?

여기서 중요한 포인트가 있습니다. **실행 중간의 일관성은 무시될 수 있지만, 최종 결과의 일관성은 반드시 보장**되어야 합니다.

1 + 2 + 3 의 결과는 항상 6이어야 합니다. 그런데 시스템 내부에서는:

- 방법 1: (1 + 2) + 3 = 3 + 3 = **6** → 중간 결과: 3
- 방법 2: (2 + 3) + 1 = 5 + 1 = **6** → 중간 결과: 5

중간 결과는 3이 될 수도 있고 5가 될 수도 있습니다. 하지만 **최종 결과는 어떤 순서로 계산하든 반드시 6**이어야 합니다. 트랜잭션에서 말하는 일관성은 바로 이 **최종 결과에 대한 일관성**을 의미합니다.

:::tip 일관성을 지키려면?
일관성은 **프로그래머가 프로그램을 올바르게 작성해야** 보장됩니다. Java, C, Python 등으로 알고리즘을 짤 때 로직에 오류가 없어야 실행 결과의 일관성이 보장됩니다. 즉, 일관성의 책임은 응용 프로그램 코드에 있습니다.
:::

### 🔒 I - 격리성 (Isolation)

**격리성이란, 실행 중인 트랜잭션의 중간 결과에 다른 트랜잭션이 접근할 수 없도록 차단하는 성질**입니다.

위에서 1 + 2 + 3 을 계산할 때 중간 결과가 3이 될 수도 있고 5가 될 수도 있다고 했습니다. 만약 트랜잭션이 아직 완료되지 않은 상태에서 다른 사용자가 이 중간 결과를 읽어간다면 어떻게 될까요?

- 사용자 A: "중간 결과가 3이야!"
- 사용자 B: "아닌데? 중간 결과가 5인데?"

두 사용자가 같은 데이터를 조회했는데 서로 다른 값을 읽어온 것입니다. 이것은 시스템의 신뢰성을 심각하게 훼손합니다.

실생활 비유로 설명하면 이렇습니다. **쇼핑몰 관리자가 지금 상품 가격을 변경하고 있는 중**이라고 합시다. 100원짜리 상품을 200원으로 올리는 작업을 하고 있어요. 이 작업이 아직 완료(Commit)되지 않은 상태에서 고객이 접근해서 주문을 넣으면 안 되겠죠? 가격이 100원인지 200원인지 확정되지 않은 상태니까요. **관리자가 변경을 완료하고 "저장" 버튼을 누른 후에야** 고객이 접근할 수 있어야 합니다.

> 격리성은 **Cascading Abort(연쇄 취소)**를 방지하기 위해 필요합니다. 만약 중간 결과를 다른 트랜잭션이 읽어갔는데, 원래 트랜잭션이 실패하여 Rollback 해야 한다면, 읽어간 트랜잭션도 함께 취소해야 하는 연쇄적인 문제가 발생합니다. 하지만 이미 읽어간 쪽에서 취소가 불가능한 상황이 생길 수 있어 매우 위험합니다.

격리성은 **동시성 제어 컴포넌트(Concurrency Control Component)**가 책임지고 관리합니다. 여러 사용자가 동시에 데이터베이스를 사용하려 할 때 중간 결과에 접근하지 못하도록 막아주는 역할을 합니다.

### 💾 D - 영속성 (Durability)

**영속성이란, 트랜잭션이 성공적으로 완료(Commit)되면 그 결과가 영구적으로 보존되어야 한다는 성질**입니다.

트랜잭션이 성공하면 그 결과는 **하드디스크에 저장**됩니다. 하드디스크는 컴퓨터 전원을 꺼도 데이터가 남아있는 **비소멸성 저장장치**이기 때문입니다. 반면 메모리(RAM)는 전원이 꺼지면 데이터가 사라지는 **휘발성(소멸성) 저장장치**입니다.

비유하자면, 여러분이 아래아한글에서 열심히 문서 작업을 하고 **저장 버튼을 눌렀다면**, 컴퓨터를 껐다 켜도 문서가 남아있죠? 그것이 영속성입니다. 하지만 저장 버튼을 누르지 않고 컴퓨터를 꺼버리면? 작업한 내용이 모두 사라집니다. 이것이 영속성이 보장되지 않은 상태입니다.

영속성은 **회복 관리 컴포넌트(Recovery Management Component)**가 책임지고 관리합니다.

---

## ✅ Commit과 Rollback - 트랜잭션의 두 가지 결말

트랜잭션의 원자성(All or Nothing)을 실현하기 위해 두 가지 핵심 명령어가 존재합니다. 바로 **Commit**과 **Rollback**입니다.

### 🟢 Commit (커밋) - 성공적 완료

**Commit은 트랜잭션이 성공적으로 종료되었음을 알리고, 작업 결과를 하드디스크에 영구 저장하는 명령**입니다.

아래아한글에서 열심히 문서를 작성한 후 **"저장" 버튼을 누르는 것**이 바로 Commit입니다. 저장 버튼을 눌러야 내가 했던 작업이 완료되고, 하드디스크에 기록되어 영속성을 갖게 됩니다.

은행 이체 예시로 돌아가면, A의 계좌에서 돈이 빠져나가고 → B의 계좌에 돈이 들어가고 → 상대방 은행에서 "정상 수신" 확인 메시지를 받으면 → 비로소 **Commit** 명령이 실행되어 이체가 확정됩니다.

```sql
-- ✅ 올바른 예시: 모든 작업이 성공한 후 Commit
BEGIN TRANSACTION;  -- 트랜잭션 시작

INSERT INTO 주문 (고객ID, 상품명, 수량) VALUES (101, '노트북', 1);  -- 주문 데이터 삽입
UPDATE 재고 SET 수량 = 수량 - 1 WHERE 상품명 = '노트북';              -- 재고 차감
UPDATE 고객 SET 포인트 = 포인트 + 100 WHERE 고객ID = 101;            -- 포인트 적립

COMMIT;  -- 모든 작업이 성공했으므로 하드디스크에 영구 저장
```

위 코드를 한 줄씩 설명하겠습니다:

1. `BEGIN TRANSACTION;` → 트랜잭션의 시작을 선언합니다. "지금부터 하나의 작업 묶음이 시작된다"는 의미입니다.
2. `INSERT INTO 주문 ...` → 주문 테이블에 새로운 주문 데이터를 삽입합니다.
3. `UPDATE 재고 SET 수량 = 수량 - 1 ...` → 재고 테이블에서 해당 상품의 수량을 1 줄입니다.
4. `UPDATE 고객 SET 포인트 = 포인트 + 100 ...` → 고객 테이블에서 해당 고객의 포인트를 100 추가합니다.
5. `COMMIT;` → 위의 3가지 작업이 모두 성공했으므로, 결과를 하드디스크에 영구 저장합니다. 이 순간 트랜잭션이 완료됩니다.

**Commit 명령을 만나야만** INSERT, UPDATE, DELETE 등의 작업 결과가 하드디스크에 저장됩니다. Commit 명령을 만나지 않으면 하드디스크에 절대 저장되어서는 안 됩니다(지연갱신 기법 기준).

### 🔴 Rollback (롤백) - 전체 취소

**Rollback은 트랜잭션 실행 중 에러가 발생하여, 그동안 했던 모든 작업을 취소시키고 트랜잭션 시작 이전의 상태로 되돌리는 명령**입니다.

Rollback은 "되돌리다"라는 뜻 그대로, **했던 작업들을 거꾸로 취소(Undo)**시키는 것입니다.

```sql
-- ❌ 잘못된 상황: 중간에 에러 발생 → Commit 불가능
BEGIN TRANSACTION;  -- 트랜잭션 시작

INSERT INTO 주문 (고객ID, 상품명, 수량) VALUES (101, '노트북', 1);  -- 주문 삽입 (성공)
UPDATE 재고 SET 수량 = 수량 - 1 WHERE 상품명 = '노트북';              -- 재고 차감 (성공)
UPDATE 고객 SET 포인트 = 포인트 + 100 WHERE 고객ID = 999;            -- ❌ 고객ID 999는 존재하지 않음! 에러 발생!

-- 에러가 발생했으므로 Commit 할 수 없음
ROLLBACK;  -- 위에서 성공했던 INSERT, UPDATE도 전부 취소! 원래 상태로 복구
```

위 코드를 한 줄씩 설명하겠습니다:

1. `BEGIN TRANSACTION;` → 트랜잭션을 시작합니다.
2. `INSERT INTO 주문 ...` → 주문 데이터 삽입이 성공합니다.
3. `UPDATE 재고 ...` → 재고 차감도 성공합니다.
4. `UPDATE 고객 ... WHERE 고객ID = 999` → 고객ID가 999인 고객이 존재하지 않아 **에러가 발생**합니다.
5. `ROLLBACK;` → 에러가 발생했으므로 Commit을 할 수 없습니다. 따라서 **앞에서 성공했던 주문 삽입과 재고 차감도 모두 취소**됩니다. 데이터베이스는 트랜잭션 시작 이전 상태로 완벽하게 되돌아갑니다.

:::danger Commit 없이는 성공이 아닙니다!
트랜잭션이 중간에 에러가 발생하면 **Commit을 할 수 없습니다.** Commit은 오직 **성공적으로 완료되었을 때만** 수행할 수 있습니다. 에러가 발생하면 반드시 Rollback만 수행할 수 있습니다. 부분적으로 성공한 것을 Commit 하는 것은 절대 허용되지 않습니다.
:::

---

## 🔄 트랜잭션의 상태 흐름도

트랜잭션은 시작부터 끝까지 여러 상태를 거칩니다. 이 상태의 흐름을 이해하면 트랜잭션의 동작 원리를 훨씬 명확하게 파악할 수 있습니다.

### 5가지 상태 한눈에 보기

| 상태 | 설명 | 비유 |
|------|------|------|
| **활동 (Active)** | 트랜잭션이 시작되어 작업이 진행 중인 상태 | 아래아한글에서 문서를 타이핑하고 있는 중 |
| **부분 완료 (Partially Committed)** | 마지막 명령문까지 실행 완료. Commit은 아직 안 됨 | 타이핑은 다 끝났지만 저장 버튼을 아직 안 누른 상태 |
| **완료 (Committed)** | Commit 명령 실행. 결과가 하드디스크에 영구 저장됨 | 저장 버튼을 눌러서 파일이 하드디스크에 저장된 상태 |
| **실패 (Failed)** | 에러가 발생하여 더 이상 정상 진행이 불가능한 상태 | 타이핑 중 프로그램이 에러를 내뿜은 상태 |
| **철회 (Aborted)** | Rollback으로 모든 작업이 취소된 상태 | 작업한 내용이 모두 사라지고 빈 문서로 돌아간 상태 |

### 상태 전이 흐름

```
활동(Active)
  │
  ├──(성공)──→ 부분 완료(Partially Committed)
  │                     │
  │                     ├──(Commit)──→ 완료(Committed) ✅
  │                     │
  │                     └──(에러 발생)──→ 실패(Failed) ──→ 철회(Aborted) ❌
  │
  └──(에러 발생)──→ 실패(Failed) ──→ 철회(Aborted) ❌
```

여기서 주의할 점이 있습니다:

1. **활동 → 부분 완료**: 모든 명령문이 성공적으로 실행되면 부분 완료 상태로 갑니다.
2. **부분 완료 → 완료**: Commit 명령을 만나면 완료 상태가 됩니다.
3. **부분 완료 → 실패**: 작업은 다 끝났지만 Commit 과정에서 에러가 발생할 수 있습니다. 예를 들어 저장 공간이 부족하거나, 파일이 읽기 전용이거나, 이름이 중복되는 등의 이유로 저장(Commit)이 실패할 수 있습니다.
4. **활동 → 실패**: 작업 진행 중에 문법 오류, 시스템 문제 등으로 바로 실패할 수도 있습니다.
5. **실패 → 철회**: 실패했으므로 Rollback을 통해 모든 작업을 취소(철회)합니다.

:::warning 실패에서 부분 완료로는 갈 수 없습니다!
실패 상태에서 부분 완료 상태로 되돌아가는 것은 불가능합니다. 한번 실패하면 Rollback을 통해 철회하는 수밖에 없습니다. 부분 완료에서 실패로는 갈 수 있지만, 실패에서 부분 완료로는 갈 수 없다는 점을 기억하세요.
:::

---

## 💾 데이터 저장과 처리 구조

트랜잭션을 제대로 이해하려면, 데이터가 컴퓨터 내부에서 어떻게 이동하고 저장되는지 알아야 합니다.

### 저장 장치의 3가지 유형

| 유형 | 영문 | 특징 | 예시 |
|------|------|------|------|
| **소멸성 저장장치** | Volatile Storage | 전원이 꺼지면 데이터 소멸 | RAM(메모리) |
| **비소멸성 저장장치** | Non-volatile Storage | 전원이 꺼져도 데이터 유지 | 하드디스크, USB, SSD |
| **안정성 저장장치** | Stable Storage | 별도로 백업하여 안전하게 보관 | 외장하드 백업, 클라우드 백업 |

### 데이터 이동 흐름: Input → Read → Write → Output

데이터는 하드디스크에서 바로 CPU로 갈 수 없습니다. 하드디스크는 속도가 매우 느리고, CPU는 속도가 매우 빠르기 때문에, 중간에 **메모리(RAM)**가 **완충(버퍼) 역할**을 해줍니다. 마치 고속도로에서 갑자기 좁은 골목길로 들어갈 수 없어서 중간에 톨게이트가 있는 것과 비슷합니다.

```
하드디스크  ──(Input)──→  메모리(RAM)  ──(Read)──→  CPU
하드디스크  ←──(Output)──  메모리(RAM)  ←──(Write)──  CPU
```

| 연산 | 방향 | 설명 |
|------|------|------|
| **Input** | 하드디스크 → 메모리 | 하드디스크에서 데이터를 메모리로 읽어옴 |
| **Read** | 메모리 → CPU | 메모리에서 데이터를 CPU로 읽어와서 처리 준비 |
| **Write** | CPU → 메모리 | CPU에서 처리된 결과를 메모리에 기록 |
| **Output** | 메모리 → 하드디스크 | 메모리에 있는 결과를 하드디스크에 영구 저장 |

### 갱신 방식: 제자리 갱신 vs 간접 갱신

데이터를 수정(갱신)할 때 두 가지 방식이 있습니다.

- **제자리 갱신**: 원래 읽어왔던 **같은 위치**에 데이터를 다시 저장하는 방식입니다. A라는 데이터가 100번 주소에 있었으면, 수정된 A도 100번 주소에 다시 저장됩니다.
- **간접 갱신**: 원래 위치가 아닌 **다른 위치**에 수정된 데이터를 저장하는 방식입니다. 100번 주소에 있던 A를 수정한 후 200번 주소에 저장하면, 100번 주소의 기존 데이터는 더 이상 필요 없는 **쓰레기(Garbage)**가 됩니다. 이 쓰레기는 나중에 **가비지 컬렉션(Garbage Collection, 쓰레기 수집)**이라는 작업으로 정리합니다.

---

## 🚨 장애의 유형과 회복의 개념

데이터베이스를 사용하다 보면 다양한 이유로 **장애(Failure)**가 발생할 수 있습니다. 사람도 살다 보면 아플 수 있고, 병원에 가서 치료를 받아 정상 상태로 돌아오죠? 데이터베이스도 마찬가지입니다. 장애가 발생하면 **회복(Recovery)**을 통해 정상 상태로 복구해야 합니다.

> **회복(Recovery)이란, 장애로 인해 손상된 데이터베이스를 손상되기 이전의 정상적인 상태로 복구시키는 것**입니다.

### 장애의 4가지 유형

| 장애 유형 | 설명 | 예시 | 심각도 |
|-----------|------|------|--------|
| **행동 장애** | 데이터 항목을 찾지 못하거나 무결성 규정 위반 | 존재하지 않는 데이터 조회, NULL이면 안 되는 곳에 NULL 입력, 점수에 0~100 범위 밖의 값 입력, 1~6학년만 가능한데 7학년 입력 | 낮음 |
| **트랜잭션 장애** | 시스템 자원 과다 사용, 입력 데이터 불량, 데이터 소실 | CPU 100% 점유로 시스템 멈춤, 메모리 풀(Full)로 작업 불가, 원치 않는 데이터 삭제 | 중간 |
| **시스템 장애** | 하드웨어 고장으로 전원 꺼짐 | CPU 고장, 메모리 고장, 그래픽카드 고장, 갑작스러운 전원 차단 | 높음 |
| **미디어 장애** | 저장장치(하드디스크) 자체 붕괴 | 하드디스크 물리적 손상, 디스크 헤드 충돌 | **매우 높음** |

:::danger 미디어 장애가 가장 치명적입니다!
데이터베이스 관점에서 **미디어 장애(하드디스크 붕괴)**가 가장 위험합니다. 시스템 장애는 운영체제를 다시 설치하거나 부품을 교체하면 해결할 수 있지만, 하드디스크가 물리적으로 망가지면 **데이터 자체가 직접적으로 손실**됩니다. 복구에도 엄청난 비용이 들기 때문에, 평소에 **백업을 철저히** 해두는 것이 필수입니다.
:::

### 회복의 기본 원리: Dump + Log

회복의 기본 원리는 크게 두 가지 요소로 구성됩니다:

1. **Dump(덤프, 백업)**: 장애가 발생하기 이전에 마지막으로 성공한 데이터베이스 전체를 **별도의 안전한 저장장치에 복사**해 놓는 것입니다. 여러분이 집에 있는 중요한 파일을 USB, 외장하드, 클라우드 등에 백업해 놓는 것과 같습니다.

2. **Log(로그, 변경 기록)**: Dump 이후에 발생한 **모든 변경 사항을 기록**해 놓는 파일입니다. 어떤 트랜잭션이 어떤 데이터를 어떤 값에서 어떤 값으로 변경했는지, 그리고 Commit 되었는지 여부까지 하나하나 기록합니다.

장애가 발생하면 → Dump 파일을 불러오고 → Log 파일의 기록을 분석하여 → 성공한 트랜잭션은 다시 반영(Redo)하고, 실패한 트랜잭션은 취소(Undo)하여 데이터베이스를 복구합니다.

---

## 🔁 Redo와 Undo - 회복의 핵심 연산

회복 과정에서 사용하는 두 가지 핵심 연산이 있습니다. **Redo(리두)**와 **Undo(언두)**입니다.

### Redo(리두) - 다시 실행 (Forward Recovery)

**Redo는 Commit이 완료된 트랜잭션의 작업을 다시 수행하는 연산**입니다. Dump 파일을 기준으로 Log에 기록된 성공적인 변경 사항을 **순방향(앞으로)**으로 다시 반영합니다.

비유하면, 레시피(Log)를 보고 요리(데이터 변경)를 처음부터 다시 만드는 것과 같습니다.

### Undo(언두) - 취소 (Backward Recovery)

**Undo는 Commit이 되지 않은 트랜잭션의 작업을 취소하는 연산**입니다. 이미 반영되어 버린 미완료 작업을 **역방향(뒤로)**으로 되돌립니다.

비유하면, 잘못 쌓은 블록을 위에서부터 하나씩 다시 빼내는 것과 같습니다.

| 연산 | 대상 | 방향 | 별칭 |
|------|------|------|------|
| **Redo** | Commit이 있는 트랜잭션 | 순방향 (Forward) | Forward Recovery |
| **Undo** | Commit이 없는 트랜잭션 | 역방향 (Backward) | Backward Recovery |

> **핵심 규칙**: Commit 명령을 만난 트랜잭션 → **Redo** / Commit 명령을 만나지 않은 트랜잭션 → **Undo**

### Log 파일의 구조

Log 파일은 다음 4가지 정보로 구성됩니다:

| 항목 | 설명 | 예시 |
|------|------|------|
| 트랜잭션 이름 | 어떤 트랜잭션인지 | T1 |
| 데이터 아이템 이름 | 어떤 데이터를 변경했는지 | X |
| 변경 전의 값 | 수정하기 전 값 (Undo에 사용) | 100 |
| 변경 후의 값 | 수정한 후 값 (Redo에 사용) | 200 |

Log 레코드 예시:

```
[T1, start]           -- T1 트랜잭션이 시작됨
[T1, X, 100, 200]     -- T1이 X 값을 100에서 200으로 변경함
[T1, commit]           -- T1이 성공적으로 완료됨 (Commit)
```

:::note Log 파일의 크기
데이터 레코드 하나하나에 대해 Log가 만들어지므로, 100만 개의 데이터를 변경하면 Log도 100만 줄이 생깁니다. 따라서 **Log 파일은 매우 큰 규모**가 될 수 있습니다. Read 연산(읽기)에 대한 Log는 파일 크기를 줄이기 위해 일반적으로 생략합니다.
:::

---

## ⏳ 지연갱신 기법 vs 즉시갱신 기법

장애 발생 시 회복하는 방법에는 크게 두 가지 기법이 있습니다. **지연갱신 기법**과 **즉시갱신 기법**입니다. 이 두 기법의 차이는 **Commit 전에 하드디스크에 데이터를 저장하느냐 안 하느냐**입니다.

### 📋 지연갱신 기법 (Deferred Update)

**지연갱신 기법은 Commit 명령을 만나기 전까지 모든 변경 사항을 메모리에서만 처리하고, 하드디스크로의 저장(Output)을 지연시키는 방식**입니다.

아래아한글에서 작업할 때, 저장 버튼을 누르기 전까지는 **절대로 자동 저장이 안 되는 방식**이라고 생각하면 됩니다. 저장 버튼(Commit)을 눌러야만 하드디스크에 기록됩니다.

이 방식의 핵심 특징:

- Commit 전에 에러가 발생하면 → 하드디스크에 반영된 것이 **하나도 없음** → 따라서 **Undo 연산이 필요 없음**
- Commit이 있는 트랜잭션만 → **Redo 연산**으로 다시 반영
- Commit이 없는 트랜잭션은 → **아무 작업도 하지 않음** (이미 하드디스크에 아무것도 없으므로)

> **지연갱신 기법의 Log에는 "변경 후의 값"만 기록됩니다.** Undo를 할 필요가 없으니 "변경 전의 값"은 필요 없기 때문입니다.

이 방식을 **No-Steal 방식**이라고도 합니다. Commit 전에는 Output이 지연되어 있는 상태라는 뜻입니다.

#### 지연갱신 기법의 단점

- 모든 데이터가 Commit 전까지 메모리에 머물러야 하므로 **메모리 공간이 매우 커야** 합니다.
- 바로바로 하드디스크에 저장되지 않으므로 **다른 사용자가 변경된 데이터를 즉시 읽을 수 없어** 동시성이 떨어집니다.

### 지연갱신 기법 예제

초기값: A = 1000, B = 2000, C = 3000

**예제 1: Commit 없이 에러 발생**

```
[T1, start]            -- T1 시작
[T1, A, 900]           -- A를 900으로 변경 (메모리에서만)
[T1, B, 2100]          -- B를 2100으로 변경 (메모리에서만)
❌ 에러 발생! (Commit 없음)
```

- T1은 Commit이 없습니다.
- 하드디스크에 반영된 것이 하나도 없으므로 → **아무 작업도 수행하지 않습니다.**
- **최종 결과: A = 1000, B = 2000, C = 3000** (원래 값 그대로)

**예제 2: T1은 Commit 있음, T2는 Commit 없음**

```
[T1, start]            -- T1 시작
[T1, A, 900]           -- A를 900으로 변경
[T1, B, 2100]          -- B를 2100으로 변경
[T1, commit]           -- T1 성공적으로 완료! ✅
[T2, start]            -- T2 시작
[T2, C, 2800]          -- C를 2800으로 변경
❌ 에러 발생! (T2는 Commit 없음)
```

- T1은 Commit이 있으므로 → **Redo 수행**: A를 900으로, B를 2100으로 다시 반영
- T2는 Commit이 없으므로 → **아무 작업도 하지 않음**
- **최종 결과: A = 900, B = 2100, C = 3000**

**예제 3: T1도 Commit, T2도 Commit**

```
[T1, start]            -- T1 시작
[T1, A, 900]           -- A를 900으로 변경
[T1, B, 2100]          -- B를 2100으로 변경
[T1, commit]           -- T1 완료 ✅
[T2, start]            -- T2 시작
[T2, C, 2800]          -- C를 2800으로 변경
[T2, commit]           -- T2 완료 ✅
```

- T1 Redo: A = 900, B = 2100
- T2 Redo: C = 2800
- **최종 결과: A = 900, B = 2100, C = 2800**

:::tip 지연갱신 기법 요약 공식
**Commit 있음 → Redo / Commit 없음 → 아무것도 안 함 (Undo 불필요)**
:::

### ⚡ 즉시갱신 기법 (Immediate Update)

**즉시갱신 기법은 Commit 여부와 관계없이, 변경 사항이 즉시 하드디스크에 반영되는 방식**입니다.

데이터가 잘못되든 올바르든, Commit이 있든 없든, 작업이 이루어지는 즉시 하드디스크에 저장되어 버립니다. 마치 아래아한글에서 글자를 입력할 때마다 **자동으로 저장되는 방식**과 비슷합니다.

이 방식의 핵심 특징:

- Commit이 없는 트랜잭션 → 이미 하드디스크에 반영되어 버렸으므로 → **Undo 연산으로 취소** 필요
- Commit이 있는 트랜잭션 → 100% 저장이 보장되지 않을 수 있으므로 → **Redo 연산으로 재반영** 필요

> **즉시갱신 기법의 Log에는 "변경 전의 값"과 "변경 후의 값" 모두 기록됩니다.** Undo를 위해 변경 전의 값이 필요하고, Redo를 위해 변경 후의 값이 필요하기 때문입니다.

#### Undo와 Redo의 실행 순서

즉시갱신 기법에서는 Undo해야 할 것과 Redo해야 할 것이 섞여 있을 수 있습니다. 이 경우:

1. **먼저 Undo 연산을 역방향(뒤에서 앞으로)으로 모두 수행**합니다.
2. **그 다음 Redo 연산을 순방향(앞에서 뒤로)으로 수행**합니다.

### 즉시갱신 기법 예제

초기값: A = 1000, B = 2000, C = 3000

**예제 1: Commit 없이 에러 발생**

```
[T1, start]              -- T1 시작
[T1, A, 1000, 900]       -- A를 1000에서 900으로 변경 (하드디스크에 즉시 반영됨!)
[T1, B, 2000, 2100]      -- B를 2000에서 2100으로 변경 (하드디스크에 즉시 반영됨!)
❌ 에러 발생! (Commit 없음)
```

- T1은 Commit이 없지만, **이미 하드디스크에 900, 2100이 저장되어 버렸습니다!**
- 따라서 **Undo 연산**을 수행해야 합니다: B를 2100 → 2000으로, A를 900 → 1000으로 되돌림 (역방향)
- **최종 결과: A = 1000, B = 2000, C = 3000** (원래 값으로 복원)

**예제 2: T1은 Commit 있음, T2는 Commit 없음**

```
[T1, start]              -- T1 시작
[T1, A, 1000, 900]       -- A를 1000에서 900으로 변경
[T1, B, 2000, 2100]      -- B를 2000에서 2100으로 변경
[T1, commit]             -- T1 완료 ✅
[T2, start]              -- T2 시작
[T2, C, 3000, 2800]      -- C를 3000에서 2800으로 변경
❌ 에러 발생! (T2는 Commit 없음)
```

- T2는 Commit이 없으므로 → **Undo**: C를 2800 → 3000으로 되돌림
- T1은 Commit이 있으므로 → **Redo**: A = 900, B = 2100으로 다시 반영
- **최종 결과: A = 900, B = 2100, C = 3000**

**예제 3: T1도 Commit, T2도 Commit**

```
[T1, start]              -- T1 시작
[T1, A, 1000, 900]       -- A를 1000에서 900으로 변경
[T1, B, 2000, 2100]      -- B를 2000에서 2100으로 변경
[T1, commit]             -- T1 완료 ✅
[T2, start]              -- T2 시작
[T2, C, 3000, 2800]      -- C를 3000에서 2800으로 변경
[T2, commit]             -- T2 완료 ✅
```

- T1 Redo: A = 900, B = 2100
- T2 Redo: C = 2800
- **최종 결과: A = 900, B = 2100, C = 2800**

:::tip 즉시갱신 기법 요약 공식
**Commit 있음 → Redo / Commit 없음 → Undo**
:::

### 두 기법 비교 정리

| 비교 항목 | 지연갱신 기법 | 즉시갱신 기법 |
|-----------|--------------|--------------|
| Commit 전 하드디스크 저장 | ❌ 안 함 (메모리에서만) | ✅ 즉시 저장 |
| Commit 있는 트랜잭션 | Redo | Redo |
| Commit 없는 트랜잭션 | 아무것도 안 함 | **Undo** |
| Log에 필요한 값 | 변경 후의 값만 | 변경 전 + 변경 후 값 모두 |
| Undo 연산 필요 여부 | ❌ 불필요 | ✅ 필요 |
| 메모리 요구량 | 큼 (Commit 전까지 메모리에 보관) | 상대적으로 작음 |
| 동시성 | 낮음 | 높음 |
| 별칭 | No-Steal 방식 | Steal 방식 |

---

## ⚠️ 주의사항과 실무 팁

### 흔히 하는 실수들

:::warning 초보자가 자주 혼동하는 포인트

1. **"부분 완료 = 완료"가 아닙니다!** 부분 완료는 작업은 끝났지만 Commit은 아직 안 된 상태입니다. 저장 버튼을 아직 안 누른 것과 같습니다. 부분 완료 상태에서도 실패로 갈 수 있습니다.

2. **"Rollback = 부분 취소"가 아닙니다!** Rollback은 반드시 **전체 취소**입니다. "이 부분만 취소하고 저 부분은 살리자"라는 개념이 아닙니다. All or Nothing!

3. **지연갱신에서 Undo가 필요 없는 이유를 정확히 이해하세요.** 지연갱신은 Commit 전에 하드디스크에 아무것도 저장하지 않기 때문에, 취소할 것 자체가 없습니다. 이미 저장된 것이 없으니 Undo가 불필요한 것입니다.

4. **즉시갱신에서 Undo가 필요한 이유도 정확히 이해하세요.** 즉시갱신은 Commit 전에도 하드디스크에 저장해 버리기 때문에, 실패한 트랜잭션의 흔적이 하드디스크에 남아있습니다. 이것을 원래대로 되돌려야 하므로 Undo가 필요합니다.
:::

### 실무에서의 트랜잭션 활용 팁

:::tip 개발할 때 기억하세요!

- **트랜잭션은 가능한 짧게 유지**하는 것이 좋습니다. 트랜잭션이 길어지면 다른 사용자의 접근이 오래 차단(격리성)되어 시스템 성능이 떨어집니다.
- **에러 처리를 반드시 포함**하세요. 에러가 발생했을 때 Rollback이 되도록 코드를 작성해야 데이터의 원자성이 보장됩니다.
- **백업(Dump)은 정기적으로** 수행하세요. 아무리 좋은 회복 기법을 사용해도 백업이 없으면 복구할 수 없습니다.
- **Log 파일은 매우 커질 수 있으므로** 관리에 신경 써야 합니다. 레코드 하나하나에 대해 Log가 생성되기 때문입니다.
:::

---

## 📌 핵심 정리

- **트랜잭션**은 하나의 논리적 기능을 수행하기 위한, 더 이상 쪼갤 수 없는 작업의 최소 단위이다
- **원자성(Atomicity)**: 모두 완료(All)되거나 모두 취소(Nothing)되어야 하며, 부분 처리는 허용하지 않는다
- **일관성(Consistency)**: 동일한 조건의 조회는 항상 동일한 최종 결과를 보장해야 한다
- **격리성(Isolation)**: 실행 중인 트랜잭션의 중간 결과에 다른 트랜잭션이 접근할 수 없다
- **영속성(Durability)**: Commit된 결과는 하드디스크에 영구 저장되어 전원이 꺼져도 유지된다
- **Commit**은 트랜잭션의 성공적 완료를 확정하고 하드디스크에 저장하는 명령이다
- **Rollback**은 에러 발생 시 모든 작업을 취소하고 이전 상태로 되돌리는 명령이다
- 트랜잭션 상태는 **활동 → 부분 완료 → 완료** 또는 **활동/부분 완료 → 실패 → 철회** 순서로 전이된다
- 회복의 기본 원리는 **Dump(백업) + Log(변경 기록)**를 활용하는 것이다
- **Redo(순방향 회복)**: Commit이 있는 트랜잭션을 다시 반영하는 연산
- **Undo(역방향 회복)**: Commit이 없는 트랜잭션을 취소하는 연산
- **지연갱신 기법**: Commit 전에는 하드디스크에 저장하지 않음 → Undo 불필요, Redo만 수행
- **즉시갱신 기법**: Commit 여부와 관계없이 즉시 하드디스크에 저장 → Undo + Redo 모두 수행

---

작성일: 2026-02-21