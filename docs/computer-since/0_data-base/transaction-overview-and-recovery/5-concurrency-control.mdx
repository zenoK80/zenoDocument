---
title: "병행제어의 개념과 필요성"
description: "병행제어의 개념과 필요성에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/transaction-overview-and-recovery/5-concurrency-control"
sidebar_label: "병행제어"
date: "2026-02-21"
---

## 🎯 트랜잭션이란 무엇인가?

데이터베이스를 공부하다 보면 가장 먼저 만나게 되는 핵심 개념이 바로 **트랜잭션(Transaction)**입니다. 트랜잭션을 이해하지 못하면 병행제어도, 회복(Recovery)도 이해할 수 없기 때문에, 이 개념부터 확실하게 짚고 넘어가겠습니다.

### 📖 트랜잭션의 정의

트랜잭션이란 **하나의 논리적 기능을 수행하기 위한 작업의 단위**입니다. 여기서 "작업의 단위"란 **더 이상 쪼개질 수 없는 가장 작은 단위**를 뜻합니다. 마치 원자(Atom)가 더 이상 쪼갤 수 없는 물질의 기본 단위인 것처럼, 트랜잭션도 데이터베이스 작업에서 더 이상 나눌 수 없는 기본 단위입니다.

> **트랜잭션 = 더 이상 쪼개질 수 없는 작업의 기본 단위**

예를 들어, 한 명의 사용자가 데이터베이스에 "데이터를 삽입하고, 검색하는 작업"을 요청했다고 합시다. 이 삽입과 검색이 하나의 묶음으로 처리되어야 한다면, 이 묶음 전체가 하나의 트랜잭션이 됩니다. **삽입만 하고 검색은 나중에 하는 식의 부분 처리는 허용되지 않습니다.** 한꺼번에 모두 처리되거나, 한꺼번에 모두 취소되어야 합니다.

### 🏗️ 트랜잭션과 응용 프로그램의 관계

하나의 트랜잭션은 **하나 이상의 데이터베이스 명령어**(INSERT, DELETE, UPDATE, SELECT 등의 SQL 연산)로 구성됩니다. 그리고 우리가 실제로 사용하는 **응용 프로그램(Application)은 여러 개의 트랜잭션들을 모아놓은 것**이라고 이해하면 됩니다. 마치 한 권의 책이 여러 개의 챕터로 이루어져 있는 것처럼, 하나의 응용 프로그램은 여러 개의 트랜잭션으로 이루어져 있습니다.

:::info 트랜잭션은 물리적 단위가 아니라 논리적 단위입니다
트랜잭션은 하드디스크 몇 바이트, 메모리 몇 킬로바이트 같은 물리적 크기의 단위가 아닙니다. "이체 작업", "주문 처리" 같은 **논리적인 의미를 가진 작업 묶음**을 가리키는 개념입니다.
:::

---

## 🔐 병행제어와 회복 — 왜 트랜잭션이 필요한가?

### 🚦 병행제어(Concurrency Control)란?

현실에서 데이터베이스는 한 사람만 사용하지 않습니다. 적게는 수백 명, 많게는 수십만 명이 **동시에** 하나의 데이터베이스 서버에 접속합니다. 이때 서로 다른 사용자의 작업이 충돌하지 않도록 관리하는 것을 **병행제어**라고 합니다.

비유하자면, **강의실이 하나인데 여러 교수님이 동시에 사용하려고 하면 충돌이 생기겠죠?** 이런 충돌을 방지하려면 시간표를 잘 짜서 각 시간에 한 분만 강의하도록 해야 합니다. 데이터베이스도 마찬가지로, 여러 사용자가 동시에 접근해도 충돌 없이 안전하게 운영되어야 합니다. 이것이 바로 병행제어의 역할입니다.

### 🏥 회복(Recovery)이란?

데이터베이스를 사용하다가 중간에 문제가 생겨서 데이터베이스가 깨지거나 고장나는 상황이 발생할 수 있습니다. 이때 **원래의 정상적인 상태로 복구하는 것**을 회복이라고 합니다. 마치 사람이 아프면 병원에 가서 치료를 받고 정상적인 몸 상태로 돌아오는 것과 같습니다.

> **병행제어 = 여러 사용자가 동시에 쓸 때 충돌 방지**
> **회복 = 장애 발생 시 정상 상태로 복구**

이 두 가지 작업에서 권한을 주고 빼거나, 복구할 때의 **기본 단위가 바로 트랜잭션**입니다. 그렇기 때문에 트랜잭션 개념을 먼저 이해해야 병행제어와 회복을 제대로 이해할 수 있는 것입니다.

---

## 💎 트랜잭션의 4가지 성질 — ACID

트랜잭션에는 반드시 지켜져야 하는 **4가지 핵심 성질**이 있습니다. 이것을 각 성질의 영어 첫 글자를 따서 **ACID**라고 부릅니다.

| 약자 | 영어 | 한국어 | 핵심 의미 |
|------|------|--------|-----------|
| **A** | Atomicity | 원자성 | 전부 완료하거나 전부 취소 |
| **C** | Consistency | 일관성 | 결과가 항상 일관되어야 함 |
| **I** | Isolation | 격리성 | 중간 결과에 다른 트랜잭션이 접근 불가 |
| **D** | Durability | 영속성 | 성공한 결과는 영구적으로 저장 |

### ⚛️ 원자성 (Atomicity) — 가장 중요한 성질

원자성은 ACID 중에서 **가장 중요한 성질**입니다. "원자(Atom)"는 더 이상 쪼갤 수 없는 가장 작은 단위를 의미합니다. 트랜잭션이 원자적이라는 것은, 트랜잭션에 포함된 모든 작업이 **한꺼번에 전부 완료되거나, 한꺼번에 전부 취소되어야 한다**는 뜻입니다.

이것을 **"All or Nothing"**이라고 표현합니다. 전부(All) 성공하든가, 아무것도(Nothing) 하지 않은 상태로 되돌리든가, 이 두 가지 중 하나만 가능하다는 것입니다. **부분적인 처리는 절대 허용하지 않습니다.**

:::warning 부분 처리는 절대 안 됩니다!
트랜잭션의 작업 10개 중 7개만 성공하고 3개는 나중에 처리하는 것은 불가능합니다. 7개가 성공했더라도 나머지 3개에서 에러가 발생하면, **7개도 전부 취소**해야 합니다.
:::

#### 🏦 은행 이체로 이해하는 원자성

가장 쉽게 이해할 수 있는 예시가 **은행 이체**입니다.

A 사용자가 B 사용자에게 돈을 이체한다고 해봅시다. 이 이체 과정이 하나의 트랜잭션입니다.

1. A의 잔액을 조회한다
2. 잔액이 충분한지 확인한다
3. A의 통장에서 돈을 빼낸다
4. B의 통장에 돈을 넣는다
5. 상대방 서버에서 "정상적으로 받았다"는 확인 메시지를 받는다

만약 3번까지 진행되어서 **A의 통장에서는 돈이 빠져나갔는데**, 상대방 서버에 문제가 생겨서 **B의 통장에는 돈이 들어가지 않았다면** 어떻게 될까요? 중간에 돈이 사라져 버리는 것입니다! 이런 일이 벌어지면 시스템은 정상적으로 작동할 수 없습니다.

원자성이 보장되면, 5번 단계까지 **모두 성공**했을 때만 이체가 완료됩니다. 만약 중간에 어디서든 에러가 발생하면, A의 통장에서 빠져나간 돈도 **다시 원래대로 되돌려집니다.** 이것이 원자성의 힘입니다.

> **원자성은 트랜잭션 관리 컴포넌트(DBMS의 구성 요소)가 책임지고 관리합니다.**

### 📊 일관성 (Consistency)

일관성이란 **동일한 조건으로 데이터를 조회하면 항상 동일한 결과가 나와야 한다**는 성질입니다.

예를 들어, 상품 A의 가격을 조회했더니 100원이었습니다. 그런데 아무도 가격을 변경하지 않았는데, 다시 조회했더니 200원이 나왔습니다. 이렇게 되면 **일관성이 깨진 것**입니다. 물론 관리자가 실제로 가격을 변경했다면 값이 바뀌는 것은 당연합니다. 하지만 아무런 변경 없이 같은 질의에 대해 다른 결과가 나오면 안 됩니다.

#### 실행 중의 일관성 vs 결과의 일관성

흥미로운 점은, **실행 중에는 일관성이 일시적으로 무시될 수 있다**는 것입니다.

`1 + 2 + 3`을 계산한다고 해봅시다. 어떤 순서로 계산하든 최종 결과는 반드시 **6**이어야 합니다.

- `(1 + 2) + 3` → 중간 결과: 3 → 최종 결과: **6**
- `(2 + 3) + 1` → 중간 결과: 5 → 최종 결과: **6**

중간 결과는 3일 수도 있고 5일 수도 있습니다. 하지만 **최종 결과는 항상 6**이어야 합니다. 트랜잭션에서 말하는 일관성은 바로 이 **결과의 일관성**을 의미합니다.

> **일관성은 프로그래밍(알고리즘)이 올바르게 작성되어야 보장됩니다.** Java, C 등으로 프로그램을 짤 때 알고리즘에 오류가 없어야 실행 결과의 일관성을 보장할 수 있습니다.

### 🔒 격리성 (Isolation)

격리성이란 **실행 중인 트랜잭션의 중간 결과에 다른 트랜잭션이 접근할 수 없도록 차단하는 것**입니다.

위에서 살펴본 것처럼, 실행 순서에 따라 중간 결과는 3이 될 수도 있고 5가 될 수도 있습니다. 만약 다른 사용자가 이 **중간 결과를 읽어간다면** 어떻게 될까요? 한 사람은 3을 읽어가고, 다른 사람은 5를 읽어갈 수 있습니다. 같은 조건으로 데이터베이스를 읽었는데 **결과가 달라져 버리는 문제**가 발생합니다.

실생활 예시로 생각해 봅시다. 관리자가 지금 상품 가격을 변경하고 있는 중입니다. 가격이 아직 확정되지 않았는데, 고객이 접근해서 주문을 넣을 수 있다면 문제가 되겠죠. **가격 변경이 완전히 완료(Commit)된 후에야** 고객이 접근할 수 있어야 합니다. 이것이 바로 격리성입니다.

:::danger 연쇄 취소(Cascading Abort) 위험!
중간 결과를 다른 트랜잭션이 읽어간 상태에서, 원래 트랜잭션이 취소되면 읽어간 트랜잭션도 함께 취소해야 합니다. 그런데 이 취소가 연쇄적으로 퍼지면서 **취소할 수 없는 상황**이 발생할 수 있습니다. 격리성은 이런 연쇄 취소(Cascading Abort)를 방지하기 위해 반드시 필요합니다.
:::

> **격리성은 동시성 제어 컴포넌트가 책임지고 관리합니다.** 여러 사용자가 동시에 접근할 때 중간 결과에 접근하지 못하도록 막아주는 역할을 합니다.

### 💾 영속성 (Durability)

영속성이란 **트랜잭션이 성공적으로 완료되면, 그 결과가 영구적으로 저장되어야 한다**는 성질입니다.

성공한 트랜잭션의 결과는 **하드디스크(비소멸성 저장 장치)**에 저장됩니다. 만약 메모리에만 저장된다면, 컴퓨터를 껐다 켜면 데이터가 사라져 버립니다. 메모리는 **휘발성(전원이 꺼지면 데이터가 사라지는 성질)**이기 때문입니다.

마치 여러분이 아래아한글에서 열심히 문서 작업을 한 후 **저장 버튼을 눌러야** 하드디스크에 파일이 저장되는 것과 같습니다. 저장 버튼을 누르지 않고 컴퓨터를 끄면, 그동안 작업한 내용이 전부 사라지죠.

> **영속성은 회복 관리 컴포넌트가 책임지고 관리합니다.**

---

## ✅ Commit과 Rollback — 원자성을 지키는 두 가지 명령

원자성을 지키기 위해서는 **Commit**과 **Rollback**이라는 두 가지 핵심 명령어가 필요합니다.

### 🟢 Commit — 성공적으로 완료!

**Commit**은 트랜잭션이 성공적으로 종료되었음을 선언하는 명령입니다. Commit 명령을 만나야만 트랜잭션의 결과가 **실제로 하드디스크에 저장**됩니다.

아래아한글에서 문서 작업을 열심히 한 후 **저장 버튼을 누르는 것**이 바로 Commit입니다. 저장 버튼을 누르면 작업 내용이 하드디스크에 기록되어 영속성을 갖게 됩니다. Commit 명령을 만나면 하나의 트랜잭션이 끝나고, 새로운 트랜잭션을 시작할 수 있습니다.

```sql
-- ✅ 올바른 예시: INSERT와 UPDATE 후 Commit
INSERT INTO 계좌 (이름, 잔액) VALUES ('홍길동', 50000);  -- 데이터 삽입
UPDATE 계좌 SET 잔액 = 잔액 - 10000 WHERE 이름 = '홍길동';  -- 잔액 차감
COMMIT;  -- 성공적으로 완료! 하드디스크에 저장됨
```

위 코드를 한 줄씩 살펴보겠습니다:
- **1번째 줄**: `계좌` 테이블에 '홍길동'이라는 이름과 50000이라는 잔액을 삽입합니다.
- **2번째 줄**: '홍길동'의 잔액에서 10000을 차감합니다.
- **3번째 줄**: `COMMIT` 명령을 실행하여, 위의 INSERT와 UPDATE 작업을 **하드디스크에 영구적으로 저장**합니다.

:::tip Commit의 핵심
Commit 명령을 만나지 않으면 하드디스크에 **절대 저장되어서는 안 됩니다** (지연갱신 기법의 경우). Commit은 "이 작업은 성공했으니 영구 저장해도 좋다"는 **확인 도장**과 같습니다.
:::

### 🔴 Rollback — 전부 취소!

**Rollback**은 트랜잭션이 중간에 실패했을 때, **그동안 했던 작업을 전부 취소**시키는 명령입니다. 에러가 발생하면 Commit을 할 수 없고, **Rollback만 수행할 수 있습니다.**

Rollback은 작업하기 이전의 상태로 되돌리는 것입니다. 그동안 수행한 작업을 취소하는 것을 **Undo(언두)**라고도 합니다.

```sql
-- ❌ 잘못된 상황: 중간에 에러 발생, Commit 불가
INSERT INTO 주문 (상품번호, 수량) VALUES (101, 5);  -- 주문 데이터 삽입
UPDATE 재고 SET 수량 = 수량 - 5 WHERE 상품번호 = 101;  -- 재고 차감
-- ⚠️ 여기서 에러 발생! (예: 재고가 부족하여 음수가 됨)
-- Commit을 할 수 없으므로 Rollback 수행
ROLLBACK;  -- 위의 INSERT와 UPDATE 작업을 전부 취소!
```

위 코드를 한 줄씩 살펴보겠습니다:
- **1번째 줄**: 상품번호 101에 대해 수량 5개를 주문합니다.
- **2번째 줄**: 재고 테이블에서 해당 상품의 수량을 5만큼 차감합니다.
- **중간에 에러 발생**: 재고가 부족하거나 기타 이유로 에러가 발생했습니다.
- **마지막 줄**: `ROLLBACK` 명령을 실행하여, 위의 INSERT와 UPDATE 작업을 **모두 취소**합니다. 데이터베이스는 이 트랜잭션이 시작되기 이전 상태로 되돌아갑니다.

| 명령 | 상황 | 동작 | 비유 |
|------|------|------|------|
| **Commit** | 트랜잭션 성공 | 하드디스크에 영구 저장 | 저장 버튼 누르기 |
| **Rollback** | 트랜잭션 실패 | 모든 작업 취소 | Ctrl+Z로 전부 되돌리기 |

---

## 🔄 트랜잭션의 상태 흐름도

트랜잭션은 시작부터 종료까지 여러 상태를 거칩니다. 이 흐름을 이해하면 Commit과 Rollback이 언제 발생하는지 명확하게 알 수 있습니다.

### 5가지 상태

1. **활동(Active)**: 트랜잭션이 시작되어 작업이 진행되고 있는 상태입니다. 아래아한글에서 열심히 문서를 타이핑하고 있는 중과 같습니다.

2. **부분 완료(Partially Committed)**: 작업은 모두 끝났지만 **Commit 명령을 아직 만나지 않은 상태**입니다. 문서 타이핑은 다 끝났고, 저장 버튼만 남은 상태입니다. 마지막 명령문을 실행한 직후의 상태라고 할 수 있습니다.

3. **완료(Committed)**: Commit 명령을 만나서 **하드디스크에 영구 저장된 상태**입니다. 저장 버튼을 눌러서 파일이 하드디스크에 안전하게 기록된 상태입니다.

4. **실패(Failed)**: 작업 실행 중에 에러가 발생하여 **더 이상 진행할 수 없는 상태**입니다. 문법 오류, 시스템 문제 등 다양한 이유로 실패할 수 있습니다.

5. **철회(Aborted)**: 실패 후 **Rollback을 수행하여 모든 작업을 취소한 상태**입니다. 작업하기 이전 상태로 완전히 되돌아간 상태입니다.

### 상태 전이 흐름

```
활동(Active) ──→ 부분 완료(Partially Committed) ──→ 완료(Committed)
    │                        │
    │                        │  (저장 실패: 공간 부족, 읽기 전용 등)
    │                        ↓
    └──────────→ 실패(Failed) ──→ 철회(Aborted)
```

:::warning 부분 완료에서 실패로 갈 수 있습니다!
가장 주의해야 할 점은 **부분 완료 상태에서도 실패 상태로 갈 수 있다**는 것입니다. 작업은 다 끝나서 저장 버튼을 눌렀는데, "저장 공간이 부족합니다", "읽기 전용 파일이라 기록할 수 없습니다", "파일 이름이 중복됩니다" 등의 에러가 발생할 수 있기 때문입니다. 하지만 **실패 상태에서 부분 완료 상태로는 갈 수 없습니다.** 흐름은 항상 한 방향입니다.
:::

---

## 💽 데이터 저장 장치와 처리 흐름

### 저장 장치의 3가지 유형

| 유형 | 특징 | 예시 |
|------|------|------|
| **소멸성 저장 장치** | 전원이 꺼지면 데이터 소실 | 메모리(RAM) |
| **비소멸성 저장 장치** | 전원이 꺼져도 데이터 유지 | 하드디스크, USB, SSD |
| **안정성 저장 장치** | 별도로 백업한 안전한 저장소 | 외장하드 백업, 클라우드 백업 |

메모리(RAM)는 속도가 빠르지만 전원이 꺼지면 데이터가 사라지는 **휘발성** 특성을 가집니다. 하드디스크는 전원이 꺼져도 데이터가 유지됩니다. 안정성 저장 장치는 재해나 하드디스크 고장에 대비하여 **별도의 장소에 안전하게 백업해 둔 것**을 말합니다.

### 데이터 처리 흐름: Input → Read → Write → Output

데이터가 처리되는 과정을 이해하려면, 하드디스크 → 메모리 → CPU 사이의 데이터 이동을 알아야 합니다.

```
하드디스크 ←──output──── 메모리 ←──write──── CPU
하드디스크 ────input───→ 메모리 ────read────→ CPU
```

- **Input**: 하드디스크에서 메모리로 데이터를 읽어오는 것
- **Read**: 메모리에서 CPU로 데이터를 읽어오는 것
- **Write**: CPU에서 처리된 결과를 메모리에 기록하는 것
- **Output**: 메모리에서 하드디스크로 데이터를 저장하는 것

:::note 왜 중간에 메모리가 필요한가요?
하드디스크는 속도가 매우 느리고, CPU는 속도가 매우 빠릅니다. 이 둘이 직접 데이터를 주고받으면 속도 차이 때문에 효율이 매우 떨어집니다. **메모리가 중간에서 완충(버퍼) 역할**을 해줍니다. 마치 물류 창고가 공장과 매장 사이에서 물건을 임시로 보관하며 조율하는 것과 같습니다.
:::

### 갱신 방식: 제자리 갱신 vs 간접 갱신

데이터를 수정(갱신)할 때 두 가지 방식이 있습니다.

- **제자리 갱신(In-place Update)**: 원래 데이터가 저장된 **같은 위치에 덮어쓰는** 방식입니다. A라는 데이터가 저장된 자리에 수정된 A를 다시 기록합니다.
- **간접 갱신(Out-of-place Update)**: 원래 위치가 아닌 **다른 위치에 저장하는** 방식입니다. 이 경우 원래 위치의 데이터는 더 이상 필요 없는 **쓰레기(Garbage)**가 됩니다. 이런 쓰레기를 정리하는 것을 **가비지 컬렉션(Garbage Collection, 쓰레기 수집)**이라고 합니다.

---

## ⚠️ 장애의 유형

데이터베이스를 사용하다 보면 다양한 장애가 발생할 수 있습니다. 장애의 유형을 알아야 적절한 회복 전략을 세울 수 있습니다.

### 1. 행동 장애 (Action Failure)

가장 가벼운 수준의 장애입니다. **데이터를 찾을 수 없거나, 무결성 규정을 위반했을 때** 발생합니다.

- 특정 데이터를 조회했는데 해당 데이터가 존재하지 않는 경우
- 기본키(Primary Key)에 NULL 값이 들어가는 경우
- 점수 필드에 0~100 범위만 허용되는데 150이 입력되는 경우
- 학년 필드에 1~6만 허용되는데 7이 입력되는 경우

이런 경우 해당 트랜잭션은 실패하게 됩니다.

### 2. 트랜잭션 장애 (Transaction Failure)

시스템 자원을 과다하게 사용하거나, 입력 데이터 자체가 불량이어서 발생하는 장애입니다.

- 입력 데이터가 불량이어서 아예 입력 자체를 못 받는 상태
- 중간에 데이터가 원치 않게 삭제되어 버리는 경우
- CPU 사용량이 100%까지 치솟거나 메모리가 가득 차서 **시스템이 멈춰버리는(Hang)** 경우

### 3. 시스템 장애 (System Failure)

**하드웨어 고장**으로 인해 발생하는 장애입니다. 전원이 갑자기 꺼지거나, CPU가 고장나거나, 메모리나 그래픽카드가 갑자기 고장나는 경우 등이 해당합니다.

### 4. 미디어 장애 (Media Failure)

데이터베이스 측면에서 **가장 치명적인 장애**입니다. **하드디스크 자체가 붕괴**된 것이기 때문에, 데이터에 직접적인 손실이 발생합니다.

:::danger 미디어 장애는 복구 비용이 가장 높습니다!
시스템 장애는 운영체제를 다시 설치하거나 부품을 교체하면 되지만, 하드디스크가 물리적으로 망가진 경우에는 **데이터 자체가 손실**될 수 있습니다. 복구에 상당히 많은 비용이 들어가므로, 평소에 **백업을 철저히** 해두어야 합니다.
:::

---

## 🛡️ 회복(Recovery)의 기본 원리 — Dump와 Log

### 회복의 기본 전략

회복의 기본 원리는 간단합니다.

1. **Dump(덤프, 백업)**: 장애가 발생하기 이전에 마지막으로 정상적이었던 데이터베이스를 **별도의 안전한 저장 장치에 통째로 복사**해 놓습니다. 우리가 집에서 중요한 파일을 USB, 외장하드, 클라우드에 복사해 놓는 것과 같습니다.

2. **Log(로그) 파일**: Dump 이후에 변경된 내용들을 하나하나 **기록해 놓은 파일**입니다. 어떤 트랜잭션이 어떤 데이터를 어떻게 변경했는지가 자동으로 기록됩니다.

3. **복구 시**: 마지막으로 백업(Dump)한 파일을 불러오고, Log 파일을 참조하여 **변경 사항을 다시 반영(Redo)**하거나 **취소(Undo)**하여 정상 상태로 복구합니다.

### Redo와 Undo 연산

| 연산 | 대상 | 동작 | 방향 | 별칭 |
|------|------|------|------|------|
| **Redo** | Commit이 있는 트랜잭션 | 작업을 다시 수행 | 순방향(Forward) | Forward Recovery |
| **Undo** | Commit이 없는 트랜잭션 | 작업을 취소 | 역방향(Backward) | Backward Recovery |

- **Redo(리두)**: 성공한 트랜잭션(Commit이 있는 것)의 작업을 백업 데이터에 다시 반영하는 것입니다. 마지막 백업 이후에 성공적으로 완료된 작업들을 다시 실행합니다. 앞으로 나아가면서 작업을 수행하므로 **Forward Recovery(순방향 회복)**라고도 부릅니다.
- **Undo(언두)**: 실패한 트랜잭션(Commit이 없는 것)의 작업을 취소하는 것입니다. 이미 반영되어 버린 미완료 작업을 되돌립니다. 뒤로 돌아가면서 작업을 취소하므로 **Backward Recovery(역방향 회복)**라고도 부릅니다.

### Log 파일의 구조

Log 파일은 다음과 같은 정보를 담고 있습니다:

| 구성 요소 | 설명 | 예시 |
|-----------|------|------|
| 트랜잭션 이름 | 어떤 트랜잭션인지 | T1 |
| 데이터 아이템 이름 | 어떤 데이터를 변경했는지 | X |
| 변경 전 값(Old Value) | 변경하기 이전의 값 | 100 |
| 변경 후 값(New Value) | 변경한 이후의 값 | 200 |

Log 레코드의 유형 예시:

```
[T1, start]           -- T1 트랜잭션이 시작됨
[T1, X, 100, 200]     -- T1이 X 값을 100에서 200으로 변경
[T1, commit]           -- T1이 성공적으로 완료됨 (Commit)
```

:::note Log 파일은 매우 클 수 있습니다
100만 개의 데이터를 변경하면 Log 파일에도 100만 줄의 기록이 생깁니다. 레코드 하나하나에 대해 Log가 만들어지기 때문에, Log 파일은 규모가 매우 큰 형태가 됩니다.
:::

---

## 📝 회복 기법 — 지연갱신과 즉시갱신

회복 기법에는 크게 **지연갱신 기법**과 **즉시갱신 기법** 두 가지가 있습니다. 이 두 기법의 차이를 이해하는 것이 매우 중요합니다.

### 🕐 지연갱신 기법 (Deferred Update)

지연갱신 기법은 **Commit 명령을 만나기 전까지는 하드디스크에 전혀 저장하지 않는 방식**입니다. 모든 작업이 **메모리에서만** 처리됩니다.

아래아한글에서 자동 저장 기능 없이 작업하는 것과 같습니다. **저장 버튼(Commit)을 누르기 전까지는 하드디스크에 아무것도 기록되지 않습니다.** 따라서 중간에 에러가 발생하더라도 하드디스크에 반영된 것이 하나도 없으므로, Undo 연산을 수행할 필요가 없습니다.

> **지연갱신 = Commit 전에는 Output(하드디스크 저장)이 지연됨 = No-Steal 방식**

#### 지연갱신의 핵심 원칙

- **Commit이 없는 트랜잭션**: 아무 작업도 수행하지 않음 (Undo 불필요)
- **Commit이 있는 트랜잭션**: Redo 연산 수행

Undo가 필요 없기 때문에, Log 파일에 **이전 값(Old Value)이 필요 없습니다.** 변경 후 값(New Value)만 기록하면 됩니다.

```
-- 지연갱신 기법의 Log 형식 (이전 값 없음)
[T1, X, 150]    -- T1이 X 값을 150으로 변경 (이전 값은 기록하지 않음)
```

:::tip 지연갱신의 장단점
**장점**: Undo 연산이 필요 없어서 회복 로직이 단순합니다.
**단점**: Commit 전까지 모든 데이터가 메모리에 머물러 있어야 하므로 **메모리 공간이 매우 커야** 합니다. 또한 하드디스크에 바로 반영되지 않으므로 다른 사용자가 최신 데이터를 읽을 수 없어 **동시성이 떨어집니다.**
:::

#### 지연갱신 예시

초기 데이터: A = 1000, B = 2000, C = 3000

**예시 1: T1에 Commit이 없는 경우**

```
[T1, start]        -- T1 시작
[T1, A, 900]       -- A를 900으로 변경 (메모리에서만)
[T1, B, 2100]      -- B를 2100으로 변경 (메모리에서만)
-- ⚠️ 여기서 에러 발생! Commit 없음
```

Commit이 없으므로 하드디스크에 반영된 데이터가 없습니다. **아무 작업도 수행할 필요가 없습니다.**

결과: A = 1000, B = 2000, C = 3000 (원래 값 그대로)

**예시 2: T1에 Commit 있고, T2에 Commit 없는 경우**

```
[T1, start]        -- T1 시작
[T1, A, 900]       -- A를 900으로 변경
[T1, B, 2100]      -- B를 2100으로 변경
[T1, commit]        -- T1 성공! ✅
[T2, start]        -- T2 시작
[T2, C, 2800]      -- C를 2800으로 변경
-- ⚠️ 여기서 에러 발생! T2에는 Commit 없음
```

- T1은 Commit이 있으므로 → **Redo 수행** (A를 900으로, B를 2100으로)
- T2는 Commit이 없으므로 → **아무 작업 안 함**

결과: A = 900, B = 2100, C = 3000

**예시 3: T1과 T2 모두 Commit이 있는 경우**

```
[T1, start]        -- T1 시작
[T1, A, 900]       -- A를 900으로 변경
[T1, B, 2100]      -- B를 2100으로 변경
[T1, commit]        -- T1 성공! ✅
[T2, start]        -- T2 시작
[T2, C, 2800]      -- C를 2800으로 변경
[T2, commit]        -- T2 성공! ✅
-- 이후 에러 발생
```

- T1 → **Redo** (A를 900으로, B를 2100으로)
- T2 → **Redo** (C를 2800으로)

결과: A = 900, B = 2100, C = 2800

### ⚡ 즉시갱신 기법 (Immediate Update)

즉시갱신 기법은 지연갱신과 반대로, **Commit 여부와 관계없이 바로바로 하드디스크에 저장하는 방식**입니다. 데이터가 변경되면 즉시 하드디스크에 반영됩니다.

이 방식은 Commit이 없는 트랜잭션의 데이터도 하드디스크에 이미 저장되어 있기 때문에, 회복 시 **Undo 연산이 반드시 필요**합니다.

> **즉시갱신 = Commit 여부와 상관없이 즉시 Output(하드디스크 저장)**

#### 즉시갱신의 핵심 원칙

- **Commit이 없는 트랜잭션**: Undo 연산 수행 (이미 저장된 것을 취소)
- **Commit이 있는 트랜잭션**: Redo 연산 수행

Undo 연산이 필요하므로, Log 파일에 **이전 값(Old Value)과 이후 값(New Value) 모두 기록**해야 합니다.

```
-- 즉시갱신 기법의 Log 형식 (이전 값 + 이후 값 모두 기록)
[T1, A, 1000, 900]    -- T1이 A 값을 1000에서 900으로 변경
```

#### 회복 순서: Undo 먼저, Redo 나중

즉시갱신에서는 Undo해야 할 것과 Redo해야 할 것이 섞여 있을 수 있습니다. 이때 회복 순서가 중요합니다:

1. **먼저 Undo 연산을 역방향(뒤에서부터)으로 수행**하여 미완료 트랜잭션을 전부 취소합니다.
2. **그 다음 Redo 연산을 순방향(앞에서부터)으로 수행**하여 완료된 트랜잭션을 다시 반영합니다.

#### 즉시갱신 예시

초기 데이터: A = 1000, B = 2000, C = 3000

**예시 1: T1에 Commit이 없는 경우**

```
[T1, start]            -- T1 시작
[T1, A, 1000, 900]     -- A를 1000에서 900으로 변경 (즉시 하드디스크에 저장됨!)
[T1, B, 2000, 2100]    -- B를 2000에서 2100으로 변경 (즉시 하드디스크에 저장됨!)
-- ⚠️ 여기서 에러 발생! Commit 없음
```

Commit이 없지만 하드디스크에 이미 900, 2100이 저장되어 있습니다. 따라서 **Undo 연산을 역방향으로 수행**해야 합니다:

1. B를 2100 → 2000으로 되돌림 (역방향이므로 B부터)
2. A를 900 → 1000으로 되돌림

결과: A = 1000, B = 2000, C = 3000 (원래 값으로 복원)

**예시 2: T1에 Commit 있고, T2에 Commit 없는 경우**

```
[T1, start]            -- T1 시작
[T1, A, 1000, 900]     -- A를 1000에서 900으로 변경
[T1, B, 2000, 2100]    -- B를 2000에서 2100으로 변경
[T1, commit]            -- T1 성공! ✅
[T2, start]            -- T2 시작
[T2, C, 3000, 2800]    -- C를 3000에서 2800으로 변경
-- ⚠️ 여기서 에러 발생! T2에는 Commit 없음
```

- T2는 Commit이 없으므로 → **Undo 수행** (C를 2800 → 3000으로 되돌림)
- T1은 Commit이 있으므로 → **Redo 수행** (A를 900으로, B를 2100으로)

결과: A = 900, B = 2100, C = 3000

**예시 3: T1과 T2 모두 Commit이 있는 경우**

```
[T1, start]            -- T1 시작
[T1, A, 1000, 900]     -- A를 1000에서 900으로 변경
[T1, B, 2000, 2100]    -- B를 2000에서 2100으로 변경
[T1, commit]            -- T1 성공! ✅
[T2, start]            -- T2 시작
[T2, C, 3000, 2800]    -- C를 3000에서 2800으로 변경
[T2, commit]            -- T2 성공! ✅
-- 이후 에러 발생
```

- T1 → **Redo** (A를 900으로, B를 2100으로)
- T2 → **Redo** (C를 2800으로)

결과: A = 900, B = 2100, C = 2800

### 지연갱신 vs 즉시갱신 비교

| 구분 | 지연갱신 기법 | 즉시갱신 기법 |
|------|--------------|--------------|
| **하드디스크 저장 시점** | Commit 후에만 저장 | 즉시 저장 |
| **Commit 없는 트랜잭션** | 아무 작업 안 함 | **Undo 수행** |
| **Commit 있는 트랜잭션** | Redo 수행 | Redo 수행 |
| **Log 파일 구성** | 이후 값만 기록 | 이전 값 + 이후 값 모두 기록 |
| **메모리 요구량** | 큼 (Commit 전까지 메모리에 보관) | 상대적으로 작음 |
| **동시성** | 낮음 | 상대적으로 높음 |
| **회복 복잡도** | 단순 (Redo만) | 복잡 (Undo + Redo) |
| **회복 순서** | Redo만 순방향 | Undo 역방향 먼저 → Redo 순방향 |

---

## 📌 핵심 정리

- **트랜잭션**은 더 이상 쪼갤 수 없는 작업의 기본 단위이며, 부분 처리를 허용하지 않는다
- **병행제어**는 여러 사용자가 동시에 DB에 접근할 때 충돌을 방지하는 것이다
- **회복**은 장애 발생 시 데이터베이스를 정상 상태로 복구하는 것이다
- **ACID**는 트랜잭션의 4가지 필수 성질: 원자성(A), 일관성(C), 격리성(I), 영속성(D)
- **원자성**은 가장 중요한 성질로, All or Nothing 원칙을 따른다
- **일관성**은 동일한 조건의 질의에 동일한 결과를 보장하며, 결과의 일관성을 의미한다
- **격리성**은 실행 중인 트랜잭션의 중간 결과에 다른 트랜잭션이 접근하지 못하도록 차단한다
- **영속성**은 성공한 트랜잭션의 결과가 하드디스크에 영구 저장되는 것을 보장한다
- **Commit**은 트랜잭션 성공 시 하드디스크에 영구 저장하는 명령이다
- **Rollback**은 트랜잭션 실패 시 모든 작업을 취소하는 명령이다
- **Redo**는 Commit이 있는 트랜잭션을 다시 수행하는 순방향 회복(Forward Recovery)이다
- **Undo**는 Commit이 없는 트랜잭션을 취소하는 역방향 회복(Backward Recovery)이다
- **지연갱신 기법**은 Commit 전까지 하드디스크 저장을 미루며, Undo가 필요 없다
- **즉시갱신 기법**은 즉시 하드디스크에 저장하며, Undo와 Redo 모두 필요하다
- **장애 유형** 중 미디어 장애(하드디스크 붕괴)가 가장 치명적이며, 평소 백업이 중요하다

작성일: 2026-02-21