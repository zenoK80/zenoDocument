---
title: "트랜잭션의 ACID 특성 개요"
description: "트랜잭션의 ACID 특성 개요에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/transaction-overview-and-recovery/3-acid-properties"
sidebar_label: "ACID 특성"
date: "2026-02-21"
---

## 🎯 트랜잭션이란 무엇인가?

데이터베이스를 다루다 보면 **"트랜잭션(Transaction)"**이라는 단어를 정말 자주 듣게 됩니다. 이 개념은 데이터베이스의 핵심 중 핵심이기 때문에, 정확하게 이해하고 넘어가야 합니다.

### 📖 트랜잭션의 정의

트랜잭션이란 **하나의 논리적 기능을 수행하기 위한 작업의 단위**입니다. 여기서 "작업의 단위"라는 말은 **더 이상 쪼개질 수 없는 가장 작은 단위**를 의미합니다.

> 비유하자면, 마치 레고 블록의 가장 작은 조각과 같습니다. 그 조각 하나를 더 이상 반으로 쪼갤 수 없듯이, 트랜잭션도 하나의 온전한 작업 덩어리로서 쪼개질 수 없습니다.

예를 들어, 한 명의 사용자가 데이터베이스에 **"데이터를 삽입하고 검색하는 작업"**을 요청했다고 합시다. 이 두 작업이 하나의 묶음으로 처리되어야 한다면, 이 묶음 전체가 하나의 트랜잭션이 됩니다. 삽입만 하고 검색은 나중에 하는 식의 **부분적인 처리는 허용되지 않습니다**.

### 🔑 트랜잭션의 핵심 특징

트랜잭션의 가장 중요한 특징은 다음과 같습니다:

- **한꺼번에 모두 수행되거나**, 아니면 **한꺼번에 모두 취소되어야 한다**
- **부분적인 처리는 절대 허용하지 않는다**
- 하나 이상의 데이터베이스 명령어(SQL 연산: INSERT, DELETE, UPDATE, SELECT 등)로 구성된다
- 물리적 개념이 아니라 **논리적 개념의 단위**이다

그리고 우리가 사용하는 **응용 프로그램(Application)**은 여러 개의 트랜잭션들을 모아놓은 것이라고 이해할 수 있습니다.

:::info 트랜잭션이 사용되는 두 가지 핵심 영역
- **병행제어(Concurrency Control)**: 동시에 여러 사용자가 데이터베이스를 사용할 때 충돌이 생기지 않도록 관리하는 것. 마치 하나의 강의실을 여러 교수님이 시간표에 따라 충돌 없이 사용하는 것과 같습니다.
- **회복(Recovery)**: 데이터베이스에 문제가 생겨 고장났을 때, 정상적인 상태로 복구하는 것. 병원에서 치료를 받고 건강한 상태로 돌아오는 것과 같습니다.

이 두 가지 영역 모두에서 **기본 단위가 바로 트랜잭션**입니다.
:::

---

## 🧪 ACID 특성 — 트랜잭션의 4가지 핵심 성질

트랜잭션에는 **ACID**라고 불리는 4가지 핵심 성질이 있습니다. ACID는 각 성질의 영어 앞글자를 따서 만든 약자입니다.

| 약자 | 영어 | 한국어 | 핵심 키워드 |
|------|------|--------|-------------|
| **A** | Atomicity | 원자성 | All or Nothing |
| **C** | Consistency | 일관성 | 동일한 요청 → 동일한 결과 |
| **I** | Isolation | 격리성 | 중간 결과 접근 차단 |
| **D** | Durability | 영속성 | 하드디스크에 영구 저장 |

이 4가지 성질이 **모두 지켜져야만** 데이터의 정확성과 무결성(데이터에 오류가 없는 상태)을 보장할 수 있습니다. 하나씩 자세히 살펴보겠습니다.

---

## ⚛️ 원자성 (Atomicity) — "전부 아니면 전무"

### 원자성이란?

원자성은 ACID 중에서 **가장 중요한 성질**입니다. "원자(Atom)"라는 말은 **더 이상 쪼개질 수 없는 가장 작은 단위**를 의미합니다. 트랜잭션이 원자적이라는 것은, 그 안에 포함된 모든 작업이 **반드시 한꺼번에 완료되거나, 한꺼번에 전부 취소되어야 한다**는 뜻입니다.

> 이것을 영어로 **"All or Nothing"**이라고 표현합니다. 전부 다 하든가(All), 아니면 아무것도 하지 않은 상태로 돌리든가(Nothing)입니다.

### 🏦 은행 이체 예시로 이해하기

가장 쉬운 예시가 **은행 이체**입니다.

A가 B에게 10만 원을 이체한다고 가정해 봅시다. 이 이체 작업은 하나의 트랜잭션입니다.

1. A의 잔액을 조회한다
2. A의 잔액에서 10만 원을 차감한다
3. B의 계좌에 10만 원을 입금한다
4. B의 은행 서버에서 "정상적으로 받았다"는 확인 메시지를 받는다

만약 2번까지만 수행되고, 3번에서 상대방 은행 서버에 문제가 생겨 이체가 안 됐다면 어떻게 될까요? A의 통장에서는 돈이 빠져나갔는데, B의 통장에는 돈이 들어가지 않은 상태가 됩니다. **돈이 공중에서 사라져 버리는 것**이죠!

이런 문제를 방지하기 위해 원자성이 필요합니다. 4번까지 모두 정상적으로 완료되어야만 트랜잭션이 성공(All)하는 것이고, 중간에 하나라도 실패하면 1~2번에서 수행한 작업까지 **전부 취소(Nothing)**시켜야 합니다.

### Commit과 Rollback

원자성을 지키기 위해 두 가지 핵심 명령어가 사용됩니다:

| 명령어 | 의미 | 역할 |
|--------|------|------|
| **COMMIT** | 확정, 저장 | 트랜잭션의 모든 작업을 **성공적으로 완료**하고 결과를 저장 |
| **ROLLBACK** | 되돌리기, 취소 | 트랜잭션 수행 중 오류 발생 시, **모든 작업을 취소**하고 이전 상태로 복구 |

> 비유하자면, **COMMIT**은 한글 워드에서 **저장 버튼**을 누르는 것과 같습니다. 열심히 문서 작업을 한 후 저장 버튼을 눌러야 비로소 하드디스크에 저장되죠. **ROLLBACK**은 저장 버튼을 누르지 않고 프로그램을 닫아버리는 것과 같습니다. 작업했던 내용이 전부 사라집니다.

```sql
-- ✅ 올바른 예시: 이체 작업이 성공한 경우
BEGIN TRANSACTION;  -- 트랜잭션 시작

UPDATE 계좌 SET 잔액 = 잔액 - 100000 WHERE 이름 = 'A';  -- A 통장에서 10만원 차감
UPDATE 계좌 SET 잔액 = 잔액 + 100000 WHERE 이름 = 'B';  -- B 통장에 10만원 입금

COMMIT;  -- 모든 작업이 성공했으므로 확정(저장)
```

```sql
-- ❌ 잘못된 상황: 중간에 오류 발생한 경우
BEGIN TRANSACTION;  -- 트랜잭션 시작

UPDATE 계좌 SET 잔액 = 잔액 - 100000 WHERE 이름 = 'A';  -- A 통장에서 10만원 차감
-- ⚠️ 여기서 B 은행 서버 오류 발생! B 통장에 입금 불가!

ROLLBACK;  -- 오류 발생! A 통장 차감도 전부 취소시켜야 함
```

위 코드를 한 줄씩 살펴보겠습니다:

- `BEGIN TRANSACTION;` → 트랜잭션이 시작됩니다. "지금부터 하나의 작업 묶음을 시작합니다"라고 선언하는 것입니다.
- `UPDATE 계좌 SET 잔액 = 잔액 - 100000 WHERE 이름 = 'A';` → A의 계좌에서 잔액을 10만 원 차감합니다.
- `UPDATE 계좌 SET 잔액 = 잔액 + 100000 WHERE 이름 = 'B';` → B의 계좌에 10만 원을 입금합니다.
- `COMMIT;` → 두 작업 모두 성공했으므로, 이 결과를 확정하여 하드디스크에 영구 저장합니다.
- `ROLLBACK;` → 중간에 오류가 발생했으므로, 이미 수행한 A 통장 차감 작업까지 모두 취소하고 원래 상태로 되돌립니다.

:::warning COMMIT 없이는 저장되지 않습니다
트랜잭션이 성공적으로 완료된 경우에만 COMMIT을 수행할 수 있습니다. 중간에 에러가 발생하면 COMMIT은 절대 수행할 수 없고, 반드시 ROLLBACK만 수행할 수 있습니다.
:::

원자성은 DBMS의 **트랜잭션 관리 컴포넌트(Transaction Management Component)**가 책임지고 관리합니다. 이 원자성이 지켜져야만 데이터의 정확성과 무결성이 완벽하게 보장될 수 있습니다.

---

## 🔄 일관성 (Consistency) — "같은 질문에는 같은 답"

### 일관성이란?

일관성이란 **동일한 조건으로 데이터를 요청하면 반드시 동일한 결과가 돌아와야 한다**는 성질입니다.

예를 들어, 온라인 쇼핑몰에서 상품 A의 가격을 조회했더니 100원이었습니다. 아무도 가격을 변경하지 않았는데, 몇 초 후 다시 조회했더니 200원으로 나온다면 어떨까요? 이것은 **일관성이 깨진 상태**입니다.

> 물론 상품 관리자가 가격을 올리면 당연히 값이 바뀌는 것은 정상입니다. 여기서 말하는 일관성은 **아무런 변경이 없었는데도 결과가 달라지면 안 된다**는 것입니다.

### 실행 중의 일관성 vs 결과의 일관성

중요한 포인트가 있습니다. **실행 중에는 일관성이 일시적으로 무시될 수 있지만, 최종 결과의 일관성은 반드시 보장되어야 합니다.**

덧셈 예시로 설명하겠습니다:

```
1 + 2 + 3 = ?
```

이 계산을 어떤 순서로 하든 결과는 항상 **6**이어야 합니다:

| 계산 순서 | 중간 결과 | 최종 결과 |
|-----------|-----------|-----------|
| (1 + 2) + 3 | 중간: 3 | **6** |
| (2 + 3) + 1 | 중간: 5 | **6** |
| (1 + 3) + 2 | 중간: 4 | **6** |

보시다시피, **중간 결과는 3, 5, 4로 다를 수 있습니다**. 하지만 **최종 결과는 항상 6**입니다. 데이터베이스에서 말하는 일관성은 바로 이 **최종 결과에 대한 일관성**을 의미하는 것입니다.

:::tip 일관성을 지키려면?
일관성이 정확하게 지켜지려면 **프로그램이 올바르게 작성되어야** 합니다. Java, C, Python 등 어떤 언어로 개발하든, 알고리즘에 오류가 없도록 정확하게 프로그래밍해야 실행 결과의 일관성을 보장할 수 있습니다. 즉, 일관성의 책임은 상당 부분 **프로그래머**에게 있습니다.
:::

---

## 🔒 격리성 (Isolation) — "진행 중인 작업은 엿보지 마세요"

### 격리성이란?

격리성이란 **실행 중인 트랜잭션의 중간 결과를 다른 트랜잭션이 접근할 수 없도록 차단하는 것**입니다.

방금 일관성에서 살펴본 것처럼, 중간 결과는 계산 순서에 따라 3이 될 수도 있고 5가 될 수도 있었죠? 만약 한 사용자가 중간 결과 3을 읽어가고, 다른 사용자가 중간 결과 5를 읽어간다면, 두 사용자는 서로 다른 값을 갖게 됩니다. **같은 데이터를 읽었는데 결과가 다른 심각한 문제**가 발생하는 것입니다.

### 🛒 쇼핑몰 예시로 이해하기

온라인 쇼핑몰에서 관리자가 상품 가격을 변경하고 있다고 가정해 봅시다. 상품 등록도 하고, 가격도 수정하는 중입니다. 이때 일반 고객이 접속해서 **변경 중인 가격**으로 주문을 해버리면 어떻게 될까요?

관리자가 아직 가격 수정을 완료하지 않았는데, 중간 상태의 잘못된 가격으로 주문이 들어가 버릴 수 있습니다. 따라서 **관리자가 가격 수정을 완료하고 COMMIT을 누른 후에야** 고객이 해당 상품에 접근할 수 있어야 합니다. 이것이 바로 격리성입니다.

> 비유하자면, 음식점에서 요리사가 요리를 만들고 있을 때, 아직 완성되지 않은 요리를 손님 테이블에 내놓지 않는 것과 같습니다. 요리가 완성되어야(COMMIT) 비로소 손님에게 서빙됩니다.

### Cascading Abort 방지

격리성이 지켜지지 않으면 **연쇄 중단(Cascading Abort)**이라는 심각한 문제가 발생할 수 있습니다.

만약 내가 다른 트랜잭션의 중간 결과를 읽어왔는데, 그 트랜잭션이 에러 때문에 취소(ROLLBACK)되어야 한다면? 내가 읽어온 데이터도 잘못된 것이므로 함께 취소되어야 합니다. 하지만 이미 내 작업이 진행되어 **취소할 수 없는 상황**이 생길 수도 있습니다. 이런 연쇄적인 문제를 방지하기 위해 격리성이 필요합니다.

:::danger 절대 하면 안 되는 것
실행 중인 트랜잭션의 중간 결과를 다른 트랜잭션이 읽어가는 것은 데이터 무결성을 심각하게 훼손합니다. 성공적으로 COMMIT된 결과만 다른 트랜잭션에서 접근할 수 있어야 합니다.
:::

격리성은 DBMS의 **동시성 제어 컴포넌트(Concurrency Control Component)**가 책임지고 관리합니다. 여러 사용자가 동시에 데이터베이스를 사용하더라도 중간 결과에 접근하지 못하도록 막아주는 역할을 합니다.

---

## 💾 영속성 (Durability) — "한번 저장하면 영원히"

### 영속성이란?

영속성이란 **트랜잭션이 성공적으로 완료(COMMIT)되면, 그 결과가 하드디스크에 영구적으로 저장되어 절대 사라지지 않는다**는 성질입니다.

컴퓨터 메모리(RAM)는 **휘발성(전원이 꺼지면 데이터가 사라지는 성질)**을 가지고 있습니다. 만약 트랜잭션 결과가 메모리에만 저장되어 있다면, 컴퓨터를 껐다 켜면 데이터가 전부 사라져 버리겠죠?

> 비유하자면, 메모리는 칠판에 분필로 쓴 글씨와 같습니다. 칠판 지우개로 지우면 바로 사라집니다. 반면 하드디스크는 책에 잉크로 인쇄한 글씨와 같습니다. 책을 닫았다가 다시 펴도 글씨는 그대로 있죠.

따라서 COMMIT 명령을 만나면 데이터가 하드디스크에 저장되어 **영속성(영구적인 보존)**이 보장됩니다. 한글 워드에서 저장 버튼을 눌러야 파일이 하드디스크에 저장되어 컴퓨터를 꺼도 문서가 남아있는 것과 정확히 같은 원리입니다.

영속성은 DBMS의 **회복 관리 컴포넌트(Recovery Management Component)**가 책임지고 관리합니다.

---

## 🔄 트랜잭션의 상태 흐름도

트랜잭션은 시작부터 종료까지 다음과 같은 상태를 거칩니다. 이 흐름을 이해하면 트랜잭션의 전체 생명주기를 파악할 수 있습니다.

### 5가지 상태

| 상태 | 설명 | 비유 |
|------|------|------|
| **활동(Active)** | 트랜잭션이 시작되어 작업이 진행 중인 상태 | 한글에서 문서 작업을 하고 있는 중 |
| **부분 완료(Partially Committed)** | 모든 작업은 끝났지만 아직 COMMIT하지 않은 상태 | 타이핑은 다 끝났고, 저장 버튼만 남은 상태 |
| **완료(Committed)** | COMMIT이 수행되어 하드디스크에 저장된 상태 | 저장 버튼을 눌러 파일이 저장된 상태 |
| **실패(Failed)** | 오류가 발생하여 더 이상 진행할 수 없는 상태 | 작업 중 에러 메시지가 뜬 상태 |
| **철회(Aborted)** | ROLLBACK이 수행되어 모든 작업이 취소된 상태 | 작업 내용이 전부 사라진 상태 |

### 상태 전이 흐름

```
활동(Active)
   │
   ├──→ 부분 완료(Partially Committed) ──→ 완료(Committed) ✅
   │         │
   │         └──→ 실패(Failed) ──→ 철회(Aborted) ❌
   │
   └──→ 실패(Failed) ──→ 철회(Aborted) ❌
```

핵심 포인트를 하나씩 설명하겠습니다:

1. **활동 → 부분 완료**: 작업이 정상적으로 진행되어 마지막 명령문까지 실행된 상태입니다. 저장만 하면 됩니다.
2. **부분 완료 → 완료**: COMMIT 명령을 만나 하드디스크에 성공적으로 저장된 상태입니다.
3. **부분 완료 → 실패**: 작업은 다 끝났지만, 저장(COMMIT)하는 과정에서 오류가 발생한 경우입니다. 예를 들어 저장 공간이 부족하거나, 파일이 읽기 전용이거나, 파일 이름이 중복되는 등의 이유로 저장이 실패할 수 있습니다.
4. **활동 → 실패**: 작업 진행 중에 문법 오류나 시스템 문제 등으로 바로 실패하는 경우입니다.
5. **실패 → 철회**: 실패했기 때문에 COMMIT할 수 없으므로, ROLLBACK을 통해 그동안 했던 작업을 모두 취소합니다.

:::warning 중요한 방향성
실패 상태에서 부분 완료 상태로 돌아갈 수는 **없습니다**. 한번 실패하면 철회(ROLLBACK)만 가능합니다. 화살표는 한 방향으로만 흐릅니다.
:::

---

## 🗄️ 데이터 저장 장치와 데이터 처리 흐름

### 저장 장치의 종류

트랜잭션과 회복을 이해하려면, 데이터가 어디에 저장되는지도 알아야 합니다.

| 종류 | 특성 | 예시 |
|------|------|------|
| **소멸성 저장 장치** | 전원이 꺼지면 데이터 사라짐 | RAM(메모리) |
| **비소멸성 저장 장치** | 전원이 꺼져도 데이터 유지 | 하드디스크, USB, SSD |
| **안정성 저장 장치** | 별도로 백업해서 안전하게 보관 | 백업 디스크, 클라우드 |

### 데이터 처리 흐름: Input → Read → Write → Output

데이터가 처리되는 흐름은 **하드디스크 ↔ 메모리 ↔ CPU** 순서입니다. 하드디스크에서 CPU로 바로 갈 수 없는 이유는, 하드디스크는 속도가 매우 느리고 CPU는 매우 빠르기 때문에 **중간에 완충 역할을 하는 메모리(버퍼)**가 필요하기 때문입니다.

```
하드디스크  ──(Input)──▶  메모리  ──(Read)──▶  CPU
하드디스크  ◀──(Output)──  메모리  ◀──(Write)──  CPU
```

| 연산 | 방향 | 설명 |
|------|------|------|
| **Input** | 하드디스크 → 메모리 | 하드디스크에서 데이터를 메모리로 읽어옴 |
| **Read** | 메모리 → CPU | 메모리에서 데이터를 CPU로 읽어와서 처리 |
| **Write** | CPU → 메모리 | CPU에서 처리된 결과를 메모리에 기록 |
| **Output** | 메모리 → 하드디스크 | 메모리의 데이터를 하드디스크에 영구 저장 |

### 갱신 방식: 제자리 갱신 vs 간접 갱신

데이터를 수정(갱신)할 때 두 가지 방식이 있습니다:

- **제자리 갱신(In-place Update)**: 원래 데이터가 있던 **같은 자리**에 새 데이터를 덮어쓰는 방식
- **간접 갱신(Out-of-place Update)**: 원래 위치가 아닌 **다른 곳**에 새 데이터를 저장하는 방식. 이 경우 원래 자리의 데이터는 쓰레기(Garbage)가 되며, 이를 정리하는 작업을 **가비지 컬렉션(Garbage Collection, 쓰레기 수집)**이라고 합니다.

---

## 🚨 장애의 유형

데이터베이스를 운영하다 보면 다양한 장애가 발생할 수 있습니다. 장애의 유형을 알아야 적절한 회복 전략을 세울 수 있습니다.

| 장애 유형 | 설명 | 심각도 |
|-----------|------|--------|
| **행동 장애** | 데이터를 찾지 못하거나 무결성 규정을 위반 (NULL 불가 필드에 NULL 입력, 0~100 범위에 150 입력 등) | 낮음 |
| **트랜잭션 장애** | 시스템 자원 과다 사용, 입력 데이터 불량, 원치 않는 데이터 삭제, CPU/메모리 100% 도달로 시스템 멈춤 | 중간 |
| **시스템 장애** | 전원 차단, CPU·메모리·그래픽카드 등 하드웨어 고장 | 높음 |
| **미디어 장애** | 하드디스크 자체가 물리적으로 손상 — **가장 치명적**. 데이터 직접 손실 발생, 복구 비용 매우 큼 | 매우 높음 |

:::danger 미디어 장애는 최악의 시나리오입니다
시스템 장애는 운영체제를 다시 설치하거나 부품을 교체하면 되지만, 하드디스크가 물리적으로 손상되면 **데이터 자체가 직접적으로 손실**됩니다. 복구 비용이 매우 많이 들기 때문에, 평소에 **백업을 철저하게** 관리해야 합니다.
:::

---

## 🔧 회복의 기본 원리 — Dump와 Log

### 회복이란?

회복(Recovery)이란 **장애로 인해 손상된 데이터베이스를, 손상되기 이전의 정상 상태로 복구시키는 것**입니다.

> 비유하자면, 우리가 아프면 병원에 가서 치료를 받고 건강한 상태로 돌아오는 것과 같습니다.

### 회복의 두 가지 핵심 도구

| 도구 | 설명 | 비유 |
|------|------|------|
| **Dump(덤프, 백업)** | 마지막으로 성공한 시점의 데이터베이스 전체를 별도의 안전한 저장 장치에 복사해두는 것 | USB에 중요한 파일을 백업해두는 것 |
| **Log(로그) 파일** | 덤프 이후 발생한 모든 데이터 변경 사항을 하나하나 자동으로 기록해놓은 파일 | 일기장에 매일 무슨 일이 있었는지 기록하는 것 |

회복 과정은 다음과 같습니다:

1. 마지막에 백업(Dump)해둔 데이터베이스를 불러온다
2. 그 이후의 Log 파일을 참고하여 변경 사항을 반영한다
3. COMMIT이 있는 트랜잭션은 **Redo(재실행)**하고, COMMIT이 없는 트랜잭션은 **Undo(취소)**한다

### Redo와 Undo 연산

| 연산 | 의미 | 적용 대상 | 방향 | 별칭 |
|------|------|-----------|------|------|
| **Redo** | 다시 실행 | COMMIT이 있는 트랜잭션 | 순방향(Forward) | Forward Recovery |
| **Undo** | 취소, 되돌리기 | COMMIT이 없는 트랜잭션 | 역방향(Backward) | Backward Recovery |

> 쉽게 기억하세요: **COMMIT 있으면 Redo, COMMIT 없으면 Undo**

### Log 파일의 구조

Log 파일은 다음과 같은 정보를 기록합니다:

| 항목 | 설명 | 예시 |
|------|------|------|
| 트랜잭션 이름 | 어떤 트랜잭션인지 | T1 |
| 데이터 아이템 이름 | 어떤 데이터가 변경됐는지 | X |
| 변경 전 값 | 원래 값 | 100 |
| 변경 후 값 | 바뀐 값 | 200 |

```
-- Log 레코드 예시
[T1, start]           -- T1 트랜잭션 시작
[T1, X, 100, 200]     -- T1이 X 값을 100에서 200으로 변경
[T1, commit]           -- T1 트랜잭션 성공적 완료
```

- `[T1, start]` → 트랜잭션 T1이 시작되었다는 표시입니다.
- `[T1, X, 100, 200]` → T1이 데이터 X를 100에서 200으로 변경했다는 기록입니다. 이전 값(100)은 Undo용, 이후 값(200)은 Redo용으로 사용됩니다.
- `[T1, commit]` → T1이 성공적으로 완료되었다는 표시입니다. 이 기록이 있으면 Redo, 없으면 Undo를 수행합니다.

:::note Log 파일의 크기
만약 100만 건의 데이터를 변경하면, Log 파일에 100만 줄이 생깁니다. 레코드 하나하나에 대해 기록이 만들어지기 때문에, Log 파일은 엄청나게 큰 규모가 될 수 있습니다.
:::

---

## 📊 회복 기법: 지연 갱신 vs 즉시 갱신

회복을 수행하는 방법에는 크게 두 가지가 있습니다. **지연 갱신 기법**과 **즉시 갱신 기법**입니다. 이 두 기법의 차이를 정확히 이해하는 것이 매우 중요합니다.

### 📋 지연 갱신 기법 (Deferred Update)

지연 갱신 기법은 **COMMIT 명령을 만나기 전까지는 하드디스크에 절대 저장하지 않고, 메모리에서만 작업하는 방식**입니다.

> 비유하자면, 한글 워드에서 **자동 저장 기능이 없는 상태**와 같습니다. 아무리 열심히 작업해도 저장 버튼(COMMIT)을 누르기 전까지는 하드디스크에 아무것도 반영되지 않습니다.

**핵심 특징:**

- COMMIT 전까지 Output(메모리 → 하드디스크) 연산이 **지연**됩니다 (No-Steal 방식)
- 에러 발생 시 하드디스크에 반영된 것이 **하나도 없으므로**, Undo 연산이 **필요 없습니다**
- COMMIT이 있는 트랜잭션만 **Redo** 수행, COMMIT이 없는 것은 **아무 작업도 하지 않음**
- Log 파일에 **이전 값이 필요 없고**, 이후 값만 기록합니다 (Undo할 일이 없으니까)

| 상황 | 처리 방법 |
|------|-----------|
| COMMIT 있음 | Redo 수행 ✅ |
| COMMIT 없음 | 아무것도 안 함 (Undo 불필요) ⏭️ |

**단점:**
- 메모리에 모든 데이터가 머무르기 때문에 **메모리 공간이 매우 커야** 합니다
- 바로 저장되지 않으므로 **다른 사용자가 최신 데이터를 즉시 읽을 수 없어** 동시성이 떨어집니다

### 🔍 지연 갱신 기법 예제

초기 값: A = 1000, B = 2000, C = 3000

**예제 1: COMMIT 없이 에러 발생**

```
[T1, start]          -- T1 트랜잭션 시작
[T1, A, 900]         -- A 값을 900으로 변경 (이후 값만 기록)
[T1, B, 2100]        -- B 값을 2100으로 변경
-- ⚠️ 여기서 에러 발생! COMMIT 없음!
```

- `[T1, start]` → T1 시작
- `[T1, A, 900]` → A를 900으로 변경했지만, 메모리에서만 변경된 것이고 하드디스크에는 반영되지 않았습니다
- `[T1, B, 2100]` → B를 2100으로 변경했지만, 역시 메모리에서만 변경된 상태입니다
- COMMIT이 없으므로 하드디스크에는 **아무것도 저장되지 않았습니다**

**결과:** 회복할 필요 없음! 원래 값 그대로 A = 1000, B = 2000, C = 3000

**예제 2: T1은 COMMIT 있음, T2는 COMMIT 없음**

```
[T1, start]          -- T1 시작
[T1, A, 900]         -- A를 900으로 변경
[T1, B, 2100]        -- B를 2100으로 변경
[T1, commit]         -- T1 성공적 완료 ✅
[T2, start]          -- T2 시작
[T2, C, 2800]        -- C를 2800으로 변경
-- ⚠️ 여기서 에러 발생! T2에 COMMIT 없음!
```

- T1은 COMMIT이 있으므로 → **Redo 수행**: A = 900, B = 2100
- T2는 COMMIT이 없으므로 → **아무 작업도 안 함**: C = 3000 (원래 값 유지)

**결과:** A = 900, B = 2100, C = 3000

**예제 3: T1도 COMMIT, T2도 COMMIT**

```
[T1, start]          -- T1 시작
[T1, A, 900]         -- A를 900으로 변경
[T1, B, 2100]        -- B를 2100으로 변경
[T1, commit]         -- T1 성공 ✅
[T2, start]          -- T2 시작
[T2, C, 2800]        -- C를 2800으로 변경
[T2, commit]         -- T2 성공 ✅
-- ⚠️ 이후 에러 발생
```

- T1 COMMIT 있음 → **Redo**: A = 900, B = 2100
- T2 COMMIT 있음 → **Redo**: C = 2800

**결과:** A = 900, B = 2100, C = 2800

:::tip 지연 갱신 기법 요약
**COMMIT 있으면 Redo, COMMIT 없으면 아무것도 안 함.** 이것만 기억하면 됩니다!
:::

---

### 📋 즉시 갱신 기법 (Immediate Update)

즉시 갱신 기법은 **COMMIT 여부와 관계없이 데이터가 바로바로 하드디스크에 반영되는 방식**입니다.

> 비유하자면, 한글 워드에서 **자동 저장 기능이 켜져 있는 상태**와 같습니다. 타이핑하는 즉시 하드디스크에 저장됩니다. 문제는 잘못 작성한 내용도 바로 저장되어 버린다는 점입니다.

**핵심 특징:**

- COMMIT 여부와 관계없이 **즉시 하드디스크에 저장(Output)**됩니다
- COMMIT이 없는 트랜잭션은 이미 하드디스크에 반영되었으므로 **Undo(취소)**해야 합니다
- COMMIT이 있는 트랜잭션은 **Redo(재실행)**합니다
- Log 파일에 **이전 값과 이후 값 모두** 기록합니다 (Undo를 위해 이전 값이 필요)
- 회복 시 **Undo를 먼저 역방향**으로 수행하고, 그 다음 **Redo를 순방향**으로 수행합니다

| 상황 | 처리 방법 |
|------|-----------|
| COMMIT 있음 | Redo 수행 ✅ |
| COMMIT 없음 | Undo 수행 (취소) ↩️ |

**회복 순서:** Undo(역방향, 뒤에서부터) → Redo(순방향, 앞에서부터)

### 🔍 즉시 갱신 기법 예제

초기 값: A = 1000, B = 2000, C = 3000

**예제 1: COMMIT 없이 에러 발생**

```
[T1, start]              -- T1 시작
[T1, A, 1000, 900]       -- A를 1000에서 900으로 변경 (이전값, 이후값 모두 기록)
[T1, B, 2000, 2100]      -- B를 2000에서 2100으로 변경
-- ⚠️ 에러 발생! COMMIT 없음!
```

- `[T1, A, 1000, 900]` → A 값이 1000에서 900으로 변경되었고, **이미 하드디스크에 반영**되었습니다
- `[T1, B, 2000, 2100]` → B 값이 2000에서 2100으로 변경되었고, **이미 하드디스크에 반영**되었습니다
- COMMIT이 없으므로 **Undo** 수행: 역방향으로 B를 2100 → 2000으로, A를 900 → 1000으로 원래대로 되돌림

**결과:** A = 1000, B = 2000, C = 3000 (원래 값으로 복구)

**예제 2: T1은 COMMIT 있음, T2는 COMMIT 없음**

```
[T1, start]              -- T1 시작
[T1, A, 1000, 900]       -- A를 1000에서 900으로 변경
[T1, B, 2000, 2100]      -- B를 2000에서 2100으로 변경
[T1, commit]             -- T1 성공 ✅
[T2, start]              -- T2 시작
[T2, C, 3000, 2800]      -- C를 3000에서 2800으로 변경
-- ⚠️ 에러 발생! T2에 COMMIT 없음!
```

- T1은 COMMIT 있음 → **Redo**: A = 900, B = 2100
- T2는 COMMIT 없음 → **Undo**: C를 2800에서 다시 3000으로 되돌림

**결과:** A = 900, B = 2100, C = 3000

**예제 3: T1도 COMMIT, T2도 COMMIT**

```
[T1, start]              -- T1 시작
[T1, A, 1000, 900]       -- A를 1000에서 900으로 변경
[T1, B, 2000, 2100]      -- B를 2000에서 2100으로 변경
[T1, commit]             -- T1 성공 ✅
[T2, start]              -- T2 시작
[T2, C, 3000, 2800]      -- C를 3000에서 2800으로 변경
[T2, commit]             -- T2 성공 ✅
-- ⚠️ 이후 에러 발생
```

- T1 COMMIT 있음 → **Redo**: A = 900, B = 2100
- T2 COMMIT 있음 → **Redo**: C = 2800

**결과:** A = 900, B = 2100, C = 2800

### 지연 갱신 vs 즉시 갱신 비교

| 비교 항목 | 지연 갱신 | 즉시 갱신 |
|-----------|-----------|-----------|
| 하드디스크 반영 시점 | COMMIT 후에만 반영 | 즉시 반영 |
| COMMIT 없는 트랜잭션 | 아무것도 안 함 | **Undo 수행** |
| COMMIT 있는 트랜잭션 | Redo 수행 | Redo 수행 |
| Log에 이전 값 필요? | ❌ 불필요 | ✅ 필요 |
| Undo 연산 필요? | ❌ 불필요 | ✅ 필요 |
| 메모리 부담 | 큼 (모든 작업이 메모리에 머무름) | 작음 |
| 동시성 | 낮음 | 높음 |
| 회복 순서 | Redo만 수행 | Undo 먼저 → Redo 나중에 |

:::tip 두 기법의 핵심 차이를 한 문장으로
**지연 갱신**은 "저장 안 했으니 취소할 것도 없다 → Undo 불필요", **즉시 갱신**은 "이미 저장됐으니 잘못된 건 취소해야 한다 → Undo 필요"입니다.
:::

---

## 📌 핵심 정리

- **트랜잭션**은 더 이상 쪼갤 수 없는 논리적 작업의 최소 단위이며, 부분적 처리를 허용하지 않는다
- **원자성(Atomicity)**: All or Nothing — 전부 성공(COMMIT)하거나 전부 취소(ROLLBACK)해야 한다
- **일관성(Consistency)**: 동일한 요청에는 항상 동일한 최종 결과가 보장되어야 한다
- **격리성(Isolation)**: 실행 중인 트랜잭션의 중간 결과에 다른 트랜잭션이 접근할 수 없다
- **영속성(Durability)**: COMMIT된 결과는 하드디스크에 영구적으로 저장되어 사라지지 않는다
- **COMMIT**은 트랜잭션의 성공적 완료(저장), **ROLLBACK**은 실패 시 모든 작업 취소(되돌리기)
- 트랜잭션 상태 흐름: 활동 → 부분 완료 → 완료(COMMIT) 또는 실패 → 철회(ROLLBACK)
- 회복 시 COMMIT이 있으면 **Redo**(재실행), COMMIT이 없으면 **Undo**(취소)
- **지연 갱신 기법**: COMMIT 전까지 하드디스크 반영을 미룸 → Undo 불필요, Redo만 수행
- **즉시 갱신 기법**: 즉시 하드디스크에 반영 → Undo와 Redo 모두 수행 (Undo 먼저, Redo 나중)
- **Dump(백업)**와 **Log 파일**은 데이터베이스 회복의 핵심 도구이다
- 장애 유형 중 **미디어 장애**(하드디스크 손상)가 가장 치명적이므로 백업 관리가 필수적이다

작성일: 2026-02-21