---
title: "COMMIT과 ROLLBACK 명령어"
description: "COMMIT과 ROLLBACK 명령어에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/transaction-overview-and-recovery/4-commit-and-rollback"
sidebar_label: "COMMIT과 ROLLBACK"
date: "2026-02-21"
---

## 🎯 트랜잭션이란 무엇인가?

데이터베이스를 공부하다 보면 **트랜잭션(Transaction)**이라는 단어를 정말 자주 만나게 됩니다. 트랜잭션은 데이터베이스에서 가장 핵심적인 개념 중 하나인데, 처음 들으면 다소 추상적으로 느껴질 수 있습니다. 하나씩 차근차근 풀어보겠습니다.

**트랜잭션**이란 **하나의 논리적 기능을 수행하기 위한 작업의 단위**를 말합니다. 여기서 핵심은 "더 이상 쪼갤 수 없는 단위"라는 점입니다. 마치 원자(atom)가 물질을 구성하는 가장 작은 단위인 것처럼, 트랜잭션은 데이터베이스 작업을 구성하는 가장 작은 논리적 단위입니다.

### 🏦 실생활 비유: 은행 이체

가장 이해하기 쉬운 예시가 **은행 이체**입니다. 여러분이 A 계좌에서 B 계좌로 10만 원을 이체한다고 생각해 보세요. 이 작업은 내부적으로 두 가지 단계로 이루어집니다.

1. A 계좌에서 10만 원을 **차감**한다
2. B 계좌에 10만 원을 **추가**한다

이 두 단계는 반드시 **함께 성공하거나, 함께 취소**되어야 합니다. 만약 A 계좌에서 돈은 빠져나갔는데 B 계좌에 돈이 들어가지 않았다면 어떻게 될까요? 돈이 허공에서 사라져 버리는 끔찍한 일이 벌어집니다. 그래서 이 두 단계를 하나의 "쪼갤 수 없는 작업 단위", 즉 **트랜잭션**으로 묶어서 처리하는 것입니다.

> **트랜잭션 = 한꺼번에 모두 성공하거나, 한꺼번에 모두 취소되어야 하는 작업 묶음**

### 📦 트랜잭션과 응용 프로그램의 관계

하나의 트랜잭션은 **하나 이상의 데이터베이스 명령어**(INSERT, UPDATE, DELETE, SELECT 등)로 구성됩니다. 예를 들어, "데이터를 삽입하고 검색하는 작업"이 하나의 트랜잭션이 될 수 있습니다. 그리고 **응용 프로그램**은 이런 트랜잭션 여러 개를 모아놓은 것이라고 이해하면 됩니다.

또한 트랜잭션은 물리적 개념이 아니라 **논리적 개념의 단위**입니다. 실제 컴퓨터 하드웨어와는 관계없이, 우리가 "이 작업은 하나의 묶음이야"라고 논리적으로 정의한 것이 트랜잭션인 셈입니다.

---

## 🧬 트랜잭션의 ACID 성질

트랜잭션이 올바르게 동작하기 위해 반드시 지켜야 하는 네 가지 성질이 있습니다. 이 네 가지의 앞글자를 따서 **ACID**라고 부릅니다. 데이터베이스 시험에도 자주 나오고, 실무에서도 매우 중요한 개념이니 꼭 이해해 두세요.

| 성질 | 영문 | 핵심 의미 | 책임 컴포넌트 |
|------|------|-----------|---------------|
| **원자성** | Atomicity | 전부 성공 또는 전부 취소 | 트랜잭션 관리 컴포넌트 |
| **일관성** | Consistency | 실행 전후 데이터 일관성 유지 | 응용 프로그램 (올바른 알고리즘) |
| **격리성** | Isolation | 중간 결과에 다른 트랜잭션 접근 불가 | 동시성 제어 컴포넌트 |
| **영속성** | Durability | 성공한 결과는 영구 저장 | 회복 관리 컴포넌트 |

### ⚛️ 원자성 (Atomicity) — 가장 중요한 성질

원자성은 ACID 중에서 **가장 중요한 성질**입니다. "원자"라는 이름에서 알 수 있듯이, 트랜잭션은 더 이상 쪼갤 수 없는 하나의 단위로 취급됩니다.

**All or Nothing** — 이 한마디로 원자성을 설명할 수 있습니다. 트랜잭션 안의 모든 작업이 **한꺼번에 전부 완료(All)**되거나, 하나라도 실패하면 **전부 취소(Nothing)**되어야 합니다. **부분적인 처리는 절대 허용되지 않습니다.**

은행 이체 예시로 돌아가 볼까요? A 계좌에서 돈이 빠져나가고, B 계좌로 이체 요청을 보냈는데 상대방 은행 서버에 문제가 생겨서 B 계좌에 돈이 들어가지 않았습니다. 이때 원자성이 지켜진다면, A 계좌에서 빠져나간 돈도 **다시 원래대로 복구**됩니다. 상대방 서버까지 포함해서 전체 작업이 하나의 트랜잭션이기 때문에, 중간에 하나라도 실패하면 모든 것이 원상복구 되는 것입니다.

> 원자성이 지켜져야만 데이터의 정확성과 무결성이 완벽하게 보장될 수 있습니다.

이 원자성을 구현하기 위해 사용하는 두 가지 핵심 명령어가 바로 오늘의 주인공인 **COMMIT**과 **ROLLBACK**입니다.

### 🔄 일관성 (Consistency)

일관성은 **동일한 조건으로 조회하면 항상 동일한 결과**가 나와야 한다는 성질입니다. 예를 들어, 어떤 상품의 가격이 100원인데, 아무도 가격을 변경하지 않았는데 다음 번 조회 시 200원이 나온다면 이것은 일관성이 깨진 것입니다.

여기서 중요한 포인트가 하나 있습니다. **실행 중간의 일관성은 무시해도 됩니다.** 비유하자면, 1+2+3을 계산할 때 (1+2)+3으로 계산하든, (2+3)+1로 계산하든 중간 결과는 다를 수 있지만, **최종 결과는 항상 6**이어야 합니다. 데이터베이스에서 말하는 일관성은 바로 이 **최종 결과의 일관성**을 의미합니다.

일관성을 보장하려면 **프로그램(알고리즘)이 올바르게 작성**되어야 합니다. 아무리 DBMS가 훌륭해도, 프로그램 자체에 버그가 있으면 일관성은 깨질 수 있습니다.

### 🔒 격리성 (Isolation)

격리성은 **실행 중인 트랜잭션의 중간 결과에 다른 트랜잭션이 접근할 수 없도록 차단**하는 성질입니다.

아까 1+2+3 예시에서, 중간 결과가 3일 수도 있고 5일 수도 있다고 했습니다. 만약 다른 사용자가 이 중간 결과를 읽어간다면, 누군가는 3을 읽고 누군가는 5를 읽어서 서로 다른 값을 가지게 됩니다. 이런 문제를 방지하려면, **트랜잭션이 완전히 성공(COMMIT)한 후에만** 다른 트랜잭션이 그 결과에 접근할 수 있어야 합니다.

실생활 예시를 들어볼까요? 쇼핑몰 관리자가 지금 한창 상품 가격을 수정하고 있습니다. 이 수정 작업이 아직 끝나지 않은 상태(COMMIT 되지 않은 상태)에서 고객이 그 상품을 주문하면 안 되겠죠. 가격 변경 작업이 완료된 후에야 고객이 새로운 가격을 볼 수 있어야 합니다. 이것이 바로 격리성입니다.

격리성이 지켜지지 않으면 **연쇄 취소(Cascading Abort)** 문제가 발생할 수 있습니다. 내가 읽어온 중간 결과가 나중에 취소되면, 그 값을 기반으로 한 내 작업도 취소해야 하는데, 이미 취소가 불가능한 상황이 생길 수 있기 때문입니다.

### 💾 영속성 (Durability)

영속성은 **성공적으로 완료된 트랜잭션의 결과는 영구적으로 보존**되어야 한다는 성질입니다. 마치 중요한 문서를 USB에 저장해두면 컴퓨터를 꺼도 파일이 남아있는 것처럼, COMMIT된 데이터는 하드디스크에 저장되어 시스템이 꺼져도 사라지지 않아야 합니다.

만약 성공한 결과가 메모리(RAM)에만 저장되어 있다면, 컴퓨터 전원이 꺼지는 순간 모든 데이터가 날아가 버립니다. 메모리는 **휘발성(전원이 꺼지면 데이터가 사라지는 성질)**이기 때문입니다. 영속성은 이런 문제를 방지하기 위해, 성공한 트랜잭션의 결과를 반드시 **비휘발성 저장 장치(하드디스크 등)**에 기록하도록 보장합니다.

---

## 🔑 COMMIT 명령어 — 성공의 확인 도장

### 왜 COMMIT이 필요한가?

여러분이 한글(아래아 한글)이나 워드에서 문서 작업을 열심히 했다고 상상해 보세요. 화면에 글자가 가득 채워져 있고, 모든 편집이 끝났습니다. 그런데 아직 **저장 버튼**을 누르지 않았습니다. 이 상태에서 갑자기 컴퓨터 전원이 꺼지면 어떻게 될까요? 그동안 작업한 모든 내용이 한순간에 사라져 버립니다.

데이터베이스에서도 마찬가지입니다. INSERT, UPDATE, DELETE 등 아무리 많은 작업을 수행해도, **COMMIT 명령을 실행하기 전까지는 그 작업이 "확정"된 것이 아닙니다.** COMMIT은 마치 문서 편집기의 "저장 버튼"과 같은 역할을 합니다.

### COMMIT의 정의와 역할

**COMMIT**은 트랜잭션이 **성공적으로 종료**되었음을 데이터베이스에 알려주는 명령어입니다. COMMIT 명령을 실행하면 다음과 같은 일이 일어납니다:

1. 그동안 수행한 모든 작업(INSERT, UPDATE, DELETE 등)이 **하드디스크에 영구적으로 저장**됩니다
2. 해당 트랜잭션이 **완료 상태**로 전환됩니다
3. 다른 트랜잭션이 이 결과에 **접근할 수 있게** 됩니다
4. **새로운 트랜잭션**을 시작할 수 있게 됩니다

> COMMIT = 트랜잭션의 성공적 완료 = 하드디스크에 영구 저장 = 영속성 보장

### COMMIT 사용 예시

```sql
-- ✅ 올바른 예시: COMMIT을 사용한 트랜잭션 완료
BEGIN TRANSACTION;  -- 트랜잭션 시작

INSERT INTO 주문 (고객ID, 상품명, 수량) 
VALUES (1001, '노트북', 1);  -- 주문 데이터 삽입

UPDATE 재고 
SET 수량 = 수량 - 1 
WHERE 상품명 = '노트북';  -- 재고 차감

COMMIT;  -- 모든 작업이 성공했으므로 확정(저장)!
```

위 코드를 한 줄씩 살펴보겠습니다:

- `BEGIN TRANSACTION;` — 새로운 트랜잭션을 시작합니다. "지금부터 하나의 작업 묶음이 시작됩니다"라고 데이터베이스에 알려주는 것입니다.
- `INSERT INTO 주문 ...` — 주문 테이블에 새로운 주문 데이터를 삽입합니다. 아직 COMMIT 전이므로, 이 데이터는 확정된 것이 아닙니다.
- `UPDATE 재고 ...` — 재고 테이블에서 해당 상품의 수량을 1 줄입니다. 역시 아직 COMMIT 전이라 확정되지 않은 상태입니다.
- `COMMIT;` — **이 순간** 위의 INSERT와 UPDATE가 모두 하드디스크에 영구 저장됩니다. 트랜잭션이 성공적으로 완료된 것입니다.

```sql
-- ❌ 잘못된 예시: COMMIT 없이 트랜잭션을 끝내는 경우
BEGIN TRANSACTION;  -- 트랜잭션 시작

INSERT INTO 주문 (고객ID, 상품명, 수량) 
VALUES (1001, '노트북', 1);  -- 주문 데이터 삽입

UPDATE 재고 
SET 수량 = 수량 - 1 
WHERE 상품명 = '노트북';  -- 재고 차감

-- COMMIT을 하지 않음! 
-- 이 상태에서 시스템이 종료되면 위의 작업은 모두 사라짐
```

:::warning COMMIT을 빼먹으면 벌어지는 일
COMMIT 없이 트랜잭션을 종료하면, 그동안 수행한 모든 작업이 **반영되지 않습니다.** 마치 문서를 열심히 작성하고 저장 버튼을 누르지 않은 채 컴퓨터를 꺼버린 것과 같습니다. COMMIT은 반드시 트랜잭션의 모든 작업이 **성공적으로 완료된 후에만** 실행해야 합니다.
:::

### COMMIT의 핵심 규칙

- COMMIT은 **성공적으로 완료된 경우에만** 실행할 수 있습니다
- 중간에 에러가 발생하면 COMMIT을 **실행할 수 없습니다**
- COMMIT이 실행되면 해당 트랜잭션은 **완료 상태**가 되고, 이후 새로운 트랜잭션을 시작할 수 있습니다

---

## 🔙 ROLLBACK 명령어 — 실수를 되돌리는 타임머신

### 왜 ROLLBACK이 필요한가?

현실 세계에서는 실수를 되돌리기 어렵지만, 데이터베이스 세계에서는 가능합니다! 트랜잭션을 실행하다가 중간에 에러가 발생하면 어떻게 해야 할까요? 이미 일부 작업은 실행되었는데, 나머지 작업은 실행되지 않은 상태입니다. 이때 **부분적으로만 처리된 상태를 그대로 두면 안 됩니다.** 원자성(All or Nothing)에 따라, 실패한 트랜잭션의 모든 작업을 **처음 상태로 되돌려야** 합니다.

이 "되돌리기" 역할을 하는 것이 바로 **ROLLBACK** 명령어입니다.

### ROLLBACK의 정의와 역할

**ROLLBACK**은 트랜잭션이 **비정상적으로 종료**되었을 때, 그동안 수행한 모든 작업을 **취소하고 이전 상태로 복구**하는 명령어입니다. 마치 게임에서 "되돌리기" 버튼을 누르면 이전 세이브 포인트로 돌아가는 것처럼, ROLLBACK은 데이터베이스를 트랜잭션 시작 전 상태로 되돌립니다.

ROLLBACK이 실행되면 다음과 같은 일이 일어납니다:

1. 그동안 수행한 모든 작업(INSERT, UPDATE, DELETE 등)이 **전부 취소**됩니다
2. 데이터베이스가 **트랜잭션 시작 전 상태**로 복원됩니다
3. 해당 트랜잭션이 **철회 상태**로 전환됩니다

이렇게 작업을 취소하는 것을 **Undo(언두)**라고도 부릅니다.

> ROLLBACK = 트랜잭션의 비정상 종료 = 모든 작업 취소 = 이전 상태로 복구

### ROLLBACK 사용 예시

```sql
-- ✅ 올바른 예시: 에러 발생 시 ROLLBACK으로 안전하게 취소
BEGIN TRANSACTION;  -- 트랜잭션 시작

INSERT INTO 주문 (고객ID, 상품명, 수량) 
VALUES (1001, '노트북', 1);  -- 주문 데이터 삽입 (성공)

UPDATE 재고 
SET 수량 = 수량 - 1 
WHERE 상품명 = '노트북';  -- 재고 차감 시도 중 에러 발생!

-- 에러가 발생했으므로 COMMIT 대신 ROLLBACK 실행
ROLLBACK;  -- 위의 INSERT도 함께 취소됨! 주문 데이터도 사라짐
```

위 코드를 한 줄씩 살펴보겠습니다:

- `BEGIN TRANSACTION;` — 트랜잭션을 시작합니다.
- `INSERT INTO 주문 ...` — 주문 데이터를 삽입합니다. 이 단계는 성공했습니다.
- `UPDATE 재고 ...` — 재고를 차감하려는데, 여기서 에러가 발생했습니다. (예: 재고 테이블이 잠겨 있거나, 수량이 이미 0이거나 등)
- `ROLLBACK;` — 에러가 발생했으므로 COMMIT을 할 수 없습니다. ROLLBACK을 실행하여 **이미 성공한 INSERT 작업까지 포함해서 전부 취소**합니다. 데이터베이스는 트랜잭션 시작 전 상태로 돌아갑니다.

```sql
-- ❌ 잘못된 예시: 에러 발생 후에도 COMMIT을 시도하는 경우
BEGIN TRANSACTION;  -- 트랜잭션 시작

INSERT INTO 주문 (고객ID, 상품명, 수량) 
VALUES (1001, '노트북', 1);  -- 주문은 삽입됨

UPDATE 재고 
SET 수량 = 수량 - 1 
WHERE 상품명 = '노트북';  -- 에러 발생!

COMMIT;  -- ❌ 에러가 발생한 상태에서 COMMIT하면 안 됨!
-- 주문은 생겼는데 재고는 안 줄어든 불일치 상태 발생!
```

:::danger 에러 발생 후 COMMIT 금지
에러가 발생한 상태에서 무리하게 COMMIT을 시도하면, **데이터의 불일치 상태**가 영구적으로 저장될 수 있습니다. 위 예시에서는 주문은 생겼는데 재고는 줄지 않는 모순된 상태가 됩니다. 에러가 발생하면 반드시 ROLLBACK을 실행하세요.
:::

### COMMIT과 ROLLBACK 비교

| 구분 | COMMIT | ROLLBACK |
|------|--------|----------|
| **실행 조건** | 트랜잭션이 성공적으로 완료되었을 때 | 트랜잭션 실행 중 에러가 발생했을 때 |
| **동작** | 모든 작업을 확정(영구 저장) | 모든 작업을 취소(이전 상태 복구) |
| **결과** | 하드디스크에 데이터 저장 | 데이터베이스를 트랜잭션 시작 전으로 복원 |
| **All or Nothing** | All (전부 성공) | Nothing (전부 취소) |
| **비유** | 문서 편집 후 "저장" 버튼 | 문서 편집 후 "저장 안 함" 버튼 |
| **관련 연산** | Redo (다시 실행) | Undo (되돌리기) |

---

## 🔄 트랜잭션의 상태 흐름

트랜잭션은 시작부터 종료까지 여러 가지 상태를 거칩니다. 이 흐름을 이해하면 COMMIT과 ROLLBACK이 **언제, 왜** 필요한지 더 명확하게 알 수 있습니다.

### 5가지 상태 한눈에 보기

```
                ┌──────────┐
                │   활동    │ ← 트랜잭션 시작, 작업 진행 중
                └────┬─────┘
                     │
            ┌────────┴────────┐
            ▼                 ▼
     ┌──────────┐      ┌──────────┐
     │ 부분 완료 │      │   실패    │ ← 실행 중 에러 발생
     └────┬─────┘      └────┬─────┘
          │                  │
     ┌────┴────┐        ┌───┴────┐
     ▼         ▼        ▼        
┌────────┐ ┌────────┐ ┌────────┐
│  완료   │ │  실패   │ │  철회   │ ← ROLLBACK 수행
└────────┘ └────────┘ └────────┘
  COMMIT      ↓
           ┌────────┐
           │  철회   │
           └────────┘
```

### 각 상태 자세히 알아보기

**1. 활동(Active) 상태**

트랜잭션이 시작되어 **작업이 진행되고 있는 상태**입니다. 아래아 한글에서 문서를 열심히 타이핑하고 있는 중이라고 생각하면 됩니다. 화면에 글자가 쫙 써지고 있는 바로 그 순간입니다.

**2. 부분 완료(Partially Committed) 상태**

모든 작업은 끝났지만 **아직 COMMIT을 만나지 않은 상태**입니다. 문서 작성을 다 마쳤는데 아직 "저장" 버튼을 누르지 않은 것과 같습니다. 마지막 명령문까지 실행이 완료된 직후의 상태로, **저장만 남은 상태**입니다.

**3. 완료(Committed) 상태**

부분 완료 상태에서 **COMMIT 명령을 실행**하여 데이터가 하드디스크에 영구 저장된 상태입니다. 트랜잭션이 성공적으로 마무리된 최종 상태입니다. 문서 편집 후 "저장" 버튼을 눌러서 파일이 하드디스크에 안전하게 저장된 상태와 같습니다.

**4. 실패(Failed) 상태**

트랜잭션 실행 중 **에러가 발생하여 더 이상 진행할 수 없는 상태**입니다. 문법 오류, 시스템 문제, 리소스 부족 등 다양한 원인으로 발생할 수 있습니다. 이 상태에서는 **COMMIT을 실행할 수 없고**, 반드시 ROLLBACK을 통해 철회 상태로 전환해야 합니다.

**5. 철회(Aborted) 상태**

실패한 트랜잭션에 대해 **ROLLBACK을 수행**하여 모든 작업을 취소하고, 데이터베이스를 트랜잭션 시작 전 상태로 복구한 상태입니다.

:::info 부분 완료에서 실패로도 갈 수 있다!
많은 분들이 놓치는 부분인데, **부분 완료 상태에서 완료로 가지 못하고 실패로 갈 수도 있습니다.** 예를 들어, 문서 작업을 다 끝내고 저장 버튼을 눌렀는데 "저장 공간이 부족합니다", "읽기 전용 파일입니다", "파일 이름이 중복됩니다" 같은 에러가 발생할 수 있습니다. 이 경우 부분 완료 → 실패 → 철회(ROLLBACK) 순서로 진행됩니다. 단, 반대로 실패 상태에서 부분 완료 상태로는 돌아갈 수 없습니다.
:::

---

## 🛡️ 장애와 회복 — COMMIT/ROLLBACK이 빛나는 순간

### 장애란 무엇인가?

데이터베이스를 사용하다 보면 다양한 **장애(Failure)**가 발생할 수 있습니다. 우리도 살다 보면 몸이 아플 수 있듯이, 데이터베이스도 문제가 생길 수 있습니다. 병원에서 치료받고 건강한 상태로 돌아오듯이, 데이터베이스도 장애가 발생하면 **정상 상태로 복구(회복, Recovery)**해야 합니다.

### 장애의 유형

| 유형 | 설명 | 예시 | 심각도 |
|------|------|------|--------|
| **행동 장애** | 데이터를 찾지 못하거나 무결성 규칙 위반 | NULL이 허용되지 않는 곳에 NULL 입력, 범위 밖의 값 입력 | 낮음 |
| **트랜잭션 장애** | 시스템 자원 과다 사용, 입력 데이터 불량 | CPU 100%, 메모리 부족, 데이터 유실 | 보통 |
| **시스템 장애** | 하드웨어 고장으로 전원 차단 | CPU 고장, 메모리 고장, 정전 | 높음 |
| **미디어 장애** | 저장 장치 자체가 붕괴 | 하드디스크 고장, 데이터 직접 손실 | **매우 높음** |

:::danger 미디어 장애는 가장 치명적
미디어 장애는 데이터베이스 측면에서 **가장 위험한 장애**입니다. 시스템 장애는 운영체제를 다시 설치하거나 부품을 교체하면 해결할 수 있지만, 하드디스크가 망가지면 **데이터가 직접적으로 손실**될 수 있습니다. 복구에 상당히 많은 비용과 시간이 소요되므로, 평소에 **백업(Dump)을 철저하게** 관리해야 합니다.
:::

### 회복의 기본 원리 — Dump와 Log

회복은 두 가지 도구를 사용합니다:

**1. Dump (덤프, 백업)**
마지막으로 정상적인 상태의 데이터베이스를 **별도의 안전한 저장 장치에 통째로 복사해 놓는 것**입니다. 여러분이 컴퓨터의 중요한 파일을 USB, 외장하드, 클라우드 등에 복사해 두는 것과 같습니다.

**2. Log 파일 (로그 파일)**
Dump 이후에 발생하는 모든 **데이터 변경 사항을 하나하나 기록해 놓는 파일**입니다. 어떤 트랜잭션이 어떤 데이터를 어떤 값에서 어떤 값으로 변경했는지, 그리고 그 트랜잭션이 COMMIT 되었는지 아닌지를 모두 기록합니다.

Log 파일의 구조는 다음과 같습니다:

```
[트랜잭션 이름, 데이터 항목, 변경 전 값, 변경 후 값]
```

```sql
-- Log 파일 예시
[T1, start]              -- T1 트랜잭션 시작
[T1, X, 100, 200]        -- T1이 X값을 100에서 200으로 변경
[T1, Y, 300, 500]        -- T1이 Y값을 300에서 500으로 변경
[T1, commit]             -- T1 트랜잭션 성공적으로 완료(COMMIT)
[T2, start]              -- T2 트랜잭션 시작
[T2, Z, 400, 100]        -- T2가 Z값을 400에서 100으로 변경
-- (COMMIT 없음 → 에러 발생으로 ROLLBACK 필요)
```

위 로그를 한 줄씩 살펴보겠습니다:

- `[T1, start]` — 트랜잭션 T1이 시작되었다는 기록입니다.
- `[T1, X, 100, 200]` — T1이 데이터 항목 X의 값을 100에서 200으로 변경했다는 기록입니다. 변경 전 값(100)과 변경 후 값(200)을 모두 저장합니다.
- `[T1, commit]` — T1이 성공적으로 COMMIT 되었다는 기록입니다. 이 트랜잭션은 Redo 대상입니다.
- `[T2, start]` — 트랜잭션 T2가 시작되었다는 기록입니다.
- `[T2, Z, 400, 100]` — T2가 Z값을 변경했지만, 이후 COMMIT 기록이 없습니다. 에러가 발생하여 ROLLBACK 대상입니다.

:::note Log 파일의 크기
데이터 변경이 발생할 때마다 로그 레코드가 한 줄씩 생성됩니다. 예를 들어 100만 건의 데이터를 변경하면 로그 파일에 100만 줄의 기록이 생깁니다. 따라서 로그 파일은 매우 큰 규모로 커질 수 있습니다.
:::

### Redo와 Undo — 회복의 두 가지 무기

장애가 발생했을 때, Dump와 Log 파일을 가지고 회복 작업을 수행합니다. 이때 사용하는 두 가지 연산이 **Redo**와 **Undo**입니다.

| 구분 | Redo (리두) | Undo (언두) |
|------|-------------|-------------|
| **대상** | COMMIT이 있는 트랜잭션 | COMMIT이 없는 트랜잭션 |
| **동작** | 작업을 다시 실행(재반영) | 작업을 취소(되돌리기) |
| **방향** | 순방향 (Forward Recovery) | 역방향 (Backward Recovery) |
| **관련 명령** | COMMIT | ROLLBACK |

**Redo(리두)**는 COMMIT이 기록된 트랜잭션에 대해, 백업(Dump) 파일에 로그의 변경 사항을 **다시 적용**하는 것입니다. "이 작업은 성공했으니까 다시 실행해서 반영해 줘!"라는 의미입니다. 순방향(앞으로)으로 진행하므로 **Forward Recovery**라고도 부릅니다.

**Undo(언두)**는 COMMIT이 기록되지 않은 트랜잭션에 대해, 이미 반영된 변경 사항을 **원래대로 취소**하는 것입니다. "이 작업은 실패했으니까 원래대로 되돌려 줘!"라는 의미입니다. 역방향(뒤로)으로 진행하므로 **Backward Recovery**라고도 부릅니다.

> **COMMIT이 있으면 Redo, COMMIT이 없으면 Undo!** 이것만 기억하세요.

---

## ⚙️ 지연 갱신과 즉시 갱신 — 두 가지 회복 기법

트랜잭션의 결과를 데이터베이스에 반영하는 시점에 따라 **지연 갱신 기법**과 **즉시 갱신 기법**, 두 가지 방식이 있습니다. 이 두 방식에서 COMMIT과 ROLLBACK의 역할이 조금 다르게 적용됩니다.

### 📋 지연 갱신 기법 (Deferred Update)

#### 핵심 개념

지연 갱신 기법은 **COMMIT 명령을 만나기 전까지는 하드디스크에 데이터를 저장하지 않는 방식**입니다. 모든 변경 사항은 메모리에서만 처리되고, COMMIT이 실행되는 순간에야 비로소 하드디스크에 반영됩니다.

아래아 한글에서 "자동 저장" 기능을 끄고 작업하는 것과 같습니다. 아무리 열심히 작업해도, 직접 "저장" 버튼을 누르기 전까지는 하드디스크에 아무것도 기록되지 않는 방식입니다. 이 방식을 **No-Steal 방식**이라고도 부릅니다.

#### 지연 갱신의 특징

- COMMIT 전에 에러가 발생하면, 하드디스크에 반영된 것이 **아무것도 없음**
- 따라서 **Undo 연산이 필요 없음** (취소할 것이 없으니까!)
- COMMIT이 있는 트랜잭션만 **Redo 연산**으로 다시 반영
- COMMIT이 없는 트랜잭션은 **아무 작업도 수행하지 않음** (이미 하드디스크에 아무것도 없으므로)
- 로그 파일에 **변경 후 값만** 기록 (이전 값은 Undo가 필요 없으므로 불필요)

:::tip 지연 갱신이 단순한 이유
하드디스크에 저장하지 않은 채로 메모리에서만 처리하기 때문에, 에러가 발생해도 "그냥 메모리를 비워버리면 끝"입니다. 원래 하드디스크의 데이터는 변하지 않았으니까요. 그래서 Undo가 필요 없고, 회복 로직이 단순합니다.
:::

#### 지연 갱신 예제

초기 값: A = 1000, B = 2000, C = 3000

**예제 1: COMMIT이 없는 경우**

```
[T1, start]           -- T1 시작
[T1, A, 900]          -- A를 900으로 변경 (이후 값만 기록)
[T1, B, 2100]         -- B를 2100으로 변경
-- COMMIT 없음 → 여기서 에러 발생!
```

분석: T1에 COMMIT이 없으므로 하드디스크에는 아무것도 반영되지 않았습니다. 따라서 **아무 작업도 수행할 필요가 없습니다.** 최종 값은 원래 그대로 A = 1000, B = 2000, C = 3000입니다.

**예제 2: T1만 COMMIT된 경우**

```
[T1, start]           -- T1 시작
[T1, A, 900]          -- A를 900으로 변경
[T1, B, 2100]         -- B를 2100으로 변경
[T1, commit]          -- T1 COMMIT ✅
[T2, start]           -- T2 시작
[T2, C, 2800]         -- C를 2800으로 변경
-- T2의 COMMIT 없음 → 에러 발생!
```

분석: T1은 COMMIT이 있으므로 **Redo** 수행 → A = 900, B = 2100. T2는 COMMIT이 없으므로 **아무 작업 안 함** → C = 3000(원래 값 유지). 최종 값: **A = 900, B = 2100, C = 3000**

**예제 3: T1, T2 모두 COMMIT된 경우**

```
[T1, start]           -- T1 시작
[T1, A, 900]          -- A를 900으로 변경
[T1, B, 2100]         -- B를 2100으로 변경
[T1, commit]          -- T1 COMMIT ✅
[T2, start]           -- T2 시작
[T2, C, 2800]         -- C를 2800으로 변경
[T2, commit]          -- T2 COMMIT ✅
```

분석: T1도 T2도 모두 COMMIT이 있으므로 둘 다 **Redo** 수행. 최종 값: **A = 900, B = 2100, C = 2800**

:::note 지연 갱신의 단점
모든 데이터를 COMMIT 전까지 메모리에 보관해야 하므로 **메모리 공간이 매우 커야** 합니다. 또한 바로 하드디스크에 저장되지 않기 때문에 다른 사용자가 즉시 읽어올 수 없어 **동시성이 떨어지는** 단점이 있습니다.
:::

### ⚡ 즉시 갱신 기법 (Immediate Update)

#### 핵심 개념

즉시 갱신 기법은 **COMMIT 여부와 상관없이 변경 사항을 바로바로 하드디스크에 반영**하는 방식입니다. 아래아 한글에서 "자동 저장" 기능이 켜져 있어서, 타이핑할 때마다 바로바로 하드디스크에 기록되는 것과 비슷합니다.

이 방식은 COMMIT이 되지 않은 데이터도 이미 하드디스크에 기록되어 있기 때문에, 에러가 발생하면 **이미 기록된 것을 취소(Undo)**해야 합니다.

#### 즉시 갱신의 특징

- COMMIT이 없는 트랜잭션 → **Undo 연산** 수행 (이미 저장된 것을 취소)
- COMMIT이 있는 트랜잭션 → **Redo 연산** 수행 (다시 반영)
- 로그 파일에 **변경 전 값과 변경 후 값을 모두** 기록 (Undo를 위해 이전 값이 필요하므로)
- 회복 시 **Undo를 먼저 역방향으로** 수행한 후, **Redo를 순방향으로** 수행

#### 즉시 갱신 예제

초기 값: A = 1000, B = 2000, C = 3000

**예제 1: COMMIT이 없는 경우**

```
[T1, start]              -- T1 시작
[T1, A, 1000, 900]       -- A를 1000에서 900으로 변경 (전/후 값 모두 기록)
[T1, B, 2000, 2100]      -- B를 2000에서 2100으로 변경
-- COMMIT 없음 → 에러 발생!
```

분석: 즉시 갱신이므로 A = 900, B = 2100이 이미 하드디스크에 저장되어 있습니다. 하지만 COMMIT이 없으므로 **Undo**를 수행해야 합니다. **역방향**으로 진행하므로: B를 2100 → 2000으로 복원, 그 다음 A를 900 → 1000으로 복원. 최종 값: **A = 1000, B = 2000, C = 3000**

**예제 2: T1만 COMMIT된 경우**

```
[T1, start]              -- T1 시작
[T1, A, 1000, 900]       -- A를 1000에서 900으로 변경
[T1, B, 2000, 2100]      -- B를 2000에서 2100으로 변경
[T1, commit]             -- T1 COMMIT ✅
[T2, start]              -- T2 시작
[T2, C, 3000, 2800]      -- C를 3000에서 2800으로 변경
-- T2의 COMMIT 없음 → 에러 발생!
```

분석: T1은 COMMIT이 있으므로 **Redo**, T2는 COMMIT이 없으므로 **Undo**. 먼저 Undo를 역방향으로 수행: C를 2800 → 3000으로 복원. 그 다음 Redo를 순방향으로 수행: A = 900, B = 2100. 최종 값: **A = 900, B = 2100, C = 3000**

**예제 3: T1, T2 모두 COMMIT된 경우**

```
[T1, start]              -- T1 시작
[T1, A, 1000, 900]       -- A를 1000에서 900으로 변경
[T1, B, 2000, 2100]      -- B를 2000에서 2100으로 변경
[T1, commit]             -- T1 COMMIT ✅
[T2, start]              -- T2 시작
[T2, C, 3000, 2800]      -- C를 3000에서 2800으로 변경
[T2, commit]             -- T2 COMMIT ✅
```

분석: T1도 T2도 모두 COMMIT이 있으므로 둘 다 **Redo** 수행. Undo할 것이 없으므로 바로 순방향으로 Redo 진행. 최종 값: **A = 900, B = 2100, C = 2800**

### 지연 갱신 vs 즉시 갱신 비교

| 구분 | 지연 갱신 | 즉시 갱신 |
|------|-----------|-----------|
| **하드디스크 저장 시점** | COMMIT 후에만 저장 | 즉시 저장 |
| **COMMIT 없는 트랜잭션** | 아무 작업 안 함 | Undo 수행 |
| **COMMIT 있는 트랜잭션** | Redo 수행 | Redo 수행 |
| **로그 파일 내용** | 변경 후 값만 | 변경 전/후 값 모두 |
| **Undo 필요 여부** | ❌ 불필요 | ✅ 필요 |
| **메모리 사용** | 많음 (COMMIT까지 메모리에 유지) | 적음 |
| **동시성** | 낮음 | 높음 |
| **회복 복잡도** | 단순 | 복잡 |
| **별칭** | No-Steal 방식 | Steal 방식 |

---

## 💡 데이터 저장과 처리의 흐름

COMMIT과 ROLLBACK의 동작을 더 깊이 이해하려면, 데이터가 **하드디스크 → 메모리 → CPU** 사이에서 어떻게 이동하는지 알아야 합니다.

### 데이터 이동의 4가지 연산

하드디스크는 저장 용량은 크지만 **속도가 느리고**, CPU는 처리 속도가 **매우 빠릅니다.** 이 속도 차이를 해결하기 위해 중간에 **메모리(RAM)**가 완충(버퍼) 역할을 합니다.

```
┌────────────┐    Input     ┌──────────┐    Read     ┌────────┐
│  하드디스크  │ ──────────→ │  메모리   │ ─────────→ │  CPU   │
│  (영구저장)  │ ←────────── │  (버퍼)   │ ←───────── │ (처리)  │
└────────────┘    Output    └──────────┘    Write    └────────┘
```

| 연산 | 방향 | 설명 |
|------|------|------|
| **Input** | 하드디스크 → 메모리 | 하드디스크의 데이터를 메모리로 읽어오는 것 |
| **Output** | 메모리 → 하드디스크 | 메모리의 데이터를 하드디스크에 저장하는 것 |
| **Read** | 메모리 → CPU | 메모리의 데이터를 CPU로 가져와서 처리 준비 |
| **Write** | CPU → 메모리 | CPU에서 처리된 결과를 메모리에 기록 |

마치 냉장고(하드디스크)에서 재료를 꺼내서 도마(메모리)에 올려놓고, 도마 위의 재료를 가지고 요리(CPU 처리)를 하는 것과 같습니다. 요리가 끝나면 다시 도마에 놓고(Write), 도마에서 냉장고에 다시 넣는(Output) 흐름입니다.

**COMMIT**은 바로 이 **Output 연산**을 실행하여 메모리의 데이터를 하드디스크에 영구 저장하는 것이고, **ROLLBACK**은 메모리에 있는 변경 사항을 **버리고 원래의 하드디스크 데이터를 유지**하는 것입니다.

### 저장 장치의 종류

| 종류 | 특성 | 예시 | 전원 꺼지면? |
|------|------|------|-------------|
| **소멸성 저장 장치** | 전원이 꺼지면 데이터 소멸 | RAM (메모리) | 데이터 **사라짐** |
| **비소멸성 저장 장치** | 전원이 꺼져도 데이터 유지 | 하드디스크, USB, SSD | 데이터 **유지됨** |
| **안정성 저장 장치** | 별도로 백업해 놓은 장치 | 외장하드 백업, 클라우드 | 데이터 **안전하게 보관** |

:::tip COMMIT이 영속성을 보장하는 이유
COMMIT을 실행하면 데이터가 소멸성 저장 장치(메모리)에서 비소멸성 저장 장치(하드디스크)로 이동합니다. 그래서 컴퓨터를 껐다 켜도 데이터가 살아남을 수 있는 것입니다. 이것이 바로 **영속성(Durability)**이 보장되는 원리입니다.
:::

---

## ⚠️ 주의사항과 실전 팁

### 실무에서 자주 하는 실수

:::warning 주의! 이런 실수를 조심하세요

**1. 긴 트랜잭션에서 COMMIT을 너무 늦게 하는 경우**
수천, 수만 건의 데이터를 변경하면서 COMMIT을 마지막에 한 번만 하면, 중간에 에러가 발생했을 때 모든 작업이 ROLLBACK 되어야 합니다. 적절한 단위로 트랜잭션을 나누어 COMMIT하는 것이 좋습니다.

**2. 에러 처리 없이 COMMIT만 하는 경우**
프로그램에서 에러 발생 여부를 확인하지 않고 무조건 COMMIT을 실행하면, 불완전한 데이터가 영구 저장될 수 있습니다. 반드시 에러 체크 후 COMMIT 또는 ROLLBACK을 결정해야 합니다.

**3. 트랜잭션을 시작하고 COMMIT도 ROLLBACK도 하지 않는 경우**
이렇게 되면 트랜잭션이 열린 상태로 계속 유지되어, 다른 사용자의 접근을 차단(Lock)하는 문제가 발생할 수 있습니다.
:::

### 올바른 트랜잭션 처리 패턴

```sql
-- ✅ 올바른 패턴: 에러 처리와 함께 COMMIT/ROLLBACK 사용
BEGIN TRANSACTION;  -- 트랜잭션 시작

BEGIN TRY
    -- 작업 1: 주문 삽입
    INSERT INTO 주문 (고객ID, 상품명, 수량)
    VALUES (1001, '노트북', 1);

    -- 작업 2: 재고 차감
    UPDATE 재고
    SET 수량 = 수량 - 1
    WHERE 상품명 = '노트북';

    -- 작업 3: 결제 처리
    INSERT INTO 결제 (주문ID, 금액, 상태)
    VALUES (5001, 1500000, '완료');

    -- 모든 작업이 성공했으므로 COMMIT
    COMMIT;  -- ✅ 성공! 모든 변경사항 영구 저장
END TRY

BEGIN CATCH
    -- 어떤 작업이든 에러가 발생하면 이쪽으로 옴
    ROLLBACK;  -- ❌ 실패! 모든 변경사항 취소
END CATCH
```

위 코드를 한 줄씩 살펴보겠습니다:

- `BEGIN TRANSACTION;` — 트랜잭션의 시작을 선언합니다. 이후의 모든 작업은 하나의 묶음으로 취급됩니다.
- `BEGIN TRY ... END TRY` — 이 블록 안의 코드를 실행하면서, 에러가 발생하면 CATCH 블록으로 이동합니다.
- `INSERT INTO 주문 ...` — 주문 데이터를 삽입합니다.
- `UPDATE 재고 ...` — 재고를 차감합니다.
- `INSERT INTO 결제 ...` — 결제 정보를 기록합니다.
- `COMMIT;` — TRY 블록의 모든 작업이 에러 없이 실행되었다면, 이 COMMIT이 실행되어 모든 변경사항이 하드디스크에 영구 저장됩니다.
- `BEGIN CATCH ... END CATCH` — TRY 블록에서 **어떤 작업이든** 에러가 발생하면 이 블록이 실행됩니다.
- `ROLLBACK;` — 에러가 발생했으므로 그동안의 모든 작업을 취소하고 트랜잭션 시작 전 상태로 복원합니다.

```sql
-- ❌ 잘못된 패턴: 에러 처리 없이 그냥 실행
INSERT INTO 주문 (고객ID, 상품명, 수량)
VALUES (1001, '노트북', 1);  -- 주문 삽입 (자동 COMMIT 될 수 있음)

UPDATE 재고
SET 수량 = 수량 - 1
WHERE 상품명 = '노트북';  -- 여기서 에러 나면?

-- 주문은 이미 COMMIT됐는데 재고는 안 줄어든 불일치 발생!
```

:::tip 자동 COMMIT 모드 주의
많은 데이터베이스 시스템에서는 기본적으로 **자동 COMMIT 모드**가 켜져 있습니다. 이 모드에서는 각 SQL 문이 실행될 때마다 자동으로 COMMIT됩니다. 여러 작업을 하나의 트랜잭션으로 묶으려면, 반드시 `BEGIN TRANSACTION`으로 명시적으로 트랜잭션을 시작해야 합니다.
:::

### 병행 제어와의 관계

데이터베이스는 동시에 수백, 수천 명의 사용자가 접속할 수 있습니다. 마치 하나의 강의실을 여러 교수님이 사용하려고 할 때 시간표를 잘 짜서 충돌이 나지 않게 하는 것처럼, 데이터베이스도 **병행 제어(Concurrency Control)**를 통해 동시 접근 시 충돌을 방지합니다.

이때 권한을 부여하고 회수하는 **기본 단위가 바로 트랜잭션**입니다. COMMIT과 ROLLBACK은 이 트랜잭션의 경계를 명확히 구분해 주는 역할도 합니다. 트랜잭션이 COMMIT되면 해당 데이터에 대한 잠금(Lock)이 해제되어 다른 사용자가 접근할 수 있게 되고, ROLLBACK되면 마찬가지로 잠금이 해제되면서 변경 사항이 취소됩니다.

---

## 📌 핵심 정리

- **트랜잭션**은 더 이상 쪼갤 수 없는 데이터베이스 작업의 논리적 단위이며, 부분적 처리를 허용하지 않는다
- **ACID**는 트랜잭션이 지켜야 할 4가지 성질로, 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 영속성(Durability)을 의미한다
- **원자성(All or Nothing)**이 가장 중요한 성질이며, COMMIT과 ROLLBACK은 이 원자성을 구현하는 핵심 명령어이다
- **COMMIT**은 트랜잭션이 성공적으로 완료되었을 때 실행하며, 모든 변경 사항을 하드디스크에 영구 저장한다
- **ROLLBACK**은 트랜잭션 실행 중 에러가 발생했을 때 실행하며, 모든 변경 사항을 취소하고 이전 상태로 복구한다
- 트랜잭션의 상태는 활동 → 부분 완료 → 완료(COMMIT) 또는 활동/부분 완료 → 실패 → 철회(ROLLBACK) 순서로 흐른다
- **Redo**는 COMMIT이 있는 트랜잭션을 다시 반영하는 순방향 회복 연산이고, **Undo**는 COMMIT이 없는 트랜잭션을 취소하는 역방향 회복 연산이다
- **지연 갱신 기법**은 COMMIT 전까지 하드디스크에 저장하지 않으므로 Undo가 불필요하고, COMMIT이 있는 것만 Redo한다
- **즉시 갱신 기법**은 즉시 하드디스크에 반영하므로 COMMIT이 없는 것은 Undo, COMMIT이 있는 것은 Redo를 수행한다
- 회복의 기본 원리는 **Dump(백업)**와 **Log 파일**을 활용하여 장애 발생 시 정상 상태로 복구하는 것이다

작성일: 2026-02-21