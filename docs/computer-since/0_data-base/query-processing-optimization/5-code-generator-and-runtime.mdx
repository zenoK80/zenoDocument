---
title: "코드 생성기와 런타임 데이터베이스 처리기"
description: "코드 생성기와 런타임 데이터베이스 처리기에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/query-processing-optimization/5-code-generator-and-runtime"
sidebar_label: "코드 생성 및 실행"
date: "2026-02-21"
---

## 🎯 질의어 처리 단계와 최적화 — 전체 그림 이해하기

우리가 데이터베이스에 무언가를 요청할 때 사용하는 언어가 바로 **SQL(Structured Query Language)**입니다. SQL은 **고급 질의어(High-level Query Language)**에 해당합니다. "고급"이라는 말이 "어렵다"는 뜻이 아니라, 사람이 읽고 쓰기 편하도록 설계된 언어라는 의미입니다. 마치 우리가 일상에서 "학생 테이블에서 남학생의 이름을 보여줘"라고 말하는 것처럼, `SELECT`, `FROM`, `WHERE` 같은 키워드로 자연스럽게 명령을 내릴 수 있죠.

그런데 컴퓨터는 이 고급 언어를 바로 이해하지 못합니다. 마치 한국어로 된 요리 레시피를 로봇에게 건네줬을 때, 로봇이 이해할 수 있는 기계어로 번역해줘야 하는 것과 같습니다. 이 **번역 과정**이 바로 질의어 처리 단계이며, 번역 과정에서 **가장 효율적인 방법을 찾는 것**이 최적화입니다.

> **핵심 포인트:** SQL 질의어는 고급 언어이므로, 데이터베이스 시스템 내부에서 여러 단계를 거쳐 변환·최적화된 후 실행됩니다. 이 전체 과정을 이해하는 것이 데이터베이스 성능 관리의 핵심입니다.

이번 문서에서는 고급 질의어가 입력되는 순간부터 최종 결과가 출력되기까지의 **전체 수행 과정**을 하나하나 뜯어보겠습니다. 특히 최적화가 어떤 원리로 이루어지는지, 코드 생성기와 런타임 데이터베이스 처리기가 어떤 역할을 하는지를 초보자도 쉽게 이해할 수 있도록 설명하겠습니다.

---

## 📋 질의어 처리의 전체 흐름 — 5가지 핵심 구성요소

고급 질의어(SQL)가 데이터베이스 시스템에 입력되면, 다음과 같은 **5가지 구성요소**를 순서대로 거치며 처리됩니다. 각 구성요소는 마치 공장의 **조립 라인**처럼 순서대로 작업을 수행합니다.

| 순서 | 구성요소 | 하는 일 | 결과물 |
|------|----------|---------|--------|
| 1 | **검사기(Scanner)** | 질의문의 요소(토큰)를 식별 | 토큰화된 질의문 |
| 2 | **파서(Parser)** | 문법 오류 검사 | 내부 형태 질의문 |
| 3 | **질의어 최적화기(Query Optimizer)** | 가장 효율적인 실행 계획 선정 | 질의문 계획 |
| 4 | **코드 생성기(Code Generator)** | 선정된 계획을 실행 코드로 변환 | 질의문 실행 코드 |
| 5 | **런타임 데이터베이스 처리기(Runtime DB Processor)** | 실행 코드를 실제로 수행 | 질의 실행 결과 |

여기서 **네모 박스(구성요소)**는 시스템의 모듈이고, 각 단계 사이에 나오는 것은 **이전 단계의 결과물**입니다. 파서를 거치면 "내부 형태 질의문"이 나오고, 최적화기를 거치면 "질의문 계획"이 나오고, 코드 생성기를 거치면 "질의문 실행 코드"가 나오고, 런타임 처리기를 거치면 최종 "질의 실행 결과"가 나옵니다.

:::info 기본 과정 vs 고급 과정
SQL 문법, 테이블 생성, 권한 부여 등은 데이터베이스의 **기본 과정**에 해당합니다. 반면, 질의어 최적화, 병행제어, 회복 등은 **고급 과정**에 해당합니다. 고급 과정까지 이해하면 데이터베이스 관리자(DBA)로서 성능을 고려한 효율적인 관리가 가능해집니다.
:::

---

## 🔍 검사기(Scanner)와 파서(Parser) — 질의문 읽기와 문법 검사

### 검사기(Scanner) — 토큰 식별하기

질의어가 시스템에 들어오면 **가장 먼저 만나는 것**이 검사기(Scanner)입니다. 검사기의 역할은 질의문을 쭉 읽어서 **각 요소(토큰, Token)**를 식별하는 것입니다.

토큰이란 무엇일까요? 마치 우리가 문장을 읽을 때 "주어", "동사", "목적어"로 나누는 것처럼, SQL 문장도 의미 있는 최소 단위로 분리할 수 있습니다. 이 최소 단위가 바로 **토큰**입니다.

```sql
-- 예시 SQL 질의문
SELECT * FROM 학생
```

검사기는 이 명령어를 읽고 다음과 같이 식별합니다:
- `SELECT` → 아, 이건 조회 명령어구나! (키워드 토큰)
- `*` → 모든 컬럼을 가져오라는 뜻이구나! (와일드카드 토큰)
- `FROM` → 어느 테이블에서 가져오는지 알려주는 절이구나! (키워드 토큰)
- `학생` → 대상 테이블 이름이구나! (식별자 토큰)

마치 편의점 계산대에서 바코드 스캐너가 상품을 하나하나 인식하듯, 검사기도 SQL 문장의 각 부분을 하나하나 인식하는 것입니다.

### 파서(Parser) — 문법 오류 체크하기

검사기가 토큰을 식별하고 나면, 다음으로 **파서(Parser)**가 문법적인 오류가 있는지 검사합니다. Java나 C 같은 프로그래밍 언어에서 컴파일할 때 문법 오류를 체크하는 것과 동일한 원리입니다.

파서는 "이 SELECT 명령어의 문법이 올바른가?"를 확인합니다. SELECT 문은 `SELECT ... FROM ... WHERE ...` 형식으로 구성되어야 하는데, 이 형식에 맞는지 검증하는 것이죠.

```sql
-- ❌ 문법 오류가 있는 예시 (FROM 절이 빠짐)
SELECT * WHERE 학년 = 3

-- ✅ 문법이 올바른 예시
SELECT * FROM 학생 WHERE 학년 = 3
```

위의 잘못된 예시에서는 `FROM` 절이 빠져 있습니다. 파서는 이런 **신택스 에러(Syntax Error, 문법 오류)**를 잡아내서 사용자에게 알려줍니다.

> **검사기(Scanner)**는 "이 문장에 어떤 단어들이 있는지" 식별하고, **파서(Parser)**는 "이 단어들이 올바른 순서와 규칙으로 배열되어 있는지" 검증합니다.

파서를 거치면 **내부 형태 질의문**이 만들어집니다. 이 내부 형태 질의문은 시스템이 처리하기 좋은 형태로 변환된 것으로, 주로 **질의 트리(Query Tree)** 방식을 사용합니다.

---

## ⚙️ 질의어 최적화기(Query Optimizer) — 가장 효율적인 길 찾기

### 왜 최적화가 필요한가?

질의어 최적화는 데이터베이스 성능과 직결되는 핵심 개념입니다. 사용자가 하나의 SQL 명령어를 작성하더라도, 그 명령어를 실행하는 방법은 **여러 가지**가 있을 수 있습니다.

비유를 들어보겠습니다. 여러분이 집에서 학교까지 가는 경로를 생각해보세요. 버스를 타고 갈 수도 있고, 지하철을 탈 수도 있고, 자전거를 탈 수도 있고, 걸어갈 수도 있습니다. 각 경로마다 소요 시간과 비용이 다르죠. **최적화기**는 이 중에서 가장 빠르고 비용이 적게 드는 경로를 자동으로 찾아주는 역할을 합니다.

### 구체적인 예시로 이해하기

학생 테이블에서 **성별이 남자이면서 지역이 서울**인 학생의 학번을 검색한다고 가정해봅시다.

```sql
-- 성별이 남자이면서 지역이 서울인 학생의 학번 검색
SELECT 학번 FROM 학생 WHERE 성별 = '남자' AND 지역 = '서울';
```

이 하나의 명령어를 실행하는 방법은 최소 3가지가 있습니다:

| 계획 | 방법 | 설명 |
|------|------|------|
| 계획 1 | 성별 먼저 → 지역 나중 | 먼저 남자를 찾고, 그 중에서 서울인 학생을 찾음 |
| 계획 2 | 지역 먼저 → 성별 나중 | 먼저 서울 학생을 찾고, 그 중에서 남자를 찾음 |
| 계획 3 | 동시 검색 | 한 명씩 확인하면서 남자이면서 서울인 학생을 동시에 찾음 |

그렇다면 어떤 계획이 가장 효율적일까요?

### 선택도(Selectivity)의 개념

학생이 총 **100명**이고, 그 중 **남자는 10명**, **지역이 서울인 학생은 50명**이라고 해봅시다.

- 남자의 **선택도** = 10/100 = **10%**
- 서울의 **선택도** = 50/100 = **50%**

**선택도(Selectivity)**란 전체 데이터 중에서 해당 조건을 만족하는 데이터의 비율을 말합니다. 선택도가 작을수록 해당 조건으로 걸러내면 더 적은 수의 데이터만 남게 됩니다.

마치 냉장고에서 재료를 꺼내는 것과 같습니다. 냉장고에 100개의 재료가 있는데, "빨간색 재료"가 10개이고 "채소"가 50개라면, 빨간색 재료를 먼저 꺼내서 10개만 놓고 그 중에서 채소를 찾는 것이, 채소 50개를 먼저 꺼내서 그 중에 빨간색을 찾는 것보다 훨씬 빠르겠죠.

> **핵심 원리:** 선택도가 작은 조건(결과 튜플 수가 적은 조건)을 **먼저 실행**하여 연산에 참여하는 데이터 양을 최대한 줄이는 것이 최적화의 기본 원리입니다.

따라서 위 예시에서는 **계획 1**(남자를 먼저 찾고 → 서울을 나중에 찾는 방법)이 가장 효율적입니다. 10명의 남자 중에서 서울인 학생을 찾는 것이, 50명의 서울 학생 중에서 남자를 찾는 것보다 처리할 데이터가 적기 때문입니다.

:::tip 선택도 정보는 어디서 오는가?
이런 통계 정보(남자가 10명, 서울이 50명 등)는 **데이터 사전(Data Dictionary, 카탈로그)**에 저장되어 있습니다. 사용자가 직접 계산하는 것이 아니라, 시스템이 자동으로 이 정보를 참조하여 최적화를 수행합니다.
:::

### 최적화의 3가지 방법

#### 1️⃣ 경험적 최적화 (Heuristic Optimization)

경험적 최적화는 말 그대로 **오랜 경험을 통해 축적된 규칙**을 바탕으로 최적화하는 방법입니다. 마치 여러분이 매일 출퇴근하면서 "이 길이 가장 빠르더라"라는 경험을 가지고 있는 것과 같습니다.

경험적 처리 전략의 주요 규칙은 다음과 같습니다:

- **선택(Selection) 연산을 가능하면 먼저 수행하라**: WHERE 절의 조건을 먼저 적용해서 연산에 참여하는 튜플(행) 수를 줄이라는 뜻입니다.
- **카티션 프로덕트(Cartesian Product) + 선택 연산은 조인(Join) 연산으로 바꿔라**: 두 테이블을 무조건 곱하면 데이터가 폭발적으로 증가합니다. 10개 × 10개 = 100개가 되어 비효율적이므로, 조인 연산으로 바꿔서 처리하는 것이 좋습니다.
- **프로젝션(Projection) 연산도 가능하면 먼저 수행하라**: 전체 컬럼을 다 가져오지 말고, 필요한 속성(컬럼)만 먼저 걸러내서 데이터 양을 줄이라는 뜻입니다.
- **공통 연산식은 한 번만 수행하라**: 예를 들어 프로젝션을 3번 중첩한 것은 마지막 프로젝션 한 번만 수행하면 결과가 같습니다.

#### 2️⃣ 비용 기반 최적화 (Cost-based Optimization)

비용 기반 최적화는 실제 실행에 드는 **비용을 수식으로 계산**하여, 가장 비용이 적게 드는 계획을 선택하는 방법입니다.

비용식에는 다음과 같은 요소들이 고려됩니다:

| 비용 요소 | 설명 | 주로 중요한 환경 |
|-----------|------|------------------|
| **디스크 I/O 비용** | 하드디스크에서 데이터를 읽고 쓰는 비용 | 대형 데이터베이스 시스템 |
| **CPU 계산 비용** | CPU에서 연산을 처리하는 시간 | 소형 데이터베이스 |
| **저장 비용** | 중간 결과를 저장하는 데 드는 비용 | 복잡한 질의 처리 |
| **통신 비용** | 네트워크를 통한 데이터 전송 비용 | 분산 데이터베이스 |

이 요소들을 비용식에 대입하면 각 계획마다 비용 값이 나옵니다. 그 중 **비용이 가장 작은 계획**이 최적의 실행 계획으로 선정됩니다.

:::note 실무에서는 두 방법을 함께 사용합니다
일반적으로 데이터베이스 시스템은 **경험적 최적화**와 **비용 기반 최적화**를 함께 사용합니다. 경험적 규칙으로 먼저 범위를 좁히고, 비용을 계산하여 최종 계획을 선정하는 방식입니다.
:::

#### 3️⃣ 의미적 질의 최적화 (Semantic Query Optimization)

의미적 질의 최적화는 **데이터의 의미(무결성 제약조건)**를 고려하여, 굳이 최적화를 수행할 필요가 없는 경우를 미리 판별하는 방법입니다.

예를 들어, 학년이 1학년부터 4학년까지만 존재하는 대학교 데이터베이스에서 다음과 같은 질의를 실행한다고 해봅시다:

```sql
-- ❌ 의미적으로 결과가 없는 질의 (5학년은 존재하지 않음)
SELECT 이름 FROM 학생 WHERE 학년 >= 5;
```

이 경우, 시스템은 데이터 사전에서 "학년은 1~4의 값만 가능하다"는 무결성 제약조건을 확인하고, **최적화 과정을 거칠 필요 없이 바로 "결과 없음"을 반환**합니다. 마치 초등학교에서 "8학년을 검색하라"고 하면, 초등학교는 1~6학년까지만 있으므로 굳이 전체 데이터를 뒤질 필요 없이 바로 "없음"이라고 답하는 것과 같습니다.

이렇게 하면 불필요한 검사기·파서·최적화기 과정을 모두 건너뛸 수 있어 **처리 시간이 크게 단축**됩니다.

---

## 🌲 최적화의 4단계 — 내부 표현 변환부터 계획 선정까지

최적화기 내부에서는 구체적으로 **4가지 단계**를 거쳐 최적의 실행 계획을 찾아냅니다. 각 단계를 하나씩 살펴보겠습니다.

### 1단계: 질의문을 내부 표현으로 변환

파서가 생성한 결과를 시스템이 처리하기 적합한 **내부 형태**로 변환하는 단계입니다. 이때 주로 사용되는 형태가 **질의 트리(Query Tree)**입니다. 관계 대수(Relational Algebra)의 경우 질의 트리를, 관계 해석(Relational Calculus)의 경우 질의 그래프를 사용합니다.

구체적인 과정은 다음과 같습니다:

**① SQL → 관계 대수로 변환**

```sql
-- 원본 SQL 질의문
SELECT S.sname          -- 선원 이름을 출력해라
FROM Reserves R, Sailors S  -- Reserves 테이블과 Sailors 테이블에서
WHERE R.sid = S.sid     -- 두 테이블의 sid가 같고
  AND R.bid = 100       -- 예약번호가 100이고
  AND S.rating > 5;     -- 등급이 5보다 큰 경우
```

이 SQL을 관계 대수 형태로 변환하면, 다음과 같은 의미가 됩니다:
- Reserves(R) 테이블과 Sailors(S) 테이블을 **sid가 같은 조건으로 조인**
- 조인된 결과에서 **bid = 100이고 rating > 5인 튜플을 선택(Selection)**
- 최종적으로 **sname을 프로젝션(Projection)하여 출력**

**② 관계 대수 → 질의 트리로 변환**

질의 트리는 나무 구조(Tree)로, 아래에서 위로 연산이 진행됩니다:

```
        π(sname)                   ← 최상위: sname을 출력 (프로젝션)
            |
   σ(bid=100 AND rating>5)        ← 중간: 조건에 맞는 튜플 선택 (셀렉션)
            |
        ⋈(sid=sid)                 ← 하위: 두 테이블을 sid 기준으로 조인
       /          \
  Reserves      Sailors            ← 최하위: 원본 테이블 (리프 노드)
```

이렇게 SQL을 트리 구조로 변환하는 이유는, **트리의 노드 위치를 바꾸면서(부모-자식 교환) 다양한 실행 순서를 만들어낼 수 있기 때문**입니다. 자료구조 과목에서 배우는 트리의 운행(Traversal) 방법이 바로 이런 데이터베이스 내부 최적화에서 활용되는 것입니다.

### 2단계: 효율적인 내부 형태로 변환

1단계에서 만들어진 기본 트리를 **정립된 변환 규칙(Transformation Rules)**을 사용하여 더 효율적인 형태로 바꿔주는 단계입니다. 이 변환 규칙은 내 마음대로 바꾸는 것이 아니라, 검증된 논리적 변환 규칙을 따릅니다 (뒤에서 상세하게 설명합니다).

핵심은 **선택 연산과 프로젝션 연산을 트리의 아래쪽(먼저 실행되는 위치)으로 내리는 것**입니다. 이렇게 하면 연산에 참여하는 튜플 수가 줄어들어 전체 처리 효율이 올라갑니다.

### 3단계: 후보 프로시저 선정

변환된 트리들로부터 여러 실행 계획이 나오면, 그 중에서 **평가할 가치가 있는 후보만 선정**하는 단계입니다.

마치 대통령 선거에서 전 국민이 후보가 되는 것이 아니라 당선 가능성 있는 후보만 선정되어 평가·투표 대상이 되는 것과 같습니다. 10개의 실행 계획이 나왔다면 10개를 모두 평가하는 것은 비효율적이므로, 경험적으로 성능이 떨어질 것이 명확한 계획은 제외하고 **정말 효율적일 만한 후보만 3~4개 정도 선정**합니다.

후보 선정 시 고려하는 요소들:
- **인덱스(Index)가 있는가**: 인덱스가 있으면 빠르게 데이터를 찾을 수 있음
- **값 세분포(Value Distribution)**: 데이터가 어떻게 분포되어 있는가
- **클러스터링(Clustering) 여부**: 물리적으로 데이터가 모여 있는가
- **해싱(Hashing) 함수 사용 여부**: 해시 기반 접근이 가능한가
- **연산의 순서**: 어떤 연산을 먼저 수행하는가

### 4단계: 계획 평가 및 선정

후보로 선정된 계획들을 실제 **비용식**으로 평가하여, 가장 비용이 적게 드는 계획을 최종 선정하는 단계입니다.

비용식에 디스크 I/O 비용, CPU 계산 비용, 저장 비용, 통신 비용 등을 모두 대입하면 각 후보 계획마다 하나의 비용 값이 나옵니다. **이 값이 가장 작은 계획이 최종 선정**됩니다.

```
후보 계획 A → 비용 = 150
후보 계획 B → 비용 = 85   ← ✅ 가장 비용이 적음 → 최종 선정!
후보 계획 C → 비용 = 200
```

:::warning 비용 평가 시 주의
모든 후보를 완벽하게 평가하려고 하면 오히려 최적화 자체에 시간이 너무 많이 걸립니다. 따라서 **경험적 기법에 따라 적당한 범위 내에서만** 평가를 수행합니다.
:::

---

## 📐 내부 형태 변환 규칙 — 트리를 효율적으로 바꾸는 12가지 규칙

최적화기가 질의 트리를 효율적으로 변환할 때 사용하는 **정립된 변환 규칙**들이 있습니다. 이 규칙들은 수학적으로 증명된 것으로, 변환 전후의 결과가 동일함을 보장합니다. 핵심 규칙들을 하나씩 살펴보겠습니다.

### 규칙 1: AND 조건의 분리

AND로 연결된 여러 조건을 하나씩 분리하여 **개별 선택 연산으로 바꾸는** 규칙입니다.

```
-- ❌ 비효율적: 모든 조건을 한꺼번에 검사
σ(성별='남자' AND 지역='서울' AND 점수>80)(학생)

-- ✅ 효율적: 조건을 하나씩 분리하여 순차적으로 적용
σ(점수>80)( σ(지역='서울')( σ(성별='남자')(학생) ) )
```

100명의 학생이 있을 때, 한 명씩 세 가지 조건을 동시에 확인하는 것보다, 먼저 남자만 걸러내고(10명), 그 중 서울만 걸러내고(5명), 그 중 80점 이상만 걸러내는(3명) 것이 훨씬 효율적입니다. 연산에 참여하는 튜플 수가 단계마다 줄어들기 때문입니다.

### 규칙 2: 선택 연산의 교환 법칙

```
-- 아래 두 연산은 결과가 동일 (교환 가능)
σ(성별='남자')( σ(지역='서울')(학생) )
=
σ(지역='서울')( σ(성별='남자')(학생) )
```

선택 연산은 순서를 바꿔도 결과가 같습니다. 따라서 **선택도가 작은 조건을 먼저 적용**할 수 있도록 자유롭게 순서를 교환할 수 있습니다. 남자의 선택도가 10%이고 서울의 선택도가 50%라면, 남자 조건을 먼저 적용하는 쪽으로 순서를 바꾸는 것이 유리합니다.

### 규칙 3: 프로젝션 연산의 단축

```
-- ❌ 비효율적: 프로젝션을 여러 번 중첩
π(학번)( π(학번, 이름)( π(학번, 이름, 성별)(학생) ) )

-- ✅ 효율적: 마지막 프로젝션만 수행하면 동일한 결과
π(학번)(학생)
```

프로젝션을 여러 번 중첩하면, 결국 마지막(가장 바깥쪽) 프로젝션의 결과와 동일합니다. 학번, 이름, 성별을 가져온 뒤 학번, 이름만 가져오고, 다시 학번만 가져오는 것은 처음부터 학번만 가져오는 것과 결과가 같습니다. 불필요한 중복 작업을 제거하는 규칙입니다.

### 규칙 4: 선택과 프로젝션의 교환

```
-- 아래 두 연산은 결과가 동일
π(학번)( σ(성별='남자')(학생) )
=
σ(성별='남자')( π(학번, 성별)(학생) )
```

선택 연산과 프로젝션 연산은 순서를 교환할 수 있습니다. 다만 프로젝션을 먼저 할 때는 선택 조건에 사용되는 속성(위 예시에서 '성별')도 함께 프로젝션해야 한다는 점에 유의해야 합니다.

### 규칙 5: 카티션 프로덕트 + 선택 → 조인 또는 선택 우선 수행

```
-- ❌ 비효율적: 두 테이블을 곱한 후 선택
σ(R.id = S.id)(R × S)

-- ✅ 효율적: 조인 연산으로 변환
R ⋈(R.id = S.id) S
```

R 테이블에 10개, S 테이블에 10개의 데이터가 있다면, 카티션 프로덕트(×)를 하면 10 × 10 = **100개**의 데이터가 만들어집니다. 이 100개 중에서 조건에 맞는 것을 찾는 것보다, 처음부터 조인 조건에 맞는 것만 결합하는 것이 훨씬 효율적입니다.

또한, 선택 조건이 한쪽 테이블에만 해당하는 경우:

```
-- ❌ 비효율적: 조인 후 선택
σ(R.bid=100)(R ⋈ S)

-- ✅ 효율적: 선택을 먼저 수행한 후 조인
(σ(R.bid=100)(R)) ⋈ S
```

R 테이블에서 bid=100인 튜플만 먼저 걸러낸 후 S와 조인하면, 조인에 참여하는 데이터 양이 크게 줄어듭니다.

### 규칙 6: 양쪽 테이블 모두 선택 우선 수행

```
-- ❌ 비효율적: 조인/곱하기 후 양쪽 조건 모두 선택
σ(R.bid=100 AND S.rating>5)(R ⋈ S)

-- ✅ 효율적: 각 테이블에서 먼저 선택 후 조인
(σ(R.bid=100)(R)) ⋈ (σ(S.rating>5)(S))
```

R 테이블의 조건과 S 테이블의 조건이 각각 있다면, **각 테이블에서 조건을 먼저 적용하여 튜플을 줄인 후** 조인하는 것이 효율적입니다. 이것이 규칙 5와 6의 핵심입니다.

### 규칙 7: 곱하기·합집합·교집합·조인의 교환 법칙

```
-- 아래 연산들은 순서를 바꿔도 결과가 동일
R × S = S × R      -- 카티션 프로덕트
R ∪ S = S ∪ R      -- 합집합
R ∩ S = S ∩ R      -- 교집합
R ⋈ S = S ⋈ R      -- 조인
```

어떤 테이블을 먼저 가져와도 결과는 같습니다.

:::danger 교환 법칙이 성립하지 않는 연산
**세미조인(Semi-join)**, **차집합(-)**, **나누기(÷)** 이 3가지 연산은 교환 법칙이 성립하지 않습니다. 순서를 바꾸면 결과가 달라지므로 주의해야 합니다.
:::

### 규칙 8: 프로젝션 우선 수행 (조인/곱하기와 함께)

```
-- ❌ 비효율적: 조인 후 프로젝션
π(a, b)(R ⋈ S)

-- ✅ 효율적: 각 테이블에서 프로젝션 먼저 수행 후 조인
(π(a)(R)) ⋈ (π(b)(S))
```

전체 컬럼을 다 가지고 와서 조인한 후 필요한 컬럼만 추출하는 것보다, 각 테이블에서 필요한 컬럼만 먼저 추출한 후 조인하는 것이 데이터 양이 줄어들어 효율적입니다.

### 규칙 9: 합집합·교집합·차집합과 선택/프로젝션

```
-- 선택 연산을 먼저 수행
σ(조건)(R ∪ S) = σ(조건)(R) ∪ σ(조건)(S)

-- 프로젝션 연산을 먼저 수행
π(속성)(R ∪ S) = π(속성)(R) ∪ π(속성)(S)
```

합집합, 교집합, 차집합을 수행한 후 선택/프로젝션하는 것보다, 각 테이블에서 **선택/프로젝션을 먼저 수행한 후** 합집합 등을 하는 것이 효율적입니다. 연산에 참여하는 튜플 수를 미리 줄이는 것이 핵심이기 때문입니다.

### 규칙 11: 곱하기의 결합 법칙

```
-- 순서를 바꿔도 결과 동일
(R × S) × T = R × (S × T)
```

세 개 이상의 테이블을 곱할 때, 어떤 두 테이블을 먼저 곱하든 최종 결과는 같습니다. 따라서 **가장 데이터 양이 적어지는 순서**로 곱하기를 수행하면 됩니다.

### 규칙 12: 교집합과 합집합의 분배 법칙

```
-- 합집합 먼저 → 교집합 나중
R ∩ (S ∪ T) = (R ∩ S) ∪ (R ∩ T)
```

OR(∪)로 연결된 조건식은 AND(∩)로 연결된 **논리곱 정형식(CNF)**으로 변환할 수 있습니다. 이는 중고등학교 수학에서 배운 분배 법칙과 동일한 원리입니다.

---

## 🏭 코드 생성기와 런타임 데이터베이스 처리기 — 실행의 마지막 단계

### 코드 생성기(Code Generator) — 실행 코드 만들기

최적화기에서 **가장 비용이 적게 드는 실행 계획이 선정**되면, 이제 이 계획을 실제로 실행할 수 있는 **코드(실행 코드)**로 변환해야 합니다. 이 작업을 담당하는 것이 **코드 생성기(Code Generator)**입니다.

비유하자면, 건축 설계도(실행 계획)가 완성되었으니, 이제 실제 공사를 할 수 있는 **작업 지시서(실행 코드)**를 만드는 단계입니다. 설계도만으로는 건물을 지을 수 없듯, 실행 계획만으로는 데이터베이스가 실제 작업을 수행할 수 없습니다. 코드 생성기가 이 계획을 컴퓨터가 이해하고 실행할 수 있는 형태의 코드로 변환해주는 것입니다.

앞선 예시에서 "남자를 먼저 찾고, 그 중에서 서울인 학생을 찾는" 계획이 선정되었다면, 코드 생성기는 다음과 같은 의미의 실행 코드를 생성합니다:

```
[의사 코드로 표현한 실행 코드 예시]

1. 학생 테이블에 접근                    ← 디스크에서 학생 데이터를 읽어옴
2. 성별 = '남자' 조건으로 필터링          ← 선택도가 작은 조건을 먼저 적용
3. 2번 결과에서 지역 = '서울' 조건 필터링  ← 두 번째 조건 적용
4. 3번 결과에서 학번 속성만 추출           ← 프로젝션 수행
5. 결과 반환                             ← 최종 결과를 사용자에게 전달
```

코드 생성기의 결과물인 **질의문 실행 코드**는 다음 단계인 런타임 데이터베이스 처리기에 전달됩니다.

### 런타임 데이터베이스 처리기(Runtime Database Processor) — 실제 실행하기

**런타임 데이터베이스 처리기**는 코드 생성기가 만들어낸 실행 코드를 **실제로 수행**하는 구성요소입니다. 마치 작업 지시서를 받은 현장 작업자가 실제로 건물을 짓는 것과 같습니다.

런타임 처리기가 하는 일을 단계적으로 보면:

1. **실행 코드를 받아들임**: 코드 생성기로부터 전달받은 실행 코드를 로드합니다.
2. **물리적 데이터 접근**: 실행 코드의 지시에 따라 디스크의 실제 데이터 파일에 접근합니다.
3. **연산 수행**: 선택, 프로젝션, 조인 등의 연산을 코드에 명시된 순서대로 수행합니다.
4. **결과 반환**: 최종 처리 결과를 사용자에게 전달합니다.

> **핵심:** 런타임 데이터베이스 처리기가 반환하는 결과는 **최적화된 실행 계획에 따라 처리된 결과**이므로, 가장 효율적인 방식으로 얻어진 결과입니다.

:::tip 전체 과정 한 줄 요약
**SQL 입력 → 검사기(토큰 식별) → 파서(문법 검사) → 최적화기(최적 계획 선정) → 코드 생성기(실행 코드 생성) → 런타임 처리기(실행 및 결과 반환)**
:::

---

## 🔄 변환 규칙 종합 정리 — 핵심 원리 한눈에 보기

지금까지 살펴본 12가지 변환 규칙의 핵심을 정리하면, 결국 다음 **6가지 원칙**으로 요약됩니다:

| 원칙 | 설명 | 관련 규칙 |
|------|------|-----------|
| **AND 조건 분리** | AND로 연결된 조건을 개별 선택 연산으로 분리 | 규칙 1 |
| **선택 연산 먼저** | 선택(σ) 연산을 최대한 먼저 실행하여 튜플 수 감소 | 규칙 2, 4, 5, 6, 9 |
| **제한적 선택 우선** | 선택도가 가장 작은(결과 튜플이 가장 적은) 조건을 가장 먼저 실행 | 규칙 2 활용 |
| **카티션 프로덕트 + 선택 → 조인** | 곱한 후 선택하는 것은 조인으로 변환 | 규칙 5 |
| **프로젝션 먼저** | 프로젝션(π) 연산을 먼저 실행하여 불필요한 속성 제거 | 규칙 3, 8, 9 |
| **OR 조건 → 논리곱 정형식** | OR로 연결된 조건식을 AND 기반의 정형식으로 변환 | 규칙 12 |

이 원칙들의 공통된 목표는 단 하나입니다:

> **연산에 참여하는 튜플(행)의 수와 속성(열)의 수를 최대한 줄여서, 처리해야 할 데이터의 양을 최소화하는 것**

마치 요리를 할 때, 냉장고의 모든 재료를 꺼내놓고 요리하는 것보다, 필요한 재료만 꺼내서 요리하는 것이 효율적인 것과 같은 원리입니다.

---

## ⚠️ 주의사항과 실무 팁

### 흔히 하는 실수

:::warning 흔한 실수 모음
1. **카티션 프로덕트를 먼저 수행하는 것**: 두 테이블을 무조건 곱하면 데이터가 폭발적으로 증가합니다. 반드시 선택 연산을 먼저 수행하거나, 조인 연산으로 변환하세요.
2. **불필요한 속성(컬럼)을 모두 가져오는 것**: `SELECT *` 대신 필요한 컬럼만 명시하면 프로젝션 연산이 먼저 수행되어 성능이 향상됩니다.
3. **의미적으로 불가능한 질의를 최적화하려는 것**: 데이터의 무결성 제약조건을 알고 있다면, 결과가 없을 것이 명확한 질의는 굳이 복잡한 최적화를 거칠 필요가 없습니다.
:::

### 알아두면 좋은 팁

:::tip 실무에서의 최적화
- 데이터베이스 시스템은 **데이터 사전(카탈로그)**에 저장된 통계 정보를 자동으로 참조하여 최적화를 수행합니다. 따라서 통계 정보가 최신 상태로 유지되는 것이 중요합니다.
- 경험적 최적화와 비용 기반 최적화를 **함께 사용**하는 것이 일반적입니다. 경험적 규칙으로 범위를 좁히고, 비용 계산으로 최종 선정합니다.
- 사용하는 DBMS의 종류(대형 vs 소형 vs 분산)에 따라 비용식에서 **어떤 요소에 가중치를 두는지**가 달라집니다.
:::

---

## 📌 핵심 정리

- **SQL은 고급 질의어**로, 시스템 내부에서 여러 단계를 거쳐 변환·최적화된 후 실행된다.
- 질의어 처리는 **검사기(Scanner) → 파서(Parser) → 최적화기(Optimizer) → 코드 생성기(Code Generator) → 런타임 데이터베이스 처리기(Runtime DB Processor)** 순서로 진행된다.
- **검사기**는 질의문의 요소(토큰)를 식별하고, **파서**는 문법 오류(Syntax Error)를 검사한다.
- **질의어 최적화기**는 여러 실행 계획 중 가장 비용이 적게 드는 최적의 계획을 선정한다.
- **선택도(Selectivity)**가 작은 조건을 먼저 실행하여 연산에 참여하는 튜플 수를 줄이는 것이 최적화의 핵심 원리이다.
- 최적화 방법에는 **경험적 최적화**, **비용 기반 최적화**, **의미적 질의 최적화** 3가지가 있다.
- 최적화 내부는 **4단계**(내부 표현 변환 → 효율적 형태 변환 → 후보 선정 → 계획 평가/선정)로 이루어진다.
- 12가지 **변환 규칙**의 공통 목표는 선택·프로젝션 연산을 먼저 수행하여 처리 데이터 양을 최소화하는 것이다.
- **코드 생성기**는 선정된 실행 계획을 실행 가능한 코드로 변환하고, **런타임 처리기**가 이를 실행하여 최적화된 결과를 반환한다.
- 카티션 프로덕트 + 선택 연산은 반드시 **조인 연산으로 변환**하여 데이터 폭발을 방지한다.

---

작성일: 2026-02-21