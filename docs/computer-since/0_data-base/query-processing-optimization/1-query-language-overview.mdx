---
title: "고급 질의어 개요와 처리 수행 과정 전체 흐름"
description: "고급 질의어 개요와 처리 수행 과정 전체 흐름에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/query-processing-optimization/1-query-language-overview"
sidebar_label: "질의어 처리 개요"
date: "2026-02-21"
---

## 🎯 고급 질의어란 무엇인가?

우리가 데이터베이스에서 데이터를 조회하거나 수정할 때 사용하는 **SQL(Structured Query Language)**을 떠올려 보세요. `SELECT`, `FROM`, `WHERE` 같은 명령어를 직접 타이핑해서 원하는 데이터를 가져오죠? 이 SQL이 바로 **고급 질의어(High-Level Query Language)**입니다.

> **고급 질의어**란 사람이 읽고 이해할 수 있는 형태로 작성되는 데이터베이스 질의 언어를 말합니다. SQL이 대표적인 고급 질의어입니다.

여기서 "고급"이라는 단어가 붙은 이유를 잠깐 짚고 넘어가겠습니다. 프로그래밍 언어의 세계에서 **고급 언어(High-Level Language)**란 사람이 이해하기 쉬운 언어를 뜻합니다. 반대로 **저급 언어(Low-Level Language)**는 컴퓨터가 직접 이해하는 기계어(0과 1로 이루어진 코드)에 가까운 언어를 말합니다. SQL은 우리가 영어 문장처럼 `SELECT * FROM 학생`이라고 적으면 데이터베이스가 알아서 처리해 주니까, 사람 친화적인 **고급 언어**인 것입니다.

### 💡 고급 질의어를 사용하는 두 가지 방식

고급 질의어는 크게 두 가지 방식으로 사용할 수 있습니다.

1. **대화식(Interactive) 사용**: 사용자가 직접 데이터베이스 서버에 접속해서 SQL 명령어를 입력하고 결과를 확인하는 방식입니다. 마치 카페에서 직접 주문하는 것과 같습니다.
2. **삽입식(Embedded) 사용**: 응용 프로그램(Java, Python 등) 안에 SQL을 삽입해서 프로그램이 자동으로 질의를 처리하는 방식입니다. 마치 배달 앱에서 미리 등록한 주문이 자동으로 나가는 것과 같습니다.

어떤 방식이든 사용자가 작성한 SQL 명령어는 데이터베이스 내부에서 **동일한 처리 과정**을 거치게 됩니다. 이번 문서에서는 바로 그 **처리 과정의 전체 흐름**과 **최적화가 어떻게 이루어지는지**를 자세히 살펴보겠습니다.

:::info 왜 이 내용을 배워야 할까요?
SQL 문법을 아는 것은 데이터베이스의 **기본 과정**에 해당합니다. 하지만 질의어 처리 단계와 최적화를 이해하는 것은 데이터베이스의 **고급 과정**입니다. 이 영역을 이해하면 단순히 SQL을 작성하는 것을 넘어, **데이터베이스 관리자(DBA)**로서 시스템의 성능을 효율적으로 관리하고 최적화하는 능력을 갖출 수 있습니다.
:::

---

## 🔄 질의어 처리의 전체 수행 과정

사용자가 SQL 명령어를 입력하면, 그 명령어가 바로 실행되는 것이 아닙니다. 마치 해외에서 주문한 택배가 여러 물류센터를 거쳐 집까지 도착하듯이, SQL 명령어도 **여러 단계의 처리 과정**을 거쳐 최종 결과가 출력됩니다.

전체 흐름을 한눈에 정리하면 다음과 같습니다.

| 순서 | 처리 구성요소 | 역할 | 결과물 |
|:---:|:---:|:---|:---:|
| 1 | **검사기(Scanner)** | 질의문의 요소(토큰)를 식별 | 토큰 목록 |
| 2 | **파서(Parser)** | 문법 오류 검사 | 내부 형태 질의문 |
| 3 | **질의어 최적화기(Optimizer)** | 가장 효율적인 실행 계획 선정 | 질의문 계획 |
| 4 | **코드 생성기(Code Generator)** | 선정된 계획을 실행 코드로 변환 | 질의문 실행 코드 |
| 5 | **런타임 DB 처리기(Runtime DB Processor)** | 실행 코드를 실제로 실행 | 질의어 실행 결과 |

> 💡 **핵심 포인트**: 네모 상자에 해당하는 것(검사기, 파서, 최적화기, 코드 생성기, 런타임 처리기)은 **시스템의 구성요소**이고, 각 단계 사이에서 나오는 것(내부 형태 질의문, 질의문 계획, 실행 코드, 실행 결과)은 **각 단계의 결과물**입니다.

비유하자면 이렇습니다. 여러분이 레스토랑에서 "스테이크 하나 주세요"라고 주문(고급 질의어)하면:

1. **접수 직원(검사기)**: "스테이크"라는 메뉴가 뭔지 식별합니다
2. **주문 검증 담당(파서)**: 주문 형식이 올바른지 확인합니다 (메뉴에 있는 것인지, 수량은 맞는지)
3. **주방장(최적화기)**: 가장 효율적인 조리 순서를 결정합니다
4. **조리 레시피 작성(코드 생성기)**: 결정된 순서대로 조리 지시서를 만듭니다
5. **실제 조리(런타임 처리기)**: 지시서대로 요리해서 완성된 스테이크(결과)를 내놓습니다

---

## 🔍 각 처리 단계 상세 설명

### 1단계: 검사기(Scanner) - 토큰 식별

질의문이 데이터베이스에 들어오면 **가장 먼저 만나는 것이 검사기(Scanner)**입니다. 검사기의 역할은 질의문을 구성하는 **각 요소(토큰, Token)**를 식별하는 것입니다.

**토큰(Token)**이란 질의문을 이루는 최소 단위의 의미 있는 조각을 말합니다. 마치 문장을 단어 단위로 쪼개는 것과 같습니다.

간단한 예시를 보겠습니다.

```sql
-- 학생 테이블의 모든 정보를 출력하는 질의문
SELECT * FROM 학생
```

이 명령어가 검사기에 들어오면, 검사기는 다음과 같이 토큰을 식별합니다:

- `SELECT` → 키워드(명령어 종류)
- `*` → 와일드카드(모든 속성)
- `FROM` → 키워드(테이블 지정)
- `학생` → 테이블 이름

검사기는 "아, 이 명령어는 `SELECT` 명령어이고, `SELECT`절과 `FROM`절로 구성되어 있으며, 대상 테이블은 '학생'이구나"라고 파악하는 것입니다. 이 과정은 마치 우체국에서 편지를 받았을 때, 보내는 사람/받는 사람/주소 등을 하나하나 식별하는 것과 같습니다.

### 2단계: 파서(Parser) - 문법 오류 검사

검사기가 토큰을 식별했으면, 그 다음은 **파서(Parser)**가 **문법(Syntax)이 올바른지 검사**합니다. 이것은 프로그래밍에서 **컴파일(Compile)**할 때 문법 오류를 체크하는 것과 동일한 개념입니다.

```sql
-- ✅ 올바른 문법
SELECT * FROM 학생

-- ❌ 잘못된 문법 (FROM이 빠짐)
SELECT * 학생

-- ❌ 잘못된 문법 (SELECT 철자 오류)
SELEC * FROM 학생
```

파서는 "SELECT 명령어의 올바른 문법은 `SELECT ... FROM ... [WHERE ...]` 형태인데, 이 질의문이 그 형식에 맞는가?"를 확인합니다. 만약 문법에 오류가 있으면 여기서 에러 메시지를 반환하고, 문법이 올바르면 다음 단계로 넘어갑니다.

파서를 거치면 **내부 형태 질의문(Internal Representation)**이 만들어집니다. 이 내부 형태 질의문은 **질의 트리(Query Tree)** 또는 **질의 그래프(Query Graph)** 형태로 표현됩니다.

:::note 질의 트리 vs 질의 그래프
- **관계 대수(Relational Algebra)** 기반 → **질의 트리(Query Tree)** 사용
- **관계 해석(Relational Calculus)** 기반 → **질의 그래프(Query Graph)** 사용

일반적으로 데이터베이스에서는 관계 대수 기반의 **질의 트리**를 주로 사용합니다.
:::

### 3단계: 질의어 최적화기(Query Optimizer) - 최적 실행 계획 선정

이 단계가 전체 과정에서 **가장 핵심적이고 중요한 단계**입니다. 최적화기는 내부 형태 질의문을 받아서 **여러 가지 실행 계획(Execution Plan)**을 만들어 내고, 그 중에서 **가장 비용이 적게 드는 최적의 계획을 선정**합니다.

이 개념을 일상생활로 비유해 보겠습니다. 여러분이 집(A)에서 학교(B)까지 가는 방법이 여러 가지 있다고 생각해 보세요:

- **경로 1**: 버스 → 지하철 환승 → 도보 10분
- **경로 2**: 자전거로 직진
- **경로 3**: 버스만 타고 가기
- **경로 4**: 지하철 → 버스 환승

이 중에서 시간과 비용을 고려해서 **가장 효율적인 경로를 선택**하는 것, 이것이 바로 최적화기가 하는 일입니다.

### 4단계: 코드 생성기(Code Generator) - 실행 코드 생성

최적화기가 "이 방법이 가장 효율적이야!"라고 선정하면, 그 계획을 실제로 실행할 수 있는 **실행 코드(Execution Code)**로 변환합니다. 마치 최적의 경로를 내비게이션에 입력하는 것과 같습니다.

### 5단계: 런타임 데이터베이스 처리기(Runtime DB Processor) - 실행 및 결과 반환

코드 생성기가 만들어 낸 실행 코드를 **실제로 실행**하여 최종 결과를 반환합니다. 내비게이션의 안내에 따라 실제로 운전해서 목적지에 도착하는 것과 같습니다. 이 결과는 가장 최적화된 방법으로 처리된 결과이므로, **성능 면에서 가장 효율적인 결과**가 됩니다.

---

## ⚡ 질의어 최적화 핵심 원리 — 왜 최적화가 필요한가?

### 하나의 SQL, 여러 가지 실행 방법

사용자는 SQL 명령어를 **하나만** 작성하지만, 데이터베이스 내부에서는 그 명령어를 실행할 수 있는 **방법이 여러 가지** 존재합니다. 이것을 구체적인 예시로 이해해 봅시다.

```sql
-- 학생 테이블에서 성별이 '남자'이고 지역이 '서울'인 학생의 학번을 검색
SELECT 학번
FROM 학생
WHERE 성별 = '남자' AND 지역 = '서울';
```

이 질의문을 실행하는 방법은 최소 3가지가 있습니다:

| 계획 | 방법 | 설명 |
|:---:|:---|:---|
| 계획 1 | 성별 먼저 → 지역 나중에 | 남자를 먼저 찾고, 그 중에서 서울인 학생을 찾음 |
| 계획 2 | 지역 먼저 → 성별 나중에 | 서울 학생을 먼저 찾고, 그 중에서 남자를 찾음 |
| 계획 3 | 동시 검색 | 한 명씩 확인하며 남자이면서 서울인 학생을 동시에 찾음 |

세 가지 방법 모두 **같은 결과**를 내지만, **처리 속도와 효율은 다릅니다**.

### 선택도(Selectivity)의 개념

어떤 계획이 가장 효율적인지 판단하는 핵심 기준이 바로 **선택도(Selectivity)**입니다.

> **선택도**란 전체 데이터 중에서 특정 조건을 만족하는 데이터의 비율을 말합니다. 선택도가 작을수록 해당 조건으로 걸러지는 데이터가 적다는 의미입니다.

구체적인 숫자로 이해해 봅시다:

- 학생 총 **100명**
- 남학생: **10명** → 선택도 = 10/100 = **10%**
- 서울 거주 학생: **50명** → 선택도 = 50/100 = **50%**

```sql
-- 계획 1: 성별 먼저 (선택도 10%) → 지역 나중에
-- 1단계: 100명 중 남자 10명 추출
-- 2단계: 10명 중 서울 거주자 검색 → 훨씬 빠름!

-- 계획 2: 지역 먼저 (선택도 50%) → 성별 나중에
-- 1단계: 100명 중 서울 50명 추출
-- 2단계: 50명 중 남자 검색 → 계획 1보다 느림
```

**선택도가 작은 조건을 먼저 적용**하면 연산에 참여하는 데이터(튜플) 수가 대폭 줄어들기 때문에 훨씬 효율적입니다. 위 예시에서는 계획 1이 가장 효율적이죠. 10명 중에서 서울인 학생을 찾는 것이, 50명 중에서 남자를 찾는 것보다 당연히 빠르니까요.

:::tip 선택도 정보는 어디서 올까?
"남자가 10명이고 서울이 50명이라는 정보를 시스템이 어떻게 알까?"라고 궁금하실 수 있습니다. 이 정보는 사용자가 직접 알려주는 것이 아니라, **데이터 사전(Data Dictionary / Catalog)**에 저장된 **통계 데이터**를 참조하여 시스템이 자동으로 파악합니다. 최적화기는 이 통계 데이터를 활용하여 자동으로 최적화를 수행합니다.
:::

---

## 🛠️ 최적화의 세 가지 방법

질의어 최적화에는 크게 세 가지 접근 방법이 있습니다.

### 1. 경험적 최적화 (Heuristic Optimization)

**경험적 최적화**란 오랜 시간 데이터베이스를 운영하면서 축적된 **경험적 규칙(Rule)**에 따라 최적화하는 방법입니다. 마치 매일 출퇴근하면서 "이 시간대에는 이 길이 가장 빠르더라"라는 경험을 활용하는 것과 같습니다.

대표적인 경험적 처리 전략은 다음과 같습니다:

- **선택 연산(Selection)을 가능하면 먼저 수행하라**: `WHERE`절의 조건을 먼저 적용해서 연산에 참여하는 튜플 수를 줄이라는 것입니다.
- **카티션 프로덕트(Cartesian Product) + 선택 연산 → 조인(Join) 연산으로 바꿔라**: 두 테이블을 먼저 곱해서 거대한 결과를 만들고 그 중에서 조건에 맞는 것을 찾는 것보다, 조인 연산으로 바꿔서 조건에 맞는 것만 결합하는 것이 훨씬 효율적입니다.
- **프로젝션(Projection) 연산도 가능하면 먼저 수행하라**: 전체 속성(컬럼)을 다 가져와서 연산하지 말고, 필요한 속성만 먼저 걸러내서 처리하라는 것입니다.
- **공통 연산식은 한 번만 수행하라**: 예를 들어 프로젝트(A, B, C)를 한 뒤 프로젝트(A, B)를 하고 다시 프로젝트(A)를 하면, 결국 프로젝트(A) 한 번만 하면 되는 것과 같습니다.

```sql
-- ❌ 비효율적: 두 테이블을 먼저 곱한 후 조건으로 걸러냄
-- 10행 × 10행 = 100행을 만들고, 그 중에서 조건에 맞는 것을 찾음
SELECT *
FROM R, S
WHERE R.id = S.id;  -- 내부적으로 카티션 프로덕트 후 선택

-- ✅ 효율적: 조인 연산으로 변환 (최적화기가 자동으로 수행)
-- 조건에 맞는 행만 결합하므로 중간 결과가 훨씬 작음
SELECT *
FROM R JOIN S ON R.id = S.id;  -- 직접 조인
```

### 2. 비용 기반 최적화 (Cost-Based Optimization)

**비용 기반 최적화**란 실제 실행에 드는 **비용(Cost)**을 수식으로 계산하여, 비용이 가장 적은 실행 계획을 선택하는 방법입니다.

비용을 계산할 때 고려하는 요소는 다음과 같습니다:

| 비용 요소 | 설명 | 중요한 경우 |
|:---:|:---|:---:|
| **디스크 I/O 비용** | 하드디스크에서 데이터를 읽고 쓰는 비용 | 대형 시스템 |
| **CPU 계산 비용** | CPU에서 연산을 처리하는 비용 | 소형 데이터베이스 |
| **저장 비용** | 중간 결과를 임시로 저장하는 비용 | 복잡한 질의 |
| **통신 비용** | 네트워크로 데이터를 전송하는 비용 | 분산 데이터베이스 |

시스템의 특성에 따라 어디에 더 가중치를 둘지 달라집니다. 대형 데이터베이스는 디스크 I/O가 가장 큰 병목이므로 I/O 비용을 중점적으로 보고, 분산 데이터베이스는 네트워크 통신 비용을 중시합니다.

> **일반적으로 경험적 최적화와 비용 기반 최적화를 함께 사용**하여 가장 효율적인 전략을 찾아냅니다. 경험적 규칙으로 후보를 줄이고, 비용 계산으로 최종 결정을 내리는 방식입니다.

### 3. 의미적 질의 최적화 (Semantic Query Optimization)

**의미적 질의 최적화**란 질의문의 **의미(Semantics)**를 분석하여, 실행할 필요 자체가 없는 질의를 사전에 걸러내는 방법입니다.

```sql
-- ❌ 의미적으로 결과가 있을 수 없는 질의
-- 대학교 학년은 1~4학년까지만 존재
SELECT 이름
FROM 학생
WHERE 학년 >= 5;  -- 5학년 이상은 존재할 수 없음 → 결과 없음

-- 마찬가지 예시: 초등학교에서 8학년을 검색
SELECT 이름
FROM 초등학생
WHERE 학년 = 8;  -- 초등학교는 1~6학년 → 결과 없음
```

위와 같은 질의는 **데이터의 무결성 제약 조건(Integrity Constraint)**을 위반하기 때문에, 굳이 검사기 → 파서 → 최적화기 → 코드 생성기의 전체 과정을 거칠 필요 없이 바로 "결과 없음"을 반환할 수 있습니다. 이렇게 하면 최적화 과정 자체가 **단축**되어 시스템 자원을 절약할 수 있습니다.

---

## 📐 최적화의 4단계 상세 과정

최적화기 내부에서 이루어지는 과정을 더 구체적으로 살펴보면 **4단계**로 나뉩니다.

### 1단계: 질의문을 내부 표현으로 변환

파서가 생성한 중간 결과를 컴퓨터가 처리하기에 적합한 **내부 형태(트리 구조)**로 변환합니다. 이 과정은 **SQL → 관계 대수 → 질의 트리** 순서로 진행됩니다.

구체적인 예시를 단계별로 살펴보겠습니다.

**① 원본 SQL 질의문:**

```sql
-- Reserves 테이블과 Sailors 테이블을 조인하여
-- 조건에 맞는 선원의 이름을 출력하는 질의
SELECT S.sname               -- 선원 이름을 출력
FROM Reserves R, Sailors S   -- 예약 테이블과 선원 테이블에서
WHERE R.sid = S.sid           -- 예약의 선원ID = 선원테이블의 선원ID (조인 조건)
  AND R.bid = 100             -- 보트 번호가 100인 것
  AND S.rating > 5;           -- 등급이 5보다 큰 것
```

한 줄씩 설명하겠습니다:

- `SELECT S.sname`: 최종적으로 화면에 출력할 것은 Sailors 테이블의 sname(선원 이름) 속성입니다.
- `FROM Reserves R, Sailors S`: Reserves(예약) 테이블과 Sailors(선원) 테이블 두 개를 사용합니다. R과 S는 각각의 별칭(alias)입니다.
- `WHERE R.sid = S.sid`: 두 테이블을 조인하는 조건입니다. 예약 테이블의 선원ID와 선원 테이블의 선원ID가 같은 행끼리 연결합니다.
- `AND R.bid = 100`: 추가 조건으로, 보트 번호(bid)가 100인 예약만 대상으로 합니다.
- `AND S.rating > 5`: 또 다른 추가 조건으로, 선원의 등급(rating)이 5보다 큰 경우만 대상으로 합니다.

**② 관계 대수로 변환:**

위 SQL을 관계 대수 형태로 변환하면 다음과 같은 논리적 표현이 됩니다:

```
π(sname)                           ← 최종: sname만 출력 (프로젝션)
  σ(bid=100 AND rating>5)          ← 조건 적용 (셀렉션)
    ⨝(R.sid = S.sid)               ← 두 테이블 조인
      Reserves × Sailors           ← 예약 테이블과 선원 테이블
```

**③ 질의 트리로 변환:**

관계 대수를 트리 구조로 표현하면:

```
        π(sname)                    ← 루트: 최종 출력할 속성
            |
    σ(bid=100 AND rating>5)         ← 조건 필터링
            |
     ⨝(R.sid = S.sid)              ← 조인 연산
        /        \
   Reserves    Sailors              ← 리프: 원본 테이블
```

- **가장 아래(리프 노드)**: 원본 테이블인 Reserves와 Sailors가 위치합니다.
- **중간**: 두 테이블을 sid가 같은 조건으로 조인(⨝)합니다.
- **그 위**: 조인 결과에서 bid=100이고 rating>5인 것만 선택(σ)합니다.
- **가장 위(루트 노드)**: 최종적으로 sname만 출력(π)합니다.

:::info 자료구조에서 배우는 트리가 여기서 사용됩니다
전산학을 전공하시는 분이라면 자료구조 과목에서 트리(Tree), 트리 순회(Traversal) 등을 배우게 됩니다. "트리를 배워서 어디에 쓰지?"라는 의문이 들 수 있는데, 바로 이런 곳에서 사용됩니다. 데이터베이스 내부에서 질의를 최적화할 때 트리 자료구조가 핵심적으로 활용되며, 트리의 노드 위치를 바꾸고(부모-자식 위치 교환) 재구성하면서 최적화를 수행하게 됩니다.
:::

이렇게 SQL을 트리 형태로 변환하면, 트리의 노드 위치를 바꾸고 재배열하면서 **다양한 실행 계획**을 만들어 낼 수 있습니다.

### 2단계: 효율적인 내부 형태로 변환

1단계에서 만든 기본 트리를 **정립된 변환 규칙(Transformation Rules)**을 사용하여 더 효율적인 형태로 바꿔줍니다. 이 변환 규칙은 뒤에서 자세히 설명하겠습니다.

핵심 원칙은 간단합니다:

- **셀렉션(선택 연산)을 트리 아래쪽으로 내려라** → 연산에 참여하는 튜플 수를 최대한 빨리 줄여라
- **프로젝션(투영 연산)을 트리 아래쪽으로 내려라** → 불필요한 속성을 최대한 빨리 제거하라
- **카티션 프로덕트 + 셀렉션 → 조인으로 바꿔라** → 불필요한 곱셈을 피하라

### 3단계: 후보 프로시저 선정

변환을 통해 **여러 가지 실행 계획**이 만들어집니다. 하지만 모든 계획을 일일이 평가하면 오히려 최적화에 시간이 너무 많이 걸립니다.

이것은 마치 선거에 비유할 수 있습니다. 전 국민이 모두 대통령 후보가 되는 것이 아니라, 당선 가능성이 있는 사람만 **후보로 선정**하여 그들을 대상으로 평가하고 투표하는 것과 같습니다.

마찬가지로, 10개의 실행 계획이 만들어졌다면:

1. 경험적으로 "이건 어차피 성능이 떨어지니까 제외" → 몇 개를 걸러냄
2. 남은 것 중 정말 성능이 향상될 만한 것만 **후보로 선정** (예: 3개)
3. 이 후보들만 대상으로 상세 평가 진행

후보를 선정할 때 고려하는 요소들:

- **인덱스(Index)**가 있는가?
- **값의 분포(Value Distribution)**가 어떠한가?
- **물리적 클러스터링(Clustering)**이 되어 있는가?
- **해싱 함수(Hashing Function)**를 사용하는가?
- **연산의 순서**가 어떻게 되어 있는가?

### 4단계: 계획 평가 및 최종 결정

후보로 선정된 계획들을 **비용식(Cost Formula)**으로 평가하여, **비용이 가장 적은 계획을 최종 선정**합니다.

비용식에 들어가는 요소들을 정리하면:

```
총 비용 = 디스크 I/O 비용 + CPU 계산 비용 + 저장 비용 + 통신 비용
```

- **디스크 I/O 비용**: 대형 시스템에서 가장 중요합니다. 데이터 양이 많을수록 하드디스크 접근 횟수가 늘어나기 때문입니다.
- **CPU 계산 비용**: 소형 데이터베이스에서 중요합니다. 데이터 양이 크지 않으므로 CPU 처리 시간이 전체 성능에 영향을 줍니다.
- **저장 비용**: 중간 결과를 임시로 저장해야 하는 비용입니다.
- **통신 비용**: 분산 데이터베이스에서 가장 중요합니다. 여러 서버에 데이터가 분산되어 있으므로 네트워크 전송 비용이 핵심입니다.

각 후보 계획에 대해 비용식을 계산한 결과가 가장 작은 것이 **최종 선정**됩니다. 이렇게 선정된 계획이 코드 생성기로 전달되어 실행 코드가 만들어지고, 런타임 처리기에 의해 실행됩니다.

---

## 📏 내부 형태 변환 규칙 (Transformation Rules) 상세 정리

최적화에서 트리를 효율적인 형태로 변환할 때 사용되는 **정립된 규칙**들을 하나씩 살펴보겠습니다. 이 규칙들은 임의로 만든 것이 아니라, 관계 대수의 수학적 성질에 기반한 **검증된 규칙**입니다.

### 규칙 1: AND 조건의 분리 (Cascade of Selection)

AND로 연결된 여러 조건을 **개별 선택 연산으로 분리**합니다.

```
-- 변환 전: AND 조건을 한 번에 처리
σ(조건1 AND 조건2 AND 조건3)(R)

-- 변환 후: 개별 선택 연산으로 분리
σ(조건1)(σ(조건2)(σ(조건3)(R)))
```

**왜 이렇게 하는가?** 100명의 학생 데이터에서 "남자 AND 서울 AND 점수≥80" 조건을 동시에 검사하면, 한 명씩 가져와서 세 가지 조건을 모두 확인해야 합니다. 하지만 분리하면:

```sql
-- ❌ 비효율적: 100명 전체를 대상으로 3개 조건 동시 확인
SELECT * FROM 학생
WHERE 성별='남자' AND 지역='서울' AND 점수>=80;
-- 내부적으로 100명 × 3조건 = 비효율

-- ✅ 효율적: 단계적으로 데이터를 줄여나감 (최적화기가 자동 변환)
-- 1단계: 100명 → 남자 10명 추출 (선택도 10%)
-- 2단계: 10명 → 서울 거주 3명 추출
-- 3단계: 3명 → 점수 80 이상 1명 추출
```

단계적으로 데이터를 줄여나가면 각 단계에서 처리해야 할 데이터 양이 급격히 감소합니다.

### 규칙 2: 선택 연산의 교환 (Commutativity of Selection)

선택 연산은 **순서를 바꿔도 결과가 동일**합니다.

```
σ(조건1)(σ(조건2)(R)) = σ(조건2)(σ(조건1)(R))
```

이 규칙 덕분에 **선택도가 작은 조건을 먼저 적용**할 수 있습니다. 남자(10%)를 먼저 찾고 서울(50%)을 나중에 찾든, 서울을 먼저 찾고 남자를 나중에 찾든 결과는 같지만, **선택도가 작은 것을 먼저** 하는 것이 효율적입니다.

### 규칙 3: 프로젝션의 축소 (Cascade of Projection)

프로젝션을 여러 번 수행한 것은 **마지막 프로젝션 한 번만 수행**하면 됩니다.

```
π(A)(π(A,B)(π(A,B,C)(R))) = π(A)(R)
```

```sql
-- ❌ 비효율적: 프로젝션을 3번 반복
-- 1단계: A, B, C 속성 추출
-- 2단계: 그 중에서 A, B 속성 추출
-- 3단계: 그 중에서 A 속성 추출

-- ✅ 효율적: 처음부터 A만 추출
SELECT A FROM R;  -- 최종적으로 필요한 것은 A뿐
```

실제 프로그래밍을 하다 보면 이런 중복 프로젝션이 의외로 자주 발생합니다. 최적화기가 이를 자동으로 줄여줍니다.

### 규칙 4: 선택과 프로젝션의 교환 (Commuting Selection and Projection)

프로젝션 후 셀렉션한 것은 셀렉션 후 프로젝션한 것과 **동일**합니다.

```
π(속성목록)(σ(조건)(R)) = σ(조건)(π(속성목록)(R))
```

이 두 연산은 교환적이므로, 상황에 따라 더 효율적인 순서를 선택할 수 있습니다.

### 규칙 5: 선택 연산의 우선 적용 (Pushing Selection Down)

이 규칙이 **가장 중요한 핵심 규칙**입니다. 조인이나 카티션 프로덕트를 한 후에 선택 연산을 하는 것보다, **선택 연산을 먼저 하고 조인을 나중에** 하는 것이 훨씬 효율적입니다.

```
-- 변환 전: R과 S를 곱한 후 조건으로 필터링
σ(R의 조건)(R × S)

-- 변환 후: R에 조건을 먼저 적용한 후 곱하기
(σ(R의 조건)(R)) × S
```

```sql
-- ❌ 비효율적: 10행 × 10행 = 100행을 만든 후 조건 적용
SELECT *
FROM 학생, 수강
WHERE 학생.학번 = 수강.학번
  AND 학생.성별 = '남자';
-- 내부적으로: 100행 생성 → 그 중에서 남자인 것만 필터링

-- ✅ 효율적: 먼저 남자만 추출(10행 → 2행) 후 조인
-- 내부적으로: 학생에서 남자 2행 추출 → 2행 × 10행 = 20행만 처리
```

또한, **카티션 프로덕트 + 셀렉션 = 조인 연산으로 변환**하는 것도 이 규칙에 포함됩니다.

```
-- 변환 전: 카티션 프로덕트 후 조건 적용
σ(R.id = S.id)(R × S)

-- 변환 후: 조인 연산으로 변환
R ⨝(R.id = S.id) S
```

:::warning 카티션 프로덕트의 위험성
카티션 프로덕트(곱하기)는 두 테이블의 **모든 행의 조합**을 만들어 냅니다. R이 10행, S가 10행이면 결과는 100행이 됩니다. R이 1,000행, S가 1,000행이면 결과는 **1,000,000행**이 됩니다! 이렇게 거대한 중간 결과를 만든 후 조건으로 필터링하는 것은 극도로 비효율적입니다. 반드시 **선택 연산을 먼저 수행하거나 조인 연산으로 변환**해야 합니다.
:::

### 규칙 6: 양쪽 테이블에 선택 분배 (Distributing Selection over Join)

두 테이블을 조인한 후 선택 연산을 하는 경우, **각 테이블에 해당하는 선택 조건을 먼저 적용**합니다.

```
-- 변환 전: 조인 후 두 조건 모두 적용
σ(R의조건 AND S의조건)(R ⨝ S)

-- 변환 후: 각 테이블에 선택을 먼저 적용한 후 조인
(σ(R의조건)(R)) ⨝ (σ(S의조건)(S))
```

카티션 프로덕트의 경우도 동일합니다:

```
-- 변환 전: 곱한 후 두 조건 모두 적용
σ(R의조건 AND S의조건)(R × S)

-- 변환 후: 각 테이블에 선택을 먼저 적용한 후 곱하기
(σ(R의조건)(R)) × (σ(S의조건)(S))
```

핵심은 동일합니다: **셀렉션을 먼저 수행하여 연산에 참여하는 튜플 수를 줄여라**.

### 규칙 7: 조인과 집합 연산의 교환 법칙

카티션 프로덕트(×), 합집합(∪), 교집합(∩), 조인(⨝)은 **순서를 바꿔도 결과가 동일**합니다.

```
R × S = S × R
R ∪ S = S ∪ R
R ∩ S = S ∩ R
R ⨝ S = S ⨝ R
```

:::danger 교환 법칙이 성립하지 않는 연산
다음 3가지 연산은 교환 법칙이 **성립하지 않습니다**:
- **세미 조인(Semi Join)**: R ⋉ S ≠ S ⋉ R
- **차집합(Difference)**: R - S ≠ S - R
- **나누기(Division)**: R ÷ S ≠ S ÷ R

이 세 연산은 순서를 바꾸면 결과가 달라지므로 주의해야 합니다.
:::

### 규칙 8: 프로젝션 연산의 우선 적용 (Pushing Projection Down)

조인이나 카티션 프로덕트를 한 후 프로젝션하는 것보다, **각 테이블에서 필요한 속성만 먼저 프로젝션**한 후 조인하는 것이 효율적입니다.

```
-- 변환 전: 조인 후 프로젝션
π(속성목록)(R ⨝ S)

-- 변환 후: 각 테이블에서 필요한 속성만 먼저 추출 후 조인
(π(R의 필요속성)(R)) ⨝ (π(S의 필요속성)(S))
```

불필요한 속성(컬럼)을 미리 제거하면 중간 결과의 크기가 줄어들어 처리 효율이 높아집니다.

### 규칙 9: 집합 연산에 대한 선택/프로젝션 분배

합집합, 교집합, 차집합과 선택/프로젝션을 결합한 경우에도, **선택과 프로젝션을 먼저 수행**합니다.

```
-- 합집합 후 셀렉션 → 셀렉션을 먼저
σ(조건)(R ∪ S) = σ(조건)(R) ∪ σ(조건)(S)

-- 합집합 후 프로젝션 → 프로젝션을 먼저
π(속성)(R ∪ S) = π(속성)(R) ∪ π(속성)(S)
```

원칙은 항상 동일합니다: **셀렉션과 프로젝션을 먼저 수행하여 연산에 참여하는 데이터를 줄여라**.

### 규칙 11: 카티션 프로덕트와 조인의 결합 법칙

세 개 이상의 테이블을 곱하거나 조인할 때, **어떤 순서로 결합해도 결과는 동일**합니다.

```
(R × S) × T = R × (S × T)
(R ⨝ S) ⨝ T = R ⨝ (S ⨝ T)
```

이 규칙 덕분에 어떤 테이블을 먼저 연산에 참여시킬지 **자유롭게 순서를 조정**할 수 있습니다.

### 규칙 12: 집합 연산의 분배 법칙

교집합과 합집합 사이의 분배 법칙입니다. 또한, OR로 연결된 조건식을 **AND로 연결된 논리곱 정형식(CNF)**으로 변환합니다.

```
R ∩ (S ∪ T) = (R ∩ S) ∪ (R ∩ T)
```

이 변환은 중고등학교 수학에서 배운 집합의 분배 법칙과 동일한 원리입니다.

---

## 🔑 변환 규칙의 핵심 정리

모든 변환 규칙을 관통하는 **3가지 핵심 원칙**을 정리하겠습니다.

> 1. **AND 조건은 개별 셀렉션으로 분리하라** (규칙 1)
> 2. **셀렉션(선택 연산)과 프로젝션(투영 연산)을 가능한 먼저 수행하라** (규칙 2, 4, 5, 6, 8, 9)
> 3. **카티션 프로덕트 + 셀렉션은 조인 연산으로 변환하라** (규칙 5)

이 세 가지 원칙의 궁극적인 목표는 단 하나입니다:

> **연산에 참여하는 튜플(행) 수와 속성(열) 수를 최대한 빨리, 최대한 많이 줄여서 처리 비용을 최소화하라.**

마치 냉장고에서 요리 재료를 꺼낼 때, 냉장고 전체를 식탁 위에 쏟아놓고 필요한 것을 고르는 것보다, 처음부터 필요한 재료만 골라서 꺼내는 것이 훨씬 효율적인 것과 같은 원리입니다.

```sql
-- ❌ 최악의 패턴: 모든 것을 다 가져온 후 나중에 필터링
-- 1. 두 테이블의 카티션 프로덕트 (거대한 중간 결과 생성)
-- 2. 그 중에서 조건에 맞는 행 필터링
-- 3. 필요한 열만 추출
SELECT 학생.이름
FROM 학생, 수강
WHERE 학생.학번 = 수강.학번
  AND 학생.성별 = '남자'
  AND 수강.과목 = '데이터베이스';

-- ✅ 최적화기가 내부적으로 변환하는 형태:
-- 1. 학생 테이블에서 남자만 추출 (셀렉션 먼저)
-- 2. 수강 테이블에서 '데이터베이스' 과목만 추출 (셀렉션 먼저)
-- 3. 두 결과를 학번으로 조인 (카티션 프로덕트 대신 조인)
-- 4. 이름만 출력 (프로젝션)
```

위 두 질의는 사용자 입장에서는 **동일한 SQL**이지만, 최적화기 내부에서는 아래와 같은 효율적인 순서로 변환되어 실행됩니다. 이것이 바로 질의어 최적화의 핵심입니다.

:::tip 실무에서의 시사점
사용자가 SQL을 작성할 때 굳이 이런 최적화를 직접 고려할 필요는 없습니다. 데이터베이스의 **질의어 최적화기가 자동으로** 가장 효율적인 실행 계획을 찾아서 실행해 줍니다. 하지만 이 원리를 이해하면:
- 왜 특정 쿼리가 느린지 원인을 파악할 수 있습니다
- 실행 계획(EXPLAIN)을 읽고 해석할 수 있습니다
- 인덱스 설계 등 성능 튜닝에 대한 판단력을 갖출 수 있습니다
:::

---

## 📌 핵심 정리

- **고급 질의어(SQL)**는 사람이 이해하기 쉬운 고급 언어이며, 내부적으로 여러 처리 단계를 거쳐 실행된다
- **전체 처리 흐름**: 고급 질의어 → 검사기(Scanner) → 파서(Parser) → 질의어 최적화기 → 코드 생성기 → 런타임 DB 처리기 → 실행 결과
- **검사기(Scanner)**는 질의문의 각 요소(토큰)를 식별하고, **파서(Parser)**는 문법 오류를 검사한다
- **질의어 최적화기**는 하나의 SQL에 대해 여러 실행 계획을 생성하고, 가장 비용이 적은 계획을 선정한다
- **선택도(Selectivity)**가 작은 조건을 연산에 먼저 참여시키면 처리할 데이터 양이 줄어들어 효율적이다
- **최적화 3가지 방법**: 경험적 최적화(경험 규칙 기반), 비용 기반 최적화(비용식 계산), 의미적 질의 최적화(무결성 제약 활용)
- **최적화 4단계**: 내부 표현 변환(트리 생성) → 효율적 형태 변환(규칙 적용) → 후보 선정 → 비용 평가 및 최종 결정
- **변환 규칙의 핵심**: 셀렉션과 프로젝션을 가능한 먼저 수행하고, 카티션 프로덕트+셀렉션은 조인으로 변환하여 연산에 참여하는 튜플 수를 줄인다
- **비용식 구성 요소**: 디스크 I/O 비용, CPU 계산 비용, 저장 비용, 통신 비용 (시스템 특성에 따라 가중치가 다름)
- 선택도 등 통계 정보는 **데이터 사전(카탈로그)**에 저장되어 있으며, 최적화기가 자동으로 참조한다

작성일: 2026-02-21