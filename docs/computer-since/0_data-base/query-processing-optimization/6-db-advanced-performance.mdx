---
title: "데이터베이스 고급 과정과 성능 최적화의 의미"
description: "데이터베이스 고급 과정과 성능 최적화의 의미에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/query-processing-optimization/6-db-advanced-performance"
sidebar_label: "성능 최적화 의의"
date: "2026-02-21"
---

## 🎯 질의어 처리와 최적화란 무엇인가?

우리가 데이터베이스에 "이 데이터를 찾아줘"라고 요청할 때 사용하는 언어가 바로 **SQL(Structured Query Language)**입니다. SQL은 프로그래밍 언어 중에서 **고급 언어(High-level Language)**에 해당합니다. 여기서 "고급"이라는 말은 "어렵다"는 뜻이 아니라, **사람이 이해하기 쉬운 형태로 작성할 수 있다**는 의미입니다. 마치 우리가 한국어로 "학생 명단 보여줘"라고 말하는 것처럼, `SELECT * FROM 학생`이라고 자연스럽게 명령을 내릴 수 있는 것이죠.

그런데 여기서 중요한 질문이 하나 생깁니다. **사용자가 작성한 SQL 명령어 한 줄이 데이터베이스 내부에서는 어떤 과정을 거쳐 실행될까요?** 그리고 같은 결과를 내는 여러 가지 실행 방법 중에서 **가장 빠르고 효율적인 방법**은 어떻게 찾아낼까요?

이것이 바로 **질의어 처리 단계 및 최적화**의 핵심 주제입니다. 사용자가 SQL 명령어를 입력하면, 데이터베이스 시스템은 그 명령어를 분석하고, 여러 가지 실행 방법을 비교한 뒤, **가장 비용이 적게 드는 최적의 방법**을 선택하여 실행합니다. 이 전체 과정을 이해하는 것이 이번 문서의 목표입니다.

> **질의어 최적화**란, 하나의 SQL 명령어를 실행할 수 있는 여러 가지 방법 중에서 **성능이 가장 좋은 실행 계획을 자동으로 찾아내는 과정**입니다.

---

## 📚 왜 최적화를 알아야 하는가? — 데이터베이스 기본 과정과 고급 과정

### 기본 과정 vs 고급 과정

데이터베이스 학습은 크게 **기본 과정**과 **고급 과정**으로 나눌 수 있습니다.

| 구분 | 다루는 내용 | 예시 |
|------|-------------|------|
| **기본 과정** | 데이터베이스 설계, SQL 문법, 권한 관리 | `SELECT`, `INSERT`, `JOIN`, `GRANT` 등 |
| **고급 과정** | 질의 최적화, 병행 제어, 회복(Recovery) | 실행 계획 분석, 트랜잭션 관리, 장애 복구 등 |

기본 과정에서는 "**어떻게 데이터를 저장하고 꺼내올 것인가**"를 배웠다면, 고급 과정에서는 "**어떻게 하면 더 빠르고 효율적으로 처리할 것인가**"를 배우는 것입니다.

### 왜 이게 중요한가?

비유를 들어보겠습니다. 여러분이 요리를 배운다고 생각해보세요. 기본 과정은 **"재료를 자르고, 볶고, 끓이는 법"**을 배우는 것입니다. 고급 과정은 **"같은 요리를 만들더라도 재료를 어떤 순서로 넣어야 가장 맛있고, 가장 빨리 완성할 수 있는가"**를 연구하는 것입니다. 

데이터베이스도 마찬가지입니다. 수백만 건의 데이터가 들어있는 테이블에서 단순히 `SELECT`를 실행하는 것과, **최적화된 방식으로 실행하는 것**은 처리 시간이 수십 배에서 수백 배까지 차이가 날 수 있습니다. 이런 영역을 이해하면 **데이터베이스 관리자(DBA)**로서 시스템을 효율적으로 관리하고, 성능 문제를 진단하는 능력을 갖출 수 있게 됩니다.

:::info 데이터베이스 고급 과정의 위치
SQL 문법, 테이블 설계, 권한 관리까지가 **기본 과정**이고, 질의 최적화·병행 제어·회복 등은 **고급 과정**에 해당합니다. 고급 과정을 이해해야 진정한 데이터베이스 관리자로서 성능을 고려한 시스템 운영이 가능해집니다.
:::

---

## ⚙️ 질의어 처리의 전체 수행 과정 — 5단계 파이프라인

SQL 명령어가 입력되면, 데이터베이스 내부에서는 다음과 같은 **5단계 파이프라인**을 거쳐 결과가 만들어집니다. 마치 공장의 조립 라인처럼, 각 단계를 순서대로 거치면서 최종 결과물이 완성되는 구조입니다.

```
고급 질의어(SQL)
    ↓
[1] 검사기(Scanner)     → 토큰 식별
    ↓
[2] 파서(Parser)        → 문법 검사 → ✅ 내부 형태 질의문
    ↓
[3] 질의 최적화기       → 실행 계획 생성 & 최적 계획 선정 → ✅ 질의문 계획
    ↓
[4] 코드 생성기         → 실행 코드 생성 → ✅ 질의문 실행 코드
    ↓
[5] 런타임 DB 처리기    → 실행 → ✅ 질의 실행 결과
```

여기서 **네모 박스로 표시된 것**(검사기, 파서, 최적화기, 코드 생성기, 런타임 DB 처리기)은 **시스템의 구성 요소**이고, 각 단계 사이에 나오는 것(내부 형태 질의문, 질의문 계획, 실행 코드, 실행 결과)은 **각 단계에서 나오는 결과물(산출물)**입니다.

| 단계 | 구성 요소 | 산출물 | 하는 일 |
|------|-----------|--------|---------|
| 1단계 | 검사기(Scanner) | 토큰(Token) | SQL 명령어의 각 요소를 식별 |
| 2단계 | 파서(Parser) | 내부 형태 질의문 | 문법 오류 검사 |
| 3단계 | 질의 최적화기(Optimizer) | 질의문 계획 | 최적 실행 계획 선정 |
| 4단계 | 코드 생성기(Code Generator) | 질의문 실행 코드 | 실행 가능한 코드 생성 |
| 5단계 | 런타임 DB 처리기 | 질의 실행 결과 | 실제 데이터 처리 및 결과 반환 |

이제 각 단계를 하나씩 자세히 살펴보겠습니다.

---

## 🔍 1단계 · 2단계: 검사기(Scanner)와 파서(Parser)

### 검사기(Scanner) — "이 명령어가 뭔지 알아보자"

SQL 명령어가 데이터베이스에 들어오면, 가장 먼저 만나는 것이 **검사기(Scanner)**입니다. 검사기의 역할은 입력된 SQL 문장을 읽어서 **각 구성 요소(토큰, Token)를 식별**하는 것입니다.

비유하자면, 마치 우체국 직원이 편지를 받아서 **"이건 보내는 사람 이름이고, 이건 받는 사람 주소이고, 이건 우편번호구나"**하고 각 부분을 구분하는 것과 같습니다.

```sql
-- 예시 SQL 명령어
SELECT * FROM 학생
```

검사기가 이 명령어를 읽으면 다음과 같이 **토큰(Token)**을 식별합니다:

- `SELECT` → 키워드(명령어 종류)
- `*` → 와일드카드(모든 컬럼을 의미)
- `FROM` → 키워드(테이블 지정)
- `학생` → 테이블 이름(식별자)

> **토큰(Token)**이란, SQL 문장을 구성하는 **의미 있는 최소 단위**를 말합니다. 검사기는 SQL 문장을 이 토큰 단위로 쪼개는 역할을 합니다.

### 파서(Parser) — "문법이 맞는지 확인하자"

검사기가 토큰을 식별한 후, 다음 단계로 **파서(Parser)**에게 넘깁니다. 파서는 **문법 오류(Syntax Error)가 있는지 없는지를 검사**합니다.

이것은 마치 국어 선생님이 학생의 작문을 보면서 **"주어가 있는지, 서술어가 있는지, 문장 구조가 올바른지"**를 확인하는 것과 같습니다. Java나 Python에서 코드를 작성한 후 **컴파일(Compile)**하는 과정과 동일한 원리입니다.

```sql
-- ❌ 잘못된 예시: 문법 오류가 있는 SQL
SELEC * FORM 학생    -- SELECT 철자 오류, FROM 철자 오류
```

```sql
-- ✅ 올바른 예시: 문법이 정확한 SQL
SELECT * FROM 학생   -- SELECT, FROM 키워드가 정확하고 구조도 올바름
```

파서는 `SELECT` 명령어의 문법 규칙이 `SELECT ... FROM ... [WHERE ...]` 형태인지 확인합니다. 문법이 맞으면 **내부 형태 질의문**을 생성하여 다음 단계로 넘기고, 문법 오류가 있으면 **에러 메시지**를 사용자에게 반환합니다.

:::warning 검사기와 파서의 차이
- **검사기(Scanner)**: SQL 문장의 각 **요소(토큰)**를 식별합니다. "이건 키워드야, 이건 테이블명이야"를 구분하는 단계입니다.
- **파서(Parser)**: 식별된 토큰들이 **올바른 문법 구조**를 따르는지 검사합니다. "SELECT 다음에 FROM이 있어야 하는데, 순서가 맞나?"를 확인하는 단계입니다.
:::

---

## 🚀 3단계: 질의 최적화기 — 가장 효율적인 실행 계획 찾기

### 최적화기가 하는 일

파서를 통과하여 문법적으로 이상이 없다고 확인되면, 이제 **질의 최적화기(Query Optimizer)**가 등장합니다. 최적화기는 이 문서에서 가장 중요한 핵심 구성 요소입니다.

최적화기의 역할을 실생활로 비유하면 이렇습니다. 여러분이 **집에서 학교까지 가는 길**을 생각해보세요.

- **경로 1**: 버스를 타고 30분
- **경로 2**: 지하철을 타고 25분  
- **경로 3**: 자전거를 타고 40분
- **경로 4**: 버스 + 지하철 환승으로 20분

목적지는 같지만, 가는 방법은 여러 가지입니다. 이 중에서 **가장 빠르고 비용이 적게 드는 경로**를 찾아내는 것이 바로 최적화기의 역할입니다.

SQL도 마찬가지입니다. **하나의 SQL 명령어를 실행하는 방법은 여러 가지**가 있습니다. 최적화기는 이 여러 가지 실행 계획(Execution Plan) 중에서 **가장 비용이 적게 드는 최적의 실행 전략**을 찾아냅니다.

### 구체적인 예시로 이해하기

다음과 같은 SQL을 실행한다고 가정해보겠습니다:

```sql
-- 학생 테이블에서 성별이 '남'이고 지역이 '서울'인 학생의 학번을 검색
SELECT 학번
FROM 학생
WHERE 성별 = '남' AND 지역 = '서울';
```

이 SQL을 실행하는 방법은 최소 3가지가 있습니다:

| 실행 계획 | 방법 | 과정 |
|-----------|------|------|
| **계획 A** | 성별 먼저 → 지역 나중 | 100명 중 남학생 10명 추출 → 10명 중 서울 거주자 검색 |
| **계획 B** | 지역 먼저 → 성별 나중 | 100명 중 서울 거주자 50명 추출 → 50명 중 남학생 검색 |
| **계획 C** | 동시에 검색 | 100명을 한 명씩 확인하며 남학생 + 서울 동시 체크 |

자, 여기서 **학생이 총 100명**이고, **남학생은 10명**, **서울 거주자는 50명**이라고 가정해봅시다.

- **계획 A**: 먼저 100명에서 남학생 10명만 추출합니다. 그런 다음 10명 중에서 서울 거주자를 찾습니다. 검색 대상이 **10명**으로 크게 줄었죠!
- **계획 B**: 먼저 100명에서 서울 거주자 50명을 추출합니다. 그런 다음 50명 중에서 남학생을 찾습니다. 검색 대상이 **50명**이나 됩니다.
- **계획 C**: 100명 한 명 한 명을 확인하면서 두 조건을 동시에 체크합니다.

상식적으로 생각해도 **계획 A가 가장 효율적**입니다. 왜냐하면 처음에 10명만 추려내면, 그 다음 검색 대상이 확 줄어들기 때문입니다.

### 선택도(Selectivity)의 개념

여기서 등장하는 중요한 개념이 **선택도(Selectivity)**입니다.

> **선택도(Selectivity)**란, 전체 데이터 중에서 **특정 조건을 만족하는 데이터의 비율**을 말합니다. 선택도가 낮을수록(비율이 작을수록) 그 조건을 먼저 적용하는 것이 효율적입니다.

위 예시에서:
- 성별 = '남'의 선택도: 10/100 = **10%** (낮음 → 먼저 실행!)
- 지역 = '서울'의 선택도: 50/100 = **50%** (높음 → 나중에 실행)

**선택도가 작은 조건을 먼저 적용**하면, 연산에 참여하는 데이터(튜플) 수가 크게 줄어들어 전체 처리 속도가 빨라집니다.

### 선택도 정보는 누가 알고 있나?

여기서 "남학생이 10명이고 서울 거주자가 50명이라는 걸 어떻게 아는 거지?"라는 의문이 생길 수 있습니다. 이 정보는 **사용자가 아는 것이 아니라, 시스템이 자동으로 알고 있습니다**.

데이터베이스에는 **데이터 사전(Data Dictionary)** 또는 **카탈로그(Catalog)**라고 불리는 곳에 각 테이블의 **통계 정보(데이터 분포, 행 수, 인덱스 정보 등)**가 저장되어 있습니다. 최적화기는 이 통계 정보를 참조하여 **자동으로** 가장 효율적인 실행 계획을 선정합니다.

:::tip 최적화는 자동으로 이루어진다
사용자가 직접 "이 조건을 먼저 실행해줘"라고 지시할 필요가 없습니다. **질의 최적화기가 카탈로그의 통계 정보를 참조하여 자동으로 최적의 실행 순서를 결정**합니다. 이것이 데이터베이스 시스템이 똑똑한 이유입니다!
:::

---

## 🔧 4단계 · 5단계: 코드 생성과 실행

### 코드 생성기(Code Generator)

최적화기가 "계획 A가 가장 좋다"고 선정했다면, 이제 그 계획을 **실제로 실행할 수 있는 코드**로 변환해야 합니다. 이 역할을 하는 것이 **코드 생성기**입니다.

비유하자면, 건축 설계도(실행 계획)가 완성되었으니 이제 **실제 공사를 위한 작업 지시서(실행 코드)**를 만드는 단계입니다. "먼저 성별='남' 조건으로 데이터를 필터링하고, 그 결과에서 지역='서울' 조건을 적용하라"는 구체적인 실행 명령이 코드로 만들어집니다.

### 런타임 데이터베이스 처리기(Runtime Database Processor)

마지막으로, 생성된 실행 코드를 **런타임 데이터베이스 처리기**가 실제로 실행합니다. 실제 디스크에서 데이터를 읽어오고, 조건에 맞는 데이터를 필터링하고, 최종 결과를 사용자에게 반환합니다.

이 모든 과정을 거쳐 나온 결과는 **가장 최적화된 방법으로 처리된 결과**입니다. 사용자는 단순히 SQL 한 줄을 작성했을 뿐이지만, 내부적으로는 이렇게 정교한 과정을 거쳐 최적의 성능으로 결과를 얻게 되는 것입니다.

---

## 🧠 최적화의 세 가지 방법

질의 최적화를 수행하는 방법에는 크게 세 가지가 있습니다.

### 1. 경험적 최적화 (Heuristic Optimization)

**경험적 최적화**란, 과거의 경험을 통해 "이렇게 하면 대부분 효율적이더라"라는 **경험적 규칙(Heuristic Rules)**을 기반으로 최적화하는 방법입니다.

비유하자면, 여러분이 매일 출퇴근하면서 "이 길이 가장 빠르다"는 경험을 쌓게 되는 것과 같습니다. 매번 모든 경로의 시간을 재볼 필요 없이, **경험적으로 알고 있는 최적 경로**를 선택하는 것이죠.

경험적 처리 전략의 핵심 규칙들:

- **선택 연산(Selection)을 가능하면 먼저 수행하라**: WHERE절의 조건을 먼저 적용하여 연산에 참여하는 튜플(행) 수를 줄여라
- **카티션 프로덕트(Cartesian Product) + 선택 연산은 조인(Join) 연산으로 바꿔라**: 두 테이블을 무조건 곱한 뒤 조건으로 걸러내는 것보다, 조인 연산으로 한 번에 처리하는 것이 훨씬 효율적이다
- **프로젝션(Projection) 연산도 가능하면 먼저 수행하라**: 필요한 컬럼만 먼저 추출하여 처리하는 데이터의 양을 줄여라
- **공통 연산식은 한 번만 수행하라**: 중복되는 계산은 마지막 것만 실행해도 된다

:::note 카티션 프로덕트(Cartesian Product)가 왜 비효율적인가?
테이블 R에 10개, 테이블 S에 10개의 데이터가 있다고 가정합시다. 카티션 프로덕트를 하면 10 × 10 = **100개의 조합**이 만들어집니다. 이 100개 중에서 조건에 맞는 것만 골라내는 것은 매우 비효율적입니다. 반면 조인 연산은 **조건에 맞는 것만 결합**하므로 불필요한 데이터 조합이 생기지 않습니다.
:::

### 2. 비용 기반 최적화 (Cost-based Optimization)

**비용 기반 최적화**란, 각 실행 계획의 **실제 실행 비용을 수식(비용식)으로 계산**하여, 비용이 가장 적은 계획을 선택하는 방법입니다.

비유하자면, 여행 경로를 정할 때 **교통비, 소요 시간, 환승 횟수 등을 종합적으로 계산**하여 가장 경제적인 경로를 선택하는 것과 같습니다.

비용식에서 고려하는 요소들:

| 비용 요소 | 설명 | 중요한 경우 |
|-----------|------|-------------|
| **디스크 I/O 비용** | 하드디스크에서 데이터를 읽고 쓰는 비용 | 대형 데이터베이스 시스템 |
| **CPU 계산 비용** | CPU에서 연산을 처리하는 비용 | 소형 데이터베이스 시스템 |
| **저장 비용** | 중간 결과를 임시로 저장하는 비용 | 복잡한 질의 처리 시 |
| **통신 비용** | 네트워크를 통한 데이터 전송 비용 | 분산 데이터베이스 시스템 |

각 비용 요소를 비용식에 대입하면 총 비용 값이 나오고, 이 **비용 값이 가장 작은 실행 계획**이 최종 선정됩니다.

### 3. 의미적 질의 최적화 (Semantic Query Optimization)

**의미적 질의 최적화**란, 질의의 **의미(Semantics)를 분석**하여 실행할 필요가 없는 질의를 미리 걸러내는 방법입니다.

예를 들어, 대학교 학생 테이블에서 학년은 1학년부터 4학년까지만 존재합니다. 그런데 누군가 다음과 같은 질의를 보냈다면:

```sql
-- ❌ 의미적으로 결과가 있을 수 없는 질의
SELECT 이름
FROM 학생
WHERE 학년 >= 5;    -- 대학교에 5학년은 존재하지 않음!
```

이 경우, 데이터베이스는 검사기 → 파서 → 최적화기의 전체 과정을 거칠 필요 없이, **"결과 없음"**을 바로 반환할 수 있습니다. 학년 컬럼에 1~4까지만 허용된다는 **무결성 제약 조건(Integrity Constraint)**을 알고 있기 때문입니다.

마치 초등학교에서 "8학년 학생 명단을 달라"고 요청하면, 찾아볼 필요도 없이 "초등학교는 1~6학년까지밖에 없습니다"라고 바로 대답할 수 있는 것과 같습니다.

```sql
-- ✅ 의미적으로 유효한 질의
SELECT 이름
FROM 학생
WHERE 학년 >= 3;    -- 3학년, 4학년이 존재할 수 있음
```

:::tip 세 가지 최적화 방법은 함께 사용된다
일반적으로 데이터베이스 시스템은 **경험적 최적화와 비용 기반 최적화를 함께 사용**합니다. 먼저 경험적 규칙으로 큰 틀을 잡고, 비용 기반 계산으로 세부적인 최적 계획을 결정합니다. 여기에 의미적 최적화까지 더해져, 불필요한 처리를 사전에 차단합니다.
:::

---

## 🌳 최적화의 4단계 — 내부에서 일어나는 일

최적화기 내부에서는 구체적으로 **4단계**를 거쳐 최적 실행 계획이 만들어집니다.

### 1단계: 질의문을 내부 표현(질의 트리)으로 변환

가장 먼저, SQL 명령어를 컴퓨터가 처리하기 적합한 **내부 형태**로 변환합니다. 이때 사용하는 형태가 바로 **질의 트리(Query Tree)**입니다.

왜 트리 구조를 사용할까요? 트리는 **부모-자식 관계**로 연산의 순서와 구조를 명확하게 표현할 수 있기 때문입니다. 마치 회사의 조직도처럼, 누가 누구 아래에 있고, 어떤 순서로 일을 처리해야 하는지를 한눈에 알 수 있습니다.

변환 과정은 다음과 같습니다:

**① SQL → 관계 대수(Relational Algebra) → 질의 트리(Query Tree)**

구체적인 예시를 보겠습니다:

```sql
-- 원본 SQL 질의
SELECT S.sname              -- 선원(Sailor)의 이름을 출력
FROM Reserves R, Sailors S  -- 예약 테이블과 선원 테이블을 조인
WHERE R.sid = S.sid         -- 두 테이블의 ID가 같고
  AND R.bid = 100           -- 예약 보트 번호가 100이고
  AND S.rating > 5;         -- 선원 등급이 5보다 큰 경우
```

이 SQL을 **관계 대수**로 변환하면:

```
π sname (σ R.sid=S.sid AND R.bid=100 AND S.rating>5 (Reserves × Sailors))
```

이것을 한 줄씩 해석하면:
- `Reserves × Sailors` → Reserves 테이블과 Sailors 테이블을 카티션 프로덕트(곱하기)
- `σ R.sid=S.sid AND R.bid=100 AND S.rating>5` → 세 가지 조건으로 선택(Selection)
- `π sname` → sname 컬럼만 추출(Projection)

이 관계 대수 표현을 **질의 트리**로 변환하면:

```
        π sname                    ← 최종: 이름만 출력 (프로젝션)
           |
  σ bid=100 AND rating>5          ← 조건 필터링 (셀렉션)
           |
     ⨝ R.sid = S.sid              ← 두 테이블 조인
        /      \
   Reserves   Sailors             ← 원본 테이블 (리프 노드)
```

트리의 **맨 아래(리프 노드)**에는 원본 테이블이 있고, **위로 올라갈수록** 연산이 적용됩니다. 최종 결과는 **맨 꼭대기(루트 노드)**에서 나옵니다.

:::info 자료 구조에서 배운 트리가 여기서 쓰인다
자료 구조 과목에서 트리(Tree), 트리의 순회(Traversal) 등을 배우는 이유가 바로 이것입니다. 데이터베이스 내부에서 질의를 최적화할 때 **트리 자료 구조**가 핵심적으로 사용됩니다. 트리의 노드 위치를 바꾸고, 부모-자식 관계를 재배치하면서 최적화가 이루어집니다.
:::

### 2단계: 효율적인 내부 형태로 변환 (변환 규칙 적용)

1단계에서 만든 기본 질의 트리를 **변환 규칙(Transformation Rules)**을 적용하여 더 효율적인 형태로 바꿉니다. 이 변환 규칙은 미리 정해진 **표준 규칙(룰)**으로, 내 마음대로 바꾸는 것이 아닙니다.

예를 들어, 위의 질의 트리에서 "카티션 프로덕트 → 셀렉션" 순서를 "셀렉션 먼저 → 조인"으로 바꾸면 훨씬 효율적입니다. 이러한 변환이 이 단계에서 이루어집니다.

### 3단계: 후보 실행 계획 선정

변환된 여러 가지 질의 트리(실행 계획) 중에서 **평가할 가치가 있는 후보**만 선정합니다.

비유하면, 선거에서 전 국민이 후보가 될 수는 없듯이, 수많은 실행 계획을 전부 평가하는 것은 비효율적입니다. 경험적으로 성능이 좋을 것 같은 계획만 **후보로 선정**하여 다음 단계에서 정밀 평가합니다.

후보 선정 시 고려하는 요소들:
- **인덱스(Index)**가 있는가?
- **값의 분포(Value Distribution)**가 어떤가?
- **물리적 클러스터링(Clustering)**이 되어 있는가?
- **해싱 함수(Hashing Function)**를 사용하는가?
- **연산의 순서**가 어떻게 되어 있는가?

### 4단계: 최적 계획 평가 및 결정

선정된 후보 계획들의 **비용을 비용식으로 계산**하여, **비용이 가장 적은 계획**을 최종 선정합니다.

```
비용(Plan) = 디스크 I/O 비용 + CPU 계산 비용 + 저장 비용 + 통신 비용
```

이 비용 값이 **가장 작은 실행 계획**이 최종적으로 선정되어 실행됩니다.

---

## 📐 내부 형태 변환 규칙 — 12가지 핵심 규칙

최적화의 2단계에서 적용하는 **변환 규칙(Transformation Rules)**은 여러 가지가 있습니다. 이 규칙들은 모두 **"연산에 참여하는 튜플(행) 수를 줄여서 성능을 향상시키라"**는 하나의 원칙을 따릅니다. 핵심적인 규칙들을 살펴보겠습니다.

### 규칙 1: AND 조건은 개별 선택 연산으로 분리하라

```
σ (조건1 AND 조건2 AND 조건3)(R)
→ σ 조건1 (σ 조건2 (σ 조건3 (R)))
```

**왜 이렇게 하는가?** 100명의 학생에서 "남자 AND 서울 AND 80점 이상"을 동시에 체크하면, 매 한 명마다 세 가지 조건을 모두 확인해야 합니다. 하지만 개별로 분리하면:

1. 먼저 남자만 추출 (10명으로 줄어듦)
2. 10명 중 서울 거주자만 추출 (5명으로 줄어듦)
3. 5명 중 80점 이상만 추출 (2명으로 줄어듦)

**각 단계마다 연산 대상이 줄어들어** 전체 처리량이 크게 감소합니다.

### 규칙 2: 선택 연산은 교환적이다

```
σ 조건1 (σ 조건2 (R)) = σ 조건2 (σ 조건1 (R))
```

남자 중에서 서울 거주자를 찾든, 서울 거주자 중에서 남자를 찾든 **결과는 같습니다**. 따라서 **선택도가 작은 조건을 먼저 적용**할 수 있도록 순서를 자유롭게 바꿀 수 있습니다.

### 규칙 3: 연속된 프로젝션은 마지막 것만 수행하면 된다

```
π a (π a,b (π a,b,c (R))) = π a (R)
```

a, b, c를 꺼낸 후 a, b만 꺼내고, 다시 a만 꺼내는 것은 **처음부터 a만 꺼내는 것**과 결과가 동일합니다. 중복 작업을 제거하여 불필요한 연산을 줄입니다.

### 규칙 4: 선택과 프로젝션은 교환적이다

```
π 속성 (σ 조건 (R)) = σ 조건 (π 속성 (R))
```

조건으로 걸러낸 뒤 필요한 컬럼만 추출하든, 필요한 컬럼만 먼저 추출한 뒤 조건으로 걸러내든 **결과는 같습니다**. (단, 조건에 사용되는 속성이 프로젝션에 포함되어야 합니다.)

### 규칙 5: 선택 연산을 먼저 수행하라 (카티션 프로덕트와 조인에서)

```
-- 카티션 프로덕트 후 선택 → 선택 먼저 하고 조인
σ 조건 (R × S) → σ 조건_R (R) ⨝ S

-- 카티션 프로덕트 후 조인 조건 선택 → 조인 연산으로 변환
σ R.id=S.id (R × S) → R ⨝(R.id=S.id) S
```

이것은 **가장 중요한 규칙** 중 하나입니다. R에 10개, S에 10개의 데이터가 있을 때:

```
❌ 잘못된 방법: R × S를 먼저 수행 (100개 생성) → 조건으로 필터링
✅ 올바른 방법: R에서 조건 필터링 (3개로 축소) → S와 조인
```

카티션 프로덕트를 먼저 하면 데이터가 폭발적으로 증가하기 때문에, **반드시 선택 연산을 먼저** 수행해야 합니다.

### 규칙 6: 양쪽 테이블 모두 선택 연산을 먼저 수행하라

```
σ 조건1_AND_조건2 (R ⨝ S)
→ σ 조건1 (R) ⨝ σ 조건2 (S)
```

R과 S를 조인한 뒤 조건을 적용하는 것보다, **R에서 조건1을 먼저 적용하고, S에서 조건2를 먼저 적용한 뒤 조인**하는 것이 훨씬 효율적입니다.

```sql
-- ❌ 비효율적: 조인 후 필터링
SELECT *
FROM Reserves R, Sailors S
WHERE R.sid = S.sid
  AND R.bid = 100        -- Reserves 테이블 조건
  AND S.rating > 5;      -- Sailors 테이블 조건

-- 내부적으로 최적화기는 이렇게 변환합니다:
-- ✅ 효율적: 각 테이블에서 먼저 필터링 후 조인
-- 1) Reserves에서 bid=100인 것만 추출
-- 2) Sailors에서 rating>5인 것만 추출  
-- 3) 줄어든 두 결과를 조인
```

### 규칙 7: 교환 법칙 (곱하기, 합집합, 교집합, 조인)

```
R × S = S × R
R ∪ S = S ∪ R
R ∩ S = S ∩ R
R ⨝ S = S ⨝ R
```

이 연산들은 **순서를 바꿔도 결과가 같습니다**. 어떤 테이블을 먼저 가져와도 상관없습니다.

:::danger 교환 법칙이 성립하지 않는 연산
**세미 조인(Semi Join)**, **차집합(Difference, -)**, **나누기(Division, ÷)** 이 세 가지 연산은 교환 법칙이 성립하지 **않습니다**. R - S ≠ S - R이므로 순서를 바꾸면 결과가 달라집니다!
:::

### 규칙 8: 프로젝션 연산을 먼저 수행하라 (조인/곱하기에서)

```
π 속성 (R ⨝ S) → π 속성_R (R) ⨝ π 속성_S (S)
π 속성 (R × S) → π 속성_R (R) × π 속성_S (S)
```

조인이나 곱하기를 한 뒤 프로젝션하는 것보다, **각 테이블에서 필요한 컬럼만 먼저 추출(프로젝션)한 뒤 조인/곱하기**하는 것이 효율적입니다. 불필요한 컬럼 데이터를 미리 제거하면 처리하는 데이터 양이 줄어듭니다.

### 규칙 9: 합집합/교집합/차집합에서 선택·프로젝션을 먼저

```
σ 조건 (R ∪ S) = σ 조건 (R) ∪ σ 조건 (S)
π 속성 (R ∪ S) = π 속성 (R) ∪ π 속성 (S)
```

합집합을 한 뒤 필터링하는 것보다, **각 테이블에서 먼저 필터링한 뒤 합집합**하는 것이 효율적입니다.

### 규칙 11: 결합 법칙 (곱하기 순서 변경)

```
(R × S) × T = R × (S × T)
```

세 개 이상의 테이블을 곱할 때, **어떤 두 개를 먼저 곱해도 결과는 같습니다**. 따라서 가장 작은 중간 결과를 만드는 순서를 선택할 수 있습니다.

### 규칙 12: 분배 법칙

```
R ∩ (S ∪ T) = (R ∩ S) ∪ (R ∩ T)
```

OR로 연결된 조건식을 AND로 연결된 **논리곱 정형식(CNF)**으로 변환할 수 있습니다. 이것은 중고등학교 수학에서 배운 **분배 법칙**과 동일한 원리입니다.

---

## 📝 변환 규칙 종합 정리

모든 변환 규칙을 관통하는 **핵심 원칙**은 단 하나입니다:

> **연산에 참여하는 튜플(행) 수를 최대한 줄여라!**

이를 위한 전략을 종합하면:

| 전략 | 해당 규칙 | 설명 |
|------|-----------|------|
| AND 조건 분리 | 규칙 1 | AND로 묶인 조건을 개별 선택 연산으로 분리 |
| 선택 연산 먼저 | 규칙 2, 4, 5, 6, 9 | WHERE 조건을 가능한 한 먼저 적용 |
| 선택도 작은 것 우선 | 규칙 2 | 결과 행 수가 적은 조건을 먼저 적용 |
| 프로젝션 먼저 | 규칙 3, 8, 9 | 필요한 컬럼만 먼저 추출하여 데이터 양 축소 |
| 카티션 프로덕트 → 조인 | 규칙 5 | 곱하기 후 선택 대신, 조인 연산으로 변환 |
| OR → 논리곱 정형식 | 규칙 12 | OR 조건을 AND 조건의 조합으로 변환 |

```sql
-- ❌ 최적화 전: 전체 데이터를 먼저 결합한 후 필터링
SELECT S.sname
FROM Reserves R, Sailors S
WHERE R.sid = S.sid
  AND R.bid = 100
  AND S.rating > 5;
-- 내부적으로: Reserves × Sailors (전체 곱하기) → 조건 필터링

-- ✅ 최적화 후: 각 테이블에서 조건을 먼저 적용한 후 조인
-- 1단계: Reserves에서 bid=100인 행만 추출 (선택 연산 먼저)
-- 2단계: Sailors에서 rating>5인 행만 추출 (선택 연산 먼저)
-- 3단계: 줄어든 두 결과를 sid 기준으로 조인
-- 4단계: sname 컬럼만 추출 (프로젝션)
```

위의 두 방법은 **최종 결과는 동일**하지만, 내부적으로 처리하는 **데이터의 양은 크게 다릅니다**. 최적화가 얼마나 중요한지 알 수 있는 대목입니다.

---

## ⚠️ 주의사항과 실무 팁

### 최적화는 시스템이 자동으로 한다

:::warning 흔한 오해
"내가 SQL을 작성할 때 WHERE 조건 순서를 바꾸면 성능이 달라지겠지?"라고 생각할 수 있습니다. 하지만 대부분의 현대 DBMS(데이터베이스 관리 시스템)는 **질의 최적화기가 자동으로 최적의 순서를 결정**합니다. 사용자가 WHERE절의 조건 순서를 바꾸더라도, 최적화기가 내부적으로 가장 효율적인 순서로 재배치합니다.
:::

### 카탈로그(통계 정보)의 중요성

최적화기가 올바른 판단을 내리려면, **카탈로그의 통계 정보가 최신 상태**여야 합니다. 만약 테이블의 데이터가 크게 변경되었는데 통계 정보가 갱신되지 않았다면, 최적화기가 잘못된 실행 계획을 선택할 수 있습니다. 실무에서는 주기적으로 통계 정보를 업데이트하는 것이 중요합니다.

### 경험적 최적화와 비용 기반 최적화의 균형

실제 데이터베이스 시스템에서는 **경험적 최적화만 사용하거나 비용 기반 최적화만 사용하는 것이 아니라, 두 가지를 함께 사용**합니다. 먼저 경험적 규칙으로 명백히 비효율적인 계획을 제거하고, 남은 후보들에 대해 비용 기반 계산을 수행하여 최종 계획을 결정합니다.

### DBMS 종류에 따른 비용 가중치 차이

| DBMS 유형 | 가장 중요한 비용 요소 | 이유 |
|-----------|----------------------|------|
| **대형 시스템** (Oracle, DB2 등) | 디스크 I/O 비용 | 대용량 데이터를 디스크에서 읽는 것이 가장 느림 |
| **소형 시스템** (SQLite 등) | CPU 계산 비용 | 데이터 양이 적어 I/O보다 CPU 연산이 병목 |
| **분산 시스템** (여러 서버에 분산) | 네트워크 통신 비용 | 서버 간 데이터 전송이 가장 큰 비용 |

:::danger 카티션 프로덕트를 남발하지 마라
SQL에서 두 테이블을 조인할 때 **조인 조건 없이 `FROM R, S`만 쓰면 카티션 프로덕트**가 발생합니다. 이는 R의 행 수 × S의 행 수만큼의 조합이 만들어져, 데이터가 폭발적으로 증가합니다. 반드시 적절한 **JOIN 조건(ON절 또는 WHERE절)**을 명시해야 합니다.
:::

---

## 📌 핵심 정리

- **SQL은 고급 언어**이며, 사용자가 작성한 SQL은 검사기 → 파서 → 최적화기 → 코드 생성기 → 런타임 처리기의 **5단계 파이프라인**을 거쳐 실행된다
- **검사기(Scanner)**는 SQL의 각 요소(토큰)를 식별하고, **파서(Parser)**는 문법 오류를 검사한다
- **질의 최적화기(Optimizer)**는 여러 실행 계획 중에서 **비용이 가장 적은 최적의 실행 계획**을 자동으로 선정한다
- **선택도(Selectivity)**가 작은 조건을 먼저 적용하면 연산에 참여하는 튜플 수가 줄어들어 성능이 향상된다
- 최적화 방법에는 **경험적 최적화**, **비용 기반 최적화**, **의미적 질의 최적화** 세 가지가 있으며, 일반적으로 함께 사용된다
- 최적화 내부 4단계: **내부 표현(질의 트리) 변환 → 효율적 형태 변환(규칙 적용) → 후보 계획 선정 → 비용 평가 및 최적 계획 결정**
- 변환 규칙의 핵심 원칙: **선택(Selection) 연산과 프로젝션(Projection) 연산을 먼저 수행**하여 연산 참여 데이터 양을 줄여라
- **카티션 프로덕트 + 선택 연산**은 반드시 **조인 연산으로 변환**하여 불필요한 데이터 폭발을 방지하라
- 선택도, 데이터 분포 등의 **통계 정보는 카탈로그(데이터 사전)**에 저장되어 있으며 최적화기가 이를 자동으로 참조한다
- 질의 최적화는 데이터베이스의 **고급 과정**에 해당하며, DBA(데이터베이스 관리자)가 시스템 성능을 이해하고 관리하기 위한 핵심 역량이다

작성일: 2026-02-21