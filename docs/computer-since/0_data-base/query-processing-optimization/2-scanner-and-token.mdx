---
title: "검사기(스캐너)와 토큰 식별"
description: "검사기(스캐너)와 토큰 식별에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/query-processing-optimization/2-scanner-and-token"
sidebar_label: "스캐너와 토큰"
date: "2026-02-21"
---

## 🎯 고급 질의어 처리란 무엇인가?

우리가 데이터베이스에 무언가를 요청할 때 사용하는 언어가 바로 **SQL(Structured Query Language)**입니다. SQL은 `SELECT`, `FROM`, `WHERE` 같은 키워드를 조합해서 "학생 테이블에서 이름을 가져와줘"와 같은 명령을 내리는 언어인데요, 이 SQL을 우리는 **고급 질의어(High-Level Query Language)**라고 부릅니다.

> **"고급"이라고 하면 어렵다는 뜻이 아닙니다.** 사람이 읽고 쓰기 쉬운 언어라는 의미입니다. 반대로 컴퓨터가 직접 이해하는 0과 1로 된 언어를 "저급 언어"라고 합니다. SQL은 사람 친화적인 고급 언어이기 때문에, 컴퓨터가 실행하려면 여러 변환 과정을 거쳐야 합니다.

마치 한국어로 쓴 편지를 영어로 번역하고, 그 영어를 다시 컴퓨터 코드로 바꾸는 것처럼, SQL 명령어도 여러 단계의 "번역"과 "검사"를 거쳐야 최종 결과가 나옵니다. 이 전체 과정을 **고급 질의어 처리 과정**이라고 하며, 이번 문서에서는 그 첫 번째 관문인 **검사기(스캐너)**와 **토큰 식별**을 중심으로, 전체 최적화 흐름까지 아주 자세하게 살펴보겠습니다.

:::info 데이터베이스 기본 vs 고급
SQL 문법, 테이블 생성, 권한 부여 등은 **데이터베이스 기본 과정**에 해당합니다. 반면 질의어 처리 단계, 최적화, 병행 제어, 회복 등은 **데이터베이스 고급 과정**입니다. 고급 과정까지 이해하면 데이터베이스 관리자(DBA)로서 데이터베이스를 효율적으로 관리하고 성능을 최적화하는 개념을 갖출 수 있습니다.
:::

---

## 🗺️ 질의어 처리의 전체 흐름

SQL 명령어 하나가 입력되면, 최종 결과가 나오기까지 **5개의 핵심 구성 요소**를 순서대로 거칩니다. 마치 공장의 컨베이어 벨트처럼, 각 단계마다 고유한 역할이 있고, 이전 단계의 **결과물**이 다음 단계의 **입력**이 됩니다.

### 전체 처리 파이프라인

| 순서 | 구성 요소 (시스템) | 하는 일 | 결과물 |
|:---:|:---|:---|:---|
| 1 | **검사기(스캐너)** | 질의문의 토큰(요소) 식별 | 토큰 목록 |
| 2 | **파서(Parser)** | 문법(Syntax) 오류 검사 | 내부 형태 질의문 |
| 3 | **질의어 최적화기** | 가장 효율적인 실행 계획 선정 | 질의문 계획 |
| 4 | **질의어 코드 생성기** | 선정된 계획을 실행 코드로 변환 | 질의문 실행 코드 |
| 5 | **런타임 데이터베이스 처리기** | 실행 코드를 실제로 실행 | 질의어 실행 결과 |

> 💡 **핵심 포인트**: 네모 박스로 표현되는 것들(검사기, 파서, 최적화기 등)은 **시스템의 구성 요소**이고, 각 단계 사이에서 나오는 것들(내부 형태 질의문, 질의문 계획 등)은 **이전 단계의 결과물**입니다.

비유하자면, **레스토랑의 주문 처리 과정**과 비슷합니다:

1. **검사기** → 주문서를 받아서 "스테이크, 미디엄, 샐러드 추가"처럼 각 항목을 식별하는 접수 담당자
2. **파서** → 주문서에 오타나 없는 메뉴가 없는지 확인하는 검수 담당자
3. **최적화기** → 여러 조리 순서 중 가장 빠르고 효율적인 방법을 찾는 주방장
4. **코드 생성기** → 최적의 조리 순서를 구체적인 레시피로 작성하는 과정
5. **런타임 처리기** → 실제로 요리를 만들어 손님에게 내놓는 조리사

---

## 🔍 검사기(스캐너)와 토큰 식별 — 첫 번째 관문

### 왜 검사기가 필요한가?

SQL 명령어가 데이터베이스에 입력되면, 컴퓨터는 이 문자열을 한꺼번에 이해할 수 없습니다. 마치 외국어 문장을 처음 볼 때, 먼저 단어 하나하나를 구분해야 문장의 의미를 파악할 수 있는 것처럼, 컴퓨터도 SQL 문장을 **개별 요소(토큰)**로 쪼개는 작업이 필요합니다.

예를 들어 `SELECT * FROM 학생`이라는 명령어를 사람은 한눈에 이해하지만, 컴퓨터 입장에서는 `S`, `E`, `L`, `E`, `C`, `T`, ` `, `*`, ` `, `F`, `R`, `O`, `M`, ` `, `학`, `생` 같은 문자의 나열일 뿐입니다. 이 문자열에서 의미 있는 단위를 뽑아내야 하는데, 그 작업을 하는 것이 바로 **검사기(스캐너, Scanner)**입니다.

### 토큰(Token)이란?

**토큰(Token)**은 질의문을 구성하는 **의미 있는 최소 단위**입니다. 마치 한국어 문장에서 "나는 학교에 간다"를 "나는 / 학교에 / 간다"로 띄어쓰기 기준으로 나누듯이, SQL 문장도 의미 있는 단위로 분리됩니다.

```sql
-- 이 SQL 명령어를 스캐너가 분석합니다
SELECT * FROM 학생
```

위 명령어를 스캐너가 읽으면 다음과 같이 **토큰을 식별**합니다:

| 토큰 | 토큰의 종류 | 설명 |
|:---|:---|:---|
| `SELECT` | 키워드(예약어) | "조회해라"라는 명령어 |
| `*` | 와일드카드 | "모든 컬럼"을 의미 |
| `FROM` | 키워드(예약어) | "어느 테이블에서"를 지정 |
| `학생` | 식별자(테이블 이름) | 데이터를 가져올 테이블 |

스캐너는 이 과정을 통해 "아, 이건 `SELECT` 명령어구나!", "아, `FROM`절이 있구나!", "테이블 이름은 `학생`이구나!" 같은 사실들을 **식별(identification)**해냅니다.

### 스캐너의 동작 과정을 코드로 이해하기

실제 데이터베이스 내부의 스캐너는 매우 복잡하지만, 개념을 이해하기 위해 간단한 파이썬 코드로 비유해 보겠습니다.

❌ **잘못된 예시 — 토큰을 식별하지 않고 통째로 처리하려는 경우:**

```python
# ❌ 잘못된 방식: SQL 문장을 통째로 처리하려고 함
sql = "SELECT * FROM 학생"

# 문장 전체를 한번에 이해하려고 하면 컴퓨터는 처리할 수 없음
if sql == "학생 테이블의 모든 데이터를 가져와":  # 이런 비교는 불가능!
    print("결과 출력")
# 컴퓨터는 자연어를 이해하지 못하므로 이 방식은 동작하지 않습니다
```

✅ **올바른 예시 — 토큰 단위로 분리하여 식별하는 경우:**

```python
# ✅ 올바른 방식: SQL 문장을 토큰으로 분리하여 하나씩 식별
sql = "SELECT * FROM 학생"

# 1단계: 공백을 기준으로 문자열을 토큰으로 분리
tokens = sql.split(" ")  # 결과: ['SELECT', '*', 'FROM', '학생']

# 2단계: 각 토큰이 어떤 종류인지 식별
keywords = {"SELECT", "FROM", "WHERE", "INSERT", "DELETE", "UPDATE"}  # 예약어 목록

for token in tokens:  # 토큰 하나하나를 순회하며 검사
    if token in keywords:
        # 예약어(키워드)에 해당하면 "키워드"로 분류
        print(f"'{token}' → 키워드(예약어)")
    elif token == "*":
        # 별표는 "모든 컬럼"을 의미하는 와일드카드
        print(f"'{token}' → 와일드카드(모든 컬럼)")
    else:
        # 나머지는 사용자가 정의한 이름(테이블명, 컬럼명 등)
        print(f"'{token}' → 식별자(이름)")
```

**실행 결과:**
```
'SELECT' → 키워드(예약어)
'*' → 와일드카드(모든 컬럼)
'FROM' → 키워드(예약어)
'학생' → 식별자(이름)
```

**코드 한 줄씩 설명:**

- `sql = "SELECT * FROM 학생"` → 사용자가 입력한 SQL 명령어를 문자열로 저장합니다.
- `tokens = sql.split(" ")` → 공백을 기준으로 문자열을 쪼개서 리스트로 만듭니다. 이것이 토큰 분리의 핵심입니다.
- `keywords = {"SELECT", "FROM", ...}` → SQL에서 미리 정의된 예약어 목록입니다. 스캐너는 이 목록과 대조하여 토큰의 종류를 판별합니다.
- `for token in tokens:` → 분리된 토큰을 하나씩 꺼내서 검사합니다.
- `if token in keywords:` → 현재 토큰이 예약어 목록에 있는지 확인합니다.
- `else:` → 예약어도 아니고 특수 기호도 아니면, 사용자가 정의한 테이블이나 컬럼 이름(식별자)으로 분류합니다.

:::tip 실생활 비유
스캐너의 토큰 식별은 **우체국에서 편지를 분류하는 것**과 비슷합니다. 편지가 들어오면 "서울행", "부산행", "등기", "일반" 등으로 하나하나 분류하죠. 스캐너도 SQL 문장을 읽고 "이건 키워드", "이건 테이블 이름", "이건 조건 값" 등으로 분류하는 것입니다.
:::

---

## 🔧 파서(Parser) — 문법 검사의 관문

### 왜 파서가 필요한가?

스캐너가 토큰을 식별했다고 해서 끝이 아닙니다. 토큰이 올바르게 식별되었더라도, **토큰들이 올바른 순서로 조합되었는지**를 확인해야 합니다. 한국어로 비유하면, "나는 학교에 간다"는 올바른 문장이지만 "간다 학교에 나는"은 단어는 맞지만 문법이 틀린 것과 같습니다.

파서(Parser)는 **문법 오류(Syntax Error)를 검사하는 구성 요소**입니다. 스캐너로부터 전달받은 토큰 목록을 가지고, SQL 문법 규칙에 맞게 구성되어 있는지를 확인합니다.

### 파서의 동작 원리

자바, 파이썬 같은 프로그래밍 언어에서 코드를 작성한 후 **컴파일(compile)**하면 문법 오류를 잡아주죠? 파서가 하는 일이 바로 이 컴파일과 동일한 개념입니다. SQL 명령어의 문법이 맞는지 체크하는 것입니다.

❌ **잘못된 SQL — 파서가 오류를 잡아내는 경우:**

```sql
-- ❌ 문법 오류: FROM 절이 빠져 있음
SELECT * WHERE 학년 = 3
-- 파서가 "FROM 절이 없습니다"라는 문법 오류를 발생시킵니다
```

```sql
-- ❌ 문법 오류: SELECT와 FROM의 순서가 바뀜
FROM 학생 SELECT *
-- 파서가 "잘못된 키워드 순서입니다"라는 문법 오류를 발생시킵니다
```

✅ **올바른 SQL — 파서가 통과시키는 경우:**

```sql
-- ✅ 올바른 문법: SELECT - FROM - WHERE 순서가 정확함
SELECT *
FROM 학생
WHERE 학년 = 3
-- 파서가 문법에 이상이 없음을 확인하고 다음 단계로 넘깁니다
```

**코드 한 줄씩 설명:**

- `SELECT *` → "모든 컬럼을 조회해라"라는 명령입니다. SELECT문의 시작은 반드시 `SELECT` 키워드여야 합니다.
- `FROM 학생` → "학생이라는 테이블에서"를 지정합니다. `SELECT` 다음에는 반드시 `FROM`절이 와야 한다는 것이 SQL의 문법 규칙입니다.
- `WHERE 학년 = 3` → "학년이 3인 데이터만"이라는 조건입니다. `WHERE`절은 선택사항이지만, 사용한다면 `FROM` 뒤에 와야 합니다.

파서를 통과하면, SQL 명령어는 **내부 형태 질의문(Internal Representation)**으로 변환됩니다. 이것은 컴퓨터가 최적화 작업을 수행하기 쉬운 형태로, 보통 **질의 트리(Query Tree)** 구조로 표현됩니다.

:::warning 스캐너와 파서의 차이를 혼동하지 마세요!
**스캐너**는 "이 문장에 어떤 단어들이 있는지"를 식별하는 것이고, **파서**는 "이 단어들이 올바른 문법 순서로 배치되었는지"를 검사하는 것입니다. 스캐너는 개별 단어를 분류하고, 파서는 단어들의 조합이 규칙에 맞는지를 확인합니다.
:::

---

## ⚡ 질의어 최적화 — 왜 필요한가?

### 하나의 SQL, 여러 가지 실행 방법

문법 검사까지 통과한 SQL 명령어는 이제 **실행**되어야 합니다. 그런데 여기서 중요한 사실이 하나 있습니다. **같은 SQL 명령어라도 실행 방법이 여러 가지**라는 것입니다.

집에서 학교까지 가는 길을 생각해 보세요. 버스를 타고 갈 수도 있고, 지하철을 탈 수도 있고, 자전거를 탈 수도 있고, 걸어갈 수도 있습니다. 목적지는 같지만 가는 방법(경로, 비용, 시간)은 모두 다릅니다. SQL도 마찬가지입니다. 하나의 질의문이지만 실행 방법(실행 계획)은 여러 가지가 될 수 있고, **어떤 방법이 가장 빠르고 효율적인지를 찾아내는 것이 바로 최적화**입니다.

### 구체적인 예시로 이해하기

다음과 같은 상황을 가정해 봅시다:

```sql
-- 학생 테이블에서 성별이 '남자'이고 지역이 '서울'인 학생의 학번을 검색
SELECT 학번
FROM 학생
WHERE 성별 = '남자' AND 지역 = '서울'
```

조건이 2개입니다: `성별 = '남자'`와 `지역 = '서울'`. 이 두 조건을 처리하는 방법은 여러 가지가 있습니다:

| 실행 계획 | 방법 | 설명 |
|:---:|:---|:---|
| 계획 1 | 성별 먼저 → 지역 나중 | 먼저 남자를 찾고, 그 중에서 서울인 사람을 찾음 |
| 계획 2 | 지역 먼저 → 성별 나중 | 먼저 서울 사람을 찾고, 그 중에서 남자를 찾음 |
| 계획 3 | 동시에 검사 | 한 명씩 가져와서 남자이면서 서울인지 동시에 확인 |

그런데 여기서 핵심은 **어떤 계획이 가장 효율적인가?**입니다.

### 선택도(Selectivity)의 개념

학생 100명이 있다고 합시다:
- **남학생**: 10명 (선택도 10%)
- **지역이 서울인 학생**: 50명 (선택도 50%)

> **선택도(Selectivity)**란 전체 데이터 중 특정 조건을 만족하는 데이터의 비율입니다. 선택도가 낮을수록 조건을 만족하는 데이터가 적다는 의미입니다.

이 경우 어떤 순서가 효율적일까요?

- **계획 1 (남자 먼저)**: 100명 → 남자 10명 추출 → 10명 중 서울 확인 → 총 110번 비교
- **계획 2 (서울 먼저)**: 100명 → 서울 50명 추출 → 50명 중 남자 확인 → 총 150번 비교

**당연히 계획 1이 더 효율적입니다!** 선택도가 작은 조건(남자 10%)을 먼저 처리하면 연산에 참여하는 데이터(튜플) 수를 대폭 줄일 수 있습니다.

:::tip 선택도 규칙
**선택도가 작은 조건을 먼저 실행**하면 연산에 참여하는 튜플(행) 수가 줄어들어 전체 처리 속도가 빨라집니다. 이것은 질의 최적화의 가장 기본적인 원칙 중 하나입니다.
:::

### 시스템이 자동으로 최적화한다

여기서 한 가지 궁금한 점이 생깁니다. "남학생이 10명이고 서울이 50명이라는 걸 어떻게 알까요?"

이 정보는 사용자가 아는 것이 아닙니다. **데이터베이스 시스템의 데이터 사전(카탈로그)**에 이러한 통계 데이터가 저장되어 있습니다. 최적화기는 이 카탈로그를 참조해서 자동으로 가장 비용이 적게 드는 실행 계획을 선정합니다. 사용자는 단지 SQL을 작성하기만 하면, 나머지는 시스템이 알아서 최적화해 줍니다.

---

## 📊 최적화의 세 가지 방법

질의어 최적화에는 크게 세 가지 접근 방법이 있습니다.

### 1. 경험적 최적화 (Heuristic Optimization)

**경험적 최적화**는 "과거에 해봤더니 이 방법이 좋더라"라는 **경험적 규칙(Heuristic Rule)**을 적용하는 방법입니다. 마치 매일 출퇴근하는 사람이 "이 시간대에는 이 길이 덜 막힌다"는 경험을 활용하는 것과 같습니다.

대표적인 경험적 처리 전략:

- **선택 연산을 가능하면 먼저 수행**: WHERE절의 조건을 먼저 처리하여 연산에 참여하는 튜플 수를 줄입니다.
- **카티션 프로덕트(Cartesian Product, 모든 조합을 만드는 곱셈 연산) + 선택 연산은 조인 연산으로 변환**: 두 테이블을 모두 곱한 뒤 조건으로 걸러내는 것보다, 처음부터 조건에 맞는 것만 결합하는 조인이 훨씬 효율적입니다.
- **프로젝션 연산(필요한 컬럼만 추출)도 가능하면 먼저 수행**: 전체 컬럼을 다 가져온 후 필요한 것만 골라내는 것보다, 처음부터 필요한 컬럼만 가져오는 것이 데이터 양을 줄입니다.
- **공통 연산식은 한 번만 수행**: 중복되는 연산이 있으면 마지막 것만 한 번 수행하면 됩니다.

### 2. 비용 기반 최적화 (Cost-Based Optimization)

**비용 기반 최적화**는 각 실행 계획의 **실제 비용을 수치로 계산**해서, 가장 비용이 적은 계획을 선택하는 방법입니다. 비용식(Cost Formula)이라는 공식에 여러 변수를 넣어서 계산합니다.

비용 계산 시 고려하는 요소:

| 비용 요소 | 설명 | 주로 중요한 환경 |
|:---|:---|:---|
| **디스크 I/O 비용** | 하드디스크에서 데이터를 읽고 쓰는 비용 | 대형 데이터베이스 시스템 |
| **CPU 계산 비용** | 연산을 처리하는 데 소요되는 시간 | 소형 데이터베이스 |
| **저장 비용** | 중간 결과를 저장하는 데 필요한 공간 | 메모리가 제한된 환경 |
| **통신 비용** | 네트워크를 통해 데이터를 전송하는 비용 | 분산 데이터베이스 |

비용식에 이 값들을 대입하면 각 실행 계획마다 숫자(비용 값)가 나오는데, **이 숫자가 가장 작은 계획이 가장 최적화된 계획**으로 선정됩니다.

:::note 실무에서는 두 가지를 함께 사용합니다
일반적으로 경험적 최적화와 비용 기반 최적화를 **함께 사용**합니다. 경험적 규칙으로 명백히 비효율적인 방법을 먼저 걸러내고, 남은 후보들에 대해 비용을 계산하여 최종 선택하는 방식입니다.
:::

### 3. 의미적 질의 최적화 (Semantic Query Optimization)

**의미적 질의 최적화**는 질의의 **의미 자체가 성립하지 않는 경우**를 미리 걸러내는 방법입니다.

예를 들어 대학교 학생 테이블에서 학년은 1학년부터 4학년까지만 존재합니다. 그런데 누군가 이런 질의를 날렸다면?

```sql
-- ❌ 의미적으로 결과가 없는 질의
SELECT 이름
FROM 학생
WHERE 학년 >= 5
-- 대학교에 5학년은 존재하지 않으므로 결과가 없음!
```

이 경우 굳이 스캐너 → 파서 → 최적화기의 전체 과정을 거칠 필요가 없습니다. **데이터의 무결성 제약 조건(학년은 1~4)을 위반**하므로, 바로 "결과 없음"을 반환하면 됩니다. 마치 초등학교에서 "8학년 학생을 찾아라"라는 명령이 들어오면, 찾을 필요 없이 바로 "없습니다"라고 답하는 것과 같습니다.

---

## 🌳 최적화의 4단계 — 내부에서 일어나는 일

최적화기 내부에서는 구체적으로 **4단계**의 과정이 진행됩니다.

### 1단계: 질의문을 내부 표현으로 변환

SQL 명령어를 컴퓨터가 최적화하기 쉬운 형태로 바꾸는 단계입니다. 이때 사용되는 것이 **질의 트리(Query Tree)**입니다.

변환 과정은 다음과 같습니다:

**SQL 명령어** → **관계 대수(Relational Algebra)로 변환** → **질의 트리(Query Tree)로 변환**

구체적인 예시를 살펴보겠습니다:

```sql
-- 원본 SQL 질의문
SELECT S.sname          -- 선원(Sailor)의 이름을 출력
FROM Reserves R, Sailors S  -- Reserves 테이블과 Sailors 테이블에서
WHERE R.sid = S.sid      -- 두 테이블의 sid가 같고
  AND R.bid = 100        -- 예약 번호(bid)가 100이고
  AND S.rating > 5       -- 등급(rating)이 5보다 큰 데이터
```

**코드 한 줄씩 설명:**

- `SELECT S.sname` → 최종 출력할 컬럼은 Sailors 테이블의 이름(sname)입니다. 이것은 관계 대수에서 **프로젝션(Projection)** 연산에 해당합니다.
- `FROM Reserves R, Sailors S` → 두 개의 테이블을 사용합니다. 두 테이블을 함께 사용한다는 것은 **조인(Join)** 연산이 필요하다는 의미입니다.
- `WHERE R.sid = S.sid` → 조인의 조건입니다. Reserves의 sid와 Sailors의 sid가 같은 행끼리 결합합니다.
- `AND R.bid = 100` → 추가 조건으로 bid가 100인 데이터만 필터링합니다. 이것은 **선택(Selection)** 연산입니다.
- `AND S.rating > 5` → 등급이 5보다 큰 데이터만 필터링하는 또 다른 **선택** 연산입니다.

이 SQL을 **관계 대수**로 변환하면:

> π(sname) [ σ(bid=100 AND rating>5) ( Reserves ⋈(sid=sid) Sailors ) ]

그리고 이 관계 대수 식을 **질의 트리**로 변환하면 다음과 같은 구조가 됩니다:

```
        π (sname)              ← 최상위: 이름만 출력 (프로젝션)
            |
    σ (bid=100 AND rating>5)   ← 중간: 조건 필터링 (선택)
            |
      ⋈ (R.sid = S.sid)       ← 하위: 두 테이블 조인
       /         \
  Reserves     Sailors         ← 최하위: 원본 테이블 (리프 노드)
```

:::info 질의 트리는 어디에서 배우나요?
질의 트리는 **자료 구조(Data Structure)** 과목에서 배우는 트리(Tree) 개념과 동일합니다. 자료 구조에서 트리의 순회 방법, 노드의 부모-자식 관계 등을 배우는 이유가 바로 이런 데이터베이스 내부 알고리즘에서 활용되기 때문입니다.
:::

### 2단계: 효율적인 내부 형태로 변환

1단계에서 만들어진 기본 질의 트리를 **정립된 변환 규칙**을 사용해서 더 효율적인 형태로 바꿉니다. 이때 사용되는 것이 바로 **내부 형태 변환 규칙(Transformation Rules)**입니다.

핵심 변환 규칙을 정리하면:

**규칙 1 — AND 연산의 분리:**

```
-- ❌ 비효율: AND로 연결된 조건을 한꺼번에 처리
σ(조건1 AND 조건2 AND 조건3)(R)

-- ✅ 효율: 각 조건을 개별 선택 연산으로 분리
σ(조건3)( σ(조건2)( σ(조건1)(R) ) )
```

이렇게 하면 첫 번째 조건에서 데이터가 걸러지고, 두 번째 조건에서 또 걸러지고, 세 번째 조건에서 또 걸러집니다. 매 단계마다 **연산에 참여하는 데이터 양이 줄어드는 효과**가 있습니다.

마치 냉장고에서 재료를 꺼낼 때, "채소이면서 초록색이면서 국산인 것"을 한 번에 찾는 것보다, 먼저 "채소만 꺼내고" → "초록색만 남기고" → "국산만 고르는" 것이 더 체계적인 것과 같습니다.

**규칙 2 — 선택 연산의 교환성:**

```
σ(조건1)( σ(조건2)(R) )  =  σ(조건2)( σ(조건1)(R) )
```

남자 중에서 서울인 사람을 찾는 것과, 서울인 사람 중에서 남자를 찾는 것은 **결과가 동일**합니다. 따라서 선택도가 작은 조건을 먼저 적용할 수 있도록 순서를 자유롭게 바꿀 수 있습니다.

**규칙 3 — 프로젝션의 축소:**

```
-- ❌ 비효율: 프로젝션을 여러 번 중복 수행
π(a)( π(a,b)( π(a,b,c)(R) ) )

-- ✅ 효율: 마지막 프로젝션만 수행하면 동일한 결과
π(a)(R)
```

a, b, c 컬럼에서 a, b를 추출하고, 다시 a만 추출하는 것은 결국 처음부터 a만 추출하는 것과 같습니다. 중복 작업을 제거하는 것입니다.

**규칙 5 — 선택 연산을 먼저 수행:**

```
-- ❌ 비효율: 두 테이블을 먼저 조인하고 조건을 나중에 적용
σ(조건)(R ⋈ S)

-- ✅ 효율: 조건에 해당하는 테이블을 먼저 필터링하고 조인
( σ(조건)(R) ) ⋈ S
```

10개짜리 테이블과 10개짜리 테이블을 먼저 조인하면 100개가 됩니다. 그 100개에서 조건을 걸면 비효율적입니다. 반면, 먼저 조건을 적용해서 10개를 3개로 줄이고 나서 조인하면 30개만 처리하면 됩니다.

:::danger 카티션 프로덕트의 위험성
카티션 프로덕트(Cartesian Product, 두 테이블의 모든 행 조합)를 먼저 수행하면 데이터가 폭발적으로 증가합니다. 10행 × 10행 = 100행, 1000행 × 1000행 = 1,000,000행! 반드시 **선택 연산이나 조인 연산으로 변환**하여 불필요한 데이터 증가를 막아야 합니다.
:::

**규칙 6 — 양쪽 테이블 모두 먼저 선택:**

```
-- ❌ 비효율
σ(R의 조건 AND S의 조건)(R ⋈ S)

-- ✅ 효율: 각 테이블에 해당하는 조건을 먼저 적용한 후 조인
( σ(R의 조건)(R) ) ⋈ ( σ(S의 조건)(S) )
```

**규칙 7 — 교환 법칙:**

조인, 곱셈, 합집합, 교집합 연산에서는 테이블의 순서를 바꿔도 결과가 같습니다.

```
R ⋈ S  =  S ⋈ R    -- 조인은 교환 가능
R × S  =  S × R    -- 곱셈은 교환 가능
R ∪ S  =  S ∪ R    -- 합집합은 교환 가능
R ∩ S  =  S ∩ R    -- 교집합은 교환 가능
```

:::warning 교환 법칙이 성립하지 않는 연산
**세미 조인(Semi-Join)**, **차집합(-)**, **나누기(÷)** 이 세 가지 연산은 교환 법칙이 성립하지 않습니다. 순서를 바꾸면 결과가 달라지므로 주의해야 합니다.
:::

**규칙 8 — 프로젝션을 먼저 수행:**

```
-- ❌ 비효율: 조인 후 프로젝션
π(컬럼)(R ⋈ S)

-- ✅ 효율: 프로젝션 먼저, 조인 나중
( π(R의 컬럼)(R) ) ⋈ ( π(S의 컬럼)(S) )
```

**규칙 11 — 연산 순서의 결합성:**

```
(R × S) × T  =  R × (S × T)
```

어떤 테이블을 먼저 연산에 참여시킬지는 자유롭게 바꿀 수 있습니다.

**규칙 12 — OR 연결 조건의 변환:**

OR(논리합)로 연결된 조건식은 AND(논리곱) 정형식(Conjunctive Normal Form)으로 변환합니다. 이는 수학의 분배 법칙과 유사한 개념입니다.

### 변환 규칙 요약표

| 규칙 | 내용 | 핵심 원리 |
|:---:|:---|:---|
| 규칙 1 | AND 조건을 개별 선택 연산으로 분리 | 단계별 필터링 |
| 규칙 2 | 선택 연산의 순서는 교환 가능 | 선택도 작은 것 먼저 |
| 규칙 3 | 중복 프로젝션은 마지막 것만 수행 | 중복 제거 |
| 규칙 4 | 선택과 프로젝션은 교환 가능 | 순서 자유 |
| 규칙 5 | 조인 후 선택 → 선택 먼저, 조인 나중 | 튜플 수 감소 |
| 규칙 6 | 양쪽 테이블 모두 선택을 먼저 | 양쪽 다 필터링 |
| 규칙 7 | 조인, 곱셈, 합/교집합은 교환 가능 | 교환 법칙 |
| 규칙 8 | 조인 후 프로젝션 → 프로젝션 먼저, 조인 나중 | 컬럼 수 감소 |
| 규칙 9 | 합/교/차집합 후 선택/프로젝션 → 먼저 수행 | 사전 필터링 |
| 규칙 11 | 곱셈의 결합 법칙 성립 | 순서 자유 |
| 규칙 12 | OR → AND 정형식으로 변환 | 분배 법칙 |

### 3단계: 후보 프로시저(실행 계획 후보) 선정

변환 규칙을 적용하면 여러 가지 형태의 질의 트리가 만들어집니다. 만약 10개의 실행 계획이 나왔다면, 10개를 **전부 평가하는 것은 비효율적**입니다.

마치 국회의원 선거에서 전 국민이 후보가 되지 않고, 당선 가능성이 있는 사람만 후보로 등록하여 그들만 평가하는 것처럼, 실행 계획도 **성능이 향상될 가능성이 높은 계획만 후보로 선정**합니다.

후보 선정 시 고려하는 요소:
- **인덱스(Index) 존재 여부**: 해당 컬럼에 인덱스가 있으면 검색이 훨씬 빠릅니다.
- **값의 분포(Data Distribution)**: 데이터가 균등하게 분포되어 있는지, 특정 값에 편중되어 있는지를 확인합니다.
- **클러스터링(Clustering) 여부**: 물리적으로 관련 데이터가 가까이 저장되어 있는지를 확인합니다.
- **해싱 함수 사용 여부**: 해시 기반 검색을 활용할 수 있는지를 확인합니다.
- **연산 순서**: 어떤 연산을 먼저 수행하는 것이 효율적인지를 판단합니다.

예를 들어, 10개 계획 중 이러한 요소들을 고려했더니 3개만 실질적으로 평가할 가치가 있다면, 이 3개가 **후보**가 됩니다.

### 4단계: 계획 평가 및 최종 선정

후보로 선정된 실행 계획들에 대해 **비용식(Cost Formula)**을 적용하여 실제 비용을 계산합니다.

```
총 비용 = 디스크 I/O 비용 + CPU 계산 비용 + 저장 비용 + 통신 비용
```

각 후보 계획의 총 비용을 계산한 후, **비용이 가장 작은 계획이 최종 선정**됩니다. 이렇게 선정된 계획은 **질의어 코드 생성기**를 통해 실행 코드로 변환되고, **런타임 데이터베이스 처리기**에서 실제로 실행되어 최종 결과를 반환합니다.

---

## ⚠️ 주의사항과 실무 팁

### 흔히 하는 실수

:::danger SELECT문에서 불필요한 전체 조회를 피하세요
```sql
-- ❌ 비효율: 모든 컬럼을 가져온 후 프로그램에서 필요한 것만 사용
SELECT * FROM 학생 WHERE 학년 = 3

-- ✅ 효율: 필요한 컬럼만 지정하여 가져옴
SELECT 학번, 이름 FROM 학생 WHERE 학년 = 3
```
`SELECT *`는 모든 컬럼을 가져오므로 데이터 전송량이 증가합니다. 프로젝션 연산을 먼저 수행하는 원칙에 따라, **필요한 컬럼만 명시적으로 지정**하는 습관을 기르세요.
:::

### 성능 관련 팁

:::tip 최적화를 돕는 SQL 작성 습관
1. **WHERE절의 조건 순서**: DBMS가 자동으로 최적화하지만, 선택도가 낮은(결과가 적은) 조건을 먼저 작성하면 가독성도 좋아집니다.
2. **JOIN을 사용할 때는 조인 조건을 명확하게**: 조인 조건 없이 두 테이블을 FROM에 나열하면 카티션 프로덕트가 발생하여 성능이 급격히 저하됩니다.
3. **인덱스 활용**: 자주 검색되는 컬럼에 인덱스를 생성하면 최적화기가 더 효율적인 실행 계획을 선택할 수 있습니다.
:::

### 최적화 관련 핵심 원칙 정리

| 원칙 | 설명 | 비유 |
|:---|:---|:---|
| 선택 연산 먼저 | WHERE 조건을 먼저 적용하여 데이터 양 줄이기 | 100명 중 10명만 먼저 추려내기 |
| 프로젝션 먼저 | 필요한 컬럼만 먼저 가져오기 | 냉장고에서 필요한 재료만 꺼내기 |
| 카티션 프로덕트 회피 | 곱셈 대신 조인 사용 | 모든 조합을 만들지 않고 맞는 것만 연결 |
| 선택도 작은 것 먼저 | 결과가 적은 조건부터 적용 | 적은 것부터 걸러내야 효율적 |
| 중복 연산 제거 | 같은 연산을 반복하지 않기 | 같은 일을 두 번 하지 않기 |

---

## 📌 핵심 정리

- **SQL은 고급 질의어**이며, 실행되기 위해 검사기 → 파서 → 최적화기 → 코드 생성기 → 런타임 처리기의 5단계를 거친다
- **검사기(스캐너)**는 SQL 문장을 읽어서 토큰(의미 있는 최소 단위)을 식별하는 역할을 한다
- **토큰(Token)**은 `SELECT`, `FROM`, 테이블 이름 등 SQL을 구성하는 개별 요소이다
- **파서(Parser)**는 식별된 토큰이 SQL 문법 규칙에 맞게 구성되었는지 검사(Syntax Error Check)한다
- **질의 최적화**란 하나의 SQL에 대해 가능한 여러 실행 계획 중 가장 비용이 적은 계획을 선정하는 과정이다
- **선택도(Selectivity)**가 작은 조건을 먼저 실행하면 연산에 참여하는 튜플 수가 줄어 성능이 향상된다
- **경험적 최적화**는 검증된 규칙(선택 먼저, 프로젝션 먼저 등)을 적용하는 방식이다
- **비용 기반 최적화**는 디스크 I/O, CPU, 저장, 통신 비용을 계산하여 가장 적은 비용의 계획을 선택한다
- **의미적 질의 최적화**는 무결성 제약을 위반하는 질의(예: 5학년 검색)를 사전에 걸러낸다
- 최적화 내부는 **내부 표현 변환 → 효율적 형태 변환 → 후보 선정 → 평가/결정**의 4단계로 진행된다
- **변환 규칙**의 핵심은 선택·프로젝션 연산을 먼저 수행하고, 카티션 프로덕트를 조인으로 바꾸는 것이다
- 통계 정보는 **데이터 사전(카탈로그)**에 저장되어 있으며, 시스템이 자동으로 참조하여 최적화를 수행한다

---

작성일: 2026-02-21