---
title: "질의어 최적화기와 실행 계획 선정"
description: "질의어 최적화기와 실행 계획 선정에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/query-processing-optimization/4-query-optimizer"
sidebar_label: "질의어 최적화"
date: "2026-02-21"
---

## 🎯 질의어 최적화란 무엇인가?

우리가 데이터베이스에 **SQL(Structured Query Language)**로 명령을 내리면, 데이터베이스 시스템은 그 명령을 곧바로 실행하는 것이 아닙니다. 마치 네비게이션이 목적지를 입력받으면 **여러 경로를 탐색한 뒤 가장 빠른 길을 안내하는 것**처럼, 데이터베이스 시스템도 하나의 SQL 명령어를 처리할 수 있는 **여러 가지 실행 방법(실행 계획)**을 만들어낸 뒤, 그중에서 **가장 비용이 적게 드는 최적의 방법을 골라서 실행**합니다.

이 전체 과정을 **질의어 최적화(Query Optimization)**라고 부릅니다.

> **핵심 한 줄 요약:** 질의어 최적화란, 사용자가 작성한 하나의 SQL 명령어를 실행할 수 있는 여러 방법 중에서 **가장 효율적인(비용이 적은) 실행 계획을 자동으로 찾아주는 과정**입니다.

SQL은 **고급 언어(High-level Language)**입니다. 고급 언어란 사람이 이해하기 쉬운 형태의 언어를 말합니다. `SELECT`, `FROM`, `WHERE` 같은 영어 단어로 명령을 내리기 때문에 사람이 읽고 쓰기 편하죠. 하지만 컴퓨터 내부에서는 이런 고급 언어를 바로 처리할 수 없기 때문에, **내부적으로 처리할 수 있는 형태로 변환하고 최적화하는 과정**이 반드시 필요합니다.

이번 문서에서는 이 최적화가 **왜 필요한지**, **어떤 단계를 거치는지**, **어떤 규칙으로 최적화가 이루어지는지**를 하나씩 자세히 살펴보겠습니다.

:::info 데이터베이스 기본 과정 vs 고급 과정
SQL 문법, 테이블 생성, 권한 부여 같은 내용은 데이터베이스의 **기본 과정**에 해당합니다. 반면 질의어 최적화, 병행 제어(동시 접근 관리), 회복(장애 복구) 같은 주제는 데이터베이스의 **고급 과정**입니다. 고급 과정까지 이해하면 **데이터베이스 관리자(DBA)**로서 데이터베이스를 효율적으로 관리하고 성능을 향상시키는 방법을 알 수 있게 됩니다.
:::

---

## 🔄 질의어 처리의 전체 흐름

SQL 명령어가 입력되면 결과가 나오기까지 **5단계의 처리 과정**을 거칩니다. 이 과정을 택배 배송에 비유하면 이해하기 쉽습니다.

| 단계 | 구성 요소 | 하는 일 | 비유 |
|------|-----------|---------|------|
| 1단계 | **검사기(Scanner)** | 질의문의 요소(토큰)를 식별 | 택배 접수 시 보내는 사람·받는 사람·주소를 확인하는 것 |
| 2단계 | **파서(Parser)** | 문법 오류 검사 | 주소가 올바른 형식인지 검증하는 것 |
| 3단계 | **질의어 최적화기(Query Optimizer)** | 여러 실행 계획 중 최적의 계획 선정 | 여러 배송 경로 중 가장 빠른 경로를 찾는 것 |
| 4단계 | **질의어 코드 생성기(Code Generator)** | 선정된 계획의 실행 코드 생성 | 최적 경로대로 배송 지시서를 작성하는 것 |
| 5단계 | **런타임 DB 처리기(Runtime DB Processor)** | 실행 코드를 실제로 실행하여 결과 반환 | 배송 지시서대로 실제 배송을 수행하는 것 |

각 단계 사이에는 **중간 결과물**이 생성됩니다:

- 파서 → **내부 형태 질의문** (질의 트리)
- 질의어 최적화기 → **질의문 계획** (최적 실행 계획)
- 코드 생성기 → **질의문 실행 코드**
- 런타임 DB 처리기 → **질의어 실행 결과**

> 네모 박스로 표현되는 것은 **시스템 구성 요소**(처리 모듈)이고, 그 사이에 나오는 것은 각 단계의 **결과물**입니다. 마치 공장의 생산 라인에서 각 기계(구성 요소)를 거칠 때마다 반제품(결과물)이 나오는 것과 같습니다.

---

## 🔍 검사기(Scanner)와 파서(Parser) — 질의문을 읽고 검증하기

### 📖 검사기(Scanner)가 하는 일

검사기는 **스캐너(Scanner)**라고도 부르며, 입력된 SQL 명령어를 처음으로 읽어들이는 역할을 합니다. 마치 우체국 직원이 편지를 받아서 "보내는 사람이 누구고, 받는 사람이 누구고, 주소가 어디인지"를 하나하나 확인하는 것과 같습니다.

검사기는 SQL 문장을 읽으면서 각각의 구성 요소를 **토큰(Token, 의미 있는 최소 단위)**으로 식별합니다.

```sql
-- 이 SQL 명령어가 입력되면
SELECT * FROM 학생;
```

검사기는 이 명령어를 다음과 같이 토큰으로 분리합니다:

| 토큰 | 종류 |
|------|------|
| `SELECT` | 키워드(명령어) |
| `*` | 와일드카드(모든 컬럼) |
| `FROM` | 키워드(절 구분) |
| `학생` | 테이블 이름 |
| `;` | 문장 종결 기호 |

이렇게 "아, 이것은 SELECT 명령어이고, FROM절이 있고, 대상 테이블은 '학생'이구나!"라고 식별해 내는 것이 검사기의 역할입니다.

### 📝 파서(Parser)가 하는 일

파서는 검사기가 식별한 토큰들을 가지고 **문법(Syntax) 오류가 있는지 검사**합니다. 프로그래밍에서 컴파일(Compile)할 때 문법 오류를 체크하는 것과 동일한 원리입니다.

```sql
-- ✅ 올바른 문법
SELECT * FROM 학생;

-- ❌ 잘못된 문법 (FROM이 빠짐)
SELECT * 학생;
```

파서는 "SELECT 명령어는 반드시 `SELECT ... FROM ...` 형식이어야 한다"는 규칙을 알고 있기 때문에, 두 번째 문장에서 `FROM`이 빠진 것을 **문법 오류(Syntax Error)**로 판단합니다.

:::warning 검사기와 파서의 차이를 헷갈리지 마세요!
- **검사기(Scanner)**: "이 문장에 어떤 요소들이 있는지" **식별**하는 단계
- **파서(Parser)**: "이 요소들이 문법에 맞게 배치되었는지" **검증**하는 단계

비유하면, 검사기는 "재료가 뭐가 있는지 확인"하는 것이고, 파서는 "이 재료들로 레시피대로 요리할 수 있는지 확인"하는 것입니다.
:::

파서를 거치면 **내부 형태 질의문**이 만들어집니다. 이것은 관계 대수(Relational Algebra) 기반의 **질의 트리(Query Tree)** 형태로 표현되며, 이후 최적화기가 이 트리를 가지고 최적화를 수행하게 됩니다.

---

## ⚙️ 질의어 최적화기 — 최적의 실행 계획을 찾아라

### 🤔 왜 최적화가 필요한가?

사용자가 SQL 명령어를 **하나만 작성**하더라도, 그 명령어를 **실행할 수 있는 방법은 여러 가지**입니다.

마치 집에서 학교까지 가는 길이 여러 개인 것과 같습니다. 어떤 사람은 버스를 타고, 어떤 사람은 지하철을 타고, 어떤 사람은 자전거를 타고, 어떤 사람은 걸어갑니다. 모두 같은 목적지에 도착하지만, **소요 시간과 비용은 다릅니다**. 가장 빠르고 저렴한 경로를 찾는 것이 바로 최적화입니다.

### 📌 실행 계획이란?

구체적인 예시를 통해 살펴보겠습니다. 다음과 같은 SQL이 있다고 가정합니다:

```sql
-- 학생 테이블에서 남자이면서 서울 지역인 학생의 학번을 검색
SELECT 학번
FROM 학생
WHERE 성별 = '남자' AND 지역 = '서울';
```

이 하나의 SQL을 처리하는 방법은 최소 3가지가 있습니다:

| 실행 계획 | 방법 | 설명 |
|-----------|------|------|
| 계획 1 | 성별 먼저 → 지역 나중 | 먼저 남자를 찾고, 그중에서 서울인 사람을 찾음 |
| 계획 2 | 지역 먼저 → 성별 나중 | 먼저 서울인 사람을 찾고, 그중에서 남자를 찾음 |
| 계획 3 | 동시에 검사 | 한 명씩 가져와서 남자이면서 서울인지 동시에 확인 |

세 가지 모두 같은 결과를 내지만, **처리 효율은 다릅니다**.

### 📊 선택도(Selectivity)와 최적 계획 선정

만약 학생이 **100명**이고, 그중 **남자가 10명**, **서울 지역이 50명**이라면 어떤 방법이 가장 효율적일까요?

- **계획 1 (성별 먼저):** 100명 중 남자 10명을 먼저 찾고 → 10명 중 서울인 사람을 찾음 → **검사 대상: 100 + 10 = 110번**
- **계획 2 (지역 먼저):** 100명 중 서울 50명을 먼저 찾고 → 50명 중 남자를 찾음 → **검사 대상: 100 + 50 = 150번**
- **계획 3 (동시 검사):** 100명을 한 명씩 두 조건 동시 확인 → **검사 대상: 100 × 2 = 200번**

당연히 **계획 1이 가장 효율적**입니다! 남자가 10명밖에 안 되니까, 먼저 남자를 추려내면 이후 검사할 데이터가 확 줄어들기 때문입니다.

이때 사용하는 개념이 바로 **선택도(Selectivity)**입니다:

> **선택도** = 조건을 만족하는 튜플(행) 수 / 전체 튜플 수

| 조건 | 만족하는 수 | 선택도 |
|------|-------------|--------|
| 성별 = '남자' | 10명 | 10% |
| 지역 = '서울' | 50명 | 50% |

**선택도가 작은 조건(더 적은 데이터를 걸러내는 조건)을 먼저 실행**하면, 이후 연산에 참여하는 데이터 양이 줄어들어 전체적으로 성능이 좋아집니다.

:::tip 선택도 정보는 누가 알고 있나요?
사용자가 "남자가 10명이고 서울이 50명"이라는 것을 직접 알려주는 것이 아닙니다. 이 정보는 **데이터 사전(Data Dictionary)**이라는 곳에 **통계 데이터**로 저장되어 있습니다. 질의어 최적화기가 이 통계 정보를 자동으로 참조하여 최적의 실행 계획을 선정합니다. 즉, **최적화는 시스템이 자동으로 수행**하는 것입니다!
:::

---

## 🧩 최적화의 3가지 방법

질의어 최적화는 크게 **세 가지 방법**으로 이루어집니다.

### 1️⃣ 경험적 최적화 (Heuristic Optimization)

**"과거의 경험을 바탕으로 효율적인 규칙을 적용하는 방법"**입니다.

여러분이 매일 집에서 학교까지 통학하면서 "이 길이 가장 빠르다", "이 시간대에는 이 경로가 덜 막힌다"라는 **경험**을 갖게 되는 것처럼, 데이터베이스 시스템도 오랜 연구를 통해 **"이렇게 하면 대부분의 경우 성능이 좋아진다"**라는 경험적 규칙들을 갖고 있습니다.

대표적인 경험적 처리 전략은 다음과 같습니다:

- **선택(Selection) 연산을 가능하면 먼저 수행하라:** WHERE절의 조건을 먼저 적용해서 연산에 참여하는 튜플(행) 수를 줄여라
- **카티션 프로덕트(Cartesian Product) + 선택 연산은 조인(Join) 연산으로 바꿔라:** 두 테이블을 무조건 곱한 뒤 조건으로 거르는 것보다, 조인 조건을 적용하면서 결합하는 것이 훨씬 효율적이다
- **프로젝션(Projection) 연산을 가능하면 먼저 수행하라:** 필요한 컬럼만 먼저 가져와서 불필요한 데이터를 제거하라
- **공통 연산식은 한 번만 수행하라:** 중복되는 연산을 반복하지 말고 마지막 결과만 한 번에 수행하라

```sql
-- ❌ 비효율적: 전체를 곱한 뒤 조건으로 거르기 (카티션 프로덕트 + 선택)
-- 10행 × 10행 = 100행을 만든 후 조건에 맞는 것만 선택
SELECT *
FROM R, S                      -- R과 S를 카티션 프로덕트 (모든 조합 생성)
WHERE R.id = S.id;             -- 그중에서 id가 같은 것만 선택

-- ✅ 효율적: 조인 연산으로 바꾸기
-- id가 같은 행끼리만 결합하므로 불필요한 조합이 생기지 않음
SELECT *
FROM R JOIN S ON R.id = S.id;  -- 조인 조건을 적용하면서 결합
```

위 두 쿼리의 결과는 같지만, 첫 번째 방법은 R이 10행이고 S가 10행이면 **100행을 먼저 만든 뒤** 거르는 반면, 두 번째 방법은 **조건에 맞는 행만 결합**하므로 훨씬 효율적입니다.

### 2️⃣ 비용 기반 최적화 (Cost-Based Optimization)

**"실제 실행 비용을 수식으로 계산하여 가장 비용이 작은 계획을 선택하는 방법"**입니다.

각 실행 계획에 대해 **비용식(Cost Formula)**을 적용하여 비용을 계산합니다. 비용식에는 다음과 같은 요소들이 포함됩니다:

| 비용 요소 | 설명 | 중요한 경우 |
|-----------|------|-------------|
| **디스크 입출력 비용(I/O Cost)** | 하드디스크에서 데이터를 읽고 쓰는 비용 | 대형 데이터베이스 시스템 |
| **CPU 계산 비용(Computation Cost)** | CPU에서 연산을 처리하는 비용 | 소형 데이터베이스 (데이터 양이 적은 경우) |
| **저장 비용(Storage Cost)** | 중간 결과를 메모리나 디스크에 저장하는 비용 | 복잡한 질의 처리 시 |
| **통신 비용(Communication Cost)** | 네트워크를 통해 데이터를 전송하는 비용 | 분산 데이터베이스 시스템 |

각 실행 계획마다 이 비용들을 합산하여, **총 비용이 가장 작은 계획이 선정**됩니다.

:::note 어떤 비용에 가중치를 둘 것인가?
사용하는 데이터베이스 시스템의 종류에 따라 중요한 비용 요소가 달라집니다. 대형 시스템은 디스크 I/O가, 소형 시스템은 CPU 처리 시간이, 분산 시스템은 네트워크 통신 비용이 더 중요합니다. 따라서 시스템 환경에 따라 비용식의 **가중치**가 달라지게 됩니다.
:::

> **일반적으로는 경험적 최적화와 비용 기반 최적화를 함께 사용합니다.** 경험적 규칙으로 명백히 비효율적인 계획을 먼저 제거한 뒤, 남은 후보들을 비용식으로 평가하여 최종 계획을 선정합니다.

### 3️⃣ 의미적 질의 최적화 (Semantic Query Optimization)

**"질의의 의미 자체가 논리적으로 불가능한 경우, 실행하지 않고 바로 결과를 반환하는 방법"**입니다.

예를 들어, 대학교에 1학년부터 4학년까지만 존재하는데 **"5학년 이상의 학생 이름을 찾아라"**라는 질의를 하면 어떻게 될까요?

```sql
-- ❌ 의미적으로 불가능한 질의 (대학교에 5학년은 존재하지 않음)
SELECT 이름
FROM 학생
WHERE 학년 >= 5;      -- 학년은 1~4까지만 존재
```

이 경우 **굳이 검사기 → 파서 → 최적화기 → 코드 생성기 → 런타임 처리**의 모든 단계를 거칠 필요가 없습니다. 학년의 **무결성 제약 조건**(1~4학년만 가능)에 의해 결과가 없다는 것을 바로 알 수 있기 때문입니다. 이렇게 의미적으로 불가능한 질의를 조기에 판단하여 **최적화 과정을 단축**하는 것이 의미적 질의 최적화입니다.

초등학교에서 "8학년 학생을 검색하라"고 질의하면 당연히 결과가 없겠죠? 초등학교는 1학년부터 6학년까지만 있으니까요. 이런 경우 시스템은 데이터를 뒤질 필요 없이 바로 **"결과 없음"**을 반환하면 됩니다.

---

## 📐 최적화의 4단계 세부 과정

질의어 최적화기 내부에서는 다음 **4단계**를 거쳐 최적의 실행 계획이 결정됩니다.

### 1단계: 질의문을 내부 표현으로 변환

파서가 생성한 중간 결과를 컴퓨터가 효율적으로 처리할 수 있는 **내부 형태(질의 트리)**로 변환합니다. 관계 대수(Relational Algebra) 기반의 **트리(Tree) 구조**를 만들어내는 것입니다.

구체적인 과정을 예시로 살펴보겠습니다:

**① SQL 질의문 (원본)**

```sql
-- Reserves 테이블과 Sailors 테이블을 조인하여 조건에 맞는 선원 이름을 검색
SELECT S.sname                    -- 선원 이름을 출력
FROM Reserves R, Sailors S        -- Reserves와 Sailors 두 테이블에서
WHERE R.sid = S.sid               -- 조인 조건: 두 테이블의 sid가 같은 행
  AND R.bid = 100                 -- 예약 번호(bid)가 100인 것
  AND S.rating > 5;               -- 등급(rating)이 5보다 큰 것
```

이 SQL은 **두 개의 테이블을 조인**하면서, **세 가지 조건**을 적용하고, 최종적으로 **선원 이름(sname)**만 출력하는 질의입니다.

**② 관계 대수로 변환**

SQL을 먼저 관계 대수(수학적 표현)로 변환합니다:

```
π(sname) [ σ(bid=100 AND rating>5) [ Reserves ⋈(sid=sid) Sailors ] ]
```

이 수식을 한 줄씩 안쪽부터 읽어보면:

- `Reserves ⋈(sid=sid) Sailors` → Reserves와 Sailors를 sid가 같은 조건으로 조인
- `σ(bid=100 AND rating>5)` → 조인 결과에서 bid=100이고 rating>5인 행만 선택
- `π(sname)` → 최종적으로 sname 컬럼만 출력(프로젝션)

**③ 질의 트리로 변환**

관계 대수 표현을 **트리 구조**로 변환합니다. 트리의 **잎(leaf) 노드**에는 테이블이, **중간 노드**에는 연산이, **루트(root) 노드**에는 최종 출력(프로젝션)이 위치합니다:

```
         π(sname)              ← 루트: 최종 출력 (sname만 프로젝션)
            |
    σ(bid=100 AND rating>5)    ← 중간: 조건 선택 (셀렉션)
            |
     ⋈ (sid = sid)             ← 중간: 조인 연산
    /              \
Reserves         Sailors       ← 잎: 원본 테이블들
```

이 트리가 바로 **내부 형태 질의문(질의 트리)**입니다. 이후 최적화기는 이 트리의 **노드 위치를 바꾸거나 연산 순서를 변경**하면서 최적화를 수행합니다.

:::info 왜 트리 구조를 사용하나요?
자료 구조(Data Structure)에서 배우는 트리는 바로 이런 곳에서 활용됩니다. 트리는 **부모-자식 관계로 연산의 순서를 표현**하기에 적합하고, 부모와 자식의 위치를 바꾸면 연산 순서를 변경할 수 있어 **최적화에 매우 유용한 자료 구조**입니다.
:::

### 2단계: 효율적인 내부 형태로 변환

1단계에서 만든 기본 질의 트리를 **변환 규칙(Transformation Rules)**을 적용하여 더 효율적인 형태로 바꿉니다. 이 변환 규칙은 마음대로 정하는 것이 아니라, **수학적으로 검증된 정립된 규칙(Rule 1~12)**을 사용합니다.

위 예시의 기본 트리를 최적화하면:

```
-- 최적화 전 (비효율적)
         π(sname)
            |
    σ(bid=100 AND rating>5)     ← 조인 후에 조건 적용
            |
     ⋈ (sid = sid)
    /              \
Reserves         Sailors


-- 최적화 후 (효율적: 선택 연산을 먼저 수행)
         π(sname)
            |
     ⋈ (sid = sid)              ← 조인은 나중에
    /              \
σ(bid=100)      σ(rating>5)     ← 선택 연산을 먼저! (튜플 수 감소)
    |                |
Reserves         Sailors
```

최적화 전에는 두 테이블을 먼저 조인한 뒤 조건으로 거르지만, 최적화 후에는 **각 테이블에서 조건에 맞는 행만 먼저 걸러낸 뒤 조인**합니다. 이렇게 하면 조인에 참여하는 데이터 양이 확 줄어들어 성능이 크게 향상됩니다.

### 3단계: 후보 프로시저 선정

변환 규칙을 적용하면 **여러 가지 실행 계획**이 나옵니다. 하지만 모든 계획을 일일이 평가하면 그것 자체가 시간 낭비입니다.

마치 **선거에서 모든 국민이 후보가 아니라, 당선 가능성이 있는 소수만 후보로 등록하는 것**처럼, 실행 계획들 중에서도 **성능 향상이 기대되는 유력한 후보만 선정**합니다.

이때 고려하는 요소들:

- **인덱스(Index)의 존재 여부:** 인덱스가 있으면 검색 속도가 빨라짐
- **값의 분포(Selectivity):** 조건을 만족하는 데이터의 비율
- **물리적 클러스터링(Clustering):** 관련 데이터가 디스크에 함께 저장되어 있는지
- **해싱 함수(Hashing Function) 사용 여부:** 해시를 통한 빠른 접근이 가능한지
- **연산의 순서:** 어떤 연산을 먼저 수행할 것인지

예를 들어 10개의 실행 계획이 나왔다면, 위 요소들을 고려했을 때 "이 3개만 평가하면 최적의 계획을 찾을 수 있겠다"고 판단하여 **3개의 후보만 선정**하는 것입니다.

### 4단계: 실행 계획 평가 및 최종 선정

선정된 후보 계획들에 대해 **비용식을 적용하여 실행 비용을 계산**하고, **비용이 가장 작은 계획이 최종 선정**됩니다.

```
계획 A의 비용 = I/O 비용 + CPU 비용 + 저장 비용 + 통신 비용 = 150
계획 B의 비용 = I/O 비용 + CPU 비용 + 저장 비용 + 통신 비용 = 85   ← 최소!
계획 C의 비용 = I/O 비용 + CPU 비용 + 저장 비용 + 통신 비용 = 210

→ 계획 B가 최종 선정!
```

선정된 계획은 **질의어 코드 생성기**에 전달되어 실행 코드로 변환되고, **런타임 데이터베이스 처리기**가 이 코드를 실행하여 최종 결과를 반환합니다.

---

## 📏 내부 형태 변환 규칙 (Rule 1 ~ 12) 상세 설명

2단계에서 사용하는 **변환 규칙**은 수학적으로 검증된 12가지 규칙입니다. 각 규칙이 무엇을 의미하는지, 왜 필요한지 하나씩 살펴보겠습니다.

### Rule 1: AND 조건을 개별 선택 연산으로 분리

```
σ(조건1 AND 조건2 AND 조건3)(R)
→ σ(조건1)( σ(조건2)( σ(조건3)(R) ) )
```

**왜 필요한가?** AND로 연결된 조건 3개를 한꺼번에 검사하면, 100명을 대상으로 매번 3개 조건을 모두 확인해야 합니다. 하지만 하나씩 분리하면, 첫 번째 조건으로 대상을 줄이고, 줄어든 대상에 두 번째 조건을 적용하고... 이런 식으로 **점점 검사 대상이 줄어듭니다**.

```sql
-- ❌ 비효율적: 100명을 대상으로 매번 3가지 조건을 모두 확인
SELECT * FROM 학생
WHERE 성별 = '남자' AND 지역 = '서울' AND 점수 > 80;
-- 100명 × 3개 조건 = 매 행마다 3번 비교

-- ✅ 효율적: 조건을 단계별로 분리하여 점점 대상을 줄임
-- 내부적으로 이렇게 처리됨:
-- 1) 100명 중 남자 10명 선택     (검사: 100번)
-- 2) 10명 중 서울인 3명 선택      (검사: 10번)  
-- 3) 3명 중 80점 초과 2명 선택    (검사: 3번)
-- 총 검사: 113번 (vs 300번)
```

### Rule 2: 선택 연산의 교환 법칙

```
σ(조건1)( σ(조건2)(R) ) = σ(조건2)( σ(조건1)(R) )
```

**왜 필요한가?** "남자 중에서 서울인 사람"을 찾는 것과 "서울인 사람 중에서 남자"를 찾는 것은 결과가 같습니다. 따라서 **선택도가 더 작은 조건을 먼저 적용**할 수 있도록 순서를 자유롭게 바꿀 수 있습니다.

### Rule 3: 프로젝션 연산의 축소

```
π(A)( π(A,B)( π(A,B,C)(R) ) ) = π(A)(R)
```

**왜 필요한가?** A, B, C 컬럼을 가져온 뒤 A, B만 남기고, 다시 A만 남기면... 결국 **처음부터 A만 가져오면 됩니다**. 중복되는 프로젝션을 제거하여 불필요한 연산을 줄이는 규칙입니다.

```sql
-- ❌ 비효율적: 불필요한 중복 프로젝션
-- (내부적으로 이렇게 처리되면 비효율적)
-- 1단계: 학번, 이름, 점수를 가져옴
-- 2단계: 그중 학번, 이름만 남김
-- 3단계: 그중 학번만 남김

-- ✅ 효율적: 마지막에 필요한 것만 한 번에 가져옴
SELECT 학번 FROM 학생;   -- 처음부터 학번만 가져옴
```

### Rule 4: 선택(Selection)과 프로젝션(Projection)의 교환

```
π(속성목록)( σ(조건)(R) ) = σ(조건)( π(속성목록)(R) )
```

**왜 필요한가?** 조건을 먼저 적용하고 컬럼을 추출하든, 컬럼을 먼저 추출하고 조건을 적용하든 결과는 같습니다. 상황에 따라 더 효율적인 순서를 선택할 수 있게 해주는 규칙입니다.

### Rule 5: 선택 연산을 조인/카티션 프로덕트 아래로 내리기

```
σ(R의 조건)( R × S ) = σ(R의 조건)(R) × S
σ(조인조건)( R × S ) = R ⋈(조인조건) S
```

이것은 **가장 중요한 규칙** 중 하나입니다.

```sql
-- ❌ 비효율적: 먼저 곱한 뒤(카티션 프로덕트) 조건으로 거름
-- R: 10행, S: 10행이면 → 100행을 만든 후 조건 적용
SELECT *
FROM R, S
WHERE R.id = S.id AND R.age > 20;
-- 100행에서 조건 검사 → 느림

-- ✅ 효율적: R에 해당하는 조건을 먼저 적용한 후 조인
-- R에서 age > 20인 행만 먼저 선택 (예: 3행) → 3행 × 10행 = 30행만 조인
-- 내부적으로:
-- σ(age>20)(R) ⋈(id=id) S
-- 훨씬 적은 데이터로 조인 수행 → 빠름
```

**핵심:** 카티션 프로덕트(모든 조합을 만드는 곱하기)를 하기 **전에** 선택 연산으로 데이터를 줄여야 합니다. 10개와 10개를 곱하면 100개가 되지만, 먼저 3개로 줄이면 30개만 만들면 되니까요.

### Rule 6: 양쪽 테이블 모두에 선택 연산 적용

```
σ(R의조건 AND S의조건)( R ⋈ S ) = σ(R의조건)(R) ⋈ σ(S의조건)(S)
```

Rule 5의 확장 버전입니다. **양쪽 테이블에 각각 해당하는 조건이 있으면, 각 테이블에서 먼저 조건을 적용한 뒤 조인**합니다.

```sql
-- ❌ 비효율적: 먼저 조인한 뒤 양쪽 조건을 한꺼번에 적용
SELECT *
FROM R JOIN S ON R.id = S.id
WHERE R.age > 20 AND S.grade = 'A';
-- R 전체 × S 전체를 조인한 뒤 조건 적용

-- ✅ 효율적: 각 테이블에서 조건을 먼저 적용
-- 내부적으로:
-- (R에서 age > 20인 것만) ⋈ (S에서 grade = 'A'인 것만)
-- 양쪽 모두 데이터가 줄어든 상태에서 조인 → 매우 빠름
```

### Rule 7: 조인, 카티션 프로덕트, 합집합, 교집합의 교환 법칙

```
R ⋈ S = S ⋈ R       -- 조인 순서 교환 가능
R × S = S × R       -- 카티션 프로덕트 순서 교환 가능
R ∪ S = S ∪ R       -- 합집합 순서 교환 가능
R ∩ S = S ∩ R       -- 교집합 순서 교환 가능
```

:::danger 교환 법칙이 성립하지 않는 연산
**세미조인(Semi-join)**, **차집합(-)**, **나누기(÷)** 이 3가지 연산은 교환 법칙이 성립하지 않습니다. 즉, R - S ≠ S - R 입니다. 이 점을 반드시 기억하세요!
:::

### Rule 8: 프로젝션 연산을 조인/카티션 프로덕트 아래로 내리기

```
π(R의속성, S의속성)( R ⋈ S ) = π(R의속성)(R) ⋈ π(S의속성)(S)
```

선택 연산뿐 아니라 **프로젝션 연산도 먼저 수행**하여, 필요한 컬럼만 먼저 추출한 뒤 조인하면 처리할 데이터 양이 줄어듭니다.

### Rule 9: 합집합, 교집합, 차집합과 선택/프로젝션의 분배

```
σ(조건)(R ∪ S) = σ(조건)(R) ∪ σ(조건)(S)
π(속성)(R ∪ S) = π(속성)(R) ∪ π(속성)(S)
```

합집합이나 교집합을 **먼저 수행한 뒤** 선택/프로젝션하는 것보다, **각 테이블에서 선택/프로젝션을 먼저 한 뒤** 합집합/교집합하는 것이 효율적입니다.

### Rule 11: 카티션 프로덕트와 조인의 결합 법칙

```
(R × S) × T = R × (S × T)
```

어떤 테이블을 먼저 곱하든 결과는 같습니다. 따라서 **데이터가 적은 테이블끼리 먼저 결합**하는 등 순서를 자유롭게 조정할 수 있습니다.

### Rule 12: OR 조건의 논리곱 정형식(CNF) 변환

```
(A OR B) AND C = (A AND C) OR (B AND C)
```

OR로 연결된 조건식을 AND로 연결된 **논리곱 정형식(Conjunctive Normal Form)**으로 변환합니다. AND로 분리된 조건은 Rule 1에 의해 개별 선택 연산으로 나눌 수 있으므로, 최적화에 더 유리한 형태가 됩니다.

---

## 🔑 변환 규칙의 핵심 원리 종합

12가지 규칙이 많아 보이지만, 결국 **핵심 원리는 3가지**로 요약됩니다:

| 핵심 원리 | 해당 규칙 | 설명 |
|-----------|-----------|------|
| **선택(Selection) 연산을 먼저 수행** | Rule 1, 2, 5, 6, 9 | WHERE절의 조건을 가능한 한 일찍 적용하여 튜플 수를 줄임 |
| **프로젝션(Projection) 연산을 먼저 수행** | Rule 3, 4, 8, 9 | 필요한 컬럼만 먼저 추출하여 데이터 양을 줄임 |
| **카티션 프로덕트를 조인으로 변환** | Rule 5, 7, 11 | 불필요한 모든 조합을 만들지 않고, 조건에 맞는 것만 결합 |

> 한 마디로 정리하면: **"연산에 참여하는 데이터의 양을 최대한 줄여라!"** 이것이 질의어 최적화의 근본 원리입니다.

마치 냉장고에서 요리 재료를 꺼낼 때, 냉장고 안의 모든 것을 꺼낸 뒤 필요한 것만 고르는 것(비효율적)이 아니라, **필요한 재료만 골라서 꺼내는 것(효율적)**과 같은 원리입니다.

---

## ⚠️ 주의사항 및 실무 팁

:::warning 최적화는 만능이 아닙니다
질의어 최적화기가 아무리 좋아도, **SQL 자체를 잘 작성하는 것이 기본**입니다. "쓰레기가 들어가면 쓰레기가 나온다(Garbage In, Garbage Out)"는 원칙은 최적화에도 적용됩니다. 불필요한 `SELECT *` 대신 필요한 컬럼만 명시하고, 적절한 인덱스를 생성하는 등 **기본적인 SQL 작성 습관**이 중요합니다.
:::

:::tip 실무에서 기억할 핵심 포인트
1. **SELECT *를 남발하지 마세요.** 필요한 컬럼만 명시하면 프로젝션 최적화에 도움이 됩니다.
2. **WHERE절의 조건은 선택도가 높은(결과가 적은) 순서대로 작성하면 좋습니다.** 물론 최적화기가 순서를 바꿔주지만, 의도를 명확히 하는 것이 코드 가독성에도 좋습니다.
3. **카티션 프로덕트를 직접 사용하지 마세요.** 반드시 JOIN 조건을 명시하여 불필요한 데이터 조합이 발생하지 않도록 합니다.
4. **통계 정보를 최신으로 유지하세요.** 데이터 사전의 통계 데이터가 오래되면 최적화기가 잘못된 판단을 할 수 있습니다.
:::

:::danger 절대 하지 말아야 할 것
**두 테이블을 조인할 때 WHERE절에 조인 조건을 빠뜨리면**, 카티션 프로덕트가 발생하여 데이터가 **기하급수적으로 폭발**합니다. R이 1만 행, S가 1만 행이면 카티션 프로덕트 결과는 **1억 행**이 됩니다. 이는 시스템 장애를 유발할 수 있습니다!

```sql
-- ❌ 절대 하지 마세요: 조인 조건 없는 두 테이블 결합
SELECT * FROM R, S;  -- R × S = 1만 × 1만 = 1억 행!

-- ✅ 반드시 조인 조건을 명시하세요
SELECT * FROM R JOIN S ON R.id = S.id;  -- 조건에 맞는 행만 결합
```
:::

---

## 📌 핵심 정리

- **SQL은 고급 언어**이며, 실행되기 전에 내부적으로 변환과 최적화 과정을 거친다
- **질의어 처리 5단계:** 검사기(Scanner) → 파서(Parser) → 질의어 최적화기 → 코드 생성기 → 런타임 DB 처리기
- **검사기(Scanner)**는 SQL의 요소(토큰)를 식별하고, **파서(Parser)**는 문법 오류를 검사한다
- **질의어 최적화기**는 하나의 SQL에 대해 여러 실행 계획을 만들어내고, 가장 비용이 적은 계획을 선정한다
- **선택도(Selectivity)**가 작은 조건을 먼저 적용하면 연산에 참여하는 데이터 양이 줄어든다
- **경험적 최적화:** 검증된 경험 규칙(선택 연산 먼저, 프로젝션 먼저, 카티션 프로덕트→조인 변환 등)을 적용
- **비용 기반 최적화:** I/O 비용, CPU 비용, 저장 비용, 통신 비용을 계산하여 총 비용이 최소인 계획 선택
- **의미적 질의 최적화:** 논리적으로 불가능한 질의는 실행 없이 즉시 "결과 없음" 반환
- **최적화 4단계:** 내부 표현(트리) 변환 → 효율적 형태로 변환(변환 규칙 적용) → 후보 선정 → 비용 평가 및 최종 선정
- **변환 규칙의 핵심 3원칙:** ① 선택 연산을 먼저 ② 프로젝션 연산을 먼저 ③ 카티션 프로덕트는 조인으로 변환
- 모든 변환 규칙의 궁극적 목표는 **"연산에 참여하는 데이터(튜플)의 양을 최대한 줄이는 것"**이다

작성일: 2026-02-21