---
title: "파서와 내부 형태 질의문 생성"
description: "파서와 내부 형태 질의문 생성에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/query-processing-optimization/3-parser-and-internal-form"
sidebar_label: "파서와 내부 형태"
date: "2026-02-21"
---

## 🎯 질의어 처리란 무엇인가?

우리가 데이터베이스에 "학생 테이블에서 남학생의 이름을 보여줘"라고 요청할 때, 이 요청은 **SQL(Structured Query Language)**이라는 **고급 질의어(사람이 읽고 쓰기 쉬운 언어)**로 작성됩니다. 여기서 "고급"이라는 말은 비싸다는 뜻이 아니라, **사람의 언어에 가깝다**는 의미입니다. 마치 우리가 한국어로 대화하듯이, SQL도 `SELECT`, `FROM`, `WHERE` 같은 영어 단어를 사용해서 데이터베이스에게 명령을 내릴 수 있습니다.

그런데 문제가 하나 있습니다. **컴퓨터는 SQL을 바로 이해하지 못합니다.** 마치 외국인 친구에게 한국어로 말하면 바로 알아듣지 못하는 것처럼, 데이터베이스 시스템도 SQL을 받으면 여러 단계의 **번역과 분석 과정**을 거쳐야 비로소 실행할 수 있습니다. 이 번역·분석·실행의 전체 과정을 **질의어 처리(Query Processing)**라고 부릅니다.

> **핵심 포인트:** SQL은 사람을 위한 고급 언어이므로, 데이터베이스 시스템이 실행하려면 반드시 내부적으로 이해할 수 있는 형태로 변환하는 과정이 필요합니다.

이번 문서에서는 SQL 질의문이 입력되었을 때 **어떤 단계를 거쳐서 최종 결과가 나오는지**, 특히 **파서(Parser)**가 무엇을 하고, **내부 형태 질의문**이 어떻게 만들어지며, 이후 **최적화**가 어떻게 이루어지는지를 초보자도 완전히 이해할 수 있도록 아주 자세하게 살펴보겠습니다.

---

## 🏗️ 질의어 처리의 전체 흐름

SQL 질의문이 입력되면, 결과가 나오기까지 **다섯 가지 핵심 구성 요소**를 순서대로 거칩니다. 이것을 택배 배송에 비유해 보겠습니다.

| 단계 | 구성 요소 | 비유 | 산출물 |
|:---:|:---:|:---:|:---:|
| 1단계 | **검사기(Scanner)** | 택배 접수처에서 주소·이름 확인 | 토큰(요소) 식별 |
| 2단계 | **파서(Parser)** | 주소 형식이 올바른지 검증 | **내부 형태 질의문** |
| 3단계 | **질의 최적화기(Query Optimizer)** | 가장 빠른 배송 경로 탐색 | **질의문 계획** |
| 4단계 | **질의어 코드 생성기(Code Generator)** | 배송 기사에게 전달할 운행 지시서 작성 | **질의문 실행 코드** |
| 5단계 | **런타임 데이터베이스 처리기(Runtime DB Processor)** | 실제 배송 수행 | **질의 실행 결과** |

위 표에서 **네모칸에 해당하는 것**(검사기, 파서, 최적화기, 코드 생성기, 런타임 처리기)은 **시스템의 구성 요소**이고, 각 단계를 거치면서 나오는 **산출물**(내부 형태 질의문, 질의문 계획, 실행 코드, 실행 결과)은 **이전 단계의 결과물**입니다.

:::info 전체 흐름 한 줄 요약
**고급 질의어(SQL)** → 검사기 → 파서 → **내부 형태 질의문** → 질의 최적화기 → **질의문 계획** → 코드 생성기 → **실행 코드** → 런타임 처리기 → **실행 결과**
:::

이제 각 단계를 하나씩 자세히 들여다보겠습니다.

---

## 🔍 검사기(Scanner) — 토큰 식별

### 검사기가 하는 일

질의문이 시스템에 들어오면, 가장 먼저 만나는 것이 **검사기(Scanner)**입니다. 검사기의 역할은 마치 **우체국 직원이 편지 봉투를 받아서 보낸 사람 이름, 받는 사람 이름, 주소 등을 하나하나 읽어 확인하는 것**과 같습니다.

예를 들어 아래와 같은 SQL 명령어가 들어왔다고 해봅시다:

```sql
-- 학생 테이블의 모든 정보를 출력하라
SELECT * FROM 학생;
```

검사기는 이 명령어를 처음부터 끝까지 쭉 읽으면서 다음과 같이 **요소(토큰, Token)**를 식별해 냅니다:

- `SELECT` → 아, 이건 **명령어 키워드**구나!
- `*` → 이건 **모든 속성을 의미하는 기호**구나!
- `FROM` → 이건 **테이블 지정 키워드**구나!
- `학생` → 이건 **테이블 이름**이구나!
- `;` → 이건 **문장의 끝 표시**구나!

> **토큰(Token)이란?** SQL 문장을 구성하는 최소 단위의 요소를 말합니다. 마치 한국어 문장에서 "나는 / 밥을 / 먹는다"처럼 문장을 의미 있는 단위로 쪼개는 것과 같습니다.

검사기는 이렇게 SQL 문장을 **의미 있는 조각(토큰)**으로 분리하는 역할을 합니다. 이 과정을 **어휘 분석(Lexical Analysis)**이라고도 부릅니다.

---

## 📐 파서(Parser) — 문법 검사와 내부 형태 질의문 생성

### 파서가 필요한 이유

검사기가 토큰을 식별해 냈다고 해서 모든 게 끝난 것이 아닙니다. **토큰이 올바르게 조합되어 있는지**, 즉 **문법(Syntax)에 맞는지** 확인해야 합니다.

비유하자면, "나는 밥을 먹는다"는 문법적으로 올바른 문장이지만, "밥을 나는 먹는다 을"은 단어는 다 있지만 문법이 틀린 것과 같습니다. 파서는 바로 이 **문법 검사**를 수행합니다.

### 파서가 하는 일

**파서(Parser)**는 검사기로부터 전달받은 토큰들을 분석하여, 해당 SQL 명령어가 **정해진 문법 규칙에 맞는지 검사**합니다. 이것을 **구문 분석(Syntax Analysis)** 또는 **신택스 에러 체크(Syntax Error Check)**라고 합니다.

자바나 C 같은 프로그래밍 언어에서 **컴파일(Compile)**을 하면 문법 오류를 잡아주죠? 파서가 하는 일이 바로 그것과 동일합니다. SQL에도 정해진 문법이 있기 때문에, 그 문법에 어긋나는 질의문은 이 단계에서 **오류로 걸러집니다.**

### 올바른 SQL과 잘못된 SQL 비교

```sql
-- ✅ 올바른 SQL: SELECT → 속성 → FROM → 테이블 순서가 맞음
SELECT * FROM 학생;
```

```sql
-- ❌ 잘못된 SQL: FROM이 빠져 있음 → 파서가 문법 오류를 감지함
SELECT * 학생;
```

```sql
-- ❌ 잘못된 SQL: SELECT 키워드 오타 → 파서가 인식 불가
SELEC * FROM 학생;
```

파서는 이처럼 **키워드 누락, 오타, 절(clause)의 순서 오류** 등을 잡아냅니다.

:::warning 파서가 잡지 못하는 오류
파서는 **문법(구문)**만 검사합니다. "5학년 학생을 검색해라"라고 했을 때, 실제로 5학년이 존재하는지 안 하는지는 파서가 판단하지 않습니다. 이런 **의미적 오류**는 이후 단계에서 처리됩니다.
:::

### 내부 형태 질의문이란?

파서가 문법 검사를 통과시킨 SQL은 이제 **내부 형태 질의문(Internal Form of Query)**으로 변환됩니다. 내부 형태 질의문이란, 사람이 읽기 쉬운 SQL을 **컴퓨터가 처리하기 좋은 구조**로 바꾼 것입니다.

이 내부 형태는 주로 **질의 트리(Query Tree)** 방식으로 표현됩니다. 관계 대수(Relational Algebra)를 기반으로 하는 경우 질의 트리를, 관계 해석(Relational Calculus)을 기반으로 하는 경우 질의 그래프를 사용합니다. 대부분의 교과 과정에서는 **관계 대수 기반의 질의 트리**를 주로 다룹니다.

### SQL에서 질의 트리로 변환하는 과정

구체적인 예시를 통해 살펴보겠습니다. 아래와 같은 SQL 질의문이 있다고 가정합시다:

```sql
-- Reserves 테이블과 Sailors 테이블을 조인하여
-- 특정 조건을 만족하는 선원의 이름(sname)을 출력
SELECT S.sname
FROM Reserves R, Sailors S
WHERE R.sid = S.sid
  AND R.bid = 100
  AND S.rating > 5;
```

이 SQL을 한 줄씩 해석해 보겠습니다:

- `SELECT S.sname` → 최종적으로 **선원의 이름(sname)**을 출력하고 싶다
- `FROM Reserves R, Sailors S` → **Reserves 테이블**과 **Sailors 테이블** 두 개를 사용한다
- `WHERE R.sid = S.sid` → 두 테이블의 **sid(선원 ID)가 같은 행**끼리 연결(조인)한다
- `AND R.bid = 100` → **예약 번호(bid)가 100번**인 것만 선택한다
- `AND S.rating > 5` → **등급(rating)이 5보다 큰** 선원만 선택한다

**1단계: SQL → 관계 대수로 변환**

위 SQL을 관계 대수 표현으로 바꾸면 다음과 같은 의미가 됩니다:

> π(sname) [ σ(bid=100 AND rating>5) [ Reserves ⋈(sid=sid) Sailors ] ]

이것을 말로 풀면: "Reserves와 Sailors를 sid가 같은 조건으로 조인하고, 그 결과에서 bid=100이고 rating>5인 행을 선택하고, 최종적으로 sname만 추출(프로젝션)해라"

**2단계: 관계 대수 → 질의 트리로 변환**

위 관계 대수를 트리 구조로 그리면 다음과 같은 구조가 됩니다:

```
        π(sname)              ← 최종: 이름만 추출 (프로젝션)
            |
    σ(bid=100 AND rating>5)   ← 조건 필터링 (셀렉션)
            |
      ⋈ (sid = sid)           ← 두 테이블 조인
       /         \
  Reserves     Sailors        ← 원본 테이블 (리프 노드)
```

이 트리의 **맨 아래(리프 노드)**에는 원본 테이블이 있고, 위로 올라갈수록 연산이 적용되어 **맨 위(루트 노드)**에서 최종 결과가 나옵니다. 마치 나무를 거꾸로 세워놓은 형태인데, **아래에서 위로 데이터가 흘러가면서 가공**된다고 이해하면 됩니다.

:::tip 질의 트리를 왜 만들까?
질의 트리를 만드는 이유는 **최적화를 하기 위해서**입니다. 트리 구조에서는 노드(연산)의 위치를 바꾸거나, 부모와 자식의 순서를 변경하는 것이 용이합니다. 이렇게 트리의 구조를 변환하면서 **가장 효율적인 실행 순서**를 찾아낼 수 있습니다. 자료구조 과목에서 트리를 배우는 이유도 바로 이런 실제 시스템 내부에서 활용되기 때문입니다.
:::

---

## ⚡ 질의 최적화(Query Optimization) — 가장 효율적인 실행 계획 찾기

### 왜 최적화가 필요한가?

내부 형태 질의문(질의 트리)이 만들어졌다면, 이제 이것을 **어떤 순서와 방법으로 실행할 것인가**를 결정해야 합니다. 같은 SQL 명령어라도 **실행하는 방법은 여러 가지**가 있기 때문입니다.

생활 속 비유를 들어보겠습니다. 여러분이 **집에서 학교까지** 가는 길을 생각해 보세요:

- **경로 1:** 버스를 타고 간다
- **경로 2:** 지하철을 타고 간다
- **경로 3:** 자전거를 타고 간다
- **경로 4:** 버스 → 지하철 환승으로 간다

목적지는 같지만, **소요 시간, 비용, 편리함**이 모두 다릅니다. 데이터베이스도 마찬가지입니다. 하나의 SQL 명령어를 실행하는 데 **여러 가지 실행 계획(Execution Plan)**이 존재하며, 그중 **가장 비용이 적게 드는 최적의 계획**을 찾는 것이 바로 **질의 최적화**입니다.

### 선택도(Selectivity)를 이용한 최적화 이해

구체적인 예시로 이해해 봅시다. 학생 테이블에서 **"성별이 남자이고 지역이 서울인 학생의 학번"**을 검색한다고 합시다:

```sql
-- 성별이 남자이고 지역이 서울인 학생의 학번 검색
SELECT 학번
FROM 학생
WHERE 성별 = '남자' AND 지역 = '서울';
```

학생이 총 **100명**이고, 그중 **남학생은 10명**, **지역이 서울인 학생은 50명**이라고 가정해 봅시다.

이 질의를 실행하는 방법은 여러 가지입니다:

| 실행 계획 | 방법 | 과정 |
|:---:|:---|:---|
| **계획 A** | 성별 먼저 → 지역 나중 | 100명 → 남자 10명 추출 → 그중 서울 찾기 |
| **계획 B** | 지역 먼저 → 성별 나중 | 100명 → 서울 50명 추출 → 그중 남자 찾기 |
| **계획 C** | 동시에 검사 | 100명을 한 명씩 "남자이면서 서울인지" 검사 |

상식적으로 생각해도 **계획 A**가 가장 효율적입니다. 왜냐하면:

- 계획 A: 100명에서 **10명**만 먼저 추리고, 10명 중에서 서울을 찾으면 됨
- 계획 B: 100명에서 **50명**을 먼저 추리고, 50명 중에서 남자를 찾아야 함

**더 적은 수를 먼저 걸러내는 것이 훨씬 효율적**입니다! 이때 사용하는 개념이 바로 **선택도(Selectivity)**입니다.

> **선택도(Selectivity)란?** 전체 데이터 중에서 특정 조건을 만족하는 데이터의 비율입니다. 위 예시에서 남학생의 선택도는 10/100 = **10%**, 서울 학생의 선택도는 50/100 = **50%**입니다. **선택도가 작은 조건을 먼저 적용**하면 연산에 참여하는 데이터(튜플) 수가 줄어들어 성능이 향상됩니다.

:::note 이 통계 정보는 누가 알고 있나요?
선택도 같은 통계 정보는 사용자가 직접 계산하는 것이 아닙니다. **데이터 사전(Data Dictionary, 카탈로그)**에 각 테이블의 행 수, 속성별 값 분포 등의 통계 정보가 저장되어 있으며, **질의 최적화기(Query Optimizer)가 자동으로** 이 정보를 참조하여 최적의 실행 계획을 선정합니다.
:::

### 최적화의 세 가지 방법

질의 최적화를 수행하는 방법은 크게 세 가지가 있습니다:

#### 1. 경험적 최적화 (Heuristic Optimization)

**"과거의 경험으로 볼 때, 이렇게 하면 대체로 성능이 좋더라"**라는 규칙을 적용하는 방법입니다. 마치 여러분이 매일 출퇴근하면서 "이 시간대에는 이 길이 덜 막혀"라는 경험을 가지고 있는 것과 같습니다.

경험적 처리 전략의 핵심 규칙들은 다음과 같습니다:

- **선택(Selection) 연산을 가능한 먼저 수행하라:** WHERE절의 조건을 먼저 적용해서 연산에 참여하는 튜플(행) 수를 줄여라
- **카티션 프로덕트(Cartesian Product) + 선택 연산은 조인(Join) 연산으로 바꿔라:** 두 테이블을 먼저 곱해서 엄청난 양의 데이터를 만든 뒤 조건을 거르는 것보다, 조건을 적용하면서 합치는 조인이 훨씬 효율적이다
- **프로젝션(Projection) 연산도 가능한 먼저 수행하라:** 필요한 속성(컬럼)만 먼저 추출해서 데이터 양을 줄여라
- **공통 연산식은 한 번만 수행하라:** 중복 연산을 제거하여 불필요한 처리를 줄여라

#### 2. 비용 기반 최적화 (Cost-Based Optimization)

각 실행 계획의 **비용을 수식으로 계산**하여, 가장 비용이 적게 드는 계획을 선택하는 방법입니다. 비용식(Cost Formula)에 다음과 같은 요소들을 대입합니다:

| 비용 요소 | 설명 | 중요한 경우 |
|:---:|:---|:---|
| **디스크 I/O 비용** | 하드디스크에서 데이터를 읽고 쓰는 비용 | 대형 데이터베이스 시스템 |
| **CPU 처리 비용** | CPU에서 연산을 수행하는 비용 | 소형 데이터베이스 |
| **저장 비용** | 중간 결과를 임시 저장하는 비용 | 복잡한 질의 |
| **통신 비용** | 네트워크를 통해 데이터를 주고받는 비용 | 분산 데이터베이스 |

각 비용 요소를 수식에 대입해서 나온 **총 비용이 가장 작은 실행 계획**이 최종 선정됩니다.

#### 3. 의미적 질의 최적화 (Semantic Query Optimization)

질의의 **의미 자체가 논리적으로 불가능**한 경우, 굳이 최적화 과정을 거칠 필요 없이 바로 **"결과 없음"**을 반환하는 방법입니다.

```sql
-- ❌ 의미적으로 불가능한 질의
-- 대학교에는 1~4학년만 존재하는데 5학년 이상을 검색
SELECT 이름
FROM 학생
WHERE 학년 >= 5;
```

위 질의는 학년 속성의 도메인(값의 범위)이 1~4인데 5 이상을 찾으라고 했으므로, **무결성 제약(도메인 제약)에 의해 결과가 있을 수 없습니다.** 이런 경우 스캐너 → 파서 → 최적화기를 거칠 필요 없이 바로 결과를 반환하면 되므로, **최적화 시간 자체를 크게 단축**할 수 있습니다.

:::tip 실무에서는?
일반적으로 데이터베이스 시스템은 **경험적 최적화와 비용 기반 최적화를 함께 사용**합니다. 경험적 규칙으로 명백히 비효율적인 계획을 먼저 걸러내고, 남은 후보들에 대해 비용을 계산하여 최종 결정합니다.
:::

---

## 🔄 최적화의 4단계 상세 과정

최적화기 내부에서 일어나는 과정을 좀 더 구체적으로 들여다보면, 다음 **4단계**로 나눌 수 있습니다.

### 1단계: 질의문을 내부 표현으로 변환

파서가 생성한 중간 결과를 **시스템이 처리하기 적합한 내부 형태**로 변환합니다. 앞서 살펴본 것처럼 **SQL → 관계 대수 → 질의 트리**로 변환하는 과정입니다. 이 트리 구조가 있어야 이후 노드의 위치를 바꾸면서 최적화를 수행할 수 있습니다.

### 2단계: 효율적인 표준 형태로 변환

만들어진 질의 트리를 **정립된 변환 규칙(Transformation Rules)**을 사용하여 더 효율적인 형태로 바꿉니다. 이 변환 규칙은 뒤에서 자세히 다루겠습니다. 핵심은 **선택 연산과 프로젝션 연산을 가능한 트리의 아래쪽(먼저 실행되는 위치)으로 내리는 것**입니다.

### 3단계: 후보 실행 계획 선정

변환된 여러 형태의 질의 트리 중에서 **정말 평가할 가치가 있는 후보**만 선정합니다.

마치 선거에서 모든 국민이 후보가 아니라 **출마 요건을 갖춘 사람만 후보로 등록**하는 것처럼, 모든 실행 계획을 전부 평가하면 오히려 **최적화 자체에 시간이 너무 많이 소요**되므로, 경험적으로 가능성 있는 계획만 후보로 남깁니다.

후보 선정 시 고려하는 요소들:
- **인덱스(Index)**가 존재하는가?
- 값의 분포(Selectivity)가 어떠한가?
- 물리적으로 **클러스터링(Clustering, 관련 데이터를 물리적으로 가까이 저장)**되어 있는가?
- **해싱(Hashing)** 함수를 사용하고 있는가?
- 연산의 순서가 어떻게 되어 있는가?

### 4단계: 후보 계획 평가 및 최종 결정

선정된 후보들에 대해 **비용식(Cost Formula)**을 적용하여 실행 비용을 계산하고, **비용이 가장 작은 계획을 최종 선정**합니다. 이것이 곧 실제로 실행될 최적의 실행 계획이 됩니다.

```
[SQL 입력]
    ↓
[1단계] SQL → 관계 대수 → 질의 트리 (내부 표현 변환)
    ↓
[2단계] 변환 규칙 적용 → 효율적 트리 형태들 생성
    ↓
[3단계] 후보 실행 계획 선정 (전부 X, 유망한 것만)
    ↓
[4단계] 비용 계산 → 가장 비용 적은 계획 최종 선정
    ↓
[코드 생성 → 런타임 실행 → 결과 출력]
```

---

## 📏 내부 형태 변환 규칙 (Transformation Rules) 상세

최적화 2단계에서 사용되는 **변환 규칙**을 하나씩 자세히 살펴보겠습니다. 이 규칙들은 질의 트리를 더 효율적인 형태로 바꾸기 위한 **수학적으로 증명된 동치(equivalent) 변환**입니다. 즉, 변환 전과 후의 결과는 동일하지만, **실행 성능은 달라질 수 있습니다.**

### 규칙 1: AND 조건을 개별 선택 연산으로 분리

```
σ(조건1 AND 조건2 AND 조건3)(R)
  ↓ 변환
σ(조건1)( σ(조건2)( σ(조건3)(R) ) )
```

**왜 필요한가?** AND로 묶인 여러 조건을 한꺼번에 검사하면, 매번 모든 조건을 동시에 확인해야 합니다. 반면, 개별 선택 연산으로 분리하면 **가장 선택도가 작은 조건을 먼저 적용**할 수 있습니다.

예를 들어 "성별='남' AND 지역='서울' AND 점수>80"이라면:

```sql
-- ❌ 비효율적: 100명 모두에게 3가지 조건을 동시에 확인
SELECT * FROM 학생
WHERE 성별 = '남' AND 지역 = '서울' AND 점수 > 80;
-- (내부적으로 100명 × 3조건 = 매번 3번 비교)
```

```
-- ✅ 효율적: 선택도 작은 것부터 단계적으로 필터링
-- 1) 남학생 10명 추출 (선택도 10%)
-- 2) 그중 서울 학생 추출
-- 3) 그중 점수 80 초과 추출
σ(성별='남') → σ(지역='서울') → σ(점수>80)
```

**냉장고에서 재료를 꺼내는 것**에 비유하면, 냉장고에서 모든 재료를 한꺼번에 꺼내서 하나하나 확인하는 것보다, "일단 채소 칸에서만 꺼내고 → 그중 초록색 채소만 골라 → 그중 유통기한 남은 것만 선택"하는 것이 훨씬 빠른 것과 같습니다.

### 규칙 2: 선택 연산은 교환적이다

```
σ(조건1)( σ(조건2)(R) ) = σ(조건2)( σ(조건1)(R) )
```

**의미:** 어떤 조건을 먼저 적용하든, 최종 결과는 동일합니다. 따라서 **선택도가 작은 조건을 먼저** 적용할 수 있습니다. "남자 중에서 서울을 찾기" = "서울 중에서 남자를 찾기"이므로, 데이터가 더 적게 나오는 조건을 먼저 적용하면 됩니다.

### 규칙 3: 연속 프로젝션은 마지막 것만 수행

```
π(a)( π(a,b)( π(a,b,c)(R) ) ) = π(a)(R)
```

**의미:** a, b, c 속성을 가진 테이블에서 a, b, c를 먼저 추출하고 → a, b를 추출하고 → a를 추출하는 3단계 작업은, **처음부터 a만 추출하는 것과 결과가 동일**합니다. 중간 프로젝션은 불필요한 작업이므로 생략할 수 있습니다.

```sql
-- ❌ 비효율적: 3번 프로젝션을 수행
-- 1단계: 학번, 이름, 성별 추출
-- 2단계: 학번, 이름 추출
-- 3단계: 학번 추출

-- ✅ 효율적: 1번만 수행
SELECT 학번 FROM 학생;  -- 바로 학번만 추출
```

### 규칙 4: 선택 연산과 프로젝션 연산은 교환 가능

```
π(속성목록)( σ(조건)(R) ) = σ(조건)( π(속성목록)(R) )
```

**의미:** 먼저 조건으로 거른 다음 원하는 속성을 추출하든, 먼저 속성을 추출한 다음 조건으로 거르든, 결과는 동일합니다. (단, 조건에 사용되는 속성이 프로젝션에 포함되어 있어야 합니다.)

### 규칙 5: 카티션 프로덕트 후 선택 = 선택 먼저 후 조인

```
-- 변환 전: R과 S를 카티션 프로덕트 후 셀렉션
σ(조건)( R × S )

-- 변환 후: R을 먼저 셀렉션 후 S와 조인
σ(R조건)(R) ⋈ S
```

**왜 이게 중요한가?** 카티션 프로덕트(Cartesian Product)는 두 테이블의 모든 행을 조합하는 연산입니다. R에 10행, S에 10행이 있으면 카티션 프로덕트 결과는 **100행**이 됩니다. 이 100행에서 조건을 거르는 것보다, **먼저 R에서 조건에 맞는 행만 추출**한 뒤(예: 3행) 조인하면 3 × 10 = **30행**만 처리하면 됩니다.

```sql
-- ❌ 비효율적: 두 테이블을 먼저 곱한 후 조건 적용
-- 10 × 10 = 100행 생성 후 필터링
SELECT *
FROM Reserves, Sailors
WHERE Reserves.sid = Sailors.sid AND Reserves.bid = 100;

-- ✅ 효율적 (시스템 내부에서 이렇게 변환됨):
-- 먼저 Reserves에서 bid=100인 것만 추출 (예: 3행)
-- 3행과 Sailors 10행을 조인 → 최대 30행만 처리
```

:::danger 카티션 프로덕트를 먼저 수행하면 안 되는 이유
카티션 프로덕트는 데이터를 **폭발적으로 증가**시킵니다. 1만 행 × 1만 행 = **1억 행**이 됩니다. 이 엄청난 데이터에서 조건을 거르는 것은 극도로 비효율적입니다. 반드시 **선택 연산을 먼저** 수행하여 데이터 양을 줄인 후 조인해야 합니다.
:::

### 규칙 6: 조인 전에 양쪽 테이블 모두 선택 연산 먼저

```
-- 변환 전
σ(R조건 AND S조건)( R ⋈ S )

-- 변환 후
σ(R조건)(R) ⋈ σ(S조건)(S)
```

**의미:** R과 S를 조인한 후 조건을 적용하는 것보다, **R에서 R 관련 조건을 먼저 적용하고, S에서 S 관련 조건을 먼저 적용한 다음** 조인하는 것이 훨씬 효율적입니다. 양쪽 테이블 모두 데이터 양이 줄어든 상태에서 조인하기 때문입니다.

### 규칙 7: 조인, 카티션 프로덕트, 합집합, 교집합은 교환적

```
R ⋈ S = S ⋈ R
R × S = S × R
R ∪ S = S ∪ R
R ∩ S = S ∩ R
```

**의미:** 이 연산들은 **어떤 테이블을 먼저 놓든 결과가 동일**합니다. 따라서 최적화기가 자유롭게 순서를 바꿀 수 있습니다.

:::warning 교환 법칙이 성립하지 않는 연산
**세미 조인(Semi-Join)**, **차집합(Difference, -)**, **나누기(Division, ÷)** 이 세 가지 연산은 교환 법칙이 성립하지 **않습니다.** R - S ≠ S - R 이므로 주의해야 합니다.
:::

### 규칙 8: 조인/카티션 프로덕트 후 프로젝션 = 프로젝션 먼저 후 조인

```
-- 변환 전
π(속성목록)( R ⋈ S )

-- 변환 후
π(R속성)(R) ⋈ π(S속성)(S)
```

**의미:** 전체 속성을 가진 채로 조인한 뒤 필요한 속성만 추출하는 것보다, **각 테이블에서 필요한 속성만 먼저 추출한 뒤 조인**하는 것이 데이터 양이 줄어들어 효율적입니다.

### 규칙 9: 합집합/교집합/차집합 후 선택·프로젝션 = 먼저 선택·프로젝션

```
-- 선택 연산의 경우
σ(조건)( R ∪ S ) = σ(조건)(R) ∪ σ(조건)(S)

-- 프로젝션의 경우
π(속성)( R ∪ S ) = π(속성)(R) ∪ π(속성)(S)
```

**의미:** 합집합을 먼저 하고 선택/프로젝션하는 것보다, **각 테이블에서 먼저 선택/프로젝션한 뒤** 합집합하는 것이 효율적입니다. 각 테이블의 데이터가 먼저 줄어든 상태에서 합치기 때문입니다.

### 규칙 11: 카티션 프로덕트의 결합 법칙

```
(R × S) × T = R × (S × T)
```

**의미:** 세 개 이상의 테이블을 조인할 때, **어떤 두 테이블을 먼저 합치든 최종 결과는 동일**합니다. 따라서 최적화기가 가장 효율적인 조합 순서를 자유롭게 선택할 수 있습니다.

### 규칙 12: 논리곱 정형식 변환

OR로 연결된 조건식을 AND로 연결된 **논리곱 정형식(Conjunctive Normal Form)**으로 변환하는 규칙입니다. 이는 중고등학교 수학 시간에 배운 **드모르간의 법칙**과 **분배 법칙**을 적용한 것입니다.

```
-- 교집합 후 합집합
(R ∩ S) ∪ T = (R ∪ T) ∩ (S ∪ T)
```

이렇게 변환하면 선택 연산을 분리하여 먼저 적용하기가 더 용이해집니다.

---

## 🎯 변환 규칙의 핵심 요약

지금까지 살펴본 변환 규칙들을 관통하는 **핵심 원칙**을 정리하면 다음과 같습니다:

| 핵심 원칙 | 해당 규칙 | 설명 |
|:---|:---|:---|
| **AND 조건은 개별 선택으로 분리** | 규칙 1 | 단계적 필터링이 가능하도록 |
| **선택 연산을 가장 먼저 수행** | 규칙 2, 4, 5, 6, 9 | 연산에 참여하는 튜플 수를 줄임 |
| **프로젝션 연산을 먼저 수행** | 규칙 3, 8, 9 | 연산에 참여하는 속성 수를 줄임 |
| **가장 제한적인 선택을 가장 먼저** | 규칙 2 | 선택도가 작은 조건 우선 적용 |
| **카티션 프로덕트 + 선택 → 조인으로 변환** | 규칙 5, 6 | 불필요한 데이터 폭증 방지 |
| **연산 순서는 교환 가능** | 규칙 7, 11 | 최적의 순서를 자유롭게 선택 |
| **중복 연산 제거** | 규칙 3 | 불필요한 반복 작업 방지 |

> **모든 규칙의 궁극적 목표:** 연산에 참여하는 **데이터의 양(튜플 수와 속성 수)**을 최대한 줄여서, 시스템의 **처리 비용을 최소화**하는 것입니다.

---

## ⚠️ 주의사항 및 실전 팁

### 자주 하는 실수

:::danger 절대 하지 말 것
1. **카티션 프로덕트를 조건 없이 사용하지 마세요.** `SELECT * FROM A, B`처럼 WHERE절 없이 두 테이블을 나열하면 카티션 프로덕트가 수행되어 데이터가 폭발적으로 증가합니다.
2. **SELECT *를 무분별하게 사용하지 마세요.** 모든 속성을 가져오면 프로젝션 최적화가 불가능해져서 불필요한 데이터까지 처리해야 합니다.
:::

### 실전 팁

:::tip 성능 향상을 위한 SQL 작성 팁
1. **필요한 컬럼만 명시하세요:** `SELECT *` 대신 `SELECT 학번, 이름`처럼 필요한 속성만 지정하면, 내부적으로 프로젝션 최적화가 효과적으로 이루어집니다.
2. **WHERE 조건은 선택도가 높은(결과가 적은) 것부터:** 최적화기가 자동으로 순서를 바꾸기도 하지만, 가독성을 위해서도 좁은 범위의 조건을 먼저 쓰는 습관을 들이세요.
3. **조인 조건을 명확히 명시하세요:** `WHERE A.id = B.id`처럼 조인 조건을 명확히 작성하면, 최적화기가 카티션 프로덕트 대신 효율적인 조인 방법을 선택할 수 있습니다.
:::

### 최적화는 데이터베이스의 "고급 과정"

질의 최적화는 데이터베이스의 **고급 주제**에 해당합니다. SQL 문법, 테이블 생성, 권한 부여 등이 **기본 과정**이라면, 최적화·병행 제어(Concurrency Control)·회복(Recovery) 등은 **고급 과정**입니다. 이 영역을 이해하면 단순히 SQL을 사용하는 수준을 넘어, **데이터베이스 관리자(DBA)**로서 시스템의 성능을 효율적으로 관리할 수 있는 역량을 갖추게 됩니다.

---

## 📌 핵심 정리

- **SQL은 고급 질의어**이며, 실행되기 위해 검사기 → 파서 → 최적화기 → 코드 생성기 → 런타임 처리기의 단계를 거친다
- **검사기(Scanner)**는 SQL 문장을 토큰(최소 의미 단위)으로 분리하여 식별하는 역할을 한다
- **파서(Parser)**는 토큰의 조합이 SQL 문법에 맞는지 구문 분석(Syntax Analysis)을 수행한다
- 파서를 통과한 SQL은 **내부 형태 질의문(질의 트리)**으로 변환되며, 이것이 최적화의 기반이 된다
- **질의 최적화**란 하나의 SQL에 대해 여러 실행 계획을 생성하고, 가장 비용이 적은 계획을 선정하는 과정이다
- **선택도(Selectivity)**가 작은 조건을 먼저 적용하면 연산에 참여하는 데이터 양이 줄어들어 성능이 향상된다
- 최적화 방법에는 **경험적 최적화**, **비용 기반 최적화**, **의미적 질의 최적화** 세 가지가 있으며, 보통 경험적 + 비용 기반을 함께 사용한다
- 최적화 4단계: 내부 표현 변환 → 효율적 형태 변환 → 후보 선정 → 평가 및 최종 결정
- 변환 규칙의 핵심은 **선택 연산과 프로젝션 연산을 먼저 수행**하여 연산 참여 튜플 수를 줄이는 것이다
- **카티션 프로덕트 + 선택 연산은 반드시 조인 연산으로 변환**해야 데이터 폭증을 방지할 수 있다
- 통계 정보(선택도 등)는 **데이터 사전(카탈로그)**에 저장되어 있으며, 최적화기가 자동으로 참조한다

---

작성일: 2026-02-21