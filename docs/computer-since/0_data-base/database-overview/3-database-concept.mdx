---
title: "데이터베이스의 등장 배경과 개념"
description: "데이터베이스의 등장 배경과 개념에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/database-overview/3-database-concept"
sidebar_label: "데이터베이스 등장"
date: "2026-02-20"
---

## 🎯 데이터베이스란 무엇인가?

데이터베이스(Database)라는 단어를 들으면 무언가 복잡하고 어려운 기술처럼 느껴질 수 있습니다. 하지만 본질은 아주 단순합니다. **데이터베이스란 여러 사람이 함께 사용할 수 있도록, 흩어져 있는 데이터를 한곳에 모아 정리해 놓은 데이터의 집합**입니다.

비유하자면, 도서관을 떠올려 보세요. 도서관에는 수만 권의 책이 있지만, 분류 체계에 따라 정리되어 있기 때문에 누구나 원하는 책을 빠르게 찾을 수 있습니다. 만약 책이 분류 없이 바닥에 아무렇게나 쌓여 있다면 어떨까요? 원하는 책을 찾는 데 하루 종일 걸릴 수도 있겠죠. 데이터베이스는 바로 이 **"잘 정리된 도서관"** 같은 역할을 컴퓨터 세계에서 수행합니다.

좀 더 정확하게 정의하면, 데이터베이스는 다음 네 가지 성격을 동시에 갖는 데이터의 집합입니다.

| 특성 | 의미 | 쉬운 비유 |
|---|---|---|
| **통합된 데이터** | 중복을 최소화하여 한곳에 모은 데이터 | 여러 창고에 흩어진 물건을 하나의 대형 창고로 합침 |
| **저장된 데이터** | 하드디스크 등 디지털 저장장치에 보관된 데이터 | 종이 문서가 아니라 컴퓨터 파일로 저장 |
| **운영 데이터** | 조직의 고유 업무를 수행하기 위해 반드시 필요한 데이터 | 학교라면 학생 성적, 병원이라면 환자 기록 |
| **공용 데이터** | 여러 사용자가 동시에 함께 사용하는 데이터 | 회사 전체가 공유하는 공용 폴더 |

> 💡 **핵심 한 줄 요약:** 데이터베이스 = 조직에서 업무와 의사결정에 활용하기 위해, 중복을 최소화하여 통합하고, 디지털 저장장치에 보관하며, 여러 사람이 공동으로 사용하는 운영 데이터의 집합

IT를 전공하든, 비전공자이든 현대 사회에서 데이터베이스의 기본 개념은 **필수 교양**이라 해도 과언이 아닙니다. 여러분이 매일 사용하는 네이버, 구글, 은행 앱, 학사 관리 시스템 뒤에는 모두 데이터베이스가 작동하고 있기 때문입니다.

---

## 📂 파일 시스템의 한계 — 데이터베이스가 필요해진 이유

### 파일 시스템이란?

데이터베이스가 등장하기 전, 컴퓨터에서 데이터를 관리하는 방법은 **파일 시스템(File System)** 이 유일했습니다. 파일 시스템은 지금도 우리가 매일 사용하고 있습니다. 윈도우 탐색기를 열어보면 폴더 안에 다양한 파일이 들어 있죠? 이것이 바로 파일 시스템입니다.

파일 시스템은 **운영체제(OS)가 기본으로 제공하는 기능**으로, 오라클(Oracle)이나 MySQL 같은 별도의 소프트웨어 없이 운영체제의 커널(운영체제의 핵심 프로그램)이 직접 파일을 관리합니다. 혼자 사용할 때는 아무런 문제가 없습니다. 내 컴퓨터에서 내 파일을 열고, 수정하고, 저장하면 그만이니까요.

### 🚨 문제 발생: 여러 사람이 동시에 사용할 때

문제는 **여러 사람이 같은 데이터를 동시에 사용해야 할 때** 발생합니다. 마치 회사에서 하나의 엑셀 파일을 10명이 동시에 수정해야 하는 상황을 상상해 보세요.

파일 시스템에는 크게 **두 가지 치명적인 문제**가 있습니다.

#### 1️⃣ 중복성(Redundancy)의 문제

A, B, C 세 사람이 똑같은 파일 `F1`을 각자 복사해서 사용한다고 가정해 봅시다.

- A가 `F1`의 내용을 수정하여 `F2`로 바꿨습니다.
- 그런데 B와 C는 여전히 원래의 `F1`을 가지고 있습니다.
- 이제 A의 파일에는 `F2`, B와 C의 파일에는 `F1`이 들어 있습니다.

이렇게 되면 **데이터 불일치(Inconsistency)** 가 발생합니다. 누구의 데이터가 맞는 건지 알 수 없게 되는 거죠. 마치 세 사람이 각자 다른 버전의 회의록을 가지고 있는 것과 같습니다. 이 상태에서 의사결정을 한다면? 당연히 엉뚱한 결과가 나오겠죠.

중복성으로 인해 발생하는 구체적인 문제들을 정리하면 다음과 같습니다.

| 문제 | 설명 |
|---|---|
| **일관성 결여** | 같은 데이터인데 서로 다른 값을 가지게 됨 (데이터 불일치) |
| **보안 취약** | 데이터가 여러 곳에 흩어져 있으면 동일한 보안 수준을 유지하기 어려움 |
| **경제성 저하** | 한 번만 수정하면 될 것을 여러 곳에서 각각 수정해야 함 (갱신 비용 증가) |
| **저장 공간 낭비** | 같은 데이터가 여러 곳에 저장되니 저장 비용이 증가 |
| **무결성(정확성) 훼손** | 위의 문제들이 종합되어 결국 데이터의 정확성을 보장할 수 없게 됨 |

:::warning 중복성의 핵심 위험
파일 시스템의 중복성이 가져오는 가장 치명적인 결과는 **데이터 무결성(정확성)을 지키기 어렵다**는 것입니다. 데이터가 정확하지 않으면 아무리 많은 데이터를 가지고 있어도 쓸모가 없습니다.
:::

:::info 중복이 항상 나쁜 것만은 아닙니다
중복에도 장점이 있습니다. 데이터가 여러 곳에 복사되어 있으면, 한 곳이 고장 나더라도 다른 곳에서 데이터를 사용할 수 있어 **가용성(Availability)** 이 높아집니다. 또한 사이트 간 데이터 이동을 줄일 수 있고, 장애 발생 시 복구가 수월해지는 장점도 있습니다. 하지만 이런 장점보다 **무결성 훼손이라는 단점이 훨씬 크기 때문에**, 여러 사람이 동시에 사용하는 환경에서는 파일 시스템을 그대로 쓰기 어렵습니다.
:::

#### 2️⃣ 종속성(Dependency)의 문제

종속성이란 **데이터의 저장 구조가 바뀌면 그 데이터를 사용하는 프로그램까지 함께 바꿔야 하는 문제**를 말합니다.

예를 들어, 파일의 저장 형식을 CSV에서 JSON으로 바꿨다고 합시다. 파일 시스템에서는 이 파일을 읽는 모든 프로그램의 코드를 수정해야 합니다. 데이터 구조와 프로그램이 **끈끈하게 묶여(종속되어)** 있기 때문입니다.

마치 집 주소가 바뀌면 택배 회사, 은행, 카드사, 학교 등 모든 곳에 일일이 변경 신청을 해야 하는 것과 비슷합니다. 하나만 빠뜨려도 택배가 엉뚱한 곳으로 가는 것처럼, 프로그램 하나만 수정을 빠뜨리면 시스템 전체에 오류가 발생할 수 있습니다.

> 🔑 **파일 시스템의 두 가지 근본 문제:** 중복성(같은 데이터가 여러 곳에 흩어짐) + 종속성(데이터 구조가 바뀌면 프로그램도 바꿔야 함) → 이 문제를 해결하기 위해 **데이터베이스**가 탄생했습니다!

---

## 🕰️ 데이터베이스의 발전 역사 — 파일 시스템에서 빅데이터까지

데이터베이스는 하루아침에 지금의 모습이 된 것이 아닙니다. 시대의 필요에 따라 단계적으로 발전해 왔습니다. 마치 교통수단이 마차 → 자동차 → 비행기로 발전한 것처럼, 데이터베이스도 여러 세대를 거쳐 진화해 왔습니다.

### 1단계: 파일 시스템 (1960년대 이전)

앞서 설명한 것처럼, 운영체제가 기본으로 제공하는 파일 관리 방식입니다. 별도의 데이터베이스 소프트웨어 없이 운영체제의 커널이 파일을 관리합니다. 혼자 쓸 때는 문제없지만, 여러 사람이 동시에 사용하면 중복성과 종속성 문제가 발생합니다.

### 2단계: 계층형 DBMS (1960년대)

파일 시스템의 문제를 해결하기 위해 가장 먼저 등장한 데이터베이스 관리 시스템(DBMS)입니다.

**계층형(Hierarchical) DBMS**는 이름 그대로 데이터를 **계층(트리) 구조**로 관리합니다. 회사의 조직도를 떠올리면 이해가 쉽습니다. 맨 위에 사장이 있고, 그 아래에 부서장, 그 아래에 팀장, 팀원이 있는 것처럼 **부모-자식(Parent-Child) 관계**로 데이터를 표현합니다.

```
        [회사]          ← 부모(최상위)
       /      \
   [영업부]   [개발부]    ← 자식이자, 아래의 부모
   /    \       |
[팀A] [팀B]  [팀C]      ← 자식(최하위)
```

계층형 DBMS의 핵심 특징은 다음과 같습니다.

- **트리 구조**: 위에서 아래로만 정보가 흐릅니다. 아래에서 위로 거슬러 올라가는 것은 불가능합니다.
- **사이클 없음**: 자식이 부모가 될 수 없습니다. 순환(사이클)이 발생하지 않습니다.
- **단방향 흐름**: 마치 폭포수처럼, 정보의 흐름은 항상 상위에서 하위로만 진행됩니다.

:::note 계층형 DBMS의 한계
부모-자식이라는 엄격한 상하관계 때문에, 현실 세계의 복잡한 관계를 표현하기 어렵다는 한계가 있었습니다. 예를 들어, 한 학생이 여러 동아리에 속하고, 각 동아리에도 여러 학생이 속하는 "다대다" 관계를 표현하기가 매우 까다로웠습니다.
:::

### 3단계: 네트워크형 DBMS (1970년대)

계층형 DBMS의 한계를 극복하기 위해 등장한 것이 **네트워크형(Network) DBMS**입니다.

네트워크형 DBMS는 **그래프(Graph) 구조**로 되어 있습니다. 계층형과 달리 **사이클(순환)을 허용**합니다. 부모-자식이라는 용어 대신 **오너(Owner)-멤버(Member)** 라는 용어를 사용합니다.

```
    [A] ←→ [B]
     ↕    ↗  ↕
    [C] ←→ [D]
```

- 하나의 오너(Owner)가 여러 멤버(Member)를 가질 수 있습니다.
- 하나의 멤버가 여러 오너에 속할 수도 있습니다.
- 멤버가 다른 관계에서는 오너가 될 수도 있습니다.

이렇게 하면 계층형에서는 표현할 수 없었던 복잡한 관계도 표현할 수 있게 되었습니다. 하지만 구조 자체가 복잡해서 설계와 관리가 어렵다는 단점이 있었습니다.

### 4단계: 관계형 DBMS (1980년대) ⭐

드디어 우리가 **현재 가장 많이 사용하는** 데이터베이스 유형이 등장합니다. 바로 **관계형(Relational) DBMS**입니다.

관계형 DBMS는 데이터를 **테이블(표) 형태**로 관리합니다. 여러분이 학교에서 본 성적표, 학사 관리 시스템, 은행의 계좌 정보 — 이 모든 것이 테이블 형태로 저장되어 있습니다.

```
[학생 테이블]
| 학번    | 이름   | 학과       |
|---------|--------|------------|
| 2024001 | 김철수 | 컴퓨터공학 |
| 2024002 | 이영희 | 경영학     |
| 2024003 | 박민수 | 전자공학   |
```

관계형 DBMS가 대중화된 이유는 명확합니다.

- **직관적**: 표 형태라서 누구나 이해하기 쉽습니다.
- **표준화**: SQL이라는 표준 언어가 있어서 어떤 관계형 DBMS를 쓰든 거의 동일한 방식으로 사용할 수 있습니다.
- **개발 용이**: 쉽고 체계적이어서 개발과 유지보수가 편리합니다.

대표적인 관계형 DBMS로는 **Oracle, MySQL, MS SQL Server, PostgreSQL** 등이 있습니다. IT 실무에서 99.9%는 관계형 데이터베이스를 사용한다고 해도 과언이 아닙니다.

:::tip 실무에서의 관계형 DBMS
여러분이 앞으로 IT 업계에서 개발자, 시스템 설계자, 운영자 등 어떤 직무를 수행하든 **관계형 데이터베이스**를 다루게 될 확률이 압도적으로 높습니다. 따라서 관계형 DBMS의 개념과 SQL을 잘 익혀두는 것이 매우 중요합니다.
:::

### 5단계: 객체지향 DBMS (1990년대)

관계형 DBMS가 아주 훌륭하지만, 모든 데이터를 표 형태로 담기에는 한계가 있었습니다. 예를 들어, **동영상, 이미지, 음악, 지리정보(GIS), CAD 데이터** 같은 멀티미디어 정보를 테이블의 행과 열에 넣기는 어렵죠.

이런 필요성에서 등장한 것이 **객체지향(Object-Oriented) DBMS**입니다.

객체지향 DBMS는 Java, C++ 같은 **객체지향 프로그래밍(OOP, Object-Oriented Programming)** 의 개념에 데이터베이스의 기본 기능을 접목한 것입니다. 동영상 하나를 "동영상 객체", 이미지 하나를 "이미지 객체"로 관리하여 복잡한 멀티미디어 데이터를 효율적으로 다룰 수 있게 했습니다.

하지만 객체지향 DBMS는 대중화에 실패했습니다. 그 이유는:

- **호환성 부족**: 기존 관계형 DBMS와 호환이 잘 되지 않았습니다.
- **높은 진입 장벽**: 클래스, 객체, 다형성, 상속 등 객체지향 개념을 이해해야 해서 배우기 어려웠습니다.
- **개발 난이도 높음**: 복잡한 개념 때문에 개발 자체가 까다로웠습니다.

결국 특정 분야에서만 제한적으로 사용되고, 대중적으로 널리 퍼지지는 못했습니다.

### 6단계: 객체관계 DBMS (1990년대 후반)

**관계형 DBMS의 대중성** + **객체지향 DBMS의 멀티미디어 처리 능력**, 이 두 가지 장점을 합친 것이 바로 **객체관계(Object-Relational) DBMS**입니다.

쉽게 사용할 수 있는 관계형의 테이블 구조를 기반으로 하면서도, 필요할 때 객체지향의 기능을 추가로 활용할 수 있게 한 것입니다. 객체지향 DBMS의 단점(어려움, 호환성 부족)을 보완한 형태로, 이 시기를 기점으로 데이터베이스가 본격적으로 발전해 나갑니다.

### 7단계: 현대의 데이터베이스 (2000년대 이후)

2000년대에 들어서며 인터넷이 폭발적으로 성장하고, 데이터의 양이 기하급수적으로 늘어나면서 데이터베이스는 새로운 역할을 맡게 됩니다.

- **빅데이터(Big Data)**: 방대한 양의 데이터를 수집·저장·분석하는 분야
- **데이터 마이닝(Data Mining)**: 대량의 데이터에서 숨겨진 패턴과 가치 있는 정보를 발견하는 기술
- **24×7 운영**: 24시간, 주 7일 멈추지 않고 돌아가는 고가용성 시스템
- **클라우드, AI와의 융합**: 최신 기술과 결합하여 더욱 강력해진 데이터 관리

> 📊 **데이터베이스 발전 흐름 요약:** 파일 시스템 → 계층형 DBMS → 네트워크형 DBMS → **관계형 DBMS** → 객체지향 DBMS → 객체관계 DBMS → 빅데이터/데이터 마이닝 시대

---

## 🔍 데이터베이스의 정의와 특성

### 데이터베이스의 4가지 정의

앞서 간단히 언급했던 내용을 좀 더 자세히 살펴보겠습니다. 누군가 "데이터베이스가 뭐예요?"라고 물었을 때, 정확하게 대답할 수 있어야 합니다.

#### 1. 통합된 데이터 (Integrated Data)

여러 곳에 흩어져 있던 데이터를 한 군데로 모으면서, **중복을 최소화**한 데이터입니다.

여기서 중요한 점은 "중복을 **완전히 제거**한다"가 아니라 "**최소한의 중복, 통제된 중복**"을 허용한다는 것입니다. 왜냐하면 중복을 100% 제거하면 오히려 성능이 떨어질 수 있기 때문입니다. 이 부분은 나중에 정규화(Normalization)와 역정규화(Denormalization)라는 개념에서 더 깊이 다루게 됩니다.

:::info 최소한의 중복이란?
데이터베이스에서는 중복을 무조건 제거하는 것이 아니라, **성능을 위해 의도적으로 허용하는 중복**도 있습니다. 다만 이런 중복은 철저하게 관리(통제)됩니다. 이것을 "통제된 중복"이라고 합니다.
:::

#### 2. 저장된 데이터 (Stored Data)

데이터베이스의 데이터는 종이 문서나 캐비닛 속 파일철이 아니라, **하드디스크(HDD/SSD) 등 디지털 저장 장치에 저장**되어 있습니다. 디지털 형태로 저장되어 있기 때문에 빠르게 검색하고, 수정하고, 삭제할 수 있습니다.

#### 3. 운영 데이터 (Operational Data)

그냥 아무 데이터나 모아놓은 것이 아닙니다. 해당 **조직이 고유한 기능을 수행하기 위해 반드시 유지해야 하는 데이터**입니다.

- 학교라면: 학생 정보, 성적, 수강 신청 데이터
- 병원이라면: 환자 정보, 진료 기록, 처방 데이터
- 쇼핑몰이라면: 상품 정보, 주문 내역, 고객 데이터

각 조직의 **핵심 업무를 운영하기 위한 데이터**가 바로 운영 데이터입니다.

#### 4. 공용 데이터 (Shared Data)

데이터베이스의 데이터는 **나 혼자만 사용하는 것이 아니라, 조직 내 여러 사용자가 함께 공유**합니다. 여러 부서, 여러 팀, 여러 직원이 동시에 같은 데이터에 접근하여 사용할 수 있습니다.

### 데이터베이스의 4가지 특성

데이터베이스가 어떤 특징을 가지고 있는지 살펴보겠습니다.

| 특성 | 설명 | 실생활 예시 |
|---|---|---|
| **실시간 접근성** | 언제든지 원하는 데이터에 즉시 접근 가능 | 네이버에 언제든지 접속하여 검색할 수 있음 |
| **계속적인 변화** | 데이터가 실시간으로 갱신되어 항상 최신 상태 유지 | 날씨 정보, 뉴스, 교통 정보가 계속 업데이트됨 |
| **동시 공유** | 여러 사용자가 동시에 같은 데이터를 사용 가능 | 수만 명이 동시에 구글에 접속해도 문제없음 |
| **내용에 의한 참조** | 데이터의 위치/주소가 아닌 **값(내용)** 으로 검색 | "점수 90점 이상" 같은 조건으로 데이터를 찾음 |

**동시 공유**가 가능한 이유는 **병행제어(Concurrency Control)** 라는 기법 덕분입니다. 수많은 사용자가 동시에 데이터베이스에 접근해도 충돌이 일어나지 않도록 제어하는 기술입니다. 마치 교차로에서 신호등이 차량의 흐름을 제어하듯, 데이터베이스도 여러 사용자의 요청을 충돌 없이 처리해 줍니다.

---

## 🧠 데이터베이스의 3대 핵심 특징 — 추상화, 독립성, 자기 정의

데이터베이스가 다른 데이터 관리 방식과 차별화되는 3가지 핵심 특징이 있습니다.

### 1. 자료 추상화 (Data Abstraction)

**왜 필요한가?** 만약 데이터베이스 내부의 모든 것을 사용자가 알아야 한다면 어떨까요? 하드디스크의 트랙과 섹터 구조, 기계어(0과 1로 된 코드), 16진수 데이터 배치 방식... 이런 것들을 전부 이해해야만 데이터베이스를 사용할 수 있다면, 일반 사용자는 절대 데이터베이스를 쓸 수 없을 것입니다.

**자료 추상화(= 개념화, 일반화)** 란 이렇게 **복잡한 내부 구조를 감추고, 사용자가 쉽게 사용할 수 있는 인터페이스를 제공하는 것**입니다.

비유하자면, 자동차를 운전할 때 엔진 내부의 피스톤 움직임, 연료 분사 타이밍, 변속기의 기어 맞물림 등을 알 필요 없이 핸들과 페달만으로 운전할 수 있는 것과 같습니다. 복잡한 것은 보닛(데이터베이스 내부) 안에 감춰져 있고, 사용자는 간단한 인터페이스만 사용하면 됩니다.

### 2. 자료 독립성 (Data Independence)

**왜 필요한가?** 파일 시스템에서는 데이터 구조가 바뀌면 관련 프로그램을 전부 수정해야 했습니다(종속성 문제). 데이터베이스는 이 문제를 해결합니다.

**자료 독립성**이란 **데이터의 구조가 바뀌어도 프로그램을 변경하지 않고 그대로 사용할 수 있는 것**입니다. 데이터와 프로그램이 서로 **독립적**으로 존재하기 때문에, 한쪽을 수정해도 다른 쪽에 영향을 주지 않습니다.

이것은 유지보수 측면에서 엄청난 장점입니다. 데이터 구조를 변경할 때마다 수십, 수백 개의 프로그램을 일일이 수정할 필요가 없으니까요.

> 🏠 **비유:** 파일 시스템은 집 주소가 바뀌면 모든 곳에 일일이 알려야 하는 것(종속)이고, 데이터베이스는 우체국에 전입 신고만 하면 알아서 처리되는 것(독립)과 비슷합니다.

### 3. 자기 정의 (Self-Description)

**왜 필요한가?** 데이터베이스는 자기 자신에 대한 정보도 스스로 관리해야 합니다. 누가 이 데이터베이스를 만들었는지, 언제 만들었는지, 어떤 테이블이 있는지, 각 테이블의 속성은 무엇인지 등의 정보가 필요합니다.

**자기 정의**란 데이터베이스가 자기 자신의 구조와 정보를 **메타데이터(데이터에 대한 데이터)** 형태로 별도의 공간에 스스로 저장하고 관리하는 것입니다. 이 메타데이터가 저장되는 곳을 **데이터 사전(Data Dictionary)** 또는 **카탈로그(Catalog)** 라고 합니다.

마치 도서관에 "이 도서관에는 어떤 책이 있고, 어느 서가에 배치되어 있는지"를 기록한 목록집이 있는 것과 같습니다. 데이터베이스의 "목록집"이 바로 데이터 사전인 셈입니다.

---

## 🧩 데이터베이스의 구성요소 — 개체, 속성, 관계

데이터베이스를 구성하는 핵심 요소 세 가지를 알아봅시다.

### 개체 (Entity)

**개체**란 데이터베이스가 표현하려고 하는 **유형·무형의 정보 대상**입니다. 현실 세계에서 구별할 수 있는 사물이나 개념을 말합니다.

- 학생, 교수, 과목, 주문, 상품 — 이런 것들이 모두 개체입니다.
- 각 개체는 **서로 구별**할 수 있어야 합니다 (김철수와 이영희는 서로 다른 학생 개체).
- 개체는 **단독으로 존재**할 수 있습니다.
- 파일 시스템에서는 **레코드(Record)** 에 해당합니다.

### 속성 (Attribute)

**속성**이란 개체가 가진 **특성이나 상태를 기술하는 항목**입니다.

예를 들어, "학생"이라는 개체는 다음과 같은 속성을 가질 수 있습니다.

```
[학생] → 학번, 이름, 주소, 전화번호, 학과, ...
```

속성의 특징을 정리하면:

- 개체의 특성이나 상태를 기술합니다.
- **가장 작은 논리적 단위**입니다 (더 이상 쪼갤 수 없는 최소 단위).
- 개체 없이 속성만 단독으로 존재할 수 **없습니다** (학번은 학생이라는 개체가 있어야 의미가 있음).
- 파일 시스템에서는 **필드(Field)** 또는 **항목(Item)** 에 해당합니다.

### 도메인 (Domain)

**도메인**이란 하나의 속성이 가질 수 있는 **값의 범위**입니다.

예를 들어:
- "점수" 속성의 도메인: **0~100** (0점부터 100점까지만 입력 가능)
- "학년" 속성의 도메인: **1, 2, 3, 4** (1학년부터 4학년까지만 허용)
- "성별" 속성의 도메인: **'남', '여'**

도메인을 설정해 놓으면, 잘못된 값이 입력되는 것을 사전에 막을 수 있어 데이터의 정확성을 높일 수 있습니다.

### 관계 (Relationship)

**관계**란 개체와 개체 사이, 또는 속성과 속성 사이의 **연결 또는 연관성**을 의미합니다.

#### 개체 간의 관계

```
[학생] ──── 지도 ──── [교수]
```

"한 명의 교수가 여러 명의 학생을 지도한다"는 관계를 표현한 것입니다. 이런 관계에는 세 가지 유형이 있습니다.

| 관계 유형 | 설명 | 예시 |
|---|---|---|
| **1:1 (일대일)** | 하나의 개체가 다른 하나의 개체와만 연결 | 한 명의 학생 – 하나의 학생증 |
| **1:N (일대다)** | 하나의 개체가 여러 개의 개체와 연결 | 한 명의 교수 – 여러 명의 학생 |
| **N:M (다대다)** | 여러 개의 개체가 여러 개의 개체와 연결 | 여러 학생 – 여러 과목 (한 학생이 여러 과목 수강, 한 과목에 여러 학생 등록) |

#### 속성 간의 관계

속성과 속성 사이에도 관계가 있습니다. 가장 대표적인 것이 **기본키(Primary Key)** 와 나머지 속성들의 관계입니다.

```
[학생]
학번(기본키) → 이름, 주소, 학과, ...
```

**학번**은 학생을 유일하게 식별할 수 있는 키입니다. 주민번호가 전 국민을 유일하게 구별하는 것처럼, 학번은 학생 한 명을 정확히 가리킵니다. 학번이 정해지면 이름, 주소, 학과 등 나머지 속성이 자동으로 결정됩니다. 이처럼 속성 간에도 **주종 관계(결정 관계)** 가 존재합니다.

### 📋 용어 정리 — 개체 타입과 개체 집합

데이터베이스 용어가 헷갈릴 수 있으니 깔끔하게 정리해 봅시다.

| 개념 | 의미 | 다른 이름들 | 비유 |
|---|---|---|---|
| **개체 타입 (Entity Type)** | 개체의 **구조** (틀, 설계도) | 스키마(Schema), 인텐션(Intension), 래퍼 | 빈 성적표 양식(학번, 이름, 점수 칸만 있는) |
| **개체 집합 (Entity Set)** | 실제 **값이 들어간 데이터** | 인스턴스(Instance), 튜플 집합, 어커런스(Occurrence), 외연(Extension) | 실제 데이터가 채워진 성적표 |

```
개체 타입(구조):  | 학번 | 이름 | 학과 |
                  ← 이것은 틀(구조)

개체 집합(값):    | 2024001 | 김철수 | 컴퓨터공학 |
                  | 2024002 | 이영희 | 경영학     |
                  ← 이것은 실제 데이터(인스턴스)
```

> 🎯 핵심: **구조(틀)냐, 값(실제 데이터)이냐** — 이 두 가지 관점으로 나뉜다는 것만 기억하세요!

---

## 🏗️ 데이터베이스의 논리적 구조와 물리적 구조

같은 데이터라도 **누가 보느냐**에 따라 다르게 인식됩니다.

### 논리적 구조 (사용자 관점)

사용자가 보는 데이터의 모습입니다. 테이블, 행, 열 같은 형태로 정리된 **의미 있는 정보**입니다. 이때 데이터를 **논리적 레코드**라고 부릅니다.

### 물리적 구조 (저장장치 관점)

하드디스크에 실제로 저장되어 있는 데이터의 모습입니다. 트랙, 섹터, 바이트 단위로 저장된 **날것 그대로의 데이터**입니다. 이때 데이터를 **저장 레코드**라고 부릅니다.

:::note 중요한 포인트
논리적 구조와 물리적 구조는 **별도의 데이터가 아닙니다**. 하나의 데이터를 사용자가 보는 관점과 저장장치가 보는 관점으로 나눈 것일 뿐입니다. 따라서 이 둘은 **1:1 대응 관계**를 가지고 있습니다.
:::

파일 시스템에서는 프로그래머가 물리적 데이터 구조를 직접 알아야만 데이터에 접근할 수 있었습니다. 하지만 데이터베이스에서는 **자료 추상화** 덕분에 물리적 구조를 몰라도 논리적 관점에서 쉽게 데이터를 다룰 수 있습니다.

---

## ⚙️ DBMS(데이터베이스 관리 시스템)란?

### DBMS의 개념

**DBMS(Database Management System, 데이터베이스 관리 시스템)** 란 사용자와 데이터베이스 사이에서 **중재자 역할을 하는 소프트웨어**입니다.

```
[사용자] → [응용 프로그램] → [DBMS] → [데이터베이스]
```

사용자는 데이터베이스에 직접 접근하지 않습니다. ATM기에서 돈을 이체할 때 ATM 소프트웨어를 통하는 것처럼, 사용자는 응용 프로그램을 통해 DBMS에 요청하고, DBMS가 데이터베이스에서 데이터를 꺼내주거나 저장해 주는 구조입니다.

**DBMS가 탄생한 이유**는 단순합니다. 파일 시스템의 **종속성과 중복성 문제를 해결**하기 위해서입니다.

### DBMS의 3대 필수 기능

DBMS가 반드시 갖추어야 하는 기능은 크게 세 가지입니다.

#### 1️⃣ 정의 기능 (DDL — Data Definition Language)

데이터베이스의 **구조를 만드는 기능**입니다.

마치 빈 표의 틀을 만드는 것과 같습니다. "학생 테이블에는 학번, 이름, 주소라는 열(컬럼)이 있다"고 정의하는 것이죠.

```sql
-- ✅ 올바른 예시: 학생 테이블 구조 생성 (DDL)
CREATE TABLE 학생 (      -- "학생"이라는 테이블을 생성하겠다
    학번 INT PRIMARY KEY, -- 학번은 정수형이며, 기본키(유일한 값)로 지정
    이름 VARCHAR(50),     -- 이름은 최대 50자의 문자열
    주소 VARCHAR(200)     -- 주소는 최대 200자의 문자열
);
```

```sql
-- ❌ 잘못된 예시: 기본키를 지정하지 않으면 중복 데이터가 들어갈 수 있음
CREATE TABLE 학생 (
    학번 INT,              -- 기본키가 없어서 같은 학번이 여러 번 입력될 수 있음
    이름 VARCHAR(50),
    주소 VARCHAR(200)
);
```

위 코드를 한 줄씩 살펴보겠습니다.

- `CREATE TABLE 학생`: "학생"이라는 이름의 테이블(표)을 새로 만들겠다는 명령입니다.
- `학번 INT PRIMARY KEY`: "학번"이라는 컬럼(열)을 만들고, 데이터 타입은 정수(INT), 그리고 이 컬럼을 기본키(PRIMARY KEY)로 지정합니다. 기본키는 테이블에서 각 행을 유일하게 구별하는 역할을 합니다.
- `이름 VARCHAR(50)`: "이름"이라는 컬럼을 만들고, 최대 50자까지 입력할 수 있는 가변 길이 문자열(VARCHAR)로 지정합니다.
- `주소 VARCHAR(200)`: "주소"라는 컬럼을 만들고, 최대 200자까지 입력할 수 있도록 합니다.

정의 기능에서는 이렇게 테이블의 구조를 생성하고, 수정하고, 삭제하는 작업을 수행합니다. 또한 기본키 지정, 응용 프로그램과 데이터베이스 간의 인터페이스 방법 정의 등도 이 기능에 포함됩니다.

#### 2️⃣ 조작 기능 (DML — Data Manipulation Language)

구조가 만들어졌으면, 이제 그 안에 **데이터를 넣고, 꺼내고, 수정하고, 삭제하는 기능**입니다. 냉장고(구조)를 만들었으면 그 안에 음식(데이터)을 넣고 꺼내는 것과 같습니다.

```sql
-- ✅ 올바른 예시: 학생 데이터 삽입 (DML - INSERT)
INSERT INTO 학생 (학번, 이름, 주소)   -- 학생 테이블의 학번, 이름, 주소 컬럼에
VALUES (2024001, '김철수', '서울시');   -- 값을 넣겠다
```

```sql
-- ✅ 올바른 예시: 점수가 90점 이상인 학생 검색 (DML - SELECT)
SELECT 학번, 이름      -- 학번과 이름을 가져오겠다
FROM 학생              -- 학생 테이블에서
WHERE 점수 >= 90;      -- 점수가 90 이상인 조건을 만족하는 행만
```

```sql
-- ❌ 잘못된 예시: WHERE 절 없이 삭제하면 모든 데이터가 삭제됨
DELETE FROM 학생;       -- 조건 없이 삭제하면 학생 테이블의 모든 행이 사라짐!
```

```sql
-- ✅ 올바른 예시: 조건을 명시하여 특정 데이터만 삭제
DELETE FROM 학생        -- 학생 테이블에서
WHERE 학번 = 2024001;  -- 학번이 2024001인 학생만 삭제
```

:::danger 위험한 실수
`DELETE FROM 테이블명;`처럼 **WHERE 절 없이 삭제하면 테이블의 모든 데이터가 사라집니다**. 실무에서 이런 실수를 하면 심각한 데이터 손실이 발생합니다. 삭제(DELETE)나 수정(UPDATE) 시에는 반드시 WHERE 조건을 확인하세요!
:::

조작 기능의 핵심 4가지를 정리하면:

| 조작 | SQL 명령어 | 의미 |
|---|---|---|
| **삽입** | INSERT | 새로운 데이터를 넣음 |
| **검색** | SELECT | 조건에 맞는 데이터를 찾아옴 |
| **수정** | UPDATE | 기존 데이터의 값을 변경 |
| **삭제** | DELETE | 데이터를 제거 |

#### 3️⃣ 제어 기능 (DCL — Data Control Language)

데이터를 만들고(정의) 사용하는(조작) 과정에서 **데이터의 정확성, 안전성, 보안을 관리하는 기능**입니다.

- **무결성 제어**: 데이터가 항상 정확한 상태를 유지하도록 관리
- **보안 제어**: 허가되지 않은 사용자의 접근을 차단
- **병행제어**: 여러 사용자가 동시에 접근해도 충돌이 발생하지 않도록 관리
- **권한 관리**: 누가 어떤 데이터에 어떤 작업을 할 수 있는지 설정
- **회복(Recovery)**: 데이터가 손상되었을 때 이전 상태로 복구

> 📝 **DBMS의 3대 필수 기능 요약:** 정의(DDL, 구조를 만든다) → 조작(DML, 데이터를 넣고 꺼낸다) → 제어(DCL, 안전하게 관리한다)

### DBMS의 장점과 단점

#### ✅ DBMS의 장점

- 데이터 **중복을 제어**할 수 있습니다.
- 여러 사용자가 **동시에** 데이터를 사용할 수 있습니다.
- 데이터의 **일관성**을 유지할 수 있습니다.
- 데이터의 **무결성(정확성)** 을 보장할 수 있습니다.
- **보안**을 유지할 수 있습니다.
- **표준화**된 방식으로 데이터를 관리할 수 있습니다.
- 효율적인 **백업 및 회복** 기능을 제공합니다.

#### ❌ DBMS의 단점

- **비용이 많이 듭니다**: 하드웨어 구매, 통신망 구축, 소프트웨어 라이선스, 운영비 등
- **복잡합니다**: 시스템이 복잡해서 장애 발생 시 원인을 파악하기 어려울 수 있습니다.
- **부분 장애의 전체 확산 위험**: 일부분의 오류가 전체 시스템을 마비시킬 수 있습니다.
- **보안 위협**: 해킹 등으로 인해 전체 데이터가 파괴될 수 있는 위험이 항상 잠재적으로 존재합니다.

:::warning DBMS의 맹점
DBMS는 모든 데이터를 한곳에서 관리하기 때문에, 그 한곳이 무너지면 **전체 시스템이 위험해질 수 있습니다**. 그래서 백업, 회복, 이중화 같은 안전장치가 필수적입니다.
:::

---

## 🔧 DBMS의 내부 구성과 동작 원리

DBMS 내부가 어떻게 동작하는지 이해하면, 데이터베이스를 더 깊이 있게 파악할 수 있습니다. DBMS를 사용하는 사용자는 크게 세 부류로 나뉩니다.

### 사용자의 세 가지 유형

| 사용자 유형 | 하는 일 | 사용하는 언어 |
|---|---|---|
| **일반 사용자** | 질의어(쿼리)로 데이터를 검색하거나 조회 | 질의어 (SQL의 SELECT 등) |
| **응용 프로그래머** | Java, Python 등에 데이터베이스 언어를 섞어 프로그램 개발 | 호스트 언어(Java 등) + DML(데이터 조작어) |
| **데이터베이스 관리자 (DBA)** | 데이터베이스의 구조를 생성·수정·삭제하고 전체를 관리 | DDL(데이터 정의어) |

### DBMS 내부 처리 흐름

DBMS 내부에서 데이터가 처리되는 과정을 각 모듈별로 살펴보겠습니다.

#### 일반 사용자의 질의 처리 과정

```
일반 사용자 → [질의어 입력] → [질의어 처리기] → [런타임 DB 처리기] → [저장 데이터 관리자] → [데이터베이스]
```

1. **질의어 처리기**: 사용자가 입력한 질의어를 받아서 **파싱(Parsing)** 합니다. 파싱이란 질의문을 토큰(최소 단위) 단위로 쪼개서 "이것이 어떤 명령인지" 분석하는 작업입니다. 마치 문장을 단어별로 나눠서 문법을 확인하는 것과 같습니다.
2. **런타임 DB 처리기**: 파싱된 명령을 실제로 **실행**합니다. 실행 과정에서 권한은 제대로 되어 있는지, 무결성은 유지되고 있는지를 확인합니다. 이 과정에서 **트랜잭션 관리자(작업 묶음 관리자)** 가 무결성 검사, 권한 검사, 병행제어, 회복 등을 담당합니다.
3. **저장 데이터 관리자**: 실행에 문제가 없으면 운영체제에 저장 명령을 전달하여 데이터를 하드디스크에 **저장**합니다.

#### 응용 프로그래머의 프로그램 처리 과정

```
응용 프로그램(Java + SQL) → [DML 예비 컴파일러] → 분리 → [호스트 언어 컴파일러] + [DML 컴파일러]
→ [런타임 DB 처리기] → [저장 데이터 관리자] → [데이터베이스]
```

1. **DML 예비 컴파일러**: Java 코드 안에 SQL 코드가 섞여 있는 경우, 이 두 가지를 **분리**하는 역할을 합니다. Java는 Java 컴파일러가 처리하고, SQL(DML)은 DBMS의 DML 컴파일러가 처리해야 하기 때문입니다.
2. **DML 컴파일러**: 분리된 DML 명령어들을 **파싱하고 컴파일**합니다. 문법 오류가 없는지 확인합니다.
3. 이후 **런타임 DB 처리기**와 **저장 데이터 관리자**가 일반 사용자의 경우와 동일하게 실행 및 저장을 수행합니다.

#### DBA의 구조 정의 처리 과정

```
DBA → [DDL 입력] → [DDL 컴파일러] → [저장 데이터 관리자] → [카탈로그/데이터 사전]
```

1. **DDL 컴파일러**: DBA가 입력한 DDL(테이블 생성, 수정, 삭제 등)을 컴파일합니다.
2. **저장 데이터 관리자**를 통해 결과가 저장되는데, 이때 일반 데이터가 아닌 **카탈로그(데이터 사전)** 에 저장됩니다. 앞서 설명한 **자기 정의** 특성에 의해, 데이터베이스의 구조 정보(메타데이터)가 데이터 사전에 기록되는 것입니다.

### DBMS 주요 모듈 정리

| 모듈 | 역할 |
|---|---|
| **질의어 처리기** | 사용자의 SQL 질의문을 파싱(분석)하고 처리 |
| **DML 예비 컴파일러** | 호스트 언어(Java 등)와 DML(SQL)을 분리 |
| **DML 컴파일러** | DML 명령어를 파싱하고 컴파일 |
| **DDL 컴파일러** | DDL 명령어를 컴파일하여 카탈로그(데이터 사전)에 저장 |
| **런타임 DB 처리기** | 실제 프로그램(질의)을 실행 |
| **트랜잭션 관리자** | 무결성 검사, 권한 검사, 병행제어, 회복 수행 |
| **저장 데이터 관리자** | 운영체제에 저장 명령을 전달하여 데이터를 디스크에 저장 |

---

## ⚠️ 주의사항과 실무 팁

### 흔히 혼동하는 개념 정리

:::tip 개체 타입 vs 개체 집합
- **개체 타입**: 빈 양식(틀, 구조). 스키마라고도 부릅니다.
- **개체 집합**: 실제 값이 채워진 데이터. 인스턴스라고도 부릅니다.
- 이 둘은 완전히 다른 개념이니 혼동하지 마세요!
:::

:::tip 논리적 구조 vs 물리적 구조
- 이 둘은 **별도의 데이터가 아닙니다**. 같은 데이터를 보는 **관점의 차이**일 뿐입니다.
- 논리적 구조 = 사용자 관점 (테이블, 행, 열)
- 물리적 구조 = 저장장치 관점 (트랙, 섹터, 바이트)
:::

### 파일 시스템과 DBMS 비교

| 항목 | 파일 시스템 | DBMS |
|---|---|---|
| 데이터 중복 | 중복 심함 | 최소한의 통제된 중복 |
| 데이터 종속성 | 구조 변경 시 프로그램도 변경 필요 | 구조와 프로그램이 독립 |
| 동시 접근 | 어려움 | 병행제어로 가능 |
| 데이터 일관성 | 유지 어려움 | 유지 가능 |
| 보안 | 동일 수준 유지 어려움 | 체계적 보안 관리 가능 |
| 회복 기능 | 별도 구현 필요 | DBMS가 자체 제공 |
| 비용 | 낮음 | 높음 (하드웨어, 소프트웨어, 운영비) |
| 복잡도 | 단순 | 복잡 |

### 실무에서 기억할 핵심 포인트

1. **관계형 DBMS를 먼저 마스터하세요**: 실무의 99.9%가 관계형입니다. Oracle, MySQL, PostgreSQL 중 하나라도 확실히 익히면 나머지는 쉽게 적응할 수 있습니다.
2. **SQL의 기본은 필수입니다**: 정의(DDL), 조작(DML), 제어(DCL)의 개념과 기본 SQL 문법을 반드시 익혀야 합니다.
3. **중복은 적이지만, 완전 제거가 정답은 아닙니다**: 성능을 위해 의도적으로 중복을 허용하는 경우도 있습니다(역정규화).
4. **DELETE/UPDATE 시 WHERE 절을 반드시 확인하세요**: 실무에서 가장 흔한 치명적 실수 중 하나입니다.

---

## 📌 핵심 정리

- **데이터베이스**는 통합·저장·운영·공용 데이터의 집합으로, 파일 시스템의 중복성과 종속성 문제를 해결하기 위해 탄생했다.
- **파일 시스템의 2대 문제점**: 중복성(데이터 불일치 → 무결성 훼손)과 종속성(구조 변경 시 프로그램도 변경 필요).
- **데이터베이스 발전 순서**: 파일 시스템 → 계층형 DBMS(트리 구조) → 네트워크형 DBMS(그래프 구조) → 관계형 DBMS(테이블 구조) → 객체지향 DBMS → 객체관계 DBMS → 빅데이터/데이터 마이닝 시대.
- **관계형 DBMS**가 현재 가장 널리 사용되며, Oracle, MySQL, MS SQL Server 등이 대표적이다.
- **데이터베이스의 4대 특성**: 실시간 접근성, 계속적인 변화, 동시 공유, 내용에 의한 참조.
- **3대 핵심 특징**: 자료 추상화(복잡한 내부를 감춤), 자료 독립성(구조와 프로그램이 독립), 자기 정의(메타데이터를 데이터 사전에 자동 저장).
- **데이터베이스 구성요소**: 개체(표현 대상), 속성(개체의 특성), 도메인(속성의 값 범위), 관계(개체·속성 간 연관성).
- **DBMS**는 사용자와 데이터베이스 사이의 중재자 소프트웨어이며, 정의(DDL)·조작(DML)·제어(DCL) 3가지 필수 기능을 갖는다.
- DBMS 내부는 질의어 처리기, DML 예비 컴파일러, DML 컴파일러, DDL 컴파일러, 런타임 DB 처리기, 트랜잭션 관리자, 저장 데이터 관리자 등의 모듈로 구성되어 데이터를 처리한다.

작성일: 2026-02-20