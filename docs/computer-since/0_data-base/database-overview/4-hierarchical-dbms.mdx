---
title: "계층형 DBMS의 구조와 특징"
description: "계층형 DBMS의 구조와 특징에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/database-overview/4-hierarchical-dbms"
sidebar_label: "계층형 DBMS"
date: "2026-02-20"
---

## 🎯 데이터베이스의 탄생 배경: 파일 시스템의 한계

데이터베이스를 이해하려면, 먼저 **데이터베이스가 왜 필요해졌는지** 그 배경부터 알아야 합니다. 1960년대 이전, 컴퓨터가 처음 등장했을 때 데이터를 저장하는 방식은 **파일 시스템(File System)**이 전부였습니다.

파일 시스템이란 무엇일까요? 여러분이 지금 쓰고 있는 윈도우 탐색기를 떠올려 보세요. 폴더 안에 다양한 종류의 파일들이 담겨 있고, **운영체제(OS, 컴퓨터를 관리하는 기본 소프트웨어)**가 이 파일들을 관리하고 있죠. 이것이 바로 파일 시스템입니다. 파일 시스템은 오라클이나 MySQL 같은 별도의 소프트웨어가 필요 없이, 운영체제가 기본적으로 제공하는 **커널(운영체제의 핵심 부분)** 수준에서 파일을 관리하는 방식입니다.

### 🔍 파일 시스템의 두 가지 치명적 문제

파일 시스템은 **혼자 쓸 때는 아무 문제가 없습니다**. 하지만 여러 사람이 동시에 같은 데이터를 사용해야 할 때, 크게 두 가지 심각한 문제가 발생합니다.

**첫 번째: 중복성(Redundancy)의 문제**

마치 같은 보고서를 팀원 A, B, C가 각자 USB에 복사해서 가져간 상황을 상상해 보세요. A가 보고서 내용을 수정했지만, B와 C는 수정하지 않았습니다. 이제 세 사람이 가진 보고서 내용이 서로 다릅니다. 누구의 것이 맞는 걸까요? 이것이 바로 **데이터 불일치(Inconsistency)** 문제입니다. 똑같은 파일이 여러 곳에 중복 저장되어 있기 때문에, 한 곳만 수정하면 나머지는 옛날 데이터 그대로 남아 있어서 정보가 정확하지 않게 되는 것이죠.

**두 번째: 종속성(Dependency)의 문제**

파일의 저장 구조나 저장 방법이 바뀌면, 그 파일을 사용하는 **프로그램도 함께 바꿔야** 합니다. 마치 집 주소가 바뀌면 택배 배송 시스템도 새 주소로 업데이트해야 하는 것처럼, 파일 구조가 바뀔 때마다 관련 프로그램을 전부 수정해야 하니 유지보수가 매우 어렵고 비용도 많이 들었습니다.

> 💡 **핵심 포인트**: 파일 시스템의 중복성과 종속성 문제를 해결하기 위해 등장한 것이 바로 **데이터베이스(Database)**라는 개념입니다.

:::info 중복성의 구체적인 피해
- **일관성 결여**: 같은 데이터인데 서로 다른 값이 존재하게 됩니다
- **보안 취약**: 데이터가 여러 곳에 흩어져 있으면 동일한 수준의 보안을 유지하기 어렵습니다
- **경제성 하락**: 한 번만 수정하면 될 것을 여러 번 수정해야 하므로 갱신 비용이 증가합니다
- **저장 공간 낭비**: 같은 내용이 여러 곳에 저장되므로 저장 비용이 늘어납니다
- **무결성(정확성) 유지 곤란**: 궁극적으로 데이터의 정확성을 보장하기 어렵습니다
:::

물론 중복에도 장점은 있습니다. 하나가 고장 나도 다른 복사본을 쓸 수 있는 **가용성(Availability)**이 높아지고, 사이트 간 데이터 이동을 최소화할 수 있습니다. 하지만 이런 장점보다 **데이터 무결성(정확성)을 지키기 어렵다**는 단점이 훨씬 크기 때문에, 여러 사람이 동시에 사용하는 환경에서는 파일 시스템만으로는 한계가 있었습니다.

---

## 🌳 계층형 DBMS: 최초의 데이터베이스 관리 시스템

1960년대에 들어서면서, 파일 시스템의 문제를 해결하기 위해 **최초로 개발된 데이터베이스 관리 시스템**이 바로 **계층형 DBMS(Hierarchical DBMS)**입니다. 말 그대로 데이터를 **계층(hierarchy, 위아래 단계)** 구조로 관리하는 방식입니다.

### 🏢 트리 구조란 무엇인가?

계층형 DBMS를 이해하려면 먼저 **트리(Tree) 구조**를 알아야 합니다. 회사에 가면 조직도가 있죠? 맨 위에 사장님이 있고, 그 아래에 부서장들이 있고, 부서장 아래에 팀장들이 있고, 팀장 아래에 팀원들이 있는 구조입니다. 마치 나무를 뒤집어 놓은 것처럼 위에서 아래로 가지가 뻗어나가는 형태, 이것이 바로 트리 구조입니다.

```
        [사장]              ← 최상위 부모(루트 노드)
       /      \
    [영업부]   [개발부]      ← 자식이자 부모
    /    \        |
 [팀A]  [팀B]   [팀C]       ← 자식(말단 노드)
```

위 그림에서 **사장**은 영업부와 개발부의 **부모(Parent)**이고, 영업부와 개발부는 사장의 **자식(Child)**입니다. 영업부는 다시 팀A와 팀B의 부모가 됩니다. 이처럼 **부모-자식 관계**로 데이터 간의 관계를 표현하는 것이 계층형 DBMS의 핵심입니다.

### 📐 계층형 DBMS의 핵심 원리

계층형 DBMS에서 가장 중요한 특징은 다음과 같습니다:

**1. 부모-자식 관계로 데이터를 표현합니다**

데이터베이스에서 다루는 대상(개체)들 간의 관계를 **부모와 자식**이라는 개념으로 표현합니다. 예를 들어, "학과" 개체가 부모이고 그 아래에 "학생" 개체가 자식으로 연결되는 방식입니다. 컴퓨터공학과라는 부모 아래에 그 학과에 소속된 학생들이 자식으로 매달려 있는 모습을 떠올리시면 됩니다.

**2. 사이클(순환)이 발생하지 않습니다**

이 부분이 매우 중요합니다. 자식이 거꾸로 부모가 될 수는 없습니다. 마치 회사 조직도에서 신입사원이 갑자기 사장님의 상사가 될 수 없는 것과 같습니다. 정보의 흐름은 **오직 위에서 아래로만** 내려갑니다. 아래에서 위로 올라가거나, 빙 돌아서 다시 원래 자리로 돌아오는 것(사이클)은 불가능합니다.

**3. 정보의 흐름이 단방향입니다**

데이터를 탐색할 때 항상 **최상위(루트)**에서 출발하여 원하는 데이터가 있는 **하위 노드**로 내려가야 합니다. 마치 족보를 보면서 조상부터 차례대로 내려와야 특정 후손을 찾을 수 있는 것과 같습니다.

:::tip 계층형 DBMS를 실생활로 이해하기
**족보**를 떠올려 보세요. 할아버지 → 아버지 → 나 → 내 자녀... 이런 식으로 위에서 아래로만 관계가 이어집니다. 내 자녀가 갑자기 할아버지의 부모가 될 수는 없죠. 이것이 바로 "사이클이 발생하지 않는 트리 구조"입니다.
:::

### 📊 계층형 DBMS의 데이터 구조 예시

실제 계층형 DBMS에서 데이터가 어떻게 구성되는지 간단한 예시로 살펴보겠습니다.

```
        [대학교]                    ← 루트 노드 (최상위 개체)
        /      \
  [공과대학]   [인문대학]           ← 중간 노드 (부모이자 자식)
    /    \         |
[컴공과] [전자과] [국문과]          ← 말단 노드 (자식)
  |        |        |
[학생A]  [학생B]  [학생C]          ← 말단 노드 (자식)
```

위 구조에서 데이터를 찾으려면 항상 **대학교**라는 루트에서 출발해야 합니다. "학생A"의 정보를 알고 싶다면, 대학교 → 공과대학 → 컴공과 → 학생A라는 경로를 따라 내려가야 합니다. 중간을 건너뛰거나, 학생A에서 역으로 올라가서 인문대학의 정보를 바로 가져올 수는 없습니다.

:::warning 계층형 DBMS의 한계
계층형 DBMS는 정보의 흐름이 **위에서 아래로만** 가능하기 때문에, 복잡한 관계를 표현하기 어렵습니다. 예를 들어, 한 학생이 두 개의 학과에 동시에 소속되는 **복수전공** 같은 관계는 트리 구조로 표현하기가 매우 까다롭습니다. 이런 한계를 극복하기 위해 이후 네트워크형 DBMS가 등장하게 됩니다.
:::

---

## 🌐 DBMS의 진화: 계층형에서 관계형까지

계층형 DBMS는 데이터베이스의 시작점이었지만, 한계가 분명했습니다. 이후 데이터베이스는 시대의 요구에 따라 계속 발전해 왔습니다. 각 세대별 DBMS가 어떤 특징을 가지고 있는지, 그리고 계층형 DBMS가 전체 흐름에서 어디에 위치하는지 이해하면 계층형 DBMS의 의미를 더 깊이 파악할 수 있습니다.

### 📈 DBMS 발전 흐름 한눈에 보기

| 시대 | DBMS 유형 | 데이터 구조 | 핵심 키워드 |
|------|-----------|------------|------------|
| 1960년대 이전 | 파일 시스템 | 파일/폴더 | 운영체제 기반, 중복·종속 문제 |
| **1960년대** | **계층형 DBMS** | **트리 구조** | **부모-자식 관계, 사이클 없음** |
| 1970년대 | 네트워크형 DBMS | 그래프 구조 | 오너-멤버 관계, 사이클 허용 |
| 1980년대~ | 관계형 DBMS | 테이블(표) 구조 | SQL, 표준화, 대중화 |
| 1990년대 | 객체지향 DBMS | 객체 구조 | 멀티미디어, OOP 접목 |
| 1990년대~ | 객체관계 DBMS | 테이블 + 객체 | 관계형 + 객체지향 장점 결합 |
| 2000년대~ | 현대 DBMS | 다양한 구조 | 빅데이터, 데이터 마이닝, 24×7 |

### 🔄 네트워크형 DBMS: 계층형의 한계를 넘어서다

1970년대에 등장한 네트워크형 DBMS는 계층형 DBMS의 "사이클 불가" 한계를 극복하기 위해 만들어졌습니다. 네트워크형은 **그래프(Graph) 구조**로 되어 있으며, 부모-자식 대신 **오너(Owner)-멤버(Member)**라는 용어를 사용합니다.

가장 큰 차이점은 **사이클(순환)을 허용한다**는 것입니다. 하나의 멤버가 다른 곳에서는 오너가 될 수도 있고, 데이터 간에 상하 관계가 아닌 **다대다(多對多) 관계**도 자유롭게 표현할 수 있습니다. 마치 SNS에서 내가 누군가를 팔로우하면서 동시에 다른 사람에게 팔로우를 받을 수 있는 것처럼, 관계의 방향이 자유롭습니다.

### 📋 관계형 DBMS: 현재의 주류

관계형 DBMS(RDBMS, Relational DBMS)는 데이터를 우리에게 친숙한 **표(테이블)** 형태로 관리합니다. 여러분이 엑셀에서 보는 것처럼 행(가로줄)과 열(세로줄)로 구성된 테이블에 데이터를 저장하는 방식입니다.

현재 실무에서 **99.9%는 관계형 데이터베이스**를 사용한다고 해도 과언이 아닙니다. 오라클(Oracle), MySQL, MSSQL 등이 모두 관계형 DBMS입니다. 표준화가 잘 되어 있고, 배우기 쉽고, 개발이 용이하기 때문에 가장 대중적으로 사용됩니다.

### 🎨 객체지향 & 객체관계 DBMS

관계형 DBMS는 텍스트나 숫자 같은 레코드를 저장하기에는 좋지만, **동영상, 사진, 음악, 지리정보(GIS)** 같은 멀티미디어 데이터를 다루기에는 한계가 있었습니다. 이를 해결하기 위해 1990년대에 **객체지향 DBMS(Object-Oriented DBMS)**가 등장했습니다.

객체지향 DBMS는 Java나 C++ 같은 **객체지향 프로그래밍(OOP, Object-Oriented Programming)**의 개념에 데이터베이스 기능을 접목한 것입니다. 하지만 호환성 문제와 학습 난이도가 높아 대중화에는 실패했습니다. 이후 관계형 DBMS의 **대중성과 편의성**에 객체지향의 기능을 결합한 **객체관계 DBMS(Object-Relational DBMS)**가 등장하면서, 두 가지 장점을 모두 취할 수 있게 되었습니다.

:::note 현대 데이터베이스의 트렌드
2000년대 이후 데이터베이스는 **빅데이터(Big Data)**, **데이터 마이닝(대량 데이터에서 의미 있는 패턴을 찾아내는 기술)**, **클라우드**, **AI** 등의 분야에서 활용되고 있습니다. 특히 **24×7(24시간 × 7일, 즉 연중무휴)**로 멈추지 않고 가동되는 것이 현대 데이터베이스의 핵심 요구사항입니다.
:::

---

## 📖 데이터베이스의 정의와 특성

지금까지 DBMS의 발전 과정을 살펴보았으니, 이제 **데이터베이스 자체**가 무엇인지 정확히 정의해 보겠습니다. 누군가가 "데이터베이스가 뭐예요?"라고 물었을 때, 명확하게 답할 수 있어야 합니다.

### 📝 데이터베이스의 정의

> **데이터베이스**란, 어느 조직(기업, 학교 등)에서 업무 수행과 의사결정에 활용하기 위해, 여러 사람이 **공용(共用)**으로 사용할 수 있도록 흩어져 있는 데이터를 한 곳에 **통합**하여 하드디스크에 **저장**한, 조직 고유의 **운영 데이터** 집합입니다.

이 정의를 하나씩 쪼개보면 네 가지 핵심 키워드가 나옵니다:

| 키워드 | 의미 | 쉬운 비유 |
|--------|------|----------|
| **통합된 데이터** | 중복을 최소화하면서 한 곳에 모은 데이터 | 흩어진 퍼즐 조각을 하나의 판에 맞추는 것 |
| **저장된 데이터** | 디지털 형태로 하드디스크에 저장된 데이터 | 캐비닛 서류가 아닌, 컴퓨터 안에 있는 데이터 |
| **운영 데이터** | 조직의 고유한 기능 수행에 필요한 데이터 | 학사관리면 학생 정보, 생산관리면 생산 정보 |
| **공용 데이터** | 여러 사용자가 함께 소유하고 이용하는 데이터 | 도서관의 책처럼 모두가 함께 이용 |

### 🔑 통합된 데이터의 핵심: 최소한의 중복

통합의 핵심은 **중복 제거**입니다. 하지만 여기서 주의할 점이 있습니다. 100% 완벽한 중복 제거가 아니라, **최소한의 중복, 통제된 중복**을 허용한다는 것입니다.

왜 그럴까요? 중복을 완전히 없애 버리면 오히려 **성능(데이터를 찾는 속도)**에 문제가 생길 수 있기 때문입니다. 마치 도서관에서 인기 있는 책을 딱 한 권만 두면 모든 사람이 줄을 서서 기다려야 하는 것처럼, 때로는 의도적으로 중복을 유지하는 것이 효율적일 수 있습니다. 이 개념은 나중에 **정규화(중복 제거 과정)**와 **역정규화(의도적 중복 허용)**에서 더 자세히 다루게 됩니다.

### ⚡ 데이터베이스의 4가지 특징

데이터베이스는 다음과 같은 일반적인 특징을 가지고 있습니다:

**1. 실시간 접근(Real-Time Accessibility)**

언제 어디서나 데이터에 접근할 수 있어야 합니다. 여러분이 네이버에 접속하고 싶을 때 언제든 접속할 수 있는 것처럼, 데이터베이스는 사용자의 요청에 **즉각적으로** 응답해야 합니다.

**2. 계속적인 변화(Continuous Evolution)**

데이터베이스의 내용은 끊임없이 변합니다. 날씨 정보, 뉴스 기사, 교통 정보 등이 실시간으로 업데이트되듯이, 사용자가 보는 데이터는 항상 **최신 상태**를 유지해야 합니다. 삽입, 수정, 삭제 등의 작업이 지속적으로 이루어지면서 데이터가 동적으로 변화합니다.

**3. 동시 공유(Concurrent Sharing)**

수많은 사용자가 **동시에** 같은 데이터베이스를 이용할 수 있어야 합니다. 네이버나 구글에 수백만 명이 동시에 접속해도 각자 원하는 정보를 문제없이 이용할 수 있죠. 이것이 가능한 이유는 **병행제어(Concurrency Control, 여러 사용자의 동시 접근을 충돌 없이 관리하는 기법)** 덕분입니다.

**4. 내용에 의한 참조(Content Reference)**

데이터베이스에서 데이터를 찾을 때는 데이터가 저장된 **위치나 주소**가 아니라, **데이터의 내용(값)**을 기준으로 찾습니다. 예를 들어, "점수가 90점 이상인 학생"을 검색하면 점수 **값**을 비교해서 해당하는 데이터를 꺼내줍니다. 마치 도서관에서 책의 위치가 아닌 **제목이나 저자**로 검색하는 것과 같습니다.

---

## 🔬 데이터베이스의 3대 중요 특징: 추상, 독립, 자기정의

데이터베이스에는 일반적인 특징 외에도, **구조적으로 매우 중요한 세 가지 특징**이 있습니다. 이 세 가지를 이해하면 데이터베이스가 왜 파일 시스템보다 우월한지 명확히 알 수 있습니다.

### 🎭 자료 추상(Data Abstraction) — 복잡함을 감추다

자료 추상은 다른 말로 **개념화**, **일반화**라고도 합니다. 핵심은 **복잡한 내부 구조를 감추고, 사용자가 쉽게 사용할 수 있게 하는 것**입니다.

실제로 하드디스크 내부를 들여다보면, 데이터는 0과 1의 기계어로 저장되어 있고, 트랙과 섹터라는 물리적 단위로 나뉘어 있으며, 16진수와 2진수가 뒤섞인 아주 복잡한 형태입니다. 원래대로라면 사용자가 이 모든 것을 이해해야만 데이터에 접근할 수 있어야 합니다.

하지만 데이터베이스는 이런 **복잡한 내부 구현을 모두 감춰주고**, 사용자에게는 "학생 테이블에서 이름이 '홍길동'인 학생을 찾아줘"라고 간단히 요청할 수 있는 인터페이스를 제공합니다.

> 마치 자동차를 운전할 때 엔진의 내부 구조를 몰라도 핸들과 페달만 조작하면 되는 것처럼, 데이터베이스도 내부 저장 방식을 몰라도 쉽게 사용할 수 있습니다. 이것이 바로 **자료 추상**입니다.

### 🔓 자료 독립(Data Independence) — 구조가 바뀌어도 프로그램은 그대로

자료 독립은 파일 시스템의 **종속성** 문제를 정확히 반대로 뒤집은 개념입니다.

파일 시스템에서는 파일 구조가 바뀌면 그 파일을 사용하는 프로그램도 함께 바꿔야 했습니다. 하지만 데이터베이스에서는 **자료 구조(테이블의 구조 등)가 바뀌어도 프로그램을 변경하지 않고 그대로 사용할 수 있습니다**. 반대로 프로그램이 바뀌어도 데이터 구조에 영향을 주지 않습니다.

이것은 **유지보수**를 훨씬 쉽게 만들어 줍니다. 마치 콘센트 규격만 맞으면 어떤 전자제품이든 꽂아서 쓸 수 있는 것처럼, 데이터베이스와 프로그램은 서로 독립적으로 존재하면서 DBMS라는 중재자를 통해 연결됩니다.

### 📋 자기 정의(Self-Describing) — 스스로를 설명하는 데이터베이스

데이터베이스는 자기 자신에 대한 정보를 **스스로 정의하고 저장**합니다. 데이터베이스를 만들면, "누가 만들었는지", "언제 만들었는지", "권한은 어떻게 설정되어 있는지", "크기는 얼마인지", "속성은 몇 개인지" 등의 정보가 자동으로 생성됩니다.

이렇게 **데이터에 대한 데이터**를 **메타데이터(Metadata)**라고 부릅니다. 마치 도서관의 도서 카드에 책의 제목, 저자, 출판일 등이 적혀 있는 것처럼, 메타데이터는 데이터베이스 자체를 설명하는 정보입니다. 이 메타데이터는 **데이터 사전(Data Dictionary)** 또는 **카탈로그(Catalog)**라는 별도의 저장소에 보관됩니다.

:::tip 세 가지 특징 요약
| 특징 | 핵심 내용 | 비유 |
|------|----------|------|
| **자료 추상** | 복잡한 내부를 감추고 쉽게 사용 | 자동차 엔진 몰라도 운전 가능 |
| **자료 독립** | 구조 변경해도 프로그램 수정 불필요 | 콘센트 규격만 맞으면 OK |
| **자기 정의** | 자신의 정보를 메타데이터로 자동 저장 | 도서관의 도서 카드 |
:::

---

## 🧩 데이터베이스의 구성요소: 개체, 속성, 관계

데이터베이스가 어떤 요소들로 이루어져 있는지 알아보겠습니다. 크게 **개체(Entity)**, **속성(Attribute)**, **관계(Relationship)** 세 가지로 구성됩니다.

### 👤 개체(Entity) — 데이터베이스가 표현하려는 대상

개체란 데이터베이스가 표현하려고 하는 **유형·무형의 정보 대상**을 말합니다. "학생", "교수", "과목", "주문" 같은 것들이 모두 개체입니다. 각 개체는 서로 **구별할 수 있어야** 하며, **단독으로 존재할 수 있고**, 하나 이상의 속성으로 구성됩니다. 파일 시스템에서는 이것을 **레코드(Record)**에 해당한다고 볼 수 있습니다.

### 📌 속성(Attribute) — 개체의 특성을 나타내는 정보

속성은 개체의 **특성이나 상태**를 기술하는 것입니다. "학생"이라는 개체가 있다면, 학번, 이름, 주소, 전화번호 등이 그 학생의 속성이 됩니다. 속성은 **더 이상 쪼갤 수 없는 가장 작은 논리적 단위**이며, 개체 없이 속성만 홀로 존재할 수는 없습니다. 파일 시스템에서는 **항목(Item)** 또는 **필드(Field)**라고 부릅니다.

하나의 속성이 가질 수 있는 **값의 범위**를 **도메인(Domain)**이라고 합니다. 예를 들어, "점수"라는 속성의 도메인이 0~100이라면, 이 속성에는 0 이상 100 이하의 값만 입력할 수 있습니다. 마치 놀이기구의 키 제한처럼, 허용된 범위 밖의 값은 입력을 거부하는 것입니다.

### 🔗 관계(Relationship) — 개체들 사이의 연결

관계는 개체와 개체 사이, 또는 속성과 속성 사이에 존재하는 **의미 있는 연결**입니다.

**개체 간의 관계 예시:**

```
[교수] ──── 지도 ──── [학생]
 (1명)               (여러 명)
```

한 명의 교수가 여러 명의 학생을 지도하는 관계입니다. 이처럼 개체 간에는 **1:1(일대일)**, **1:N(일대다)**, **M:N(다대다)** 등 다양한 유형의 관계가 존재합니다.

**속성 간의 관계 예시:**

학생 개체에서 "학번"은 나머지 속성(이름, 주소 등)을 모두 **결정**합니다. 학번을 알면 그 학생의 이름과 주소를 알 수 있죠. 이처럼 학번이 다른 속성들의 "주인" 역할을 하기 때문에, 속성과 속성 사이에도 **주종 관계**가 있습니다. 이 "주인" 역할을 하는 속성을 **기본키(Primary Key)**라고 합니다. 우리 국민을 대표하는 주민등록번호처럼, 전체 데이터에서 **유일한 값**을 가지는 속성입니다.

### 📚 개체 타입과 개체 집합 — 구조 vs 실제 값

데이터베이스에서 자주 헷갈리는 용어를 정리해 보겠습니다.

| 구분 | 의미 | 예시 | 다른 이름들 |
|------|------|------|-----------|
| **개체 타입(Entity Type)** | 데이터의 **구조(틀)** | 학번, 이름, 학과라는 열 구조 | 스키마, 인텐션, 내포 |
| **개체 집합(Entity Set)** | **실제 값**들의 모음 | 20210001, 홍길동, 컴공과 | 인스턴스, 튜플 집합, 어커런스, 외연 |

마치 붕어빵 **틀**이 개체 타입이고, 그 틀로 찍어낸 **붕어빵 하나하나**가 개체 어커런스(Occurrence)이며, 붕어빵 **전체 모음**이 개체 집합인 것과 같습니다.

---

## 🖥️ DBMS의 구조와 동작 원리

### 🔧 DBMS란 무엇인가?

**DBMS(Database Management System, 데이터베이스 관리 시스템)**는 사용자와 데이터베이스 사이에서 **중재자** 역할을 하는 **소프트웨어**입니다.

```
[사용자/응용 프로그램]  ←→  [DBMS]  ←→  [데이터베이스]
```

사용자가 데이터베이스에 직접 접근하는 것이 아니라, **반드시 DBMS를 거쳐서** 접근합니다. 여러분이 ATM기에서 돈을 이체할 때, ATM기의 소프트웨어를 통해 은행 데이터베이스에 접근하는 것과 같습니다. 네이버에 접속해서 정보를 보는 것도, 네이버의 응용 프로그램이 DBMS를 통해 데이터베이스에서 정보를 가져와 보여주는 것입니다.

### 🛠️ DBMS의 3대 필수 기능

DBMS가 반드시 갖추어야 할 핵심 기능은 세 가지입니다:

**1. 정의 기능(DDL — Data Definition Language)**

데이터베이스의 **구조를 만드는** 기능입니다. 테이블을 생성하고, 수정하고, 삭제하는 것이 여기에 해당합니다. 마치 건축에서 **설계도를 그리는 것**과 같습니다.

```sql
-- ✅ 올바른 예시: 학생 테이블의 구조를 만드는 정의 기능 (DDL)
CREATE TABLE 학생 (
    학번 INT PRIMARY KEY,    -- 학번: 정수형, 기본키로 지정
    이름 VARCHAR(50),        -- 이름: 최대 50자의 문자열
    주소 VARCHAR(200)        -- 주소: 최대 200자의 문자열
);
```

```sql
-- ❌ 잘못된 예시: 구조를 만들 때 데이터 타입을 지정하지 않음
CREATE TABLE 학생 (
    학번,    -- 데이터 타입이 없어서 오류 발생
    이름,    -- 어떤 종류의 데이터인지 알 수 없음
    주소     -- DBMS가 저장 방법을 결정할 수 없음
);
```

위 올바른 예시의 각 줄을 설명하면:
- `CREATE TABLE 학생`: "학생"이라는 이름의 테이블을 새로 만들겠다는 명령입니다.
- `학번 INT PRIMARY KEY`: 학번이라는 열을 만들고, 정수(INT) 타입이며, 이 열이 기본키(PRIMARY KEY, 각 행을 유일하게 구별하는 키)임을 지정합니다.
- `이름 VARCHAR(50)`: 이름이라는 열을 만들고, 최대 50글자까지 저장할 수 있는 가변 길이 문자열(VARCHAR) 타입으로 지정합니다.
- `주소 VARCHAR(200)`: 주소이라는 열을 만들고, 최대 200글자까지 저장할 수 있는 문자열 타입으로 지정합니다.

**2. 조작 기능(DML — Data Manipulation Language)**

구조를 만든 후, 그 안에 **데이터를 넣고, 찾고, 수정하고, 삭제하는** 기능입니다. 마치 설계도대로 지은 집에 **가구를 배치하고, 정리하고, 바꾸는 것**과 같습니다.

```sql
-- ✅ 올바른 예시: 데이터 삽입 (조작 기능 - INSERT)
INSERT INTO 학생 (학번, 이름, 주소)
VALUES (20210001, '홍길동', '서울시 강남구');
-- 학생 테이블에 학번 20210001, 이름 홍길동, 주소 서울시 강남구인 데이터를 넣는다

-- ✅ 올바른 예시: 데이터 검색 (조작 기능 - SELECT)
SELECT 이름, 주소
FROM 학생
WHERE 학번 = 20210001;
-- 학생 테이블에서 학번이 20210001인 학생의 이름과 주소를 찾아서 보여준다
```

```sql
-- ❌ 잘못된 예시: 존재하지 않는 테이블에 데이터를 넣으려는 경우
INSERT INTO 교직원 (사번, 이름)
VALUES (10001, '김철수');
-- "교직원"이라는 테이블이 아직 정의(생성)되지 않았다면 오류 발생!
-- 반드시 정의 기능(DDL)으로 테이블을 먼저 만든 후에 데이터를 조작해야 합니다.
```

각 줄을 설명하면:
- `INSERT INTO 학생 (학번, 이름, 주소)`: 학생 테이블의 학번, 이름, 주소 열에 새로운 데이터를 넣겠다는 명령입니다.
- `VALUES (20210001, '홍길동', '서울시 강남구')`: 실제로 넣을 값들을 순서대로 지정합니다. 숫자는 그대로, 문자열은 작은따옴표로 감쌉니다.
- `SELECT 이름, 주소`: 결과로 보고 싶은 열(이름과 주소)을 지정합니다.
- `FROM 학생`: 어느 테이블에서 데이터를 가져올지 지정합니다.
- `WHERE 학번 = 20210001`: 조건을 지정합니다. 학번이 20210001인 행만 찾습니다.

**3. 제어 기능(DCL — Data Control Language)**

데이터를 조작하는 과정에서 **정확성, 안전성, 보안, 권한, 병행제어** 등을 관리하는 기능입니다. 마치 아파트 관리실에서 **출입 통제, 보안 카메라, 소방 안전 점검** 등을 하는 것과 같습니다.

데이터베이스를 사용하다가 데이터가 망가지면 안 되니까 **무결성 검사**를 하고, 허가되지 않은 사용자가 접근하지 못하도록 **권한 관리**를 하고, 여러 사용자가 동시에 접근할 때 충돌이 나지 않도록 **병행제어**를 하고, 문제가 생겼을 때 원래 상태로 되돌리는 **회복(Recovery)** 기능을 수행합니다.

:::danger 순서를 반드시 지켜야 합니다
테이블 구조를 먼저 **정의(DDL)**한 후에 데이터를 **조작(DML)**해야 합니다. 존재하지 않는 테이블에 데이터를 넣거나 검색하려고 하면 오류가 발생합니다. 마치 집을 짓기도 전에 가구를 들여놓으려는 것과 같습니다.
:::

### 👥 데이터베이스 사용자의 종류

DBMS를 사용하는 사용자는 크게 세 가지로 분류됩니다:

| 사용자 유형 | 사용 도구 | 역할 |
|------------|----------|------|
| **일반 사용자** | 질의어(Query Language) | 궁금한 것을 질의어로 입력하여 데이터 검색 |
| **응용 프로그래머** | 프로그램 + DML(데이터 조작어) | Java 등의 프로그램 안에 DB 언어를 넣어 개발 |
| **DBA(데이터베이스 관리자)** | DDL(데이터 정의어) | 데이터베이스 구조를 생성·수정·삭제, 전체 관리 |

### ⚙️ DBMS 내부 동작 흐름

DBMS 내부에서 데이터가 처리되는 과정을 사용자 유형별로 살펴보겠습니다:

**일반 사용자의 질의 처리 흐름:**

```
일반 사용자 → [질의어 입력]
  → 질의어 처리기 (어떤 명령인지 확인)
    → 런타임 DB 처리기 (실행 + 권한/무결성/회복 검사)
      → 트랜잭션 관리자 (무결성·권한·병행제어·회복 관리)
        → 저장 데이터 관리자 (하드디스크에 저장)
```

**응용 프로그래머의 프로그램 처리 흐름:**

```
응용 프로그래머 → [Java 코드 + DML 코드]
  → DML 예비 컴파일러 (Java 코드와 DB 코드를 분리)
    → 호스트 언어(Java) → Java 컴파일러가 처리
    → DML 코드 → DML 컴파일러 (문법 검사 및 컴파일)
      → 런타임 DB 처리기 (실행)
        → 저장 데이터 관리자 (하드디스크에 저장)
```

**DBA의 정의 처리 흐름:**

```
DBA → [DDL로 테이블 구조 정의]
  → DDL 컴파일러 (구조 정보 컴파일)
    → 저장 데이터 관리자
      → 카탈로그(데이터 사전)에 메타데이터 저장
```

여기서 핵심적인 모듈들을 정리하면:

- **질의 처리기**: 사용자가 입력한 질의문을 **파싱(Parsing, 토큰 단위로 쪼개서 어떤 명령인지 확인하는 작업)**하고 분석합니다.
- **DML 예비 컴파일러**: 호스트 프로그램(Java 등)과 데이터베이스 언어(SQL 등)를 **분리**해주는 역할을 합니다. Java는 Java 컴파일러가, SQL은 DML 컴파일러가 각각 처리해야 하기 때문입니다.
- **런타임 DB 처리기**: 실제 프로그램을 **실행**하는 모듈입니다.
- **트랜잭션(작업 묶음) 관리자**: 무결성 검사, 권한 검사, 병행제어, 회복 등을 수행합니다. 데이터를 안전하게 관리하는 **경비원** 역할입니다.
- **DDL 컴파일러**: 테이블 구조(스키마)를 컴파일하여 **카탈로그(데이터 사전)**에 메타데이터를 저장합니다.
- **저장 데이터 관리자**: 운영체제에 저장 명령을 내려 실제 하드디스크에 데이터를 기록합니다.

---

## 📊 데이터베이스의 논리적 구조와 물리적 구조

데이터베이스의 데이터를 바라보는 **관점**은 두 가지가 있습니다.

### 👁️ 논리적 구조 — 사용자의 눈에 보이는 모습

사용자가 보는 데이터의 형태를 **논리적 구조**라고 합니다. 여기서 다루는 데이터를 **논리적 레코드**라고 부릅니다. 예를 들어, "학생 테이블에 학번, 이름, 주소 열이 있고, 첫 번째 행에 20210001, 홍길동, 서울..." 이렇게 보이는 것이 논리적 관점입니다.

### 💾 물리적 구조 — 저장 장치의 실제 모습

하드디스크에 실제로 저장되어 있는 데이터의 형태를 **물리적 구조**라고 합니다. 여기서 다루는 데이터를 **저장 레코드**라고 부릅니다. 트랙과 섹터에 0과 1로 기록된 실제 모습이 물리적 관점입니다.

> 💡 **중요**: 논리적 데이터와 물리적 데이터는 **따로따로 존재하는 것이 아닙니다**. 하나의 하드디스크에 저장된 **같은 데이터**를 사용자 입장에서 보면 논리적 구조이고, 저장 장치 입장에서 보면 물리적 구조인 것입니다. 따라서 둘은 **1:1 대응 관계**를 가지고 있습니다.

파일 시스템에서는 프로그래머가 **물리적 데이터 구조를 알아야만** 프로그램을 만들 수 있었습니다. 하지만 데이터베이스에서는 **자료 추상** 덕분에 물리적 구조를 몰라도 논리적 구조만으로 데이터에 접근할 수 있습니다.

---

## ✅ DBMS의 장점과 단점

### 👍 DBMS의 장점

DBMS를 사용하면 파일 시스템의 문제를 해결하면서 다음과 같은 이점을 얻을 수 있습니다:

- **중복 제어**: 데이터의 불필요한 중복을 최소화하여 관리합니다
- **동시 접근**: 여러 사용자가 동시에 데이터를 사용할 수 있습니다
- **데이터 일관성**: 한 곳에서 수정하면 모든 사용자가 같은 데이터를 봅니다
- **데이터 무결성(정확성)**: 잘못된 데이터가 입력되지 않도록 제어합니다
- **보안 유지**: 권한에 따라 접근을 통제할 수 있습니다
- **표준화**: 표준화된 방법으로 데이터를 관리하고 분석할 수 있습니다
- **백업 및 회복**: 데이터가 손상되었을 때 원래 상태로 복구할 수 있는 기능을 제공합니다
- **자료 독립성**: 프로그램과 데이터 구조가 독립적이라 유지보수가 용이합니다
- **개발 기간 단축**: 표준화된 개발 방법론이 내장되어 있어 프로그램을 빠르게 개발할 수 있습니다

### 👎 DBMS의 단점

하지만 DBMS에도 분명한 단점이 있습니다:

- **높은 비용**: 하드웨어 구매, 통신망 구축, 소프트웨어 구매 등 초기 비용과 운영비가 많이 듭니다
- **복잡성**: 시스템이 복잡하기 때문에 고장이 났을 때 **어디서 문제가 발생했는지 파악하기 어렵습니다**
- **전체 시스템 정지 위험**: 일부분의 오류가 **전체 시스템을 마비**시킬 수 있는 위험이 있습니다
- **보안 위협**: 해킹이나 시스템 장애로 인해 **전체 데이터가 파괴**될 수 있는 잠재적 위험을 가지고 있습니다

:::warning DBMS의 단점을 과소평가하지 마세요
DBMS는 매우 편리하고 강력하지만, 인터넷이 워낙 복잡하게 얽혀 있기 때문에 **한 곳의 작은 오류가 전체 서비스를 멈추게 할 수 있습니다**. 실제 기업에서는 이런 위험에 대비하여 **이중화(같은 시스템을 두 대 이상 운영)**, **정기적인 백업**, **재해 복구 계획** 등을 반드시 수립합니다.
:::

---

## 📌 핵심 정리

- **파일 시스템**은 운영체제가 관리하는 기본적인 데이터 저장 방식이지만, **중복성**과 **종속성** 문제가 있다
- **계층형 DBMS**는 1960년대에 최초로 개발된 DBMS로, **트리 구조**의 **부모-자식 관계**로 데이터를 표현한다
- 계층형 DBMS는 **사이클(순환)이 불가능**하며, 정보의 흐름이 **위에서 아래로만** 이동한다
- **네트워크형 DBMS**는 **그래프 구조**로 **오너-멤버** 관계를 사용하며, 사이클을 허용한다
- **관계형 DBMS**는 **테이블(표) 구조**로 현재 실무에서 가장 많이 사용되는 DBMS이다
- 데이터베이스는 **통합 데이터**, **저장 데이터**, **운영 데이터**, **공용 데이터**의 네 가지로 정의된다
- 데이터베이스의 일반적 특징은 **실시간 접근**, **계속적인 변화**, **동시 공유**, **내용에 의한 참조**이다
- 데이터베이스의 3대 중요 특징은 **자료 추상**(복잡함을 감춤), **자료 독립**(구조-프로그램 분리), **자기 정의**(메타데이터 자동 생성)이다
- 데이터베이스의 구성요소는 **개체**(표현 대상), **속성**(개체의 특성), **관계**(개체 간 연결)이다
- **DBMS**는 사용자와 데이터베이스 사이의 **중재자** 역할을 하는 소프트웨어이다
- DBMS의 3대 필수 기능은 **정의 기능(DDL)**, **조작 기능(DML)**, **제어 기능(DCL)**이다
- DBMS 사용자는 **일반 사용자**(질의어), **응용 프로그래머**(프로그램+DML), **DBA**(DDL)로 구분된다

---

작성일: 2026-02-20