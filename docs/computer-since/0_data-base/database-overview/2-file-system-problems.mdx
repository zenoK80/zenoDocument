---
title: "파일 시스템의 중복성과 종속성 문제"
description: "파일 시스템의 중복성과 종속성 문제에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/database-overview/2-file-system-problems"
sidebar_label: "중복성과 종속성"
date: "2026-02-20"
---

## 🎯 파일 시스템이란 무엇인가?

데이터베이스를 제대로 이해하려면, 먼저 **데이터베이스가 왜 필요해졌는지**를 알아야 합니다. 그 출발점이 바로 **파일 시스템(File System)**입니다.

여러분이 지금 윈도우 탐색기를 열어보면, 수많은 폴더와 파일이 정리되어 있는 것을 볼 수 있죠? 문서 파일, 이미지 파일, 엑셀 파일 등이 폴더별로 나뉘어 저장되어 있습니다. 이처럼 **운영체제(OS)가 기본적으로 제공하는 파일 관리 방식**을 파일 시스템이라고 합니다.

> 파일 시스템은 오라클(Oracle)이나 MySQL 같은 별도의 소프트웨어 없이, **운영체제의 커널(운영체제의 핵심 엔진)** 차원에서 파일을 저장하고 관리하는 구조입니다.

비유하자면, 파일 시스템은 마치 **각자 자기 책상 서랍에 서류를 보관하는 방식**과 같습니다. 별도의 도서관 시스템 없이, 각자 자기가 필요한 서류를 자기 서랍에 넣어두고 꺼내 쓰는 것이죠. 컴퓨터가 처음 등장한 1960년대 이전부터 이 방식은 사용되어 왔고, 지금도 우리는 일상적으로 파일 시스템을 활용하고 있습니다.

### 파일 시스템의 기본 특성

파일 시스템에서는 **프로그래머가 물리적 데이터 구조(하드디스크에 실제로 데이터가 어떻게 저장되어 있는지)를 직접 알고 있어야만** 데이터에 접근하는 프로그램을 만들 수 있습니다. 즉, 데이터가 어디에, 어떤 형태로 저장되어 있는지를 프로그래머가 직접 파악해야 한다는 뜻입니다.

이 구조는 **나 혼자 사용할 때는 아무런 문제가 없습니다.** 마치 혼자 사는 집에서 냉장고에 음식을 넣고 꺼내는 것처럼, 내가 어디에 뭘 넣었는지 내가 알고 있으니까요. 하지만 **여러 사람이 동시에 같은 데이터를 사용해야 하는 상황**이 되면, 심각한 문제가 발생하기 시작합니다.

그 심각한 문제가 바로 오늘의 핵심 주제인 **중복성(Redundancy)**과 **종속성(Dependency)**입니다.

---

## 🔄 중복성(Redundancy) — 똑같은 데이터가 여기저기 흩어져 있는 문제

### 중복성이란?

**중복성**이란, 말 그대로 **똑같은 내용의 데이터가 여러 곳에 중복되어 저장되어 있는 상태**를 말합니다.

파일 시스템에서는 각 사용자(또는 각 부서)가 자신이 필요한 데이터를 **자기만의 파일로 따로 가지고 있습니다.** 예를 들어 회사에서 "고객 정보"가 필요한 부서가 세 곳이라면, 세 부서 모두 각자 고객 정보 파일을 복사해서 가지고 있는 것이죠.

> 마치 같은 교과서를 반 학생 30명이 각자 한 권씩 복사해서 가지고 있는 것과 같습니다. 한 명이 교과서 내용에 오타를 발견해서 수정했더라도, 나머지 29명의 교과서에는 여전히 오타가 남아 있겠죠?

### 구체적인 예시로 이해하기

A, B, C 세 명의 사용자가 `F1`이라는 **같은 파일**을 사용해야 하는 상황을 생각해 봅시다.

파일 시스템에서는 각자 `F1` 파일의 **복사본**을 가지고 작업합니다:

- **A 사용자**: F1 파일을 가지고 있음
- **B 사용자**: F1 파일을 가지고 있음 (복사본)
- **C 사용자**: F1 파일을 가지고 있음 (복사본)

이제 A가 `F1`의 내용을 수정해서 `F2`로 바꿨습니다. 그런데 B와 C는 이 사실을 모르고, 자기가 가진 `F1`을 그대로 사용하고 있습니다.

| 사용자 | 보유 파일 | 상태 |
|--------|-----------|------|
| A | F2 (수정됨) | ✅ 최신 데이터 |
| B | F1 (원본 그대로) | ❌ 옛날 데이터 |
| C | F1 (원본 그대로) | ❌ 옛날 데이터 |

이 상황에서 B가 자기 파일을 보고 업무를 처리하면, **이미 바뀐 정보를 모른 채 잘못된 데이터로 일을 하게 됩니다.** 이것이 바로 중복성이 만들어내는 대표적인 문제입니다.

### 중복성이 일으키는 4가지 문제

#### 1️⃣ 일관성 결여 — 데이터 불일치 발생

똑같은 데이터인데 어떤 곳에서는 수정되었고 어떤 곳에서는 수정되지 않았다면, **데이터 간의 불일치**가 발생합니다. 위 예시에서 A는 `F2`를, B와 C는 `F1`을 가지고 있으니, 세 사람이 가진 정보가 서로 다릅니다. 이렇게 되면 **어떤 것이 정확한 정보인지 알 수 없게 되고**, 결국 그 데이터는 신뢰할 수 없는 정보가 되어버립니다.

#### 2️⃣ 보안성 문제 — 동일 수준의 보안 유지가 어려움

데이터가 한 곳에만 있다면 그 한 곳만 철저하게 보안을 유지하면 됩니다. 하지만 **똑같은 데이터가 세 곳, 다섯 곳, 열 곳에 퍼져 있다면** 모든 곳에 동일한 수준의 보안을 적용하기가 매우 어렵습니다. 마치 금고가 한 개일 때는 경비를 세우기 쉽지만, 금고가 열 개로 분산되어 있으면 어딘가 한 곳은 보안에 구멍이 생길 수밖에 없는 것과 같습니다.

#### 3️⃣ 경제성 저하 — 비용이 여러 배로 증가

한 번만 수정하면 될 것을 **중복된 수만큼 반복해서 수정**해야 합니다. 3명이 중복 보유하고 있으면 3번 갱신해야 하고, 100명이 보유하고 있으면 100번 갱신해야 합니다. 갱신에 드는 시간과 노력, 즉 **갱신 비용이 기하급수적으로 늘어납니다.** 또한 **저장 공간** 측면에서도, 한 곳에 저장하면 될 데이터를 여러 곳에 중복 저장하니 디스크 공간이 낭비됩니다.

#### 4️⃣ 무결성(정확성) 유지 어려움

**무결성(Integrity)**이란 쉬운 말로 **데이터의 정확성**을 의미합니다. 중복된 데이터가 여기저기 흩어져 있으면, 어떤 데이터가 정확한 것인지 보장하기 어렵습니다. 결국 파일 시스템의 중복성은 **데이터의 정확성을 지키기 어렵게 만드는 근본적인 원인**이 됩니다.

:::warning 중복성의 핵심 위험
중복성의 가장 큰 문제는 **데이터 불일치**입니다. 여러 곳에 같은 데이터가 있을 때, 한 곳만 수정하고 나머지를 수정하지 않으면 정보가 서로 달라집니다. 이렇게 되면 어떤 것이 "진짜" 정보인지 알 수 없게 되어, 해당 데이터는 업무에 사용할 수 없는 쓸모없는 정보가 됩니다.
:::

### 그렇다면 중복은 무조건 나쁜 걸까?

흥미롭게도, 중복에는 **장점**도 있습니다.

- **가용성(Availability) 향상**: 원본이 고장 나더라도 복사본이 있으니 계속 사용할 수 있습니다. 마치 USB에 백업 파일을 넣어두면 컴퓨터가 고장 나도 데이터를 살릴 수 있는 것처럼요.
- **데이터 이동 최소화**: 각자 복사본을 가지고 있으므로, 다른 사이트에서 데이터를 가져올 필요가 없습니다.
- **장애 시 복구 용이**: 한쪽이 망가져도 다른 쪽의 복사본으로 복구할 수 있습니다.

하지만 이런 장점보다도 **무결성(데이터 정확성)을 지키기 어렵다는 단점**이 훨씬 크기 때문에, 여러 사람이 동시에 사용하는 환경에서는 파일 시스템의 중복 방식을 그대로 사용할 수 없는 것입니다.

:::info 데이터베이스에서의 중복 처리
나중에 배울 데이터베이스에서는 중복을 100% 제거하는 것이 아니라, **최소한의 중복**만 허용하고 이를 **통제된 중복**으로 관리합니다. 왜냐하면 중복을 완전히 없애면 성능이 떨어질 수 있기 때문입니다. 이 부분은 정규화(Normalization)와 역정규화(Denormalization)라는 개념에서 더 자세히 다루게 됩니다.
:::

---

## 🔗 종속성(Dependency) — 구조가 바뀌면 프로그램도 바꿔야 하는 문제

### 종속성이란?

**종속성**이란, **데이터의 저장 구조나 저장 방법이 바뀌면, 그 데이터를 사용하는 프로그램도 함께 바꿔야 하는 것**을 말합니다.

파일 시스템에서는 데이터의 구조(어떤 순서로 저장되어 있는지, 어떤 형식인지 등)와 프로그램이 **서로 꽉 묶여 있습니다.** 데이터 구조가 조금이라도 바뀌면, 그 데이터를 읽고 쓰는 프로그램의 코드도 수정해야 합니다.

### 비유로 이해하기

> 종속성은 마치 **열쇠와 자물쇠의 관계**와 같습니다. 자물쇠(데이터 구조)를 바꾸면, 반드시 열쇠(프로그램)도 새로 만들어야 문을 열 수 있죠. 자물쇠만 바꾸고 열쇠는 그대로 쓰면 문이 열리지 않습니다.

또 다른 비유를 들어볼게요. 여러분이 **택배를 보낼 때 주소 형식**이 정해져 있다고 합시다. "시/도 → 구/군 → 동/읍 → 번지" 순서로 적도록 되어 있는데, 어느 날 갑자기 주소 형식이 "번지 → 동/읍 → 구/군 → 시/도"로 바뀌었다면? 기존에 주소를 읽어서 배달하던 시스템(프로그램) 전체를 수정해야 합니다. 이것이 종속성입니다.

### 코드로 보는 종속성 문제

파일 시스템에서 학생 정보를 저장하고 읽는 간단한 예를 들어보겠습니다.

**❌ 파일 시스템 방식 — 종속성 문제가 발생하는 코드:**

```python
# ❌ 파일 시스템 방식: 데이터 구조가 프로그램에 직접 묶여 있음

# 학생 정보를 파일에서 읽는 프로그램
def read_student_file():
    file = open("student.txt", "r")  # student.txt 파일을 읽기 모드로 연다
    for line in file:                  # 파일의 각 줄을 반복한다
        data = line.split(",")         # 쉼표(,)로 데이터를 나눈다
        student_id = data[0]           # 첫 번째 값 = 학번 (위치 고정!)
        name = data[1]                 # 두 번째 값 = 이름 (위치 고정!)
        address = data[2]              # 세 번째 값 = 주소 (위치 고정!)
        print(f"학번: {student_id}, 이름: {name}, 주소: {address}")
    file.close()                       # 파일을 닫는다
```

위 코드에서 **`data[0]`이 학번, `data[1]`이 이름, `data[2]`가 주소**라는 것은 프로그래머가 파일의 구조를 정확히 알고 있기 때문에 가능한 것입니다. 그런데 만약 파일 구조가 바뀌어서 **학번과 이름 사이에 "학과" 항목이 추가**되었다면 어떻게 될까요?

```python
# ❌ 파일 구조가 바뀌었는데 프로그램을 수정하지 않은 경우

# student.txt 파일 내용이 바뀜:
# (기존) 학번,이름,주소
# (변경) 학번,학과,이름,주소   ← "학과" 항목이 추가됨!

def read_student_file():
    file = open("student.txt", "r")
    for line in file:
        data = line.split(",")
        student_id = data[0]           # 학번 ← 여전히 맞음
        name = data[1]                 # ❌ 이름이 아니라 "학과"가 들어옴!
        address = data[2]              # ❌ 주소가 아니라 "이름"이 들어옴!
        print(f"학번: {student_id}, 이름: {name}, 주소: {address}")
        # 출력 결과: 학번: 2024001, 이름: 컴퓨터공학, 주소: 홍길동
        # → 완전히 잘못된 결과가 나온다!
    file.close()
```

파일의 구조가 바뀌었으니, 프로그램도 반드시 수정해야 합니다:

```python
# ❌ 파일 구조 변경에 맞춰 프로그램도 수정해야 함 (종속적)

def read_student_file():
    file = open("student.txt", "r")
    for line in file:
        data = line.split(",")
        student_id = data[0]           # 첫 번째 값 = 학번
        department = data[1]           # 두 번째 값 = 학과 (새로 추가된 항목)
        name = data[2]                 # 세 번째 값 = 이름 (위치가 바뀜!)
        address = data[3]              # 네 번째 값 = 주소 (위치가 바뀜!)
        print(f"학번: {student_id}, 학과: {department}, 이름: {name}, 주소: {address}")
    file.close()
```

이제 올바른 결과가 나오지만, **파일 구조가 바뀔 때마다 프로그램을 매번 수정해야 합니다.** 만약 이 파일을 사용하는 프로그램이 10개, 100개라면? 모두 다 수정해야 합니다. 이것이 종속성의 무서움입니다.

**✅ 데이터베이스 방식 — 종속성 문제가 해결된 코드:**

```sql
-- ✅ 데이터베이스 방식: 데이터 구조와 프로그램이 독립적

-- 학생 테이블에서 학번, 이름, 주소를 조회한다
SELECT 학번, 이름, 주소
FROM 학생;

-- 테이블에 "학과" 컬럼이 추가되더라도
-- 위 SQL 쿼리는 수정할 필요가 없다!
-- "학번, 이름, 주소"만 요청했기 때문에 해당 데이터만 정확히 반환된다
```

```sql
-- ✅ 학과 컬럼이 추가된 후에도 기존 쿼리 그대로 사용 가능

-- 기존 쿼리 (수정 불필요!)
SELECT 학번, 이름, 주소
FROM 학생;
-- → 학과가 추가되었든, 전화번호가 추가되었든 상관없이
--   요청한 학번, 이름, 주소만 정확히 반환된다

-- 새 컬럼이 필요하면 그때만 쿼리를 추가하면 된다
SELECT 학번, 학과, 이름, 주소
FROM 학생;
```

데이터베이스에서는 **컬럼 이름(속성 이름)으로 데이터를 요청**하기 때문에, 테이블 구조가 바뀌어도 기존 프로그램을 수정할 필요가 없습니다. 이것이 바로 **자료 독립성(Data Independence)**이며, 데이터베이스가 파일 시스템의 종속성 문제를 해결한 핵심 방법입니다.

:::danger 종속성이 실무에서 위험한 이유
실제 기업 환경에서는 하나의 데이터 파일을 수십, 수백 개의 프로그램이 참조합니다. 파일 구조가 한 번 바뀌면 관련된 **모든 프로그램을 찾아서 수정**해야 하는데, 하나라도 빠뜨리면 시스템 오류가 발생합니다. 이 때문에 파일 시스템 환경에서는 데이터 구조를 바꾸는 것 자체를 극도로 꺼리게 되고, 이는 시스템 발전과 유지보수를 심각하게 방해합니다.
:::

---

## ⚖️ 중복성과 종속성 비교 — 한눈에 정리

중복성과 종속성은 파일 시스템의 **두 가지 근본적인 문제점**입니다. 둘 다 파일 시스템의 구조적 한계에서 비롯되지만, 문제의 성격은 서로 다릅니다.

| 구분 | 중복성 (Redundancy) | 종속성 (Dependency) |
|------|---------------------|---------------------|
| **정의** | 똑같은 데이터가 여러 곳에 중복 저장됨 | 데이터 구조가 바뀌면 프로그램도 바꿔야 함 |
| **비유** | 같은 책을 여러 권 복사해서 각자 보유 | 자물쇠를 바꾸면 열쇠도 새로 만들어야 함 |
| **핵심 문제** | 데이터 불일치(정확성 저하) | 유지보수 비용 증가 |
| **발생 원인** | 각 사용자/부서가 데이터를 따로 보유 | 프로그램이 데이터의 물리적 구조에 직접 의존 |
| **해결 방법** | 데이터 통합(한 곳에서 관리) | 자료 독립성(구조와 프로그램 분리) |
| **DB에서의 해결** | DBMS가 중복을 최소화하고 통제 | DBMS가 논리적/물리적 구조를 분리 |

> **핵심 요약**: 중복성은 "같은 데이터가 여러 곳에 있어서 생기는 문제"이고, 종속성은 "데이터 구조와 프로그램이 서로 묶여 있어서 생기는 문제"입니다. 데이터베이스(DBMS)는 이 두 가지 문제를 해결하기 위해 탄생했습니다.

---

## 🗄️ 데이터베이스는 어떻게 이 문제를 해결하는가?

### 데이터베이스의 탄생 배경

파일 시스템의 중복성과 종속성 문제가 점점 심각해지면서, 1960년대부터 이 문제를 근본적으로 해결할 수 있는 새로운 데이터 관리 방식이 연구되기 시작했습니다. 그 결과 탄생한 것이 바로 **데이터베이스(Database)**와 이를 관리하는 **DBMS(Database Management System, 데이터베이스 관리 시스템)**입니다.

### 통합된 데이터로 중복성 해결

데이터베이스의 첫 번째 핵심 특성은 **통합된 데이터(Integrated Data)**입니다.

여러 곳에 흩어져 있던 중복 데이터를 **한 곳으로 통합**하면서, 통합하는 과정에서 **중복을 제거**합니다. 마치 반 학생 30명이 각자 가지고 있던 교과서 복사본을 걷어내고, 교실에 **한 권의 원본 교과서**를 비치해서 모두가 그것을 보게 만드는 것과 같습니다.

```sql
-- ✅ 데이터베이스: 학생 정보가 하나의 테이블에 통합되어 있음

-- 학생 테이블 (단 하나만 존재)
CREATE TABLE 학생 (
    학번 VARCHAR(10) PRIMARY KEY,  -- 학번: 학생을 구별하는 고유 값 (기본키)
    이름 VARCHAR(50),               -- 이름: 학생의 이름
    학과 VARCHAR(50),               -- 학과: 소속 학과
    주소 VARCHAR(200)               -- 주소: 거주지 주소
);

-- A, B, C 사용자 모두 이 하나의 테이블을 공유해서 사용
-- 중복 저장이 발생하지 않으므로 데이터 불일치도 발생하지 않음
```

```sql
-- ✅ 한 곳에서 수정하면 모든 사용자가 즉시 최신 데이터를 볼 수 있음

-- A 사용자가 학생 주소를 변경
UPDATE 학생
SET 주소 = '서울시 강남구'  -- 주소를 '서울시 강남구'로 수정한다
WHERE 학번 = '2024001';     -- 학번이 2024001인 학생의 정보를

-- B, C 사용자가 조회하면 바로 변경된 주소가 보임
SELECT 학번, 이름, 주소
FROM 학생
WHERE 학번 = '2024001';
-- 결과: 2024001, 홍길동, 서울시 강남구 ← 최신 데이터!
```

:::tip 최소한의 중복과 통제된 중복
데이터베이스에서도 중복을 100% 제거하지는 않습니다. 성능 향상을 위해 의도적으로 일부 중복을 허용하는 경우가 있는데, 이를 **"통제된 중복(Controlled Redundancy)"**이라고 합니다. 중요한 것은 중복 자체를 없애는 것이 아니라, **중복을 DBMS가 인식하고 관리할 수 있도록 만드는 것**입니다.
:::

### 자료 독립성으로 종속성 해결

데이터베이스의 두 번째 핵심 특성은 **자료 독립(Data Independence)**입니다.

파일 시스템에서는 데이터 구조가 바뀌면 프로그램도 바꿔야 했지만, 데이터베이스에서는 **데이터 구조와 프로그램이 서로 독립**되어 있습니다. 데이터의 저장 방식이나 구조가 바뀌더라도, 프로그램은 수정하지 않고 그대로 사용할 수 있습니다.

이것이 가능한 이유는 데이터베이스가 사용자와 실제 저장 구조 사이에 **DBMS라는 중재자**를 두기 때문입니다.

```
❌ 파일 시스템:
  사용자/프로그램 ←→ 파일 (직접 연결, 종속적)

✅ 데이터베이스:
  사용자/프로그램 ←→ DBMS ←→ 데이터베이스 (DBMS가 중재, 독립적)
```

> DBMS는 마치 **레스토랑의 웨이터**와 같습니다. 손님(사용자)은 메뉴판(SQL)을 보고 원하는 음식을 주문하기만 하면 됩니다. 주방(데이터 저장 구조)에서 조리법이 바뀌든, 재료 보관 방법이 바뀌든, 손님은 전혀 신경 쓸 필요가 없죠. 웨이터(DBMS)가 알아서 중간에서 처리해 주니까요.

### DBMS의 3가지 필수 기능

DBMS는 파일 시스템의 문제를 해결하기 위해 **3가지 핵심 기능**을 제공합니다:

| 기능 | 설명 | 비유 |
|------|------|------|
| **정의 기능 (DDL)** | 데이터베이스의 구조(테이블)를 생성·수정·삭제 | 건물의 설계도를 그리는 것 |
| **조작 기능 (DML)** | 데이터를 검색·삽입·수정·삭제 | 건물 안에 가구를 배치하고 옮기는 것 |
| **제어 기능 (DCL)** | 무결성·보안·병행제어·권한 관리 | 건물의 보안 시스템과 관리 규칙을 운영하는 것 |

```sql
-- ✅ 정의 기능 (DDL): 테이블 구조를 만든다
CREATE TABLE 학생 (
    학번 VARCHAR(10) PRIMARY KEY,  -- 기본키(학생을 구별하는 고유 값) 지정
    이름 VARCHAR(50),               -- 이름 속성 정의
    주소 VARCHAR(200)               -- 주소 속성 정의
);
-- 이 명령으로 '학생'이라는 테이블의 구조(틀)가 만들어진다
```

```sql
-- ✅ 조작 기능 (DML): 데이터를 넣고, 조회하고, 수정하고, 삭제한다

-- 데이터 삽입: 학생 정보를 테이블에 넣는다
INSERT INTO 학생 (학번, 이름, 주소)
VALUES ('2024001', '홍길동', '서울시 종로구');

-- 데이터 조회: 학생 정보를 검색한다
SELECT 학번, 이름, 주소
FROM 학생
WHERE 이름 = '홍길동';  -- 이름이 '홍길동'인 학생을 찾는다

-- 데이터 수정: 학생의 주소를 변경한다
UPDATE 학생
SET 주소 = '서울시 강남구'  -- 주소를 변경한다
WHERE 학번 = '2024001';     -- 학번이 2024001인 학생의

-- 데이터 삭제: 학생 정보를 삭제한다
DELETE FROM 학생
WHERE 학번 = '2024001';     -- 학번이 2024001인 학생을 삭제한다
```

```sql
-- ✅ 제어 기능 (DCL): 권한과 보안을 관리한다

-- 특정 사용자에게 학생 테이블 조회 권한을 부여한다
GRANT SELECT ON 학생 TO user_kim;
-- user_kim이라는 사용자에게 학생 테이블을 조회할 수 있는 권한을 준다

-- 특정 사용자의 권한을 회수한다
REVOKE SELECT ON 학생 FROM user_kim;
-- user_kim에게 부여했던 조회 권한을 다시 빼앗는다
```

---

## 💡 파일 시스템 vs 데이터베이스 — 실생활 비유로 총정리

파일 시스템과 데이터베이스의 차이를 **"동네 게시판"**과 **"중앙 관리 시스템"**으로 비유해 보겠습니다.

### 🏘️ 파일 시스템 = 동네 게시판 방식

마을에 주민 공지사항을 전달해야 한다고 합시다. 파일 시스템 방식은 마을 곳곳에 게시판을 세우고, **같은 공지를 모든 게시판에 각각 붙이는 것**입니다.

- **A 게시판**, **B 게시판**, **C 게시판**에 모두 같은 공지를 붙임 (중복성)
- 공지 내용이 바뀌면 모든 게시판을 일일이 찾아다니며 수정해야 함 (경제성 저하)
- A 게시판만 수정하고 B, C를 깜빡하면 서로 다른 정보가 붙어 있게 됨 (데이터 불일치)
- 게시판 규격이 바뀌면 공지문의 크기도 맞춰서 다시 만들어야 함 (종속성)

### 🏢 데이터베이스 = 중앙 관리 시스템 방식

반면 데이터베이스 방식은 마을 중앙에 **하나의 전광판**을 설치하고, 모든 주민이 그 전광판을 보게 만드는 것입니다.

- 전광판은 **하나**만 있으므로 중복 없음 (중복성 해결)
- 공지를 수정하면 전광판 **하나만 수정**하면 모든 주민이 최신 정보를 봄 (일관성 유지)
- 전광판의 내부 구조가 바뀌어도 주민은 전광판 **화면만 보면** 됨 (종속성 해결)
- 전광판 관리인(DBMS)이 누가 수정할 수 있는지, 언제 수정되었는지 기록 (보안, 무결성)

---

## ⚠️ 주의사항과 실전 팁

### 파일 시스템이 항상 나쁜 것은 아닙니다

파일 시스템의 중복성과 종속성 문제를 배웠다고 해서, 파일 시스템 자체가 나쁜 것은 아닙니다. **혼자 사용하는 환경**이나 **단순한 데이터 관리**에는 파일 시스템이 오히려 더 적합할 수 있습니다.

:::note 언제 파일 시스템이 적합할까?
- 개인 프로젝트에서 간단한 설정 파일을 관리할 때
- 로그 파일처럼 순차적으로 기록만 하는 데이터
- 동시 접근이 거의 없는 소규모 데이터
- 이미지, 동영상 등 비정형 파일 자체를 저장할 때 (데이터베이스에는 파일의 경로나 메타데이터를 저장)
:::

### 데이터베이스도 단점이 있습니다

DBMS는 강력하지만, 도입하려면 **비용이 많이 듭니다.** 하드웨어 구매, 통신망 구축, DBMS 소프트웨어 라이선스 비용, 운영 인력 등이 필요합니다. 또한 시스템이 복잡하기 때문에 장애가 발생하면 **어디서 문제가 생겼는지 파악하기 어렵고**, 일부분의 오류가 **전체 시스템을 정지시킬 수 있는 위험성**이 있습니다.

:::warning 실무에서 주의할 점
데이터베이스를 도입할 때는 반드시 **비용 대비 효과**를 따져봐야 합니다. 소규모 프로젝트에 대규모 데이터베이스 시스템을 도입하는 것은 오히려 낭비일 수 있습니다. 반대로, 여러 사용자가 동시에 데이터를 공유해야 하는 환경에서 파일 시스템을 고집하는 것은 심각한 데이터 품질 문제를 초래할 수 있습니다.
:::

### 중복성과 종속성 개념은 시험에도 자주 나옵니다

데이터베이스 관련 자격증이나 학교 시험에서 "파일 시스템의 문제점"을 묻는 문제가 매우 빈번하게 출제됩니다. 핵심 키워드를 정확히 기억해 두세요:

- **중복성** → 데이터 불일치 → 일관성 결여 → 무결성(정확성) 유지 어려움
- **종속성** → 구조 변경 시 프로그램 수정 필수 → 유지보수 비용 증가

---

## 📌 핵심 정리

- **파일 시스템**은 운영체제가 기본 제공하는 파일 관리 방식으로, 별도의 DBMS 소프트웨어 없이 동작한다
- **중복성(Redundancy)**은 같은 데이터가 여러 곳에 중복 저장되어 있는 상태를 말한다
- 중복성은 **데이터 불일치, 보안 취약, 경제성 저하, 무결성(정확성) 유지 어려움**이라는 4가지 문제를 일으킨다
- 중복의 장점(가용성 향상, 장애 복구 용이)도 있지만, 동시 사용 환경에서는 단점이 훨씬 크다
- **종속성(Dependency)**은 데이터 구조가 바뀌면 프로그램도 함께 바꿔야 하는 문제를 말한다
- 종속성은 **유지보수 비용 증가**와 **시스템 변경의 어려움**을 초래한다
- 데이터베이스(DBMS)는 파일 시스템의 중복성과 종속성 문제를 해결하기 위해 탄생했다
- DBMS는 **통합된 데이터**로 중복성을, **자료 독립성**으로 종속성을 해결한다
- DBMS의 3가지 필수 기능: **정의(DDL) - 구조 생성**, **조작(DML) - 데이터 처리**, **제어(DCL) - 보안·무결성 관리**
- 데이터베이스에서도 중복을 완전히 제거하지 않고 **최소한의 통제된 중복**을 허용한다

작성일: 2026-02-20