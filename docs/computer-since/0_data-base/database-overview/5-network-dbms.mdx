---
title: "네트워크형 DBMS의 구조와 특징"
description: "네트워크형 DBMS의 구조와 특징에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/database-overview/5-network-dbms"
sidebar_label: "네트워크형 DBMS"
date: "2026-02-20"
---

## 🎯 데이터베이스의 탄생 배경: 파일 시스템의 한계

데이터베이스를 이해하려면 먼저 **데이터베이스가 왜 필요해졌는지**부터 알아야 합니다. 1960년대 이전, 컴퓨터에서 데이터를 저장하는 방법은 **파일 시스템(File System)**이 유일했습니다. 파일 시스템이란 여러분이 윈도우 탐색기에서 보는 것처럼, 폴더 안에 파일을 넣어서 관리하는 방식입니다. 이 파일 시스템은 별도의 소프트웨어 없이 **운영체제(OS)가 기본으로 제공하는 커널(핵심 프로그램) 수준에서 관리**됩니다. 즉, 오라클이나 MySQL 같은 특별한 소프트웨어가 필요 없고, 컴퓨터를 켜면 바로 사용할 수 있는 가장 기본적인 저장 방식인 것이죠.

하지만 파일 시스템에는 **두 가지 치명적인 문제**가 있었습니다.

### 🔴 중복성(Redundancy)의 문제

마치 학교에서 A, B, C 세 명의 학생이 같은 과제 파일을 각자 USB에 복사해서 가져간 상황을 떠올려 보세요. A가 자기 파일을 수정했는데, B와 C는 수정하지 않았다면 어떻게 될까요? A의 파일은 버전 2인데, B와 C의 파일은 여전히 버전 1입니다. 이렇게 **똑같은 데이터가 여러 곳에 중복 저장**되어 있으면, 누군가 하나를 수정했을 때 나머지가 자동으로 바뀌지 않기 때문에 **데이터 불일치(inconsistency)**가 발생합니다. 나 혼자 쓸 때는 아무 문제가 없지만, **여러 사람이 동시에 사용할 때** 이 문제가 터지는 것입니다.

### 🔴 종속성(Dependency)의 문제

종속성이란 **데이터의 저장 구조가 바뀌면 프로그램도 함께 바꿔야 하는 것**을 말합니다. 비유하자면, 냉장고(저장 구조)의 선반 위치를 바꿨더니, 요리 레시피(프로그램)까지 전부 다시 써야 하는 상황과 같습니다. 파일의 형태나 저장 방법이 바뀌면 그 파일을 사용하는 모든 프로그램을 일일이 수정해야 했기 때문에, 유지보수 비용이 엄청나게 높았습니다.

> 💡 **핵심 포인트**: 파일 시스템의 **중복성**과 **종속성** 문제를 해결하기 위해 등장한 것이 바로 **데이터베이스(Database)**라는 개념입니다.

---

## 📚 데이터베이스의 발전 역사: 파일 시스템에서 빅데이터까지

데이터베이스는 하루아침에 지금의 모습이 된 것이 아닙니다. 수십 년에 걸쳐 단계적으로 발전해 왔습니다. 각 시대별로 어떤 형태의 DBMS(데이터베이스 관리 시스템)가 등장했는지 살펴보겠습니다.

| 시대 | DBMS 유형 | 핵심 구조 | 주요 특징 |
|------|-----------|-----------|-----------|
| 1960년대 이전 | 파일 시스템 | 파일/폴더 | 운영체제가 관리, 중복성·종속성 문제 |
| 1960년대 | **계층형 DBMS** | 트리 구조 | 부모-자식 관계, 사이클 불가 |
| 1970년대 | **네트워크형 DBMS** | 그래프 구조 | 오너-멤버 관계, 사이클 허용 |
| 1980년대 | **관계형 DBMS** | 테이블 구조 | 가장 대중적, 현재 99.9% 사용 |
| 1990년대 | 객체지향 DBMS | 객체 구조 | 멀티미디어 처리, 배우기 어려움 |
| 1990년대 후반 | 객체관계 DBMS | 테이블+객체 | 관계형의 편리함 + 객체지향의 기능 |
| 2000년대~ | 빅데이터/데이터 마이닝 | 다양한 구조 | 24×7 운영, 의사결정 지원 |

### 🌳 계층형 DBMS (Hierarchical DBMS)

1960년대에 가장 먼저 개발된 데이터베이스 관리 시스템입니다. 회사 조직도를 떠올려 보세요. 사장 아래에 부장이 있고, 부장 아래에 과장이 있고, 과장 아래에 사원이 있는 **트리(나무) 구조**입니다. 위에 있는 것이 **부모(Parent)**, 아래에 있는 것이 **자식(Child)**이 됩니다.

중요한 특징은 **자식이 부모가 될 수 없다**는 것입니다. 정보의 흐름이 **위에서 아래로만** 내려가지, 아래에서 위로 거꾸로 올라갈 수 없습니다. 따라서 **사이클(순환)이 발생하지 않는** 구조입니다.

### 🕸️ 네트워크형 DBMS (Network DBMS)

계층형 DBMS의 한계(정보의 순환이 어려운 점)를 보완하기 위해 1970년대에 등장한 것이 바로 **네트워크형 DBMS**입니다. 이것이 오늘 문서의 핵심 주제이며, 아래 섹션에서 아주 자세히 다루겠습니다.

### 📊 관계형 DBMS (Relational DBMS)

현재 실무에서 **가장 많이 사용되는** DBMS 유형입니다. 성적표, 학사 관리 시스템 등 우리가 일상에서 접하는 거의 모든 데이터가 **테이블(표) 형태**로 저장됩니다. Oracle, MySQL, MSSQL 등이 대표적인 관계형 DBMS이며, IT 직무를 수행하는 사람의 99.9%가 이 관계형 데이터베이스를 사용하게 됩니다.

### 🎮 객체지향 DBMS와 객체관계 DBMS

관계형 DBMS는 텍스트나 숫자 같은 정형 데이터를 저장하기에는 좋지만, **동영상·사진·음악·지리 정보** 같은 멀티미디어 데이터를 저장하기에는 적합하지 않았습니다. 이를 해결하기 위해 Java나 C++ 같은 **객체지향 프로그래밍(OOP)** 기법에 데이터베이스 기본 기능을 접목한 **객체지향 DBMS**가 등장했습니다. 하지만 호환성 문제와 높은 학습 난이도 때문에 대중화되지 못했고, 이를 보완하여 **관계형의 편리함 + 객체지향의 기능**을 합친 **객체관계 DBMS**가 나오게 되었습니다.

---

## 🕸️ 네트워크형 DBMS의 구조: 그래프로 연결된 데이터 세계

### 왜 네트워크형 DBMS가 필요했을까?

계층형 DBMS는 **트리 구조**였기 때문에 정보가 위에서 아래로만 흐를 수 있었습니다. 마치 일방통행 도로처럼, 한 방향으로만 이동할 수 있고 되돌아올 수 없었던 것이죠. 현실 세계의 데이터 관계는 이렇게 단순하지 않습니다.

예를 들어, 한 명의 학생이 여러 과목을 수강하고, 한 과목에 여러 학생이 등록되어 있는 상황을 생각해 보세요. 계층형 구조에서는 "학생 → 과목" 방향으로만 관계를 표현할 수 있지, "과목 → 학생" 방향으로 동시에 표현하기 어렵습니다. **하나의 자식이 여러 부모를 가질 수 없기 때문**입니다.

이런 한계를 극복하기 위해 등장한 것이 바로 **네트워크형 DBMS**입니다.

### 네트워크형 DBMS의 핵심 구조: 그래프(Graph)

네트워크형 DBMS는 **그래프 구조**로 되어 있습니다. 그래프란 여러 개의 점(노드)과 그 점들을 연결하는 선(간선)으로 이루어진 구조입니다. 마치 지하철 노선도를 떠올려 보세요. 여러 역(노드)이 있고, 역과 역 사이를 노선(간선)이 연결합니다. 어떤 역에서든 다른 역으로 이동할 수 있고, 한 역이 여러 노선의 교차점이 될 수도 있습니다.

계층형 DBMS가 **일방통행 도로**라면, 네트워크형 DBMS는 **양방향 도로가 얽혀 있는 도시의 도로망**과 같습니다.

```
        [학과]
       ↗     ↘
   [학생] ←→ [교수]
       ↘     ↗
        [과목]
```

위 그림처럼, 학생은 학과와도 연결되고, 과목과도 연결되고, 교수와도 연결될 수 있습니다. 교수는 학과와도, 과목과도 연결됩니다. 이런 식으로 **어떤 개체든 다른 여러 개체와 자유롭게 관계를 맺을 수 있는 구조**가 바로 네트워크형 DBMS의 핵심입니다.

### 오너(Owner)와 멤버(Member) 관계

계층형 DBMS에서 **부모-자식**이라는 용어를 사용했다면, 네트워크형 DBMS에서는 **오너(Owner)-멤버(Member)**라는 용어를 사용합니다.

> 📌 **오너(Owner)**: 관계에서 주체가 되는 쪽. 계층형의 "부모"와 비슷하지만, 더 유연합니다.
> 📌 **멤버(Member)**: 관계에서 참여하는 쪽. 계층형의 "자식"과 비슷하지만, 핵심 차이가 있습니다.

핵심 차이점은 바로 이것입니다: **하나의 멤버가 동시에 다른 관계에서는 오너가 될 수 있습니다.** 마치 회사에서 김과장이 부장에게는 부하직원(멤버)이지만, 대리에게는 상사(오너)인 것처럼요. 그리고 더 나아가, **하나의 멤버가 여러 오너에 소속될 수도 있습니다.** 계층형에서는 한 자식이 오직 하나의 부모만 가질 수 있었지만, 네트워크형에서는 이 제한이 없어진 것입니다.

:::info 계층형 vs 네트워크형 비교

| 비교 항목 | 계층형 DBMS | 네트워크형 DBMS |
|-----------|-------------|-----------------|
| **데이터 구조** | 트리(Tree) | 그래프(Graph) |
| **관계 표현** | 부모-자식(Parent-Child) | 오너-멤버(Owner-Member) |
| **사이클 허용** | ❌ 불가 | ✅ 가능 |
| **자식/멤버의 부모/오너 수** | 반드시 1개 | 여러 개 가능 |
| **정보 흐름** | 위→아래 단방향 | 다방향 자유 이동 |
| **데이터 접근** | 루트부터 순서대로 | 여러 경로로 접근 가능 |

:::

### 사이클(Cycle) 허용: 네트워크형의 가장 큰 특징

**사이클이란 출발점에서 시작해서 다시 출발점으로 돌아올 수 있는 경로**를 말합니다. 마치 서울에서 부산으로 가고, 부산에서 대구로 가고, 대구에서 다시 서울로 돌아올 수 있는 것처럼요.

계층형 DBMS에서는 이것이 불가능했습니다. A → B → C로 내려갈 수는 있지만, C에서 다시 A로 돌아가는 경로는 존재하지 않았습니다. 하지만 네트워크형 DBMS에서는 **A → B → C → A로 되돌아오는 순환 경로가 허용**됩니다.

이것이 왜 중요할까요? 현실 세계에서는 데이터 간의 관계가 순환적인 경우가 매우 많기 때문입니다. 예를 들어:

- 부품 A는 부품 B를 포함하고, 부품 B는 부품 C를 포함하고, 부품 C는 다시 부품 A에 사용될 수 있습니다.
- 직원 A가 프로젝트 X를 관리하고, 프로젝트 X의 결과가 다시 직원 A의 평가에 반영됩니다.

이런 복잡한 현실 세계의 관계를 표현하기 위해 **사이클 허용**은 필수적이었던 것입니다.

---

## 🛠️ 네트워크형 DBMS의 실제 구조 살펴보기

### 레코드 타입과 세트 타입

네트워크형 DBMS에서 데이터를 구성하는 두 가지 기본 단위를 알아보겠습니다.

**레코드 타입(Record Type)**은 관계형 DBMS의 테이블에 해당하는 개념입니다. 하나의 개체(Entity)를 표현합니다. 예를 들어 "학생", "과목", "교수" 각각이 하나의 레코드 타입입니다.

**세트 타입(Set Type)**은 두 레코드 타입 사이의 관계를 나타냅니다. 하나의 오너 레코드 타입과 하나의 멤버 레코드 타입이 연결된 것이 하나의 세트 타입입니다. 마치 "교수가 학생을 지도한다"라는 관계에서 "교수"가 오너, "학생"이 멤버, "지도"가 세트 타입이 되는 것입니다.

```
[교수] ---(지도 세트)--→ [학생]
 오너                     멤버
```

이때 **하나의 오너에 여러 멤버가 연결**될 수 있습니다. 한 교수가 여러 학생을 지도할 수 있는 것처럼요. 그리고 핵심적으로, **하나의 멤버가 여러 세트의 멤버**가 될 수 있습니다.

```
[교수] ---(지도 세트)--→ [학생] ←---(소속 세트)--- [학과]
 오너                     멤버                      오너
```

위 구조에서 "학생"은 "지도 세트"에서는 교수의 멤버이면서, 동시에 "소속 세트"에서는 학과의 멤버입니다. 계층형에서는 이런 **다중 부모 관계**를 표현할 수 없었지만, 네트워크형에서는 자연스럽게 가능합니다.

### 구조를 코드로 이해하기

네트워크형 DBMS는 현재 실무에서 거의 사용되지 않지만, 그 개념을 이해하기 위해 의사코드(pseudocode)로 구조를 살펴보겠습니다.

:::warning 현대에서의 네트워크형 DBMS
네트워크형 DBMS는 1970~80년대에 주로 사용되었으며, 현재는 관계형 DBMS로 대체되었습니다. 하지만 그 구조적 개념(그래프 관계, 다대다 관계 표현)은 현대 데이터베이스 설계의 기초가 되므로 반드시 이해해야 합니다.
:::

❌ **잘못된 예시 – 계층형으로 다대다 관계를 표현하려는 경우:**

```sql
-- 계층형 구조에서는 학생이 하나의 학과에만 소속 가능
-- 한 학생이 복수 전공(두 개의 학과)을 하는 상황을 표현할 수 없음

-- 학과 (부모)
--   └── 학생 (자식) ← 이 학생이 다른 학과에도 소속? 불가능!

-- 컴퓨터공학과
--   └── 홍길동    ← 홍길동은 오직 컴퓨터공학과의 자식
-- 경영학과
--   └── 홍길동?   ← 같은 홍길동을 또 넣으면 데이터 중복 발생!
```

위 코드의 문제를 한 줄씩 설명하겠습니다:
- **1~2번 줄**: 계층형 구조에서는 자식 노드가 반드시 하나의 부모만 가질 수 있다는 제약을 설명합니다.
- **4~5번 줄**: 학과(부모) 아래에 학생(자식)이 위치하는 전형적인 트리 구조입니다.
- **7~8번 줄**: "홍길동"이라는 학생이 컴퓨터공학과의 자식으로 등록되었습니다.
- **9~10번 줄**: 같은 "홍길동"을 경영학과 아래에도 넣고 싶지만, 그렇게 하면 동일한 데이터가 두 곳에 중복 저장되어 데이터 불일치 문제가 발생합니다.

✅ **올바른 예시 – 네트워크형으로 다대다 관계를 표현하는 경우:**

```sql
-- 네트워크형 구조에서는 멤버가 여러 오너에 소속 가능
-- 한 학생이 복수 전공(두 개의 학과)을 하는 상황을 자연스럽게 표현

-- 레코드 타입 정의
-- RECORD TYPE: 학과 (오너 역할)
-- RECORD TYPE: 학생 (멤버 역할)

-- 세트 타입 정의
-- SET TYPE: 소속 (학과 → 학생)

-- 컴퓨터공학과 ---소속--→ 홍길동 ←---소속--- 경영학과
--                          ↑
--                    (하나의 레코드가 여러 오너에 연결!)

-- 홍길동은 하나의 레코드로 존재하면서
-- 컴퓨터공학과와 경영학과 모두에 연결됨 → 중복 없음!
```

위 코드의 핵심을 한 줄씩 설명하겠습니다:
- **1~2번 줄**: 네트워크형의 핵심 장점인 "멤버가 여러 오너에 소속 가능"을 선언합니다.
- **4~6번 줄**: 레코드 타입을 정의합니다. "학과"는 오너 역할, "학생"은 멤버 역할을 합니다.
- **8~9번 줄**: 세트 타입 "소속"을 정의하여 학과와 학생 사이의 관계를 설정합니다.
- **11~13번 줄**: 핵심 부분입니다. "홍길동"이라는 하나의 학생 레코드가 "컴퓨터공학과"와 "경영학과" 두 오너에 동시에 연결되어 있습니다.
- **15~16번 줄**: 데이터 중복 없이 복수 전공 관계를 깔끔하게 표현할 수 있음을 보여줍니다.

:::tip 현대적 관점에서 보는 네트워크형 구조
현대의 관계형 DBMS에서는 이런 다대다(M:N) 관계를 **중간 테이블(연결 테이블)**을 만들어서 해결합니다. 네트워크형 DBMS의 "멤버가 여러 오너에 연결"되는 개념이 관계형에서는 "중간 테이블"로 발전한 것이라고 이해할 수 있습니다.
:::

---

## 🔍 데이터베이스의 핵심 정의와 특성

네트워크형 DBMS를 포함한 모든 데이터베이스가 공통적으로 가지는 정의와 특성을 정리해 보겠습니다.

### 데이터베이스란 무엇인가?

누군가 "데이터베이스가 뭐예요?"라고 물어본다면, 다음과 같이 대답할 수 있어야 합니다:

> 📌 **데이터베이스(Database)란** 어떤 조직(기업, 학교 등)에서 업무 수행과 의사결정에 활용하기 위해, 여러 사용자가 **공용(함께 사용)**할 수 있도록, 흩어져 있는 데이터를 **통합**하여, **하드디스크에 저장**해 놓은, 조직의 고유한 기능을 수행하기 위한 **운영 데이터의 집합**입니다.

이 정의에는 4가지 핵심 키워드가 담겨 있습니다:

**1. 통합된 데이터 (Integrated Data)**

여러 곳에 흩어져 있던 데이터를 한 곳으로 모으면서 **중복을 제거**한 데이터입니다. 마치 여러 지점에 분산되어 있던 고객 명부를 하나로 합치면서 중복된 고객 정보를 정리하는 것과 같습니다. 단, 100% 중복 제거가 아니라 **최소한의 중복**은 허용하며, 이를 **통제된 중복**이라고 합니다. 왜냐하면 중복을 완전히 제거하면 오히려 성능이 떨어질 수 있기 때문입니다.

**2. 저장된 데이터 (Stored Data)**

종이 문서로 캐비넷에 보관된 것이 아니라, **디지털 형태로 하드디스크(저장 장치)**에 저장된 데이터입니다.

**3. 운영 데이터 (Operational Data)**

단순히 아무 데이터나 모아놓은 것이 아닙니다. 각 조직이 **고유한 기능을 수행하기 위해 반드시 유지해야 하는 데이터**입니다. 학사 관리 시스템이라면 학생 정보·수강 정보·성적 정보가, 생산 관리 시스템이라면 제품 정보·공정 정보·재고 정보가 운영 데이터가 됩니다.

**4. 공용 데이터 (Shared Data)**

나 혼자 사용하는 것이 아니라, 조직 내의 **여러 사용자가 공동으로 소유하고 이용**하는 데이터입니다.

### 데이터베이스의 4가지 일반적 특성

| 특성 | 설명 | 실생활 예시 |
|------|------|-------------|
| **실시간 접근성** | 언제 어디서나 원하는 데이터에 즉시 접근 가능 | 네이버에 언제든 접속하여 정보 검색 |
| **계속적인 변화** | 데이터가 실시간으로 갱신되어 항상 최신 상태 유지 | 날씨 정보, 뉴스 기사, 교통 정보가 실시간 업데이트 |
| **동시 공용** | 여러 사용자가 동시에 접근해도 충돌 없이 사용 가능 | 수천 명이 동시에 구글에 접속해도 문제 없음 |
| **내용에 의한 참조** | 데이터의 위치가 아니라 값(내용)으로 검색 | "점수가 90점 이상인 학생"을 조건으로 검색 |

동시에 여러 사용자가 접근해도 충돌이 발생하지 않는 이유는 **병행제어(Concurrency Control)**라는 기법 덕분입니다. 마치 교차로에서 신호등이 차량의 흐름을 조절하듯, 병행제어가 여러 사용자의 데이터 접근을 조절해주는 것입니다.

---

## ⚙️ 데이터베이스의 3가지 주요 특징: 추상화, 독립성, 자기정의

### 🎭 자료 추상(Data Abstraction) – 복잡함을 감추다

**왜 필요한가?** 데이터베이스 내부의 하드디스크에는 0과 1의 이진수, 16진수, 트랙과 섹터 등 매우 복잡한 형태로 데이터가 저장되어 있습니다. 만약 사용자가 이 모든 내부 구조를 알아야만 데이터베이스를 사용할 수 있다면, 일반인은 절대 데이터베이스를 쓸 수 없을 것입니다.

자료 추상이란 이런 **복잡한 내부 구조를 감추고, 사용자가 쉽게 사용할 수 있는 형태로 데이터를 제공**하는 것입니다. 다른 말로 **개념화** 또는 **일반화**라고도 합니다.

비유하자면, 자동차를 운전할 때 엔진 내부의 피스톤 동작 원리나 연료 분사 시스템을 몰라도 핸들과 페달만으로 운전할 수 있는 것과 같습니다. 복잡한 내부가 **감춰져 있기 때문에** 누구나 쉽게 사용할 수 있는 것입니다.

### 🔗 자료 독립(Data Independence) – 구조가 바뀌어도 프로그램은 그대로

**왜 필요한가?** 파일 시스템에서는 파일 구조가 바뀌면 그 파일을 사용하는 모든 프로그램을 함께 수정해야 했습니다(종속성 문제). 데이터베이스에서는 **자료 구조와 프로그램이 서로 독립**되어 있어서, 데이터 구조가 변경되어도 프로그램을 수정하지 않고 그대로 사용할 수 있습니다.

비유하자면, 도서관의 책꽂이 배치(데이터 구조)가 바뀌어도 도서 검색 시스템(프로그램)은 여전히 정상적으로 작동하는 것과 같습니다. 이 덕분에 **유지보수가 훨씬 용이**해집니다.

### 📖 자기정의(Self-describing) – 스스로를 설명하는 데이터베이스

**왜 필요한가?** 데이터베이스를 만들면, "누가 만들었는지", "언제 만들었는지", "어떤 권한이 설정되어 있는지", "속성은 몇 개인지", "크기는 얼마인지" 같은 **데이터베이스 자체에 대한 정보**가 필요합니다.

데이터베이스는 이런 정보를 스스로 만들어서 **메타데이터(Metadata, 데이터에 대한 데이터)**로 저장합니다. 이 메타데이터는 **데이터 사전(Data Dictionary)** 또는 **카탈로그(Catalog)**라는 별도의 저장소에 보관됩니다.

비유하자면, 도서관에 있는 책 한 권 한 권이 데이터라면, 도서관의 목록 카드(제목, 저자, 분류번호 등이 적힌)가 바로 메타데이터입니다. 도서관은 새 책이 들어올 때마다 자동으로 목록 카드를 만들어 관리합니다.

---

## 🧩 데이터베이스의 구성 요소: 개체, 속성, 관계

### 개체(Entity) – 데이터베이스가 표현하는 대상

**개체**란 데이터베이스가 표현하려고 하는 **유형·무형의 정보 대상**입니다. "학생", "교수", "과목" 등이 각각 하나의 개체입니다. 개체는 서로 구별할 수 있어야 하며, 단독으로 존재할 수 있고, 하나 이상의 속성으로 구성됩니다. 파일 시스템에서는 **레코드(Record)**에 해당합니다.

### 속성(Attribute) – 개체를 설명하는 특성

**속성**이란 개체의 특성이나 상태를 기술하는 것입니다. "학생"이라는 개체에는 "학번", "이름", "주소" 같은 속성이 있습니다. 속성은 **가장 작게 쪼갤 수 있는 논리적 단위**이며, 개체 없이 속성만 단독으로 존재할 수는 없습니다. 파일 시스템에서는 **필드(Field)** 또는 **항목**이라고 합니다.

**도메인(Domain)**이란 하나의 속성이 가질 수 있는 **값의 범위**입니다. 예를 들어 "점수"라는 속성의 도메인은 0~100입니다. 이 범위를 벗어나는 값(예: -10이나 150)은 입력될 수 없습니다.

### 관계(Relationship) – 개체와 개체를 이어주는 연결

**관계**란 개체와 개체 사이의 연결을 의미합니다. "교수가 학생을 지도한다"에서 "지도"가 바로 관계입니다. 관계에는 세 가지 유형이 있습니다:

- **1:1 관계** – 한 명의 학생에 하나의 학생증 (일대일)
- **1:N 관계** – 한 명의 교수가 여러 학생을 지도 (일대다)
- **M:N 관계** – 여러 학생이 여러 과목을 수강 (다대다)

네트워크형 DBMS는 바로 이 **M:N(다대다) 관계를 직접적으로 표현할 수 있다**는 점에서 계층형 DBMS보다 강력했습니다.

또한 관계는 개체 간뿐 아니라 **속성과 속성 사이**에도 존재합니다. 예를 들어 "학번"이라는 속성은 "이름", "주소" 등 나머지 속성을 **결정(기본키)**합니다. 학번이 정해지면 나머지 정보가 자동으로 결정되는 **주종 관계**가 있는 것입니다.

### 용어 정리: 구조 vs 실제 값

| 구분 | 다른 이름들 | 설명 |
|------|-------------|------|
| **개체 타입(구조)** | 스키마, 인텐션, 내포 | 학번·이름·학과라는 **틀(구조)** |
| **개체 집합(실제 값)** | 인스턴스, 튜플 집합, 어커런스, 외연 | 20230001·홍길동·컴공 같은 **실제 데이터** |

비유하자면, 개체 타입은 **빈 성적표 양식**이고, 개체 집합은 **실제로 점수가 기입된 성적표**입니다.

---

## 🏗️ DBMS의 구조와 필수 기능

### DBMS란 무엇인가?

**DBMS(Database Management System, 데이터베이스 관리 시스템)**는 사용자와 데이터베이스 사이에서 **중재자 역할**을 하는 소프트웨어입니다.

```
[사용자/응용 프로그램] ←→ [DBMS] ←→ [데이터베이스]
```

마치 은행 창구 직원처럼, 고객(사용자)이 직접 금고(데이터베이스)에 들어가는 것이 아니라, 창구 직원(DBMS)을 통해 입출금(데이터 조작)을 하는 것입니다. 여러분이 ATM기에서 돈을 이체할 때, 네이버에서 정보를 검색할 때, 모두 DBMS를 거쳐서 데이터베이스에 접근하고 있는 것입니다.

### DBMS의 3가지 필수 기능

```sql
-- ✅ 1. 정의 기능 (DDL - Data Definition Language)
-- 데이터베이스의 구조(테이블)를 만들고, 수정하고, 삭제하는 기능
CREATE TABLE 학생 (        -- 학생이라는 테이블(구조)을 만듦
    학번 INT PRIMARY KEY,   -- 학번 속성을 기본키로 지정
    이름 VARCHAR(50),       -- 이름 속성 정의
    주소 VARCHAR(200)       -- 주소 속성 정의
);
-- 이 명령이 실행되면 메타데이터가 카탈로그(데이터 사전)에 자동 저장됨
```

- **1번 줄**: `CREATE TABLE`은 새로운 테이블 구조를 생성하는 DDL 명령입니다.
- **2번 줄**: `학번`이라는 속성을 정수(INT) 타입으로 만들고, `PRIMARY KEY`(기본키)로 지정합니다. 기본키는 각 레코드를 유일하게 식별하는 속성입니다.
- **3번 줄**: `이름`이라는 속성을 최대 50자의 문자열로 정의합니다.
- **4번 줄**: `주소`라는 속성을 최대 200자의 문자열로 정의합니다.
- **마지막 줄**: DDL 명령이 실행되면 DBMS가 자동으로 이 테이블에 대한 메타데이터를 생성하여 데이터 사전에 저장합니다(자기정의 특성).

```sql
-- ✅ 2. 조작 기능 (DML - Data Manipulation Language)
-- 구조 안에 데이터를 삽입, 검색, 수정, 삭제하는 기능
INSERT INTO 학생 VALUES (20230001, '홍길동', '서울시');  -- 데이터 삽입
SELECT * FROM 학생 WHERE 학번 = 20230001;               -- 데이터 검색
UPDATE 학생 SET 주소 = '부산시' WHERE 학번 = 20230001;   -- 데이터 수정
DELETE FROM 학생 WHERE 학번 = 20230001;                  -- 데이터 삭제
```

- **3번 줄**: `INSERT INTO`로 학생 테이블에 새로운 레코드(학번 20230001, 이름 홍길동, 주소 서울시)를 삽입합니다.
- **4번 줄**: `SELECT`로 학번이 20230001인 학생의 모든 정보를 검색합니다.
- **5번 줄**: `UPDATE`로 학번이 20230001인 학생의 주소를 '부산시'로 수정합니다.
- **6번 줄**: `DELETE`로 학번이 20230001인 학생의 레코드를 삭제합니다.

```sql
-- ✅ 3. 제어 기능 (DCL - Data Control Language)
-- 데이터의 정확성, 보안, 권한, 병행제어 등을 관리하는 기능
GRANT SELECT ON 학생 TO user1;    -- user1에게 학생 테이블 조회 권한 부여
REVOKE SELECT ON 학생 FROM user1; -- user1에게서 학생 테이블 조회 권한 회수
COMMIT;                           -- 작업 내용을 확정(저장)
ROLLBACK;                         -- 작업 내용을 되돌림(복구)
```

- **3번 줄**: `GRANT`로 특정 사용자에게 데이터 접근 권한을 부여합니다.
- **4번 줄**: `REVOKE`로 부여된 권한을 회수합니다.
- **5번 줄**: `COMMIT`으로 지금까지의 작업을 최종 확정합니다.
- **6번 줄**: `ROLLBACK`으로 문제가 발생했을 때 이전 상태로 되돌립니다.

:::danger DBMS 없이 데이터베이스에 직접 접근하면 안 됩니다
DBMS를 거치지 않고 데이터베이스 파일에 직접 접근하면, 데이터의 무결성(정확성)이 깨지고, 보안이 뚫리며, 동시 접근 시 충돌이 발생할 수 있습니다. 반드시 DBMS라는 중재자를 통해 접근해야 합니다.
:::

### DBMS의 장점과 단점

**장점:**
- 데이터 **중복 제어** 가능
- 여러 사용자의 **동시 접근** 지원
- 데이터 **일관성(consistency)** 유지
- 데이터 **무결성(정확성)** 보장
- **보안** 유지 (권한 관리)
- **표준화**된 개발 방법론 제공
- **백업 및 회복** 기능 제공
- 개발 기간 단축, 유지보수 용이

**단점:**
- 하드웨어·소프트웨어·통신 인프라 등 **운영 비용이 많이 듦**
- 시스템이 **복잡**하여 장애 발생 시 원인 파악이 어려움
- **일부 장애가 전체 시스템을 마비**시킬 수 있는 위험성
- **해킹** 등의 보안 위협에 전체 데이터가 파괴될 가능성

---

## 🖥️ DBMS의 내부 동작 구조: 데이터가 처리되는 과정

DBMS 내부에서 데이터가 어떤 과정을 거쳐 처리되는지 사용자 유형별로 살펴보겠습니다.

### 사용자 유형 3가지

| 사용자 유형 | 사용하는 언어 | 역할 |
|-------------|---------------|------|
| **일반 사용자** | 질의어(Query Language) | 궁금한 정보를 질의어로 입력하여 검색 |
| **응용 프로그래머** | 호스트 언어 + DML | Java 등의 프로그램에 DB 언어를 넣어 개발 |
| **데이터베이스 관리자(DBA)** | DDL (정의어) | 데이터베이스 구조를 만들고 관리 |

### 일반 사용자의 데이터 처리 흐름

```
일반 사용자가 질의어 입력
    ↓
질의어 처리기(Query Processor)에서 명령어 확인
    ↓
런타임 데이터베이스 처리기에서 실행
(이때 트랜잭션 관리자가 권한·무결성·병행제어·회복 검사)
    ↓
문제 없으면 저장 데이터 관리자가 하드디스크에 저장/조회
```

### 응용 프로그래머의 데이터 처리 흐름

응용 프로그래머가 Java 같은 호스트 언어 안에 SQL(DML)을 넣어서 프로그램을 작성하면, **DML 예비 컴파일러(Precompiler)**가 호스트 언어 코드와 데이터베이스 코드를 **분리**합니다. 왜냐하면 Java는 Java 컴파일러가, SQL은 DML 컴파일러가 각각 컴파일해야 하기 때문입니다.

```
응용 프로그램 (Java 코드 + SQL 코드)
    ↓
DML 예비 컴파일러가 두 코드를 분리
    ↓                    ↓
Java 컴파일러        DML 컴파일러
(Java 코드 처리)     (SQL 코드 처리)
                         ↓
              런타임 데이터베이스 처리기에서 실행
                         ↓
              저장 데이터 관리자가 저장/조회
```

### 데이터베이스 관리자(DBA)의 데이터 처리 흐름

DBA가 DDL(테이블 생성·수정·삭제)을 실행하면, DDL 컴파일러가 컴파일하여 **카탈로그(데이터 사전)**에 메타데이터를 저장합니다. 구조를 만드는 작업이므로 런타임 실행 과정 없이 바로 사전에 저장됩니다.

```
DBA가 DDL 명령 실행 (CREATE TABLE, ALTER TABLE 등)
    ↓
DDL 컴파일러가 컴파일
    ↓
카탈로그(데이터 사전)에 메타데이터 저장
```

### 각 모듈의 역할 정리

| 모듈 | 역할 |
|------|------|
| **질의어 처리기** | 사용자가 입력한 질의문을 파싱(토큰 단위로 쪼개기)하고 분석하여 어떤 명령인지 확인 |
| **DML 예비 컴파일러** | 호스트 언어(Java 등)와 DB 언어(SQL)를 분리하는 역할 |
| **DML 컴파일러** | DML 명령어를 파싱하고 컴파일하여 실행 가능한 형태로 변환 |
| **DDL 컴파일러** | DDL 명령어를 컴파일하여 카탈로그에 메타데이터 저장 |
| **런타임 DB 처리기** | 실제 프로그램(명령)을 실행하는 모듈 |
| **트랜잭션 관리자** | 무결성 검사, 권한 검사, 병행제어, 회복 작업 수행 |
| **저장 데이터 관리자** | 운영체제에 저장 명령을 내려서 실제 하드디스크에 데이터를 읽고 쓰는 역할 |

:::note 파싱(Parsing)이란?
파싱이란 문장을 작은 단위(토큰)로 쪼개서 의미를 분석하는 과정입니다. 마치 "SELECT * FROM 학생"이라는 문장을 "SELECT", "*", "FROM", "학생"으로 나누어서 각각이 어떤 역할을 하는지 파악하는 것과 같습니다.
:::

---

## ⚠️ 주의사항과 실무 팁

### 네트워크형 DBMS의 한계와 현대적 의미

:::warning 네트워크형 DBMS는 현재 거의 사용되지 않습니다
네트워크형 DBMS는 그래프 구조의 복잡성 때문에 데이터 구조 변경이 어렵고, 프로그래밍이 복잡하며, 관계형 DBMS에 비해 사용하기 불편합니다. 1980년대 이후 관계형 DBMS가 등장하면서 사실상 대체되었습니다. 하지만 **그래프 데이터베이스(Graph Database)**라는 형태로 현대에 다시 주목받고 있으므로, 네트워크형의 기본 개념을 이해하는 것은 여전히 중요합니다.
:::

### 데이터베이스 학습 시 자주 하는 실수

❌ **"데이터베이스 = 테이블"이라고 생각하는 것**
→ 테이블은 **관계형 DBMS**의 구조입니다. 데이터베이스는 계층형(트리), 네트워크형(그래프), 관계형(테이블), 객체지향형(객체) 등 다양한 구조를 가질 수 있습니다.

❌ **중복은 무조건 나쁘다고 생각하는 것**
→ 중복이 있으면 **가용성(한쪽이 고장 나도 다른 쪽을 사용 가능)**이 좋아지고, 사이트 간 데이터 이동을 줄일 수 있습니다. 다만, 무결성(데이터 정확성)을 해치는 **통제되지 않은 중복**이 문제인 것입니다.

❌ **논리적 구조와 물리적 구조가 별개라고 생각하는 것**
→ 둘은 **같은 데이터**를 바라보는 관점의 차이일 뿐입니다. 사용자가 보는 관점(논리적 구조)이냐, 저장 장치가 보는 관점(물리적 구조)이냐에 따라 달라지는 것이지, 따로 따로 존재하는 것이 아닙니다. 둘은 **1:1 대응 관계**를 가집니다.

### 네트워크형과 관계형의 실무적 비교

```sql
-- ❌ 네트워크형 DBMS 방식 (포인터 기반 탐색 - 복잡하고 유지보수 어려움)
-- 학과 레코드에서 포인터를 따라가서 학생 레코드를 찾아야 함
-- FIND FIRST 학과 WHERE 학과명 = '컴퓨터공학'
-- FIND NEXT 학생 WITHIN 소속  -- 소속 세트를 따라 다음 학생으로 이동
-- 포인터를 하나씩 따라가며 탐색 → 코드가 길고 복잡해짐
```

```sql
-- ✅ 관계형 DBMS 방식 (SQL 기반 - 간결하고 직관적)
SELECT 학생.이름, 학과.학과명           -- 원하는 정보를 명시
FROM 학생                               -- 학생 테이블에서
JOIN 학과 ON 학생.학과코드 = 학과.학과코드  -- 학과 테이블과 연결
WHERE 학과.학과명 = '컴퓨터공학';       -- 컴퓨터공학과 학생만 필터링
```

위 두 코드를 비교하면:
- **네트워크형**: 포인터를 하나씩 따라가며 데이터를 탐색해야 합니다. 구조가 바뀌면 포인터 경로도 수정해야 하므로 유지보수가 어렵습니다.
- **관계형**: SQL이라는 선언적 언어로 "무엇을 원하는지"만 명시하면 DBMS가 알아서 처리합니다. 구조가 바뀌어도 SQL 문 수정이 최소화됩니다.

이것이 바로 관계형 DBMS가 네트워크형 DBMS를 대체하게 된 핵심 이유입니다.

---

## 📌 핵심 정리

- **파일 시스템**은 운영체제가 관리하며, **중복성**과 **종속성** 문제로 인해 다수 사용자 환경에 부적합하다
- **데이터베이스**는 통합·저장·운영·공용 데이터의 집합으로, 파일 시스템의 문제를 해결하기 위해 탄생했다
- **계층형 DBMS**는 트리 구조(부모-자식 관계)이며, 사이클이 발생하지 않고 정보가 위→아래로만 흐른다
- **네트워크형 DBMS**는 그래프 구조(오너-멤버 관계)이며, **사이클을 허용**하고 멤버가 여러 오너에 소속 가능하다
- **관계형 DBMS**는 테이블 구조로 현재 가장 대중적이며, Oracle·MySQL·MSSQL 등이 대표적이다
- 데이터베이스의 4가지 특성: **실시간 접근성, 계속적인 변화, 동시 공용, 내용에 의한 참조**
- 데이터베이스의 3가지 주요 특징: **자료 추상(복잡함을 감춤)**, **자료 독립(구조와 프로그램 분리)**, **자기정의(메타데이터를 사전에 저장)**
- **DBMS**는 사용자와 데이터베이스 사이의 중재자 소프트웨어이다
- DBMS의 3가지 필수 기능: **정의 기능(DDL)**, **조작 기능(DML)**, **제어 기능(DCL)**
- 데이터베이스 구성 요소: **개체(Entity)**, **속성(Attribute)**, **관계(Relationship)**
- **도메인(Domain)**은 속성이 가질 수 있는 값의 범위이다
- 중복은 **무결성(정확성)** 문제를 야기하지만, **가용성** 측면에서는 장점이 될 수 있다

작성일: 2026-02-20