---
title: "파일 시스템의 개념과 한계"
description: "파일 시스템의 개념과 한계에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/database-overview/1-file-system"
sidebar_label: "파일 시스템"
date: "2026-02-20"
---

## 🎯 데이터베이스, 왜 배워야 할까?

IT 분야에서 일하게 되면 **데이터베이스(Database)**는 피할 수 없는 핵심 기술입니다. 웹 사이트를 만들든, 앱을 개발하든, 시스템을 운영하든 결국 모든 데이터는 어딘가에 저장되고 관리되어야 합니다. 네이버에서 검색할 때, ATM기에서 돈을 이체할 때, 학교의 학사 관리 시스템에서 성적을 조회할 때 — 이 모든 것 뒤에는 데이터베이스가 있습니다.

그런데 데이터베이스가 처음부터 지금의 모습이었던 것은 아닙니다. 컴퓨터가 처음 세상에 나왔을 때는 **파일 시스템(File System)**이라는 방식으로 데이터를 관리했습니다. 마치 서류를 종이에 적어서 캐비닛에 넣어두는 것처럼, 컴퓨터에도 파일이라는 형태로 데이터를 저장했던 것이죠.

이번 글에서는 **파일 시스템이 무엇인지**, 그리고 **왜 파일 시스템만으로는 부족해서 데이터베이스가 등장하게 되었는지**를 아주 자세하게 살펴보겠습니다. 데이터베이스의 발전 과정부터 정의, 특징, DBMS의 구조까지 폭넓게 다루니 천천히 따라오시면 됩니다.

> 💡 **핵심 한 줄 요약**: 파일 시스템의 한계(중복성과 종속성)를 극복하기 위해 데이터베이스가 탄생했습니다.

---

## 📁 파일 시스템이란 무엇인가?

### 파일 시스템의 기본 개념

**파일 시스템(File System)**이란 컴퓨터의 **운영체제(OS, Operating System)**가 파일을 저장하고 관리하는 기본적인 방식입니다. 여러분이 윈도우 탐색기를 열어보면 수많은 폴더와 파일들이 정리되어 있는 것을 볼 수 있죠? 그것이 바로 파일 시스템입니다.

비유하자면, **파일 시스템은 마치 집에 있는 서랍장**과 같습니다. 서랍마다 이름표를 붙여놓고, 필요한 서류를 해당 서랍에 넣어두는 것이죠. "영수증" 서랍, "계약서" 서랍, "사진" 서랍 이런 식으로요. 운영체제가 이 서랍장을 관리해주는 것입니다.

파일 시스템의 중요한 특징은 **별도의 특별한 소프트웨어가 필요 없다**는 것입니다. 데이터베이스를 사용하려면 오라클(Oracle), MySQL, MSSQL 같은 전문 소프트웨어를 설치해야 하지만, 파일 시스템은 운영체제가 기본적으로 지원하는 **커널(Kernel, 운영체제의 핵심 부분)** 수준에서 관리됩니다. 윈도우를 설치하면 바로 파일을 저장할 수 있는 것처럼요.

### 파일 시스템의 작동 방식

파일 시스템에서 데이터를 사용하려면, **프로그래머가 물리적인 데이터 구조를 직접 알고 있어야** 합니다. 하드디스크에 데이터가 어떤 형태로 저장되어 있는지, 어떤 방식으로 접근해야 하는지를 프로그램 코드에 직접 작성해야 한다는 뜻입니다.

이것은 마치 **도서관에서 책을 찾을 때, 사서도 없고 검색 시스템도 없어서 직접 책장의 몇 번째 줄, 몇 번째 칸에 무슨 책이 있는지 외워야 하는 것**과 비슷합니다. 책장의 배치가 바뀌면? 처음부터 다시 외워야 하죠.

:::info 파일 시스템의 역사
파일 시스템은 1960년대 이전, 컴퓨터가 처음 등장했을 때부터 사용되어 온 가장 오래된 데이터 관리 방식입니다. 지금도 여전히 사용되고 있지만, 여러 사람이 동시에 데이터를 관리해야 하는 환경에서는 심각한 문제를 가지고 있습니다.
:::

---

## ⚠️ 파일 시스템의 두 가지 치명적 한계

파일 시스템에는 좋은 점도 있지만, **두 가지 치명적인 문제점**이 있습니다. 바로 **중복성(Redundancy)**과 **종속성(Dependency)**입니다. 이 두 가지 문제가 결국 데이터베이스의 탄생으로 이어지게 됩니다.

### 🔄 중복성(Redundancy) — 똑같은 데이터가 여기저기에!

**중복성**이란 **똑같은 내용의 데이터가 여러 곳에 중복되어 저장되는 문제**입니다.

예를 들어볼까요? 회사에 A, B, C 세 사람이 있고, 이 세 사람이 모두 "고객목록.xlsx"라는 파일을 사용한다고 가정합시다. 파일 시스템에서는 각자 자기 컴퓨터에 이 파일의 복사본을 가지고 작업합니다.

```
📂 A의 컴퓨터: 고객목록.xlsx (원본)
📂 B의 컴퓨터: 고객목록.xlsx (복사본)
📂 C의 컴퓨터: 고객목록.xlsx (복사본)
```

어느 날, A가 고객 전화번호를 수정했습니다. 그런데 B와 C는 수정 사실을 모릅니다. 결과적으로:

```
📂 A의 컴퓨터: 고객목록.xlsx → 전화번호 010-1234-5678 (수정됨 ✅)
📂 B의 컴퓨터: 고객목록.xlsx → 전화번호 010-9999-0000 (옛날 정보 ❌)
📂 C의 컴퓨터: 고객목록.xlsx → 전화번호 010-9999-0000 (옛날 정보 ❌)
```

이것이 바로 **데이터 불일치(Inconsistency)**입니다. 같은 고객인데 누가 보느냐에 따라 전화번호가 다르니, 어떤 정보가 정확한 건지 알 수가 없게 됩니다.

#### 중복성으로 인한 구체적 문제점

| 문제점 | 설명 | 비유 |
|---|---|---|
| **일관성 결여** | 같은 데이터인데 내용이 서로 달라짐 | 같은 사람의 주소록이 친구마다 다른 것 |
| **보안 취약** | 여러 곳에 분산되어 있어 동일 수준의 보안 유지가 어려움 | 금고가 3개면 3개 모두 잠가야 하는 것 |
| **경제성 저하** | 한 번만 수정하면 될 것을 3번 수정해야 함 | 편지를 100통 수정하는 것 |
| **저장 공간 낭비** | 같은 내용이 여러 곳에 저장되어 디스크 공간 낭비 | 같은 책을 3권 사서 보관하는 것 |
| **무결성(정확성) 훼손** | 결국 데이터의 정확성을 보장할 수 없음 | 진짜 답이 뭔지 아무도 모르는 상태 |

:::warning 중복성의 핵심 문제
나 혼자 파일을 사용할 때는 아무런 문제가 없습니다. 하지만 **여러 사람이 동시에 사용할 때** 중복성 문제가 폭발적으로 발생합니다. 현대의 IT 시스템은 수백, 수천 명이 동시에 접근하기 때문에 파일 시스템만으로는 감당할 수 없습니다.
:::

#### 중복의 장점도 있다?

물론 중복이 100% 나쁜 것만은 아닙니다. 똑같은 데이터가 여러 곳에 있으면:

- **가용성(Availability)** 향상: 하나가 고장 나도 다른 곳의 데이터를 쓸 수 있습니다
- **사이트 간 이동 최소화**: 멀리 있는 서버까지 데이터를 가져오지 않아도 됩니다
- **장애 처리 용이**: 복구할 때 다른 복사본을 활용할 수 있습니다

하지만 이런 장점보다 **데이터의 정확성(무결성)을 지키기 어렵다는 단점이 훨씬 크기 때문에**, 동시에 여러 사람이 사용하는 시스템에서는 파일 시스템을 그대로 사용할 수 없습니다.

### 🔗 종속성(Dependency) — 파일 구조가 바뀌면 프로그램도 바꿔야!

**종속성**이란 **데이터의 저장 방법이나 구조가 바뀌면, 그 데이터를 사용하는 프로그램도 함께 바꿔야 하는 문제**입니다.

비유하자면, **집 주소가 바뀔 때마다 택배 회사, 은행, 보험사, 학교 등 모든 곳에 일일이 연락해서 주소를 바꿔야 하는 상황**과 같습니다. 하나를 바꾸면 연쇄적으로 다른 모든 것을 바꿔야 하니 유지보수가 매우 어렵죠.

파일 시스템에서 데이터 파일의 구조를 변경하면, 그 파일을 읽는 프로그램의 코드도 전부 수정해야 합니다. 아래 예시를 보겠습니다.

❌ **잘못된 상황 (파일 시스템 — 종속성 문제)**

```c
// 기존 파일 구조: 이름(20자) + 나이(4자) = 24바이트
// 프로그램이 파일 구조를 직접 알고 있어야 함

struct Student {
    char name[20];  // 이름은 20바이트 고정
    int age;        // 나이는 4바이트 정수형
};

// 파일에서 학생 정보를 읽는 함수
void readStudent(FILE *fp) {
    struct Student s;
    fread(&s, sizeof(struct Student), 1, fp);  // 24바이트를 한 번에 읽음
    printf("이름: %s, 나이: %d\n", s.name, s.age);
}
```

```c
// ⚠️ 파일 구조가 변경됨: "전화번호" 필드가 추가됨!
// 이름(20자) + 나이(4자) + 전화번호(15자) = 39바이트
// → 프로그램도 반드시 수정해야 함! (종속성)

struct Student {
    char name[20];   // 이름은 20바이트 고정
    int age;         // 나이는 4바이트 정수형
    char phone[15];  // 전화번호 15바이트 추가됨!
};

// 기존 프로그램이 그대로면 24바이트만 읽어서 데이터가 깨짐!
// 반드시 프로그램을 수정해야 함
void readStudent(FILE *fp) {
    struct Student s;
    fread(&s, sizeof(struct Student), 1, fp);  // 이제 39바이트를 읽어야 함
    printf("이름: %s, 나이: %d, 전화번호: %s\n", s.name, s.age, s.phone);
}
```

파일의 구조에 필드 하나만 추가해도, 그 파일을 사용하는 **모든 프로그램**을 찾아서 수정해야 합니다. 프로그램이 10개면 10개를 다 바꿔야 하고, 100개면 100개를 다 바꿔야 합니다. 이것이 종속성의 문제입니다.

✅ **올바른 상황 (데이터베이스 — 독립성 보장)**

```sql
-- 데이터베이스에서는 테이블 구조가 바뀌어도 기존 쿼리가 그대로 동작합니다

-- 기존 테이블에 전화번호 컬럼 추가
ALTER TABLE student ADD phone VARCHAR(15);

-- 기존에 작성한 쿼리는 그대로 사용 가능!
-- 프로그램을 수정할 필요가 없음
SELECT name, age FROM student;  -- 여전히 정상 동작 ✅
```

데이터베이스에서는 **자료 구조(테이블)와 프로그램이 서로 독립**되어 있습니다. 테이블에 컬럼이 추가되어도 기존 프로그램은 수정 없이 그대로 동작합니다. 이것이 **자료 독립성(Data Independence)**이며, 파일 시스템의 종속성을 해결한 핵심 개념입니다.

---

## 🚀 파일 시스템의 한계를 넘어 — 데이터베이스의 발전 과정

파일 시스템의 중복성과 종속성 문제를 해결하기 위해 데이터베이스가 탄생했습니다. 데이터베이스는 시대에 따라 여러 형태로 발전해왔는데, 그 과정을 순서대로 살펴보겠습니다.

### 1️⃣ 파일 시스템 (1960년대 이전)

앞에서 자세히 설명한 것처럼, 운영체제가 파일을 관리하는 가장 원시적인 방식입니다. 나 혼자 사용할 때는 문제가 없지만, 여러 사람이 동시에 사용하면 중복성과 종속성 문제가 발생합니다.

### 2️⃣ 계층형 DBMS (1960년대)

**계층형 DBMS(Hierarchical DBMS)**는 최초로 개발된 데이터베이스 관리 시스템입니다. 데이터를 **트리(Tree) 구조**, 즉 **나무를 뒤집어 놓은 형태**로 관리합니다.

회사 조직도를 생각하면 쉽습니다. 사장이 맨 위에 있고, 그 밑에 부장, 부장 밑에 과장, 과장 밑에 대리... 이런 식으로 **위에서 아래로만** 내려가는 구조입니다.

```
        [사장]           ← 부모(Parent)
       /      \
    [부장A]  [부장B]      ← 자식(Child)이면서 부모
    /    \       \
 [과장1] [과장2] [과장3]  ← 자식(Child)
```

**핵심 특징:**
- **부모-자식 관계**: 위에 있는 것이 부모, 아래에 있는 것이 자식
- **단방향 흐름**: 정보가 위에서 아래로만 흐릅니다. 자식이 부모가 될 수 없습니다
- **사이클(순환) 불가**: A → B → C → A 처럼 돌고 도는 구조가 불가능합니다

:::note 계층형 DBMS의 한계
위에서 아래로만 탐색할 수 있기 때문에, 데이터 간의 복잡한 관계를 표현하기 어렵습니다. 예를 들어, 한 직원이 두 부서에 동시에 소속되어 있는 경우를 표현하기 어렵죠.
:::

### 3️⃣ 네트워크형 DBMS (1970년대)

계층형 DBMS의 단방향 한계를 극복하기 위해 등장한 것이 **네트워크형 DBMS(Network DBMS)**입니다. 트리 구조 대신 **그래프(Graph) 구조**를 사용합니다.

```
    [A] ←→ [B]
     ↕    ↗  ↕
    [C] ←→ [D]
```

**핵심 특징:**
- **오너-멤버(Owner-Member) 관계**: 부모-자식 대신 오너-멤버라는 표현을 사용합니다
- **사이클(순환) 허용**: A → B → D → A처럼 돌고 도는 구조가 가능합니다
- **멤버가 다른 오너가 될 수 있음**: 더 유연한 관계 표현이 가능합니다

계층형보다 유연하지만, 구조가 복잡해서 사용하기 어려운 단점이 있었습니다.

### 4️⃣ 관계형 DBMS (1980년대~현재) ⭐

현재 가장 널리 사용되는 것이 바로 **관계형 DBMS(Relational DBMS, RDBMS)**입니다. 데이터를 **표(테이블, Table)** 형태로 관리합니다. 여러분이 엑셀에서 보는 스프레드시트를 떠올리면 됩니다.

```
┌──────┬────────┬──────────┐
│ 학번  │  이름   │   학과    │
├──────┼────────┼──────────┤
│ 1001 │ 김철수  │ 컴퓨터공학 │
│ 1002 │ 이영희  │ 경영학    │
│ 1003 │ 박민수  │ 전자공학   │
└──────┴────────┴──────────┘
```

**핵심 특징:**
- **테이블 구조**: 행(Row)과 열(Column)로 데이터를 깔끔하게 정리
- **표준화**: SQL이라는 표준 질의 언어가 있어서 배우기 쉽고 적용하기 쉬움
- **대중성**: 오라클(Oracle), MySQL, MSSQL, PostgreSQL 등 다양한 제품이 존재

> IT 회사에서 개발자, 시스템 설계자, 운영자 등 어떤 직무를 수행하든, **99.9%는 관계형 데이터베이스를 사용**하게 됩니다. 그만큼 관계형 DBMS는 현대 IT의 근간입니다.

### 5️⃣ 객체지향 DBMS (1990년대)

관계형 DBMS는 텍스트나 숫자 같은 **정형 데이터**를 다루기에는 훌륭하지만, **동영상, 사진, 음악, 지리 정보(GIS), CAD 데이터** 같은 멀티미디어 데이터를 테이블에 그대로 넣기는 어렵습니다. 테이블 칸에 동영상을 어떻게 집어넣겠어요?

그래서 등장한 것이 **객체지향 DBMS(Object-Oriented DBMS)**입니다. Java, C++ 같은 **객체지향 프로그래밍(OOP, Object-Oriented Programming)** 기법에 데이터베이스의 기본 기능을 접목한 것입니다.

하지만 객체지향 DBMS는 **호환성 문제**, **배우기 어려움** (클래스, 다형성, 상속 등 복잡한 개념), **대중화 실패** 등의 이유로 특정 분야에서만 제한적으로 사용되었습니다.

### 6️⃣ 객체관계 DBMS (1990년대 후반~)

객체지향 DBMS의 단점을 보완하기 위해, **관계형 DBMS의 대중성과 사용 편의성**에 **객체지향의 멀티미디어 처리 기능**을 결합한 것이 **객체관계 DBMS(Object-Relational DBMS)**입니다. 쉬우면서도 멀티미디어 데이터까지 다룰 수 있어 훨씬 효율적입니다.

### 7️⃣ 현재와 미래 (2000년대~)

현재의 데이터베이스는 **빅데이터(Big Data)**, **데이터 마이닝(Data Mining, 방대한 데이터에서 유용한 패턴을 찾아내는 기술)**, **AI(인공지능)**, **클라우드(Cloud)** 등의 분야에서 활발히 활용되고 있습니다. **24×7**(24시간 × 7일, 즉 연중무휴)로 멈추지 않고 돌아가는 시스템이 요구됩니다.

| 시대 | DBMS 유형 | 구조 | 핵심 특징 |
|---|---|---|---|
| 1960년대 이전 | 파일 시스템 | 파일/폴더 | 운영체제가 관리, 중복성·종속성 문제 |
| 1960년대 | 계층형 DBMS | 트리(부모-자식) | 단방향, 사이클 불가 |
| 1970년대 | 네트워크형 DBMS | 그래프(오너-멤버) | 양방향, 사이클 허용 |
| 1980년대~ | **관계형 DBMS** ⭐ | **테이블(표)** | **표준화, 대중화, 가장 많이 사용** |
| 1990년대 | 객체지향 DBMS | 객체 | 멀티미디어 처리, 대중화 실패 |
| 1990년대 후반~ | 객체관계 DBMS | 테이블+객체 | 관계형+객체지향의 장점 결합 |
| 2000년대~ | 현대 DBMS | 다양 | 빅데이터, AI, 클라우드, 24×7 운영 |

---

## 📖 데이터베이스의 정의 — 한마디로 뭐라고 설명할까?

누군가 "데이터베이스가 뭐예요?"라고 물어보면, 정확하게 답할 수 있어야 합니다. 단순히 "정보를 저장하는 거야"라고 하면 부족합니다. 데이터베이스의 정의에는 **네 가지 핵심 키워드**가 포함되어야 합니다.

> **데이터베이스란?**
> 어떤 조직(기업, 학교 등)에서 업무와 의사결정에 활용하기 위해, 여러 사람이 **공용(Shared)**으로 사용할 수 있도록, 흩어져 있는 데이터를 **통합(Integrated)**하고, 하드디스크에 **저장(Stored)**하며, 조직의 고유한 기능을 수행하기 위한 **운영(Operational)** 데이터의 집합입니다.

### 🔹 통합된 데이터 (Integrated Data)

**통합**이란 여러 곳에 흩어져 있는 데이터를 한 곳으로 모으면서 **중복을 제거**하는 것입니다. 마치 여러 서랍에 나눠져 있던 서류를 하나의 큰 캐비닛으로 정리하면서 같은 서류가 두 장 있으면 한 장만 남기는 것과 같습니다.

단, **100% 중복 제거가 아니라 "최소한의 중복", "통제된 중복"을 허용**합니다. 중복을 완전히 없애버리면 오히려 성능이 떨어질 수 있기 때문입니다. 이 부분은 나중에 정규화(Normalization)와 역정규화(Denormalization)에서 자세히 다루게 됩니다.

### 🔹 저장된 데이터 (Stored Data)

데이터베이스는 종이 문서가 아니라 **디지털 형태로 하드디스크(저장장치)**에 저장되어 있습니다. 캐비닛에 파일로 보관하는 것이 아니라, 컴퓨터가 빠르게 읽고 쓸 수 있는 형태로 디스크에 저장되어 있다는 뜻입니다.

### 🔹 운영 데이터 (Operational Data)

각 조직의 고유한 기능을 수행하기 위해 **반드시 유지해야 하는 데이터**로 구성됩니다. 학사 관리 시스템이면 학생, 교수, 강의, 성적 등의 데이터가 필요하고, 생산 관리 시스템이면 제품, 재고, 주문 등의 데이터가 필요합니다. 쓸모없는 데이터를 마구 넣는 것이 아니라, 조직 운영에 꼭 필요한 데이터만 관리합니다.

### 🔹 공용 데이터 (Shared Data)

**나 혼자 쓰는 것이 아니라, 조직의 여러 사용자가 함께 소유하고 유지하며 이용**하는 데이터입니다. 파일 시스템에서 각자 복사본을 가지고 쓰던 것과는 근본적으로 다릅니다. 하나의 데이터베이스를 여러 사람이 동시에 공유하면서 사용하는 것이죠.

---

## ⚙️ 데이터베이스의 핵심 특징

### 일반적 특징 4가지

데이터베이스는 다음과 같은 **네 가지 일반적 특징**을 가지고 있습니다.

**1. 실시간 접근(Real-Time Accessibility)**: 언제 어디서나 데이터에 접근할 수 있어야 합니다. 네이버에 접속하고 싶을 때 바로 접속할 수 있는 것처럼, 사용자가 원할 때 즉시 데이터를 조회할 수 있어야 합니다.

**2. 계속적인 변화(Continuous Evolution)**: 데이터는 실시간으로 갱신됩니다. 날씨 정보, 뉴스 기사, 교통 정보 등이 끊임없이 바뀌듯이, 데이터베이스의 내용은 삽입, 수정, 삭제를 통해 항상 **최신 상태**를 유지합니다.

**3. 동시 공유(Concurrent Sharing)**: 네이버에 수만 명이 동시에 접속해도 충돌 없이 각자 원하는 정보를 이용할 수 있죠? 이것이 가능한 이유는 **병행제어(Concurrency Control)**라는 기법 덕분입니다. 여러 사용자의 요청이 충돌하지 않도록 DBMS가 알아서 조율해줍니다.

**4. 내용에 의한 참조(Content Reference)**: 데이터를 찾을 때 "하드디스크의 몇 번째 섹터"처럼 물리적 위치로 찾는 것이 아니라, **데이터의 내용(값)으로 검색**합니다. "점수가 90점 이상인 학생을 찾아줘"라고 하면, 내부적으로 점수 값을 비교해서 해당하는 데이터를 꺼내주는 것입니다.

### 세 가지 핵심 특성

데이터베이스에는 세 가지 더 깊은 핵심 특성이 있습니다.

#### 🔸 자료 추상(Data Abstraction)

**자료 추상**이란 **복잡한 내부 구조를 감추고 사용자가 쉽게 사용할 수 있도록 하는 것**입니다. 다른 말로 **개념화** 또는 **일반화**라고도 합니다.

하드디스크 내부는 트랙과 섹터로 나뉘어 있고, 데이터는 0과 1의 이진수, 16진수 등 기계어로 저장되어 있습니다. 원래라면 사용자가 이런 것들을 모두 알아야 데이터에 접근할 수 있습니다. 하지만 데이터베이스는 이 복잡한 내용을 전부 숨겨주고, 사용자에게는 **테이블, 행, 열** 같은 쉬운 개념만 보여줍니다.

비유하자면, **자동차를 운전할 때 엔진의 원리를 몰라도 핸들과 페달만으로 운전할 수 있는 것**과 같습니다. 내부의 복잡한 메커니즘은 감춰져 있고, 사용자에게는 간단한 인터페이스만 제공되는 것이죠.

#### 🔸 자료 독립(Data Independence)

**자료 독립**이란 **데이터의 구조가 바뀌어도 프로그램을 변경하지 않아도 되는 것**입니다. 파일 시스템에서의 "종속성" 문제를 정반대로 해결한 것이죠.

테이블에 새로운 컬럼을 추가하거나, 데이터의 저장 방식을 변경해도, 기존에 작성한 프로그램은 수정 없이 그대로 동작합니다. 이를 통해 **유지보수가 훨씬 쉬워집니다**.

#### 🔸 자기 정의(Self-Describing)

데이터베이스는 자기 자신에 대한 정보를 스스로 정의하고 저장합니다. 누가 만들었는지, 언제 만들었는지, 권한은 어떻게 설정되어 있는지, 크기는 얼마인지, 속성은 몇 개인지 — 이런 **데이터에 대한 데이터**를 **메타데이터(Metadata)**라고 하며, 이것은 **데이터 사전(Data Dictionary)**이라는 별도의 공간에 저장됩니다.

비유하자면, **도서관에 있는 도서 목록 카드**와 같습니다. 책(데이터) 자체와는 별개로, 책의 제목, 저자, 출판년도, 위치 등의 정보(메타데이터)가 별도로 관리되는 것이죠.

---

## 🧩 데이터베이스의 구성 요소

데이터베이스를 이해하려면 **개체(Entity)**, **속성(Attribute)**, **관계(Relationship)** 이 세 가지 구성 요소를 반드시 알아야 합니다.

### 개체 (Entity) — "무엇을 표현할 것인가?"

**개체**란 데이터베이스가 표현하려고 하는 **유형·무형의 정보 대상**입니다. "학생", "교수", "강의", "제품" 같은 것들이 개체입니다. 서로 구별할 수 있어야 하고, 단독으로 존재할 수 있습니다. 관계형 데이터베이스에서 개체는 보통 **하나의 레코드(행, Row)**에 해당합니다.

하나의 개체는 **하나 이상의 속성**으로 구성됩니다. 예를 들어, "학생"이라는 개체는 학번, 이름, 주소 등의 속성을 가집니다.

### 속성 (Attribute) — "어떤 정보를 가지고 있는가?"

**속성**이란 개체의 **특성이나 상태를 기술하는 가장 작은 논리적 단위**입니다. "학생" 개체의 속성은 학번, 이름, 주소, 전화번호 등이 될 수 있습니다. 파일 시스템에서는 **항목(Item)** 또는 **필드(Field)**라고 불렀습니다.

중요한 점은, **개체가 없으면 속성만 단독으로 존재할 수 없다**는 것입니다. "이름"이라는 속성은 "학생"이라는 개체가 있어야 의미가 있죠. 이름만 덩그러니 있으면 누구의 이름인지 알 수 없습니다.

#### 도메인 (Domain)

**도메인(Domain)**이란 **하나의 속성이 취할 수 있는 값의 범위**입니다. 예를 들어:
- "점수" 속성의 도메인: 0~100 (0점부터 100점까지만 입력 가능)
- "학년" 속성의 도메인: 1, 2, 3, 4 (1~4학년만 가능)
- "성별" 속성의 도메인: '남', '여'

도메인을 설정하면 엉뚱한 값이 들어오는 것을 방지할 수 있습니다. 점수에 150점이 입력되거나, 학년에 7이 입력되는 것을 막아주는 것이죠.

### 관계 (Relationship) — "개체와 개체는 어떻게 연결되는가?"

**관계**란 개체와 개체 사이, 또는 속성과 속성 사이의 **연결 관계**를 의미합니다.

예를 들어, "학생" 개체와 "교수" 개체 사이에 "지도"라는 관계가 있을 수 있습니다. "한 명의 교수가 여러 명의 학생을 지도한다" — 이것이 바로 **1:N(1대다) 관계**입니다.

```
[교수] ──지도──→ [학생]
 (1)              (N)

예: 김교수 → 학생A, 학생B, 학생C
```

관계의 유형은 세 가지입니다:

| 관계 유형 | 설명 | 예시 |
|---|---|---|
| **1:1** (일대일) | 하나의 개체가 하나의 개체와 연결 | 한 사람 — 하나의 주민번호 |
| **1:N** (일대다) | 하나의 개체가 여러 개체와 연결 | 한 교수 — 여러 학생 |
| **N:M** (다대다) | 여러 개체가 여러 개체와 연결 | 여러 학생 — 여러 강의 |

또한 속성과 속성 사이에도 관계가 있습니다. "학번"이 나머지 속성(이름, 주소 등)을 **결정**하는 **주종 관계**가 그 예입니다. 학번을 알면 이름, 주소 등을 알 수 있죠. 이때 학번을 **기본키(Primary Key)**라고 합니다. 마치 주민번호가 한 국민의 모든 정보를 대표하는 것처럼요.

:::tip 개체 타입과 개체 집합의 차이
- **개체 타입(Entity Type)**: 구조를 의미합니다. "학번, 이름, 학과"라는 틀. 다른 말로 **스키마(Schema)**, **인텐션(Intension)**이라고도 합니다.
- **개체 집합(Entity Set)**: 실제 값의 모음입니다. "1001/김철수/컴퓨터공학" 같은 실제 데이터. 다른 말로 **인스턴스(Instance)**, **익스텐션(Extension)**, **어커런스(Occurrence)**라고도 합니다.
:::

---

## 🏗️ 데이터베이스의 논리적 구조와 물리적 구조

같은 데이터라도 **누구의 관점에서 보느냐**에 따라 두 가지로 나뉩니다.

| 구분 | 논리적 구조 | 물리적 구조 |
|---|---|---|
| **관점** | 사용자가 보는 관점 | 저장 장치(디스크)가 보는 관점 |
| **데이터 단위** | 논리적 레코드 | 저장 레코드 |
| **비유** | 엑셀 표에서 보는 깔끔한 데이터 | 하드디스크 내부의 0과 1 |

이 둘은 별도로 존재하는 것이 아니라, **같은 데이터를 다른 관점에서 본 것**입니다. 하드디스크에 저장된 하나의 데이터를 사용자는 테이블 형태로 보고, 컴퓨터 내부에서는 물리적 저장 형식으로 관리하는 것이죠. 당연히 **1:1 대응 관계**를 가지고 있습니다.

파일 시스템에서는 프로그래머가 이 물리적 구조를 직접 알아야 했지만, 데이터베이스에서는 **자료 추상** 덕분에 사용자는 논리적 구조만 알면 됩니다.

---

## 🛠️ DBMS(데이터베이스 관리 시스템)의 이해

### DBMS란?

**DBMS(Database Management System, 데이터베이스 관리 시스템)**는 **사용자와 데이터베이스 사이의 중재자** 역할을 하는 **소프트웨어**입니다.

```
[사용자] → [응용 프로그램] → [DBMS] → [데이터베이스]
```

사용자가 데이터베이스에 직접 접근할 수 없습니다. 마치 **은행 창구 직원**처럼, DBMS가 중간에서 사용자의 요청을 받아 데이터베이스에 전달하고, 결과를 다시 사용자에게 돌려주는 것입니다.

여러분이 ATM기에서 돈을 이체할 때, ATM 소프트웨어(응용 프로그램)를 통해 요청하면, DBMS가 그 요청을 처리해서 데이터베이스의 잔액을 변경해주는 것이죠.

### DBMS가 탄생한 이유

바로 **파일 시스템의 종속성과 중복성 문제를 해결하기 위해서**입니다. DBMS를 사용하면:

- **표준화된 개발 방법**이 제공되어 프로그램을 쉽게 개발 가능
- **개발 기간 단축** 가능
- **자료 독립성** 보장으로 유지보수 용이
- **표준화**로 비용 절감
- 데이터베이스에 대한 **모든 접근을 통합 관리**

### DBMS의 필수 기능 3가지

DBMS가 반드시 갖추어야 할 기능은 **정의 기능**, **조작 기능**, **제어 기능** 세 가지입니다.

#### 1. 정의 기능 (DDL — Data Definition Language)

**테이블의 구조를 만드는 기능**입니다. 어떤 속성(컬럼)이 있고, 각 속성의 데이터 타입은 무엇이며, 기본키는 무엇인지를 정의합니다.

```sql
-- 정의 기능: 테이블 구조 생성 (DDL)
-- "학생" 테이블을 새로 만드는 명령어
CREATE TABLE student (
    student_id INT PRIMARY KEY,  -- 학번: 정수형, 기본키로 지정
    name VARCHAR(50),            -- 이름: 최대 50자의 문자열
    address VARCHAR(100)         -- 주소: 최대 100자의 문자열
);
```

이 코드를 한 줄씩 설명하면:
- `CREATE TABLE student`: "student(학생)"이라는 이름의 새 테이블을 생성하라는 명령
- `student_id INT PRIMARY KEY`: "student_id(학번)"이라는 컬럼을 만들고, 데이터 타입은 정수(INT), 이 컬럼을 기본키(PRIMARY KEY)로 지정
- `name VARCHAR(50)`: "name(이름)"이라는 컬럼을 만들고, 최대 50글자까지 저장 가능한 가변 문자열(VARCHAR)
- `address VARCHAR(100)`: "address(주소)"이라는 컬럼을 만들고, 최대 100글자까지 저장 가능

#### 2. 조작 기능 (DML — Data Manipulation Language)

구조를 만들었으면 이제 **데이터를 넣고, 조회하고, 수정하고, 삭제하는 기능**입니다.

```sql
-- 조작 기능: 데이터 삽입 (INSERT)
-- "학생" 테이블에 새로운 학생 정보를 추가
INSERT INTO student (student_id, name, address)
VALUES (1001, '김철수', '서울시 강남구');

-- 조작 기능: 데이터 조회 (SELECT)
-- "학생" 테이블에서 모든 학생 정보를 검색
SELECT * FROM student;

-- 조작 기능: 데이터 수정 (UPDATE)
-- 학번이 1001인 학생의 주소를 변경
UPDATE student
SET address = '부산시 해운대구'
WHERE student_id = 1001;

-- 조작 기능: 데이터 삭제 (DELETE)
-- 학번이 1001인 학생 정보를 삭제
DELETE FROM student
WHERE student_id = 1001;
```

각 명령어를 설명하면:
- `INSERT INTO ... VALUES ...`: 새로운 레코드(행)를 테이블에 추가
- `SELECT * FROM student`: student 테이블의 모든(*) 데이터를 조회
- `UPDATE ... SET ... WHERE ...`: 조건에 맞는 레코드의 값을 수정
- `DELETE FROM ... WHERE ...`: 조건에 맞는 레코드를 삭제

#### 3. 제어 기능 (DCL — Data Control Language)

데이터를 사용하다 보면 **정확성(무결성)**, **보안**, **동시 접근 제어(병행제어)**, **장애 발생 시 복구(회복)** 등을 관리해야 합니다. 이런 것들을 처리하는 기능이 제어 기능입니다.

```sql
-- 제어 기능: 권한 부여 (GRANT)
-- 사용자 'user1'에게 student 테이블의 조회 권한을 부여
GRANT SELECT ON student TO user1;

-- 제어 기능: 권한 회수 (REVOKE)
-- 사용자 'user1'에게서 student 테이블의 조회 권한을 회수
REVOKE SELECT ON student FROM user1;
```

- `GRANT SELECT ON student TO user1`: user1 사용자에게 student 테이블을 조회(SELECT)할 수 있는 권한을 줍니다
- `REVOKE SELECT ON student FROM user1`: user1 사용자에게서 student 테이블 조회 권한을 빼앗습니다

:::danger DBMS 필수 기능을 혼동하지 마세요!
- **정의(DDL)**: 구조를 **만드는** 것 (CREATE, ALTER, DROP)
- **조작(DML)**: 데이터를 **다루는** 것 (SELECT, INSERT, UPDATE, DELETE)
- **제어(DCL)**: 안전하게 **관리하는** 것 (GRANT, REVOKE, 무결성, 병행제어, 회복)

이 세 가지는 DBMS의 **필수 기능**이며, SQL을 배울 때 가장 기본이 되는 분류입니다.
:::

### DBMS의 장점과 단점

#### ✅ 장점

- **중복 제어**: 데이터 중복을 최소화하고 통제할 수 있습니다
- **동시 공유**: 여러 사용자가 동시에 사용할 수 있습니다
- **데이터 일관성**: 한 곳만 수정하면 모든 사용자가 동일한 데이터를 봅니다
- **데이터 무결성**: 정확한 데이터를 유지할 수 있습니다
- **보안 유지**: 사용자별 접근 권한을 설정할 수 있습니다
- **표준화**: SQL이라는 표준 언어로 누구나 동일한 방식으로 사용 가능합니다
- **백업 및 회복**: 장애 발생 시 데이터를 복구할 수 있는 기능을 제공합니다

#### ❌ 단점

- **높은 비용**: 하드웨어 구매, 통신망 구축, 소프트웨어 구매 등 운영비가 많이 듭니다
- **복잡한 구조**: 시스템이 복잡하여 고장 원인을 파악하기 어렵습니다
- **장애 파급 위험**: 일부의 고장이 전체 시스템을 멈추게 할 수 있습니다
- **보안 위협**: 해킹 등으로 전체 데이터가 파괴될 수 있는 잠재적 위험이 있습니다

---

## 🔄 DBMS의 동작 구조 — 데이터는 어떻게 처리되는가?

DBMS를 사용하는 사용자는 크게 세 종류입니다:

| 사용자 유형 | 역할 | 사용하는 언어 |
|---|---|---|
| **일반 사용자** | 데이터를 조회하고 검색 | 질의어(Query Language) |
| **응용 프로그래머** | 프로그램에 DB 언어를 삽입하여 개발 | 호스트 언어(Java 등) + DML |
| **데이터베이스 관리자(DBA)** | DB 구조를 만들고 관리 | 정의어(DDL) |

### 일반 사용자의 데이터 처리 흐름

일반 사용자가 질의어(예: `SELECT * FROM student WHERE score >= 90`)를 입력하면 다음과 같은 과정을 거칩니다:

1. **질의 처리기**: 입력된 명령어가 어떤 종류인지 확인합니다. 명령문을 토큰(token) 단위로 쪼개서 분석하는 **파싱(Parsing)** 작업을 수행합니다.
2. **런타임 데이터베이스 처리기**: 실제 명령을 실행합니다. 이 과정에서 **트랜잭션 관리자(Transaction Manager)**가 권한 검사, 무결성 검사, 병행제어, 회복 등을 수행합니다.
3. **저장 데이터 관리자**: 실행 결과를 하드디스크에 저장하거나, 하드디스크에서 데이터를 읽어옵니다.

### 응용 프로그래머의 데이터 처리 흐름

Java 같은 프로그램 안에 SQL 코드가 섞여 있는 경우입니다:

```java
// Java 프로그램 안에 SQL이 포함된 예시
public void getStudent() {
    String javaCode = "변수 선언";  // Java 코드
    String sql = "SELECT * FROM student"; // SQL 코드 (DML)
    // Java와 SQL이 한 프로그램 안에 섞여 있음!
}
```

1. **DML 예비 컴파일러(Precompiler)**: Java 코드와 SQL 코드를 **분리**합니다. Java는 Java 컴파일러가, SQL은 DML 컴파일러가 각각 처리해야 하기 때문입니다.
2. **DML 컴파일러**: 분리된 SQL 명령어를 파싱하고 컴파일합니다. 문법 오류가 없는지 확인합니다.
3. **런타임 데이터베이스 처리기**: 컴파일된 SQL을 실행합니다.
4. **저장 데이터 관리자**: 결과를 하드디스크에 저장하거나 읽어옵니다.

### 데이터베이스 관리자(DBA)의 데이터 처리 흐름

DBA가 DDL로 테이블 구조를 정의하면:

1. **DDL 컴파일러**: DDL 명령어를 컴파일합니다.
2. **카탈로그(데이터 사전)에 메타데이터 저장**: 구조를 실행하는 것이 아니라, 그 구조에 대한 정보(메타데이터)를 데이터 사전에 저장합니다.

앞에서 배운 **자기 정의(Self-Describing)** 특성이 바로 여기서 나타나는 것입니다. 테이블을 만들면 그 테이블에 대한 정보가 자동으로 카탈로그에 기록됩니다.

:::tip 트랜잭션 관리자의 역할
**트랜잭션(Transaction)**이란 하나의 논리적 작업 단위를 의미합니다. 예를 들어, 계좌이체는 "출금 + 입금"이 하나의 트랜잭션입니다. 트랜잭션 관리자는 다음을 담당합니다:
- **무결성 검사**: 데이터의 정확성을 확인
- **권한 검사**: 해당 사용자가 이 작업을 할 권한이 있는지 확인
- **병행제어**: 여러 사용자의 동시 요청을 충돌 없이 처리
- **회복**: 장애 발생 시 데이터를 이전 상태로 복구
:::

---

## ⚡ 파일 시스템 vs 데이터베이스 — 전체 비교

지금까지 배운 내용을 한눈에 비교해 보겠습니다.

| 비교 항목 | 파일 시스템 | 데이터베이스 (DBMS) |
|---|---|---|
| **관리 주체** | 운영체제 | 전용 소프트웨어 (Oracle, MySQL 등) |
| **데이터 중복** | 중복 심함 | 최소한의 통제된 중복 |
| **데이터 종속** | 구조 변경 시 프로그램도 변경 필요 | 자료 독립성 보장 |
| **동시 접근** | 매우 어려움 | 병행제어로 안전하게 지원 |
| **데이터 일관성** | 보장 어려움 | 일관성 유지 |
| **보안** | 동일 수준 유지 어려움 | 사용자별 권한 설정 가능 |
| **복잡한 내부 구조** | 프로그래머가 직접 알아야 함 | 추상화로 감춤 |
| **비용** | 별도 비용 없음 | 하드웨어, 소프트웨어 비용 발생 |
| **적합한 환경** | 개인 사용, 단순 저장 | 다수 사용자, 기업 시스템 |

---

## 📌 핵심 정리

- **파일 시스템**은 운영체제가 파일을 관리하는 방식으로, 별도의 전문 소프트웨어 없이 사용 가능하다
- 파일 시스템의 두 가지 치명적 문제는 **중복성**(같은 데이터가 여러 곳에 존재)과 **종속성**(구조 변경 시 프로그램도 변경 필요)이다
- 중복성으로 인해 **데이터 불일치**, **보안 취약**, **경제성 저하**, **무결성 훼손** 문제가 발생한다
- 이 문제를 해결하기 위해 **데이터베이스**가 탄생했으며, 계층형 → 네트워크형 → 관계형 → 객체지향 → 객체관계 순으로 발전했다
- 현재 가장 많이 사용되는 것은 **관계형 DBMS(RDBMS)**이며, 테이블(표) 구조로 되어 있다
- 데이터베이스의 정의: **통합, 저장, 운영, 공용** 데이터의 집합
- 데이터베이스의 특징: **실시간 접근**, **계속적 변화**, **동시 공유**, **내용에 의한 참조**
- 데이터베이스의 핵심 특성: **자료 추상**(복잡한 내부를 감춤), **자료 독립**(구조 변경에 프로그램 영향 없음), **자기 정의**(메타데이터를 사전에 저장)
- 데이터베이스의 구성 요소: **개체**(표현 대상), **속성**(개체의 특성), **관계**(개체 간 연결)
- **DBMS**는 사용자와 데이터베이스 사이의 중재자 소프트웨어이며, **정의 기능(DDL)**, **조작 기능(DML)**, **제어 기능(DCL)**이 필수 기능이다
- DBMS 사용자는 **일반 사용자**(질의어), **응용 프로그래머**(호스트 언어+DML), **DBA**(DDL)로 구분된다

작성일: 2026-02-20