---
title: "관계대수 연산자의 프로그래밍 구현"
description: "관계대수 연산자의 프로그래밍 구현에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/database-tuning/5-relational-operator-implementation"
sidebar_label: "연산자 구현"
date: "2026-02-21"
---

## 🎯 관계대수 연산자란 무엇인가?

데이터베이스를 사용할 때, 우리는 단순히 데이터를 저장하는 것에서 끝나지 않습니다. 저장된 데이터 중에서 **원하는 조건에 맞는 데이터를 찾아내고**, 여러 테이블에 흩어져 있는 데이터를 **합쳐서 의미 있는 결과를 만들어내는** 작업이 필수적입니다. 이런 작업을 수학적으로 정의한 것이 바로 **관계대수(Relational Algebra)**이고, 그 안에서 사용되는 도구들을 **관계대수 연산자**라고 부릅니다.

대표적인 관계대수 연산자로는 **Selection(선택)**, **Projection(추출)**, **Join(조인)** 등이 있습니다. 이 연산자들은 SQL 쿼리문의 뒤에서 실제로 동작하는 핵심 엔진과 같은 역할을 합니다.

> **핵심 포인트:** 관계대수 연산자를 프로그래밍적으로 어떻게 구현하는지 이해하면, 데이터 검색과 조인의 알고리즘을 이해하게 되고, 이는 곧 **성능 최적화(튜닝)**의 기초가 됩니다.

마치 자동차 엔진의 원리를 이해하면 더 효율적으로 운전할 수 있는 것처럼, 관계대수 연산자의 내부 구현 원리를 알면 **더 빠르고 효율적인 쿼리**를 작성할 수 있습니다. 알고리즘을 이해하고 개발하는 것과, 모르고 그냥 개발하는 것은 결과물의 품질에서 큰 차이가 납니다.

---

## 🔍 접근 루틴(Access Routine)이란?

### 접근 루틴의 개념

관계대수 연산자를 실제로 C, Java 같은 프로그래밍 언어로 구현한 프로시저(절차적 코드)를 **접근 루틴(Access Routine)**이라고 합니다. 쉽게 말해, "데이터를 어떤 방법으로 찾아갈 것인가"를 코드로 작성한 것입니다.

비유하자면, 도서관에서 책을 찾는 방법이 여러 가지인 것과 같습니다. 서가를 처음부터 끝까지 훑어볼 수도 있고, 도서 분류 번호를 활용할 수도 있고, 사서에게 직접 물어볼 수도 있죠. 이처럼 **같은 데이터를 찾더라도 여러 가지 방법(접근 루틴)**이 존재합니다.

### 접근 루틴이 다루는 것들

접근 루틴은 다음과 같은 연산들을 실행하는 루틴을 모두 포함합니다:

- **관계대수 연산자**: Selection, Projection, Join 등
- **결합(조합) 연산자**: 여러 연산을 조합해서 처리하는 것
- **집단 함수(Aggregate Function)**: COUNT, SUM, AVG 같은 함수

:::info 접근 루틴과 접근 경로
접근 루틴은 **특정 저장 구조**와 **접근 경로**(인덱스, 해시 등)에 맞춰서 적용됩니다. 같은 Selection 연산이라도 인덱스가 있느냐 없느냐에 따라 완전히 다른 접근 루틴이 사용됩니다.
:::

---

## 📋 Selection 연산의 프로그래밍 구현

Selection 연산은 **조건에 맞는 데이터를 찾아내는 연산**입니다. SQL에서 `WHERE` 절에 해당하는 부분이죠. 예를 들어, 학생 테이블에서 "점수가 50점 이하인 학생의 번호를 찾아라"라는 요청이 Selection 연산입니다.

### 예시 데이터

아래와 같은 학생 테이블 R이 있다고 가정해봅시다:

| 학번 | 점수 |
|------|------|
| 1    | 100  |
| 2    | 80   |
| 3    | 50   |
| 4    | 70   |
| 5    | 90   |

여기서 **"점수가 50점 이하인 학생의 학번을 찾아라"**라는 질의는 관계대수로 다음과 같이 표현됩니다:

```
π_학번 (σ_점수≤50 (R))
```

이것은 "R 테이블에서 점수가 50점 이하인 레코드를 선택(Selection)한 뒤, 학번만 추출(Projection)하라"는 의미입니다. 결과는 학번 3번이 되겠죠.

그렇다면 이 50점 이하인 데이터를 **어떻게 찾을 것인가?** 여기에 여러 가지 방법이 존재합니다.

---

### 방법 1: 선형 탐색 (Linear Search) 🔄

**선형 탐색**은 데이터를 **처음부터 끝까지 순서대로 하나씩** 확인하는 방법입니다. 자료구조를 공부해보신 분이라면 익숙할 개념입니다. 마치 책장에서 원하는 책을 찾기 위해 **첫 번째 칸부터 마지막 칸까지 하나씩** 살펴보는 것과 같습니다.

위 예시에서 "점수 ≤ 50"인 데이터를 선형 탐색으로 찾으면:

1. **1번 학생(100점)** → 조건 불만족 ❌
2. **2번 학생(80점)** → 조건 불만족 ❌
3. **3번 학생(50점)** → 조건 만족 ✅ → 찾음!

세 번 만에 찾았지만, 만약 찾는 데이터가 맨 끝에 있다면 **모든 레코드를 다 확인**해야 합니다.

```c
// 선형 탐색으로 조건에 맞는 레코드 찾기 (C 언어)
// ❌ 비효율적이지만 가장 단순한 방법

int scores[] = {100, 80, 50, 70, 90};  // 점수 배열
int ids[] = {1, 2, 3, 4, 5};           // 학번 배열
int n = 5;                               // 전체 레코드 수

for (int i = 0; i < n; i++) {            // 처음부터 끝까지 반복
    if (scores[i] <= 50) {               // 조건: 점수가 50 이하인지 확인
        printf("학번: %d\n", ids[i]);    // 조건 만족 시 학번 출력
    }
}
```

**한 줄씩 설명:**
- `int scores[] = {100, 80, 50, 70, 90};` → 5명의 점수를 배열에 저장합니다.
- `int ids[] = {1, 2, 3, 4, 5};` → 5명의 학번을 배열에 저장합니다.
- `for (int i = 0; i < n; i++)` → 0번째부터 마지막까지 **모든 레코드를 순회**합니다.
- `if (scores[i] <= 50)` → 현재 레코드의 점수가 50 이하인지 **조건을 검사**합니다.
- `printf(...)` → 조건에 맞으면 해당 학번을 출력합니다.

:::warning 선형 탐색의 한계
선형 탐색은 데이터가 정렬되어 있지 않아도 사용할 수 있지만, **평균적으로 전체 데이터의 50%를 탐색**해야 합니다. 데이터가 100만 건이면 평균 50만 번 비교해야 하므로, 대용량 데이터에서는 매우 비효율적입니다.
:::

---

### 방법 2: 이진 탐색 (Binary Search) ✂️

이진 탐색은 **데이터를 먼저 정렬해 놓고**, 찾으려는 값과 **중간값을 비교**하면서 **탐색 범위를 절반씩 줄여나가는** 방법입니다. 마치 사전에서 단어를 찾을 때, 사전을 반으로 펼쳐서 원하는 단어가 앞쪽에 있는지 뒤쪽에 있는지 판단하고, 해당 절반만 다시 탐색하는 것과 같습니다.

먼저 점수를 오름차순으로 정렬하면:

| 학번 | 점수 |
|------|------|
| 3    | 50   |
| 4    | 70   |
| 2    | 80   |
| 5    | 90   |
| 1    | 100  |

이제 "점수 ≤ 50"을 찾으려면:

1. **중간값 확인**: 5개 중 가운데(3번째)는 80점 → 50 < 80이므로 **왼쪽 절반만 탐색**
2. **왼쪽 절반의 중간값 확인**: 50점 → 조건 만족! ✅

단 2번 만에 찾았습니다! 선형 탐색보다 훨씬 빠르죠.

```c
// 이진 탐색으로 조건에 맞는 레코드 찾기 (C 언어)
// ✅ 정렬된 데이터에서 효율적인 방법

int sorted_scores[] = {50, 70, 80, 90, 100};  // 정렬된 점수 배열
int sorted_ids[] = {3, 4, 2, 5, 1};           // 정렬에 따른 학번 배열
int n = 5;                                      // 전체 레코드 수
int target = 50;                                // 찾으려는 값

int low = 0;          // 탐색 범위의 시작점
int high = n - 1;     // 탐색 범위의 끝점

while (low <= high) {                          // 탐색 범위가 유효한 동안 반복
    int mid = (low + high) / 2;                // 중간 위치 계산
    if (sorted_scores[mid] == target) {        // 중간값이 목표값과 같으면
        printf("찾음! 학번: %d\n", sorted_ids[mid]);  // 결과 출력
        break;                                  // 탐색 종료
    } else if (sorted_scores[mid] > target) {  // 중간값이 더 크면
        high = mid - 1;                         // 왼쪽 절반만 탐색
    } else {                                    // 중간값이 더 작으면
        low = mid + 1;                          // 오른쪽 절반만 탐색
    }
}
```

**한 줄씩 설명:**
- `int sorted_scores[] = {50, 70, 80, 90, 100};` → 점수를 **오름차순으로 정렬**해둔 배열입니다.
- `int low = 0; int high = n - 1;` → 탐색 범위를 전체 배열로 설정합니다.
- `int mid = (low + high) / 2;` → 현재 탐색 범위의 **정확한 중간 위치**를 계산합니다.
- `if (sorted_scores[mid] == target)` → 중간값이 찾는 값과 같으면 성공입니다.
- `high = mid - 1;` → 찾는 값이 중간보다 작으면, **오른쪽은 볼 필요 없으므로** 범위를 왼쪽으로 줄입니다.
- `low = mid + 1;` → 찾는 값이 중간보다 크면, **왼쪽은 볼 필요 없으므로** 범위를 오른쪽으로 줄입니다.

> **이진 탐색의 핵심 전제 조건:** 반드시 데이터가 **정렬되어 있어야** 합니다. 정렬되지 않은 데이터에는 이진 탐색을 적용할 수 없습니다.

---

### 방법 3: 인덱스를 이용한 탐색 📖

인덱스를 이용한 탐색은 **책의 목차**를 활용하는 것과 똑같습니다. 책에서 120페이지의 내용을 찾으려면 어떻게 하나요? 1페이지부터 119페이지까지 순서대로 넘기지 않습니다. **맨 앞의 목차를 먼저 펼쳐서** "120페이지에 해당하는 내용이 여기 있구나"를 확인하고, 바로 그 페이지로 이동하죠.

데이터베이스의 **인덱스(Index)**도 마찬가지입니다. 인덱스는 특정 컬럼의 값과 해당 레코드의 위치 정보를 미리 정리해둔 **별도의 자료 구조**입니다. 인덱스를 먼저 조회하고, 인덱스가 가리키는 위치로 바로 이동해서 데이터를 가져옵니다.

---

### 방법 4: 해싱(Hashing)을 이용한 탐색 ⚡

해싱은 **해시 함수(Hash Function)**라는 특별한 수학 함수에 찾으려는 값을 넣으면, **데이터가 저장된 주소가 바로 계산되어 나오는** 방법입니다.

마치 택배 주소처럼, 주소만 알면 바로 그 집으로 갈 수 있는 것과 같습니다. "서울시 강남구 ○○동 123번지"라는 주소를 알면, 굳이 동네를 처음부터 끝까지 돌아다니지 않고 **바로 해당 주소로** 이동할 수 있죠.

```c
// 해싱을 이용한 탐색 개념 (의사 코드)
// ✅ 해시 함수로 주소를 계산해서 한 번에 찾아감

int hash_function(int key) {
    return key % 10;    // 간단한 해시 함수: 키를 10으로 나눈 나머지
}

int address = hash_function(50);  // 50을 넣으면 주소 0이 나옴
// address 위치로 바로 이동하여 데이터를 가져옴
```

---

### Selection 구현 방법 비교 📊

| 방법 | 정렬 필요 | 인덱스 필요 | 탐색 속도 | 특징 |
|------|-----------|-------------|-----------|------|
| **선형 탐색** | ❌ 불필요 | ❌ 불필요 | 느림 (O(n)) | 가장 단순하지만 비효율적 |
| **이진 탐색** | ✅ 필요 | ❌ 불필요 | 빠름 (O(log n)) | 정렬이 전제 조건 |
| **인덱스 탐색** | ❌ 불필요 | ✅ 필요 | 빠름 | 목차처럼 활용 |
| **해싱 탐색** | ❌ 불필요 | ❌ 불필요 | 매우 빠름 (O(1)) | 해시 함수 계산 비용 존재 |

---

## 🔗 Join 연산의 프로그래밍 구현

### Join 연산이 왜 중요한가?

Selection이 **하나의 테이블**에서 조건에 맞는 데이터를 찾는 것이라면, Join은 **두 개 이상의 테이블**에서 관련 있는 데이터를 결합하는 연산입니다. 그리고 Join은 데이터베이스 성능에 **가장 큰 영향을 미치는 연산**입니다.

왜냐하면 하나의 테이블에서 결과를 가져올 수 있다면 간단하겠지만, 현실의 데이터베이스에서는 정보가 **여러 테이블에 분산**되어 있기 때문입니다. 예를 들어, "학생 정보"는 학생 테이블에, "수강 정보"는 수강 테이블에, "과목 정보"는 과목 테이블에 따로 저장되어 있죠.

**"김철수 학생이 수강한 과목의 이름을 모두 찾아라"**라는 질의를 처리하려면:
1. 학생 테이블에서 김철수를 찾고
2. 수강 테이블에서 김철수의 수강 기록을 찾고
3. 과목 테이블에서 해당 과목의 이름을 찾아야 합니다

이 과정에서 **여러 테이블을 읽고, 값을 비교하고, 맞는 값을 추출하는** 과정이 필요합니다. 이 모든 과정이 연산이기 때문에, Join이 많아지면 그만큼 **성능이 떨어질 수밖에 없습니다**.

> **Join 연산은 피할 수 없습니다.** 여러 테이블에서 원하는 결과를 가져오려면 결국 Join이 필요합니다. 따라서 **어떻게 효율적으로 Join을 수행할 것인가**가 데이터베이스 튜닝의 핵심입니다.

---

### Join 방법 1: 정렬 합병 조인 (Sort-Merge Join) 📑

#### 개념

정렬 합병 조인(Sort-Merge Join)은 이름 그대로 **양쪽 테이블을 모두 정렬한 뒤, 동시에 비교하며 합병하는** 방식입니다.

실생활 비유로 설명하겠습니다. 여러분 앞에 두 뭉치의 종이가 있습니다. **왼쪽 뭉치**에는 학생 명단이, **오른쪽 뭉치**에는 수강 기록이 적혀 있습니다. 양쪽에서 같은 학번을 가진 종이를 짝지어야 합니다.

만약 종이들이 **뒤죽박죽 섞여** 있다면? 왼쪽에서 A를 꺼내고, 오른쪽 뭉치를 전부 뒤져서 A를 찾고... 다시 왼쪽에서 B를 꺼내고, 오른쪽을 전부 뒤지고... 이러면 너무 비효율적이겠죠.

하지만 **양쪽 뭉치를 모두 가나다순(또는 번호순)으로 정렬**해두면 어떨까요? 양쪽 맨 위에 같은 것이 있을 것이고, 순서대로 비교해 나가면 아주 쉽게 짝을 찾을 수 있습니다!

#### 동작 원리

1. **R 테이블을 조인 키 기준으로 정렬**합니다.
2. **S 테이블도 같은 기준으로 정렬**합니다.
3. 양쪽 테이블의 **첫 번째 레코드부터 동시에** 비교하며 나아갑니다.
4. 값이 같으면 조인 결과에 추가하고, 값이 다르면 더 작은 쪽의 포인터를 다음으로 이동합니다.

```python
# 정렬 합병 조인 구현 (Python)
# ✅ 양쪽 테이블을 정렬한 뒤 동시에 비교하며 합병

def sort_merge_join(R, S, key_r, key_s):
    """
    R: 왼쪽 테이블 (리스트 of 딕셔너리)
    S: 오른쪽 테이블 (리스트 of 딕셔너리)
    key_r: R 테이블의 조인 키 컬럼명
    key_s: S 테이블의 조인 키 컬럼명
    """
    # 1단계: 양쪽 테이블을 조인 키 기준으로 정렬
    R_sorted = sorted(R, key=lambda x: x[key_r])  # R을 조인 키로 정렬
    S_sorted = sorted(S, key=lambda x: x[key_s])  # S를 조인 키로 정렬

    result = []       # 조인 결과를 담을 리스트
    i = 0             # R 테이블의 현재 위치 (포인터)
    j = 0             # S 테이블의 현재 위치 (포인터)

    # 2단계: 양쪽을 동시에 비교하며 합병
    while i < len(R_sorted) and j < len(S_sorted):  # 둘 다 끝에 도달하지 않은 동안
        if R_sorted[i][key_r] == S_sorted[j][key_s]:  # 양쪽 키 값이 같으면
            # 조인 결과에 추가 (양쪽 데이터를 합침)
            merged = {**R_sorted[i], **S_sorted[j]}
            result.append(merged)
            i += 1    # R의 포인터를 다음으로 이동
            j += 1    # S의 포인터를 다음으로 이동
        elif R_sorted[i][key_r] < S_sorted[j][key_s]:  # R의 값이 더 작으면
            i += 1    # R의 포인터만 다음으로 이동 (S에는 매칭할 값이 없으므로)
        else:                                           # S의 값이 더 작으면
            j += 1    # S의 포인터만 다음으로 이동

    return result     # 최종 조인 결과 반환

# 사용 예시
R = [
    {"학번": 1, "이름": "김철수"},
    {"학번": 3, "이름": "박영희"},
    {"학번": 2, "이름": "이민수"},
]

S = [
    {"학번": 2, "과목": "수학"},
    {"학번": 1, "과목": "영어"},
    {"학번": 3, "과목": "과학"},
]

# 정렬 합병 조인 실행
joined = sort_merge_join(R, S, "학번", "학번")
for row in joined:
    print(row)  # 학번이 같은 레코드끼리 합쳐진 결과 출력
```

**한 줄씩 핵심 설명:**
- `R_sorted = sorted(R, key=lambda x: x[key_r])` → R 테이블을 조인 키(학번) 기준으로 **오름차순 정렬**합니다. 이것이 정렬 합병 조인의 **첫 번째 핵심 단계**입니다.
- `while i < len(R_sorted) and j < len(S_sorted)` → 양쪽 테이블을 **동시에** 순회합니다. 한쪽이 끝나면 반복 종료합니다.
- `if R_sorted[i][key_r] == S_sorted[j][key_s]` → 양쪽의 현재 키 값이 **같은지** 비교합니다. 같으면 조인 성공!
- `elif R_sorted[i][key_r] < S_sorted[j][key_s]` → R의 값이 더 작으면, R 쪽 포인터를 앞으로 이동합니다. 정렬되어 있으므로 S에서는 절대 매칭될 수 없기 때문입니다.

:::tip 정렬 합병 조인은 언제 사용할까?
- **전체 데이터를 처리**해야 할 때 적합합니다.
- **처리량이 많은 경우**, 즉 양쪽 테이블의 데이터를 전부 조인해야 할 때 유리합니다.
- 단, **양쪽 모두 정렬이 필수**라는 전제 조건이 있습니다.
:::

---

### Join 방법 2: 중첩 루프 조인 (Nested Loop Join) 🔁

#### 개념

중첩 루프 조인(Nested Loop Join)은 **한쪽 테이블의 특정 범위를 정하고, 그 범위의 각 레코드에 대해 다른 쪽 테이블을 반복(루프)하며 매칭하는** 방식입니다.

비유하자면, 교실에서 짝꿍을 찾는 상황을 떠올려보세요. 선생님이 "영희야, 너는 옆반 학생들 중에서 같은 혈액형인 친구를 찾아봐"라고 합니다. 영희는 옆반 학생 30명을 **한 명씩 차례대로** 확인합니다. 그 다음 "철수야, 너도 찾아봐"하면 철수도 30명을 다시 확인합니다. 이것이 중첩 루프 조인입니다.

#### 선행 테이블과 후행 테이블

중첩 루프 조인에서는 두 가지 역할의 테이블이 있습니다:

- **선행 테이블(Driving Table, 외부 테이블)**: 조인의 범위를 결정하는 테이블입니다. "어느 범위까지 처리할 것인지"를 정해주는 역할을 합니다.
- **후행 테이블(Driven Table, 내부 테이블)**: 선행 테이블에서 추출된 값을 가지고 **반복적으로 탐색되는** 테이블입니다.

```python
# 중첩 루프 조인 구현 (Python)
# ✅ 선행 테이블의 각 레코드에 대해 후행 테이블을 반복 탐색

def nested_loop_join(R, S, key_r, key_s):
    """
    R: 선행(드라이빙) 테이블 - 범위를 결정
    S: 후행(내부) 테이블 - 반복 탐색 대상
    key_r: R 테이블의 조인 키
    key_s: S 테이블의 조인 키
    """
    result = []  # 조인 결과를 담을 리스트

    # 외부 루프: 선행 테이블(R)의 각 레코드를 순회
    for r_row in R:                          # R의 레코드 하나를 가져옴
        # 내부 루프: 후행 테이블(S)의 모든 레코드를 순회
        for s_row in S:                      # S의 레코드를 하나씩 확인
            if r_row[key_r] == s_row[key_s]: # 양쪽 키 값이 같으면
                merged = {**r_row, **s_row}  # 두 레코드를 합침
                result.append(merged)        # 결과에 추가

    return result  # 최종 조인 결과 반환

# 사용 예시: 생산부 직원의 주소를 찾는 경우
# R(선행): 부서 테이블에서 '생산부'만 필터링한 결과
R = [
    {"사번": 101, "부서": "생산부"},
    {"사번": 103, "부서": "생산부"},
]

# S(후행): 전체 주소 테이블
S = [
    {"사번": 101, "주소": "서울"},
    {"사번": 102, "주소": "부산"},
    {"사번": 103, "주소": "대전"},
    {"사번": 104, "주소": "광주"},
]

# 중첩 루프 조인 실행
joined = nested_loop_join(R, S, "사번", "사번")
for row in joined:
    print(row)
```

**한 줄씩 핵심 설명:**
- `for r_row in R:` → **외부 루프**입니다. 선행 테이블(R)의 레코드를 하나씩 가져옵니다. R의 범위가 조인의 전체 처리량을 결정합니다.
- `for s_row in S:` → **내부 루프**입니다. R의 각 레코드마다 S의 **모든 레코드를 처음부터 끝까지** 반복 탐색합니다.
- `if r_row[key_r] == s_row[key_s]:` → 양쪽의 조인 키가 같은지 비교합니다.
- 중첩 루프라는 이름은 바로 이 **루프 안의 루프(이중 반복문)** 구조에서 비롯됩니다.

:::info 후행 테이블에 인덱스가 있으면?
후행 테이블(S)에 조인 키에 대한 **인덱스가 설정되어 있으면** 내부 루프에서 전체를 탐색하지 않고 인덱스를 통해 빠르게 찾을 수 있습니다. 마치 책 목차가 있으면 원하는 페이지로 바로 갈 수 있는 것처럼, **후행 테이블에 인덱스가 존재하는 경우 중첩 루프 조인의 효율이 크게 향상**됩니다.
:::

#### 정렬 합병 조인 vs 중첩 루프 조인

| 비교 항목 | 정렬 합병 조인 | 중첩 루프 조인 |
|-----------|----------------|----------------|
| **정렬 필요 여부** | ✅ 양쪽 모두 정렬 필요 | ❌ 정렬 불필요 |
| **적합한 상황** | 전체 데이터 처리, 대용량 | 부분 범위 처리, 소량 |
| **처리 방식** | 양쪽 동시 비교 | 선행 → 후행 반복 탐색 |
| **핵심 요인** | 정렬 비용 | 선행 테이블의 범위 |
| **인덱스 활용** | 덜 중요 | 후행 테이블에 인덱스 있으면 유리 |

> **핵심 차이:** 정렬 합병 조인은 **전체 데이터를 대상**으로 할 때 유리하고, 중첩 루프 조인은 **부분 범위 처리**를 할 때 유리합니다. 선행(드라이빙) 테이블의 처리 범위가 곧 전체 처리량을 결정합니다.

---

### Join 방법 3: 해시 조인 (Hash Join) 🗝️

#### 개념

해시 조인(Hash Join)은 **해시 함수를 이용하여 양쪽 테이블의 조인 키에 대한 주소를 계산**하고, **주소가 같은 것끼리 매칭**하는 방식입니다.

정렬 합병 조인처럼 정렬할 필요도 없고, 중첩 루프 조인처럼 인덱스가 필요하지도 않습니다. 대신 **해시 함수로 각 테이블의 키 값에 대한 주소를 계산**해서, 같은 주소로 해시된 것들끼리 비교합니다.

비유하자면, 100명의 학생을 혈액형별로 분류하는 것과 같습니다. A형은 1번 방, B형은 2번 방, O형은 3번 방... 이런 식으로 **해시 함수가 방 번호를 정해주면**, 같은 방에 들어간 사람들끼리만 비교하면 됩니다. 전체를 다 비교할 필요가 없어지죠.

```python
# 해시 조인 구현 (Python)
# ✅ 해시 함수로 주소를 계산하여 같은 버킷끼리 매칭

def hash_join(R, S, key_r, key_s):
    """
    R: 왼쪽 테이블
    S: 오른쪽 테이블
    key_r: R의 조인 키
    key_s: S의 조인 키
    """
    # 1단계: R 테이블로 해시 테이블 구축 (빌드 단계)
    hash_table = {}                           # 빈 해시 테이블 생성
    for r_row in R:                           # R의 각 레코드에 대해
        hash_key = r_row[key_r]               # 조인 키 값을 가져옴
        if hash_key not in hash_table:        # 해시 테이블에 해당 키가 없으면
            hash_table[hash_key] = []         # 새로운 버킷(빈 리스트) 생성
        hash_table[hash_key].append(r_row)    # 해당 버킷에 레코드 추가

    # 2단계: S 테이블을 순회하며 해시 테이블에서 매칭 (프로브 단계)
    result = []                               # 조인 결과를 담을 리스트
    for s_row in S:                           # S의 각 레코드에 대해
        hash_key = s_row[key_s]               # 조인 키 값을 가져옴
        if hash_key in hash_table:            # 해시 테이블에 같은 키가 있으면
            for r_row in hash_table[hash_key]:  # 해당 버킷의 모든 레코드와
                merged = {**r_row, **s_row}      # 합침
                result.append(merged)            # 결과에 추가

    return result  # 최종 조인 결과 반환

# 사용 예시
R = [{"학번": 1, "이름": "철수"}, {"학번": 2, "이름": "영희"}]
S = [{"학번": 1, "점수": 90}, {"학번": 2, "점수": 85}]

joined = hash_join(R, S, "학번", "학번")
for row in joined:
    print(row)
```

**한 줄씩 핵심 설명:**
- `hash_table = {}` → 해시 테이블을 딕셔너리(사전) 형태로 생성합니다. 이것이 **버킷(Bucket)**의 역할을 합니다.
- `hash_table[hash_key].append(r_row)` → R 테이블의 각 레코드를 조인 키 값에 해당하는 버킷에 넣습니다. 이 단계를 **빌드(Build) 단계**라고 합니다.
- `if hash_key in hash_table:` → S 테이블의 레코드에서 조인 키를 계산하고, 같은 키를 가진 버킷이 있는지 확인합니다. 이 단계를 **프로브(Probe) 단계**라고 합니다.

:::warning 해시 조인의 제약
해시 조인은 **동일 조인(Equi Join)**에서만 사용할 수 있습니다. 즉, `=` 조건으로 비교하는 경우에만 적용 가능합니다. 해시 함수는 하나의 키 값에 대해 하나의 주소만 계산하므로, "크다/작다" 같은 범위 비교에는 사용할 수 없습니다. 또한 해시 함수의 **주소 계산에 CPU 비용이 소요**된다는 단점이 있습니다.
:::

#### 세 가지 조인 방법 종합 비교

| 비교 항목 | 정렬 합병 조인 | 중첩 루프 조인 | 해시 조인 |
|-----------|----------------|----------------|-----------|
| **정렬 필요** | ✅ 양쪽 모두 | ❌ 불필요 | ❌ 불필요 |
| **인덱스 필요** | ❌ 불필요 | ✅ 후행에 있으면 유리 | ❌ 불필요 |
| **적합한 상황** | 전체 데이터 대량 처리 | 부분 범위 소량 처리 | 동일 조인, 비용 기반 최적화 |
| **조인 조건** | 모든 조건 가능 | 모든 조건 가능 | 동일 조인(=)만 가능 |
| **주요 비용** | 정렬 비용 | 반복 탐색 비용 | CPU 해시 계산 비용 |

---

## 💰 질의 처리 비용의 구성 요소

조인 연산을 비롯한 모든 질의(쿼리)를 처리할 때는 **비용(Cost)**이 발생합니다. 어떤 조인 방법이 가장 효율적인지 판단하려면, 이 비용을 정확하게 계산할 수 있어야 합니다.

### 5가지 비용 요소

**1. 보조기억장치 접근 비용 (I/O 비용)**

하드디스크에서 데이터를 읽고 쓰는 비용입니다. 마치 냉장고에서 재료를 꺼내듯이, 저장 장치에서 데이터를 메모리로 가져오는 데 걸리는 시간과 자원을 의미합니다. 데이터베이스에서 **가장 큰 비중을 차지하는 비용**이기도 합니다.

**2. 저장 비용**

R과 S를 조인하면 **중간 결과**가 생성됩니다. 예를 들어, R × S × T를 계산할 때, 먼저 R × S의 결과를 어딘가에 저장해야 T와 다시 연산할 수 있습니다. 이런 중간 결과(임시 파일)를 저장하는 데 드는 비용입니다.

**3. 계산 비용 (CPU 비용)**

CPU에서 연산을 수행할 때 드는 비용입니다. 특히 해시 조인에서 해시 함수로 주소를 계산하는 것처럼, **CPU가 직접 수행하는 연산**에 소요되는 자원입니다.

**4. 메모리 사용 비용**

질의를 처리하는 동안 메모리에 데이터를 올려놓고 CPU가 처리해야 하므로, **메모리 공간을 사용하는 비용**이 발생합니다.

**5. 네트워크 통신 비용**

분산 데이터베이스(Distributed Database) 환경에서는 서로 다른 서버에 있는 데이터를 네트워크를 통해 주고받아야 합니다. 이때 발생하는 **통신 비용**입니다.

### 비용 계산에 필요한 카탈로그 정보

위의 비용들을 정확하게 계산하기 위해서는 **데이터 사전(카탈로그)**에 저장된 통계 정보가 필요합니다:

- **레코드 수**: 테이블에 레코드가 10개인지 100만 개인지에 따라 비용이 크게 달라집니다.
- **블록 수**: I/O의 단위인 블록이 몇 개인지가 중요합니다.
- **블로킹 팩터(BFR, Blocking Factor)**: 하나의 블록에 레코드를 몇 개 저장할 수 있는지를 나타냅니다. 이 값에 따라 I/O 횟수가 달라집니다.
- **인덱스 단계 수**: 인덱스가 몇 단계로 구성되어 있는지입니다. 첫 번째 단계의 블록 수가 성능에 가장 큰 영향을 미칩니다.
- **인덱스 키의 고유 값 범위**: 인덱스에 서로 다른 값이 얼마나 있는지입니다. 고유 값이 많을수록(선택도가 높을수록) 인덱스가 효과적입니다.
- **선택률(Selectivity)**: 하나의 조건을 만족하는 레코드의 평균 개수입니다.

:::note 카탈로그란?
카탈로그(Catalog)는 **데이터베이스에 대한 데이터**, 즉 **메타데이터(Metadata)**를 저장하는 시스템 테이블입니다. 테이블이 몇 개인지, 각 테이블에 레코드가 몇 개인지, 인덱스가 어떻게 설정되어 있는지 등의 정보가 카탈로그에 저장되어 있으며, 데이터베이스 옵티마이저가 최적의 실행 계획을 세울 때 이 정보를 참조합니다.
:::

---

## ⚙️ 데이터베이스 튜닝의 단계와 방법

### 튜닝이란?

**튜닝(Tuning)**이란 시스템의 성능을 향상시키기 위해 **여러 가지 요소를 조정하는 작업**입니다. 자동차를 튜닝한다고 하면 엔진 출력을 높이거나 서스펜션을 조정하는 것처럼, 데이터베이스 튜닝은 **데이터베이스의 성능을 향상시키기 위해 다양한 조치를 취하는 것**입니다.

기타 줄이 안 맞으면 줄을 조정하고, 피아노 건반이 안 맞으면 조율하듯이, 데이터베이스도 성능이 떨어지면 **병목 현상(Bottleneck)을 찾아서 개선**해 나가야 합니다.

> **튜닝의 핵심:** 병목 현상을 찾아서 그 병목 구간을 점진적으로 개선해 나가는 방식입니다.

### 튜닝의 3단계

#### 1단계: 하드웨어 튜닝 (가장 낮은 단계) 🖥️

가장 기본적인 방법은 **하드웨어를 업그레이드**하는 것입니다. 집에 있는 컴퓨터가 느려졌다면, 가장 확실한 방법은 컴퓨터를 바꾸는 것이죠!

- **디스크 성능 저하** → 디스크를 추가하거나 SSD로 교체
- **메모리 부족** → 메모리 용량 증설
- **CPU 부하** → CPU를 더 빠른 것으로 교체
- **네트워크 지연** → 더 빠른 네트워크로 업그레이드

:::info 5분 규칙과 1분 규칙
- **5분 규칙**: 메모리에 올린 데이터가 5분 내에 다시 사용될 가능성이 있다면, 메모리에 계속 유지하는 것이 효율적입니다. 이 규칙을 만족하려면 **충분히 큰 메모리**가 필요합니다.
- **1분 규칙**: 1분마다 계속 사용되는 데이터라면, 반드시 메모리에 상주시켜야 합니다.
이 규칙들은 메모리 크기를 설정할 때 참고하는 기준입니다.
:::

#### 2단계: 인스턴스 파라미터 조정 (중간 단계) 🔧

DBMS가 가지고 있는 **설정 값(파라미터)**을 조정하는 것입니다. 마치 한글 워드프로세서에서 자동 저장 간격을 1분에서 30분으로 바꾸면 문서 작성 중 버벅거림이 줄어드는 것처럼, 데이터베이스의 설정 값을 적절히 조정하면 성능이 향상됩니다.

대표적인 파라미터들:
- **체크포인트(Checkpoint) 간격**: 데이터를 디스크에 저장하는 주기입니다. 너무 짧으면 저장 작업 때문에 시스템이 느려지고, 너무 길면 장애 발생 시 데이터 손실이 커집니다.
- **버퍼 크기**: 메모리에서 데이터를 임시 저장하는 공간의 크기입니다.
- **블로킹 팩터**: 하나의 블록에 저장하는 레코드 수입니다.

#### 3단계: 설계 변경 (가장 높은 단계) 📐

가장 근본적이면서도 효과가 큰 방법입니다:

- **정규화/역정규화**: 테이블 구조를 재설계합니다.
- **인덱스 추가/제거**: 적절한 인덱스를 설정합니다.
- **트랜잭션 방식 변경**: 처리 방식을 최적화합니다.
- **실체화된 뷰(Materialized View)**: 자주 사용하는 조인 결과를 미리 저장해둡니다.

### 인덱스 튜닝의 핵심 원칙

```sql
-- ❌ 잘못된 인덱스 사용 예시
-- 갱신(INSERT, UPDATE, DELETE)이 빈번한 테이블에 인덱스를 과도하게 설정
CREATE INDEX idx_col1 ON 주문테이블(상태);      -- 인덱스 1
CREATE INDEX idx_col2 ON 주문테이블(배송지);     -- 인덱스 2
CREATE INDEX idx_col3 ON 주문테이블(주문일자);   -- 인덱스 3
CREATE INDEX idx_col4 ON 주문테이블(결제방법);   -- 인덱스 4
-- 인덱스가 너무 많으면 데이터 삽입/수정/삭제 시마다
-- 모든 인덱스를 갱신해야 하므로 오히려 성능 저하!
```

```sql
-- ✅ 올바른 인덱스 사용 예시
-- WHERE 절과 JOIN에 자주 사용되는 컬럼에만 인덱스 설정
CREATE INDEX idx_order_date ON 주문테이블(주문일자);  -- 검색에 자주 사용
-- 갱신이 많은 컬럼에는 인덱스를 설정하지 않음
```

:::danger 인덱스의 양면성
인덱스는 **검색 성능은 향상**시키지만, **갱신(INSERT/UPDATE/DELETE) 성능은 저하**시킵니다. 데이터가 변경될 때마다 인덱스도 함께 갱신해야 하기 때문입니다. 따라서 **검색보다 갱신이 많은 테이블**에서는 오히려 인덱스를 제거하는 것이 성능에 도움이 됩니다.
:::

### 불필요한 연산 제거로 성능 향상

```sql
-- ❌ 불필요한 정렬과 중복 제거
SELECT DISTINCT 부서명     -- DISTINCT는 중복 제거를 위해 정렬 수행
FROM 직원
ORDER BY 부서명;           -- 추가적인 정렬 비용 발생

-- ✅ 중복 제거가 불필요한 경우 UNION ALL 사용
SELECT 부서명 FROM 정규직
UNION ALL                  -- UNION ALL은 중복 제거 없이 결과를 합침 (정렬 불필요)
SELECT 부서명 FROM 계약직;

-- ❌ 불필요한 UNION (중복 제거 + 정렬 발생)
SELECT 부서명 FROM 정규직
UNION                      -- UNION은 자동으로 중복 제거 수행 (정렬 비용 발생)
SELECT 부서명 FROM 계약직;
```

| 키워드 | 중복 제거 | 정렬 | 사용 시점 |
|--------|-----------|------|-----------|
| `UNION` | ✅ 수행 | ✅ 발생 | 중복 제거가 반드시 필요할 때 |
| `UNION ALL` | ❌ 안 함 | ❌ 안 함 | 중복이 있어도 상관없을 때 |
| `DISTINCT` | ✅ 수행 | ✅ 발생 | 결과에서 중복을 꼭 제거해야 할 때 |
| `SORT AGGREGATE` | ❌ 안 함 | ❌ 안 함 | 그룹별 합계/평균 등 집계 시 |

> **성능 튜닝 원칙:** 정렬할 필요가 없는 경우에는 정렬하지 말고, 중복을 제거할 필요가 없는 경우에는 중복 제거를 하지 않는 것이 성능에 도움이 됩니다. `UNION ALL`을 쓸 수 있는 곳에 `UNION`을 쓰거나, 불필요하게 `DISTINCT`를 사용하는 것은 피해야 합니다.

또한 전체 레코드 수를 셀 필요 없이 **레코드가 존재하는지만 확인**하면 되는 경우에는 `COUNT(*)` 대신 `EXISTS`를 사용하는 것이 더 효율적입니다. 그리고 데이터를 한꺼번에 대량으로 처리하기보다는 **미니 배치 트랜잭션**으로 쪼개서 처리하면 파일 크기를 줄이고 부하를 분산할 수 있습니다.

---

## 📊 성능 평가와 데이터 품질

### TPC 성능 평가 표준

데이터베이스의 성능을 "좋다, 나쁘다"로 막연하게 평가할 수는 없습니다. 객관적인 기준이 필요한데, 이를 위해 **TPC(Transaction Processing Performance Council)**라는 글로벌 표준이 존재합니다.

**성능 측정의 기본 기준**은 **처리율(Throughput)**입니다. 즉, **1초에 몇 건의 트랜잭션(작업 묶음)을 처리하느냐**가 핵심 지표입니다.

- 1초에 10건 처리 → **10 TPS**
- 1초에 100건 처리 → **100 TPS**
- 1초에 1,000건 처리 → **1,000 TPS**

비즈니스 관점에서는 단순 처리율보다 **Price/TPS(단위 트랜잭션당 비용)**를 더 중요하게 봅니다. "이 시스템은 1TPS당 25만 원이다"처럼, 처리 능력 대비 비용으로 **가성비**를 평가하는 것입니다.

### TPC 벤치마크 종류

| 벤치마크 | 평가 대상 | 설명 |
|----------|-----------|------|
| **TPC-A** | 단순 입출금 시스템 | 은행 ATM 같은 단순 트랜잭션 |
| **TPC-B** | 운영체제 수준 평가 | 시스템 레벨의 성능 측정 |
| **TPC-C** | 주문 처리 시스템 | 전자상거래, 항공권 예약 등 **가장 보편적** |
| **TPC-D** | 의사결정 지원 시스템 | 데이터 분석, 리포팅 |
| **TPC-H** | 대용량 비정형 질의 | 예측 불가능한 다양한 질의 |
| **TPC-R** | 보고서 기능 | 요약표, 보고서 생성 |
| **TPC-W** | 웹/인터넷 시스템 | E-커머스 환경 평가 |

:::tip 어떤 벤치마크를 선택할까?
- 주문 처리 시스템을 평가할 때 → **TPC-C**
- 의사결정 지원 시스템을 평가할 때 → **TPC-D**
- 인터넷 환경의 시스템을 평가할 때 → **TPC-W**
- 객체지향 데이터베이스를 평가할 때 → **OO1, OO7** 등 별도 벤치마크 사용
:::

### 데이터 품질 관리

성능이 아무리 좋아도 **데이터의 품질(Quality)**이 나쁘면 시스템의 가치가 떨어집니다. 마치 성능이 뛰어난 슈퍼카가 가끔씩 폭발한다면 아무도 타지 않을 것처럼, **성능과 품질은 항상 함께 고려**되어야 합니다.

**데이터 품질**이란 데이터 이용자의 요구를 만족시킬 수 있는 수준을 의미하며, 이를 유지하고 관리하는 활동을 **데이터 품질 관리**라고 합니다.

### 품질 진단의 3가지 유형

**1. 값 진단(Value Diagnosis):**
테이블, 속성, 코드, 관계, 비즈니스 규칙 등을 기준으로 **데이터 값 자체를 분석**합니다. 값이 정확한지, 오류가 없는지, 잘못된 데이터가 들어가 있지 않은지를 확인하는 것입니다. 마치 요리사가 음식의 맛을 직접 보는 것과 같습니다.

**2. 구조 진단(Structure Diagnosis):**
시스템의 **모델링과 스키마 구조가 올바르게 설계**되어 있는지를 확인합니다. 주로 **설계 관점**에서 품질을 진단하며, **리버스 모델링**(완성된 결과물을 가지고 거꾸로 설계도를 복원하는 방법)을 통해 구조를 파악합니다. 마치 집의 구조가 제대로 설계되었는지 확인하는 것과 같습니다.

**3. 관리 프로세스 진단(Process Diagnosis):**
데이터의 값과 구조가 **전체 라이프사이클에 걸쳐 체계적으로 관리**되고 있는지를 확인합니다. 단순히 현재 상태만 보는 것이 아니라, 전체 프로세스가 정해진 규칙대로 잘 운영되고 있는지를 점검합니다.

---

## 📌 핵심 정리

- **관계대수 연산자**는 Selection, Projection, Join 등 데이터를 조작하는 핵심 도구이며, 이를 프로그래밍으로 구현한 것을 **접근 루틴**이라 한다.
- **Selection 구현 방법** 4가지: 선형 탐색(순차), 이진 탐색(정렬 필요), 인덱스 탐색(목차 활용), 해싱(주소 계산).
- **정렬 합병 조인(Sort-Merge Join)**: 양쪽 테이블을 정렬한 뒤 동시에 비교하며 합병하는 방식으로, **전체 데이터 대량 처리**에 적합하다.
- **중첩 루프 조인(Nested Loop Join)**: 선행 테이블의 범위를 정하고 후행 테이블을 반복 탐색하는 방식으로, **부분 범위 처리**에 적합하다.
- **해시 조인(Hash Join)**: 해시 함수로 주소를 계산하여 매칭하는 방식으로, **동일 조인(=)**에서만 사용 가능하다.
- **질의 처리 비용**은 I/O 비용, 저장 비용, CPU 비용, 메모리 비용, 네트워크 비용 5가지로 구성되며, **카탈로그 정보**를 참조하여 계산한다.
- **튜닝의 3단계**: 하드웨어 업그레이드 → 인스턴스 파라미터 조정 → 설계 변경(정규화, 인덱스, 뷰 등).
- **인덱스**는 검색 성능을 높이지만 갱신 성능을 떨어뜨리므로, 작업 특성에 맞게 추가하거나 제거해야 한다.
- 불필요한 **정렬(ORDER BY)**과 **중복 제거(DISTINCT, UNION)**를 피하는 것이 성능 향상의 기본이다.
- 성능 평가는 **TPC 표준**을 기준으로 하며, **성능과 품질은 항상 함께** 고려해야 한다.

작성일: 2026-02-21