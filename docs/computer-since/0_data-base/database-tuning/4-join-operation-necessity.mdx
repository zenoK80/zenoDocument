---
title: "조인 연산의 필요성과 다중 테이블 처리"
description: "조인 연산의 필요성과 다중 테이블 처리에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/database-tuning/4-join-operation-necessity"
sidebar_label: "조인의 필요성"
date: "2026-02-21"
---

## 🎯 데이터베이스 튜닝이란 무엇인가?

데이터베이스를 사용하다 보면 점점 느려지거나, 원하는 결과를 가져오는 데 시간이 오래 걸리는 상황을 겪게 됩니다. 이때 **성능을 향상시키기 위해 여러 가지 조치를 취하는 과정**을 바로 **튜닝(Tuning)**이라고 합니다.

"튜닝"이라는 단어는 우리 일상에서도 자주 사용됩니다. 자동차를 튜닝한다고 하면 엔진이나 서스펜션 등을 조정해서 성능을 끌어올리는 것이고, 기타나 피아노를 튜닝한다고 하면 줄의 음이 맞지 않을 때 정확한 음으로 맞추는 것입니다. 마치 **기타 줄이 안 맞을 때 줄을 돌려서 음을 맞추듯이**, 데이터베이스도 성능이 떨어지면 여러 가지 설정 값을 조정하고 구조를 개선하는 작업이 필요합니다.

> **데이터베이스 튜닝** = 데이터베이스의 성능을 향상시키기 위해 수행하는 모든 조치와 조정 작업

데이터베이스 튜닝에는 하드웨어 교체부터 SQL 쿼리 최적화, 인덱스 설정, 파라미터 조정까지 다양한 방법이 포함됩니다. 이번 문서에서는 그중에서도 **조인(Join) 연산**이 왜 성능에 큰 영향을 미치는지, 그리고 이를 어떻게 효율적으로 처리할 수 있는지를 중심으로 살펴보겠습니다.

---

## 🔍 관계대수 연산과 접근 루틴의 이해

### 관계대수 연산이란?

데이터베이스에서 데이터를 다루기 위한 기본적인 연산을 **관계대수 연산**이라고 합니다. 대표적으로 다음 세 가지가 있습니다:

| 연산 | 의미 | 쉬운 설명 |
|------|------|-----------|
| **Selection(셀렉션)** | 조건에 맞는 행(row)을 골라내는 것 | "성적이 50점 이하인 학생만 찾아줘" |
| **Projection(프로젝션)** | 원하는 열(column)만 뽑아내는 것 | "학번만 보여줘" |
| **Join(조인)** | 두 개 이상의 테이블을 연결하는 것 | "학생 정보와 수강 정보를 합쳐서 보여줘" |

이 중에서 **조인 연산은 성능을 가장 많이 떨어뜨리는 주범**입니다. 왜냐하면 하나의 테이블에서 결과를 가져오는 것이 아니라, 여러 테이블을 동시에 읽고 비교해야 하기 때문입니다.

### 접근 루틴이란?

**접근 루틴(Access Routine)**이란 관계대수 연산이나 결합 연산, 집단 함수(SUM, AVG 등) 같은 것들을 **실제로 프로그래밍으로 구현한 절차(프로시저)**를 말합니다. 마치 "레시피"와 같은 것인데, 데이터를 찾는 방법을 단계별로 정해 놓은 것입니다.

> **접근 루틴** = 데이터를 찾고 처리하기 위한 구체적인 실행 방법(알고리즘)

각각의 연산(Selection, Join 등)은 **여러 가지 접근 루틴으로 구현할 수 있습니다.** 예를 들어 Selection 연산 하나도 "처음부터 끝까지 찾기", "정렬 후 반으로 나눠 찾기", "인덱스로 찾기" 등 다양한 방법이 있습니다. 이 알고리즘을 이해하면 나중에 데이터를 검색하거나 접근하는 프로그램을 개발할 때 훨씬 효율적인 코드를 작성할 수 있습니다.

---

## 📖 Selection 연산의 다양한 검색 방법

조인 연산을 본격적으로 이해하기 전에, 먼저 **Selection 연산(조건 검색)**이 어떻게 동작하는지 알아보겠습니다. Selection은 특정 조건에 맞는 데이터를 찾아내는 연산입니다.

예를 들어, 다음과 같은 학생 테이블 R이 있다고 가정합니다:

| 학번 | 점수 |
|------|------|
| 1 | 100 |
| 2 | 80 |
| 3 | 50 |
| 4 | 70 |
| 5 | 90 |

여기서 **"점수가 50점 이하인 학생의 학번을 찾아라"**라는 요구가 있다면, 이것이 바로 Selection 연산입니다.

### 방법 1: 선형 탐색 (Linear Search)

**선형 탐색**은 가장 단순한 방법입니다. **처음부터 끝까지 하나씩 차례대로** 모든 레코드를 확인하는 것입니다. 마치 서랍 속에서 물건을 찾을 때 **첫 번째 서랍부터 마지막 서랍까지 하나씩 열어보는 것**과 같습니다.

```sql
-- 선형 탐색 방식으로 동작하는 쿼리 예시
-- 테이블 R에서 점수가 50 이하인 학번을 조회
SELECT 학번
FROM R
WHERE 점수 <= 50;
```

위 예시에서는 1번 학생(100점) → 아님, 2번 학생(80점) → 아님, 3번 학생(50점) → **찾음!** 이렇게 세 번 만에 결과를 찾을 수 있습니다. 하지만 찾고자 하는 데이터가 맨 끝에 있다면 모든 레코드를 다 확인해야 합니다.

:::info 선형 탐색의 특징
- 데이터가 **정렬되어 있지 않아도** 사용 가능
- 데이터가 맨 앞에 있으면 빠르게 찾고, 맨 뒤에 있으면 가장 오래 걸림
- 평균적으로 전체 데이터의 **약 50%** 정도를 탐색해야 함
:::

### 방법 2: 이진 탐색 (Binary Search)

**이진 탐색**은 데이터를 먼저 **정렬(오름차순 또는 내림차순)**해 놓고, **반씩 잘라가며** 찾는 방법입니다. 마치 **사전에서 단어를 찾을 때 가운데를 펴서 앞쪽인지 뒤쪽인지 판단하는 것**과 동일한 원리입니다.

먼저 데이터를 정렬하면 다음과 같이 됩니다:

| 학번 | 점수 |
|------|------|
| 3 | 50 |
| 4 | 70 |
| 2 | 80 |
| 5 | 90 |
| 1 | 100 |

이제 "50점"을 찾는다고 해봅시다:

1. **가운데 값 확인**: 5개 중 가운데(3번째)는 80점 → 50은 80보다 작으므로 **왼쪽에 있음**
2. **왼쪽 절반에서 다시 가운데 확인**: 50점, 70점 중 → 50점 **발견!**

```python
# 이진 탐색을 파이썬으로 구현한 예시
def binary_search(data, target):
    """정렬된 데이터에서 target 값을 이진 탐색으로 찾는 함수"""
    low = 0                    # 탐색 범위의 시작 인덱스
    high = len(data) - 1       # 탐색 범위의 끝 인덱스

    while low <= high:
        mid = (low + high) // 2  # 가운데 인덱스 계산
        if data[mid] == target:  # 가운데 값이 찾는 값이면
            return mid           # 해당 인덱스 반환
        elif data[mid] < target: # 찾는 값이 더 크면
            low = mid + 1        # 오른쪽 절반에서 탐색
        else:                    # 찾는 값이 더 작으면
            high = mid - 1       # 왼쪽 절반에서 탐색

    return -1  # 찾지 못한 경우

# 정렬된 점수 데이터
scores = [50, 70, 80, 90, 100]
# 50점 찾기
result = binary_search(scores, 50)
print(f"50점의 인덱스: {result}")  # 결과: 0
```

**코드 한 줄씩 설명:**
- `low = 0`, `high = len(data) - 1`: 탐색 범위를 전체 배열로 설정합니다.
- `mid = (low + high) // 2`: 현재 범위의 가운데 위치를 계산합니다.
- `data[mid] == target`: 가운데 값이 찾는 값과 같으면 바로 반환합니다.
- `data[mid] < target`: 가운데 값이 작으면, 찾는 값은 오른쪽에 있으므로 `low`를 올립니다.
- `high = mid - 1`: 가운데 값이 크면, 찾는 값은 왼쪽에 있으므로 `high`를 내립니다.

:::warning 이진 탐색의 전제 조건
이진 탐색은 반드시 **데이터가 정렬되어 있어야** 사용할 수 있습니다. 정렬되지 않은 데이터에 이진 탐색을 적용하면 올바른 결과를 얻을 수 없습니다.
:::

### 방법 3: 인덱스를 이용한 탐색

**인덱스(Index)**를 이용하면 마치 **책의 목차**를 활용하는 것과 같습니다. 120페이지의 내용을 찾으려면 책을 처음부터 한 장씩 넘기는 것이 아니라, **목차를 보고 120페이지 근처로 바로 이동**하는 것이 훨씬 빠르겠죠. 인덱스도 동일합니다. 데이터의 위치 정보를 미리 저장해 놓고, 해당 위치로 바로 접근하는 방식입니다.

### 방법 4: 해싱을 이용한 탐색

**해싱(Hashing)**은 **해시 함수(Hash Function)**라는 특별한 계산식에 값을 넣으면 **바로 주소가 나오는** 방식입니다. 마치 **택배 송장 번호를 입력하면 바로 위치가 나오는 것**과 같습니다. `h(db)` → 바로 120이 나오면, 120번 위치로 직접 이동할 수 있습니다.

> **검색 방법 요약**: 선형 탐색(처음부터 순서대로), 이진 탐색(정렬 후 반으로 나누며), 인덱스 탐색(목차 활용), 해싱(주소 직접 계산)

---

## 🔗 조인 연산의 필요성과 핵심 원리

### 왜 조인이 필요한가?

하나의 테이블에서 원하는 결과를 모두 가져올 수 있다면 가장 좋겠지만, **현실에서는 거의 불가능**합니다. 정규화(데이터 중복을 줄이기 위해 테이블을 나누는 과정)를 거친 데이터베이스에서는 관련된 정보가 **여러 테이블에 나뉘어 저장**되기 때문입니다.

예를 들어, "생산부에 소속된 직원들의 주소를 알고 싶다"고 할 때:
- **부서 테이블**: 부서명, 부서코드 등이 저장됨
- **직원 테이블**: 직원명, 주소, 소속 부서코드 등이 저장됨

이 두 테이블을 **연결(Join)**해야만 "생산부 소속 직원의 주소"를 알 수 있습니다.

> 조인 연산이 많아진다 = **여러 테이블을 읽어야 하고** → **여러 값을 비교해야 하고** → **맞는 값을 추출해야 한다** → 그만큼 **연산이 많아져 성능이 떨어진다**

### 조인이 성능에 미치는 영향

조인 연산은 다음과 같은 과정을 거치기 때문에 성능에 큰 영향을 미칩니다:

1. **여러 테이블을 디스크에서 읽어와야 함** (I/O 비용)
2. **각 테이블의 값을 서로 비교해야 함** (CPU 계산 비용)
3. **조건에 맞는 값만 추출해야 함** (필터링 비용)
4. **중간 결과를 임시로 저장해야 할 수도 있음** (저장 비용)

하지만 조인 연산을 **안 할 수는 없습니다.** 여러 테이블에서 원하는 결과를 가져오려면 결국 조인이 필요할 수밖에 없기 때문입니다. 따라서 **어떤 방식으로 조인하느냐**가 성능을 좌우하게 됩니다.

---

## ⚙️ 조인 연산의 3가지 구현 방법

조인 연산을 실제로 처리하는 방법에는 크게 세 가지가 있습니다. 각 방법마다 장단점이 다르기 때문에 상황에 맞는 방법을 선택하는 것이 중요합니다.

### 방법 1: 정렬 병합 조인 (Sort Merge Join)

**정렬 병합 조인**은 이름 그대로 **양쪽 테이블을 먼저 정렬한 후, 동시에 비교하면서 합치는** 방식입니다.

비유를 들어 설명하면, 왼쪽에 카드 더미가 있고 오른쪽에도 카드 더미가 있는데, **같은 숫자의 카드 쌍을 찾아야** 한다고 상상해 보세요.

❌ **비효율적인 방법:**
왼쪽 더미에서 A 카드를 뽑고 → 오른쪽 더미를 처음부터 끝까지 뒤져서 A를 찾고 → 다시 왼쪽에서 B 카드를 뽑고 → 오른쪽 더미를 처음부터 끝까지 뒤져서 B를 찾고...

✅ **정렬 병합 조인 방법:**
1. 왼쪽 카드 더미를 **숫자 순서대로 정렬**합니다.
2. 오른쪽 카드 더미도 **숫자 순서대로 정렬**합니다.
3. 양쪽 맨 위부터 **동시에 비교하며** 같은 것을 찾습니다.
4. 양쪽 모두 정렬되어 있으니 **한 번에 쉽게** 같은 카드를 찾을 수 있습니다!

```python
# 정렬 병합 조인을 파이썬으로 구현한 예시
def sort_merge_join(table_r, table_s, key_r, key_s):
    """
    두 테이블을 정렬 병합 조인으로 결합하는 함수
    table_r: R 테이블 (리스트 of 딕셔너리)
    table_s: S 테이블 (리스트 of 딕셔너리)
    key_r: R 테이블의 조인 키 이름
    key_s: S 테이블의 조인 키 이름
    """
    # 1단계: 양쪽 테이블을 조인 키 기준으로 정렬
    sorted_r = sorted(table_r, key=lambda x: x[key_r])  # R 테이블 정렬
    sorted_s = sorted(table_s, key=lambda x: x[key_s])  # S 테이블 정렬

    result = []       # 조인 결과를 저장할 리스트
    i, j = 0, 0       # 양쪽 테이블의 현재 위치(포인터)

    # 2단계: 양쪽을 동시에 비교하며 조인
    while i < len(sorted_r) and j < len(sorted_s):
        if sorted_r[i][key_r] == sorted_s[j][key_s]:
            # 같은 값을 찾으면 결과에 추가
            result.append({**sorted_r[i], **sorted_s[j]})
            i += 1  # R 테이블 다음으로 이동
            j += 1  # S 테이블 다음으로 이동
        elif sorted_r[i][key_r] < sorted_s[j][key_s]:
            # R의 값이 더 작으면 R을 다음으로 이동
            i += 1
        else:
            # S의 값이 더 작으면 S을 다음으로 이동
            j += 1

    return result  # 최종 조인 결과 반환

# 예시 데이터
employees = [
    {"emp_id": 3, "name": "김철수"},
    {"emp_id": 1, "name": "이영희"},
    {"emp_id": 2, "name": "박민수"},
]
departments = [
    {"dept_id": 2, "dept_name": "생산부"},
    {"dept_id": 1, "dept_name": "영업부"},
    {"dept_id": 3, "dept_name": "개발부"},
]

# 정렬 병합 조인 실행
joined = sort_merge_join(employees, departments, "emp_id", "dept_id")
for row in joined:
    print(row)
```

**코드 한 줄씩 설명:**
- `sorted_r = sorted(table_r, key=lambda x: x[key_r])`: R 테이블을 조인 키 기준으로 오름차순 정렬합니다.
- `sorted_s = sorted(table_s, key=lambda x: x[key_s])`: S 테이블도 동일하게 정렬합니다.
- `i, j = 0, 0`: 양쪽 테이블을 동시에 훑기 위한 포인터(위치 표시)를 0으로 초기화합니다.
- `sorted_r[i][key_r] == sorted_s[j][key_s]`: 양쪽 현재 위치의 키 값이 같으면 조인 결과에 추가합니다.
- `sorted_r[i][key_r] < sorted_s[j][key_s]`: R의 값이 더 작으면 R 쪽 포인터만 전진합니다(정렬되어 있으니 S에서 더 찾을 필요 없음).

:::tip 정렬 병합 조인은 언제 유리한가?
- **전체 데이터를 모두 조인**해야 할 때 유리합니다.
- **처리량이 많은 경우**, 양쪽을 모두 정렬해서 한 번에 처리하므로 효율적입니다.
- 핵심 조건: **양쪽 데이터가 반드시 정렬되어 있어야** 합니다.
:::

### 방법 2: 중첩 루프 조인 (Nested Loop Join)

**중첩 루프 조인**은 정렬을 하지 않는 대신, **한쪽 테이블에서 범위를 정한 뒤 다른 쪽 테이블을 반복(루프)**하며 찾는 방식입니다.

여기에는 두 가지 중요한 개념이 등장합니다:

| 용어 | 의미 | 역할 |
|------|------|------|
| **선행 테이블 (Driving Table)** | 먼저 범위를 정하는 테이블 (바깥쪽 루프) | "어떤 범위를 조인할지" 결정 |
| **후행 테이블 (Driven Table)** | 반복하며 값을 찾는 테이블 (안쪽 루프) | 선행 테이블에서 나온 값과 매칭 |

비유를 들면, **학교에서 출석부(선행 테이블)를 보면서 교실(후행 테이블)에 있는 학생을 한 명씩 확인하는 것**과 같습니다. 출석부에서 "김철수"를 호명하면 교실에서 김철수를 찾고, 다음으로 "이영희"를 호명하면 교실에서 이영희를 찾는 방식입니다.

```python
# 중첩 루프 조인을 파이썬으로 구현한 예시
def nested_loop_join(driving_table, driven_table, key_r, key_s):
    """
    중첩 루프 조인으로 두 테이블을 결합하는 함수
    driving_table: 선행(드라이빙) 테이블 - 범위를 결정하는 바깥쪽 루프
    driven_table: 후행(드리븐) 테이블 - 반복 탐색하는 안쪽 루프
    """
    result = []  # 조인 결과를 저장할 리스트

    # 바깥 루프: 선행 테이블의 각 레코드에 대해
    for r_row in driving_table:
        # 안쪽 루프: 후행 테이블 전체를 반복하며 매칭 검색
        for s_row in driven_table:
            # 두 테이블의 키 값이 일치하면 결과에 추가
            if r_row[key_r] == s_row[key_s]:
                result.append({**r_row, **s_row})

    return result  # 최종 조인 결과 반환

# 예시: 생산부 직원만 조인하는 경우 (부분 범위)
# 선행 테이블에서 특정 조건(생산부)만 필터링한 후 조인
production_dept = [{"dept_id": 2, "dept_name": "생산부"}]  # 부분 범위!
all_employees = [
    {"emp_id": 1, "name": "이영희", "dept_id": 1},
    {"emp_id": 2, "name": "박민수", "dept_id": 2},
    {"emp_id": 3, "name": "김철수", "dept_id": 3},
    {"emp_id": 4, "name": "정수진", "dept_id": 2},
]

joined = nested_loop_join(production_dept, all_employees, "dept_id", "dept_id")
for row in joined:
    print(row)
# 결과: 박민수와 정수진만 조인됨 (생산부 소속)
```

**코드 한 줄씩 설명:**
- `for r_row in driving_table`: 선행 테이블의 레코드를 하나씩 가져옵니다(바깥 루프).
- `for s_row in driven_table`: 선행 테이블의 각 레코드마다 후행 테이블 **전체**를 반복합니다(안쪽 루프).
- `if r_row[key_r] == s_row[key_s]`: 양쪽 키 값이 같으면 매칭 성공으로 판단하여 결과에 추가합니다.

:::info 후행 테이블에 인덱스가 있으면?
후행 테이블에 **인덱스가 설정되어 있으면** 안쪽 루프에서 전체를 다 뒤지는 대신 인덱스를 통해 빠르게 검색할 수 있어 **훨씬 효율적으로** 조인을 수행할 수 있습니다. 마치 교실에서 학생을 찾을 때 자리 배치도(인덱스)가 있으면 바로 찾아갈 수 있는 것과 같습니다.
:::

**정렬 병합 조인 vs 중첩 루프 조인 비교:**

| 비교 항목 | 정렬 병합 조인 | 중첩 루프 조인 |
|-----------|---------------|---------------|
| **정렬 필요 여부** | 양쪽 모두 정렬 필요 ✅ | 정렬 불필요 ❌ |
| **적합한 상황** | 전체 데이터를 조인할 때 | 부분 범위를 조인할 때 |
| **처리량** | 대량 데이터에 유리 | 소량~부분 데이터에 유리 |
| **핵심 포인트** | 정렬 비용 | 선행 테이블의 범위 결정 |

### 방법 3: 해시 조인 (Hash Join)

**해시 조인**은 정렬도 하지 않고 인덱스도 사용하지 않습니다. 대신 **해시 함수를 이용해서 주소를 계산**하고, 그 주소 값이 같은 것끼리 한 번에 매칭시키는 방법입니다.

비유하면, 학교에서 학생들을 **생일 월별로 바구니에 나누어 담아 놓고**, 같은 바구니에 있는 학생들끼리만 비교하는 것과 같습니다. 전체를 비교하지 않고 **같은 그룹끼리만 비교**하니 훨씬 효율적입니다.

작동 원리:
1. **R 테이블**의 조인 키 값을 해시 함수에 넣어 **주소를 계산**합니다.
2. **S 테이블**의 조인 키 값도 동일한 해시 함수에 넣어 **주소를 계산**합니다.
3. **같은 주소**를 가진 값끼리 매칭하여 조인합니다.

```python
# 해시 조인을 파이썬으로 구현한 예시
def hash_join(table_r, table_s, key_r, key_s):
    """
    해시 조인으로 두 테이블을 결합하는 함수
    해시 테이블을 만들어서 빠르게 매칭합니다.
    """
    # 1단계: R 테이블을 해시 테이블로 변환 (해시 함수 = 딕셔너리 키)
    hash_table = {}
    for r_row in table_r:
        hash_key = r_row[key_r]  # 조인 키 값을 해시 키로 사용
        if hash_key not in hash_table:
            hash_table[hash_key] = []  # 같은 키가 없으면 새 리스트 생성
        hash_table[hash_key].append(r_row)  # 해당 키의 리스트에 추가

    # 2단계: S 테이블을 순회하며 해시 테이블에서 매칭 검색
    result = []
    for s_row in table_s:
        lookup_key = s_row[key_s]  # S 테이블의 조인 키 값
        if lookup_key in hash_table:  # 해시 테이블에 같은 키가 있으면
            for r_row in hash_table[lookup_key]:  # 매칭되는 모든 R 행과 결합
                result.append({**r_row, **s_row})

    return result  # 최종 조인 결과 반환

# 예시 실행
employees = [
    {"emp_id": 1, "name": "이영희", "dept_id": 1},
    {"emp_id": 2, "name": "박민수", "dept_id": 2},
    {"emp_id": 3, "name": "김철수", "dept_id": 2},
]
departments = [
    {"dept_id": 1, "dept_name": "영업부"},
    {"dept_id": 2, "dept_name": "생산부"},
]

joined = hash_join(employees, departments, "dept_id", "dept_id")
for row in joined:
    print(row)
```

**코드 한 줄씩 설명:**
- `hash_table = {}`: R 테이블의 데이터를 키 값 기준으로 빠르게 찾을 수 있도록 해시 테이블(딕셔너리)을 만듭니다.
- `hash_key = r_row[key_r]`: R 테이블 각 행의 조인 키 값을 해시 키로 사용합니다.
- `hash_table[hash_key].append(r_row)`: 같은 키 값을 가진 행들을 같은 바구니(리스트)에 모읍니다.
- `if lookup_key in hash_table`: S 테이블의 키 값이 해시 테이블에 존재하는지 **O(1)** 시간에 확인합니다.
- `for r_row in hash_table[lookup_key]`: 매칭되는 R 행이 여러 개일 수 있으므로 모두 결합합니다.

:::warning 해시 조인의 제약 사항
- **동일 조인(Equi Join)**에서만 사용 가능합니다. 즉, `=` 조건으로 비교하는 경우에만 해시 함수를 통해 정확히 한 값을 매칭할 수 있습니다.
- 해시 함수를 통한 **주소 계산에 CPU 비용**이 발생합니다.
- 비용 기반 옵티마이저(Cost-Based Optimizer)에서 주로 사용됩니다.
:::

### 세 가지 조인 방법 종합 비교

| 비교 항목 | 정렬 병합 조인 | 중첩 루프 조인 | 해시 조인 |
|-----------|---------------|---------------|-----------|
| **정렬 필요** | ✅ 양쪽 모두 | ❌ 불필요 | ❌ 불필요 |
| **인덱스 필요** | ❌ 불필요 | ✅ 후행 테이블에 있으면 유리 | ❌ 불필요 |
| **적합한 상황** | 전체 데이터 대량 처리 | 부분 범위 처리 | 동일 조인, 비용 기반 최적화 |
| **주요 비용** | 정렬 비용 | 루프 반복 비용 | CPU 해시 계산 비용 |
| **비유** | 양쪽 카드를 정렬해서 맞추기 | 출석부 보며 교실에서 찾기 | 생일 월별 바구니로 분류해 찾기 |

---

## 💰 쿼리 처리 비용의 종류

조인 연산을 포함한 쿼리(질의)를 수행할 때는 다양한 **비용(Cost)**이 발생합니다. 어떤 조인 방법이 가장 효율적인지 판단하려면 이러한 비용을 종합적으로 고려해야 합니다.

### 5가지 주요 비용

| 비용 종류 | 설명 | 쉬운 비유 |
|-----------|------|-----------|
| **디스크 I/O 비용** | 하드디스크에서 데이터를 읽고 쓰는 비용 | 창고에서 물건을 꺼내오는 시간 |
| **저장 비용** | 중간 결과를 임시로 저장하는 비용 | 작업대에 재료를 잠시 놓아두는 공간 |
| **계산 비용** | CPU에서 연산(해시 함수, 비교 등)을 수행하는 비용 | 계산기로 복잡한 계산을 하는 시간 |
| **메모리 사용 비용** | 데이터를 메모리에 올려놓고 처리하는 비용 | 요리할 때 조리대 위의 공간 |
| **네트워크 통신 비용** | 분산 데이터베이스에서 데이터를 주고받는 비용 | 다른 도시에서 재료를 택배로 받는 시간 |

예를 들어, R 테이블과 S 테이블을 조인하고 그 결과를 다시 T 테이블과 조인해야 한다면(R × S × T), **R과 S의 조인 중간 결과**를 어딘가에 저장해야 T와 다시 연산할 수 있습니다. 이때 중간 결과를 저장하는 데 드는 비용이 바로 **저장 비용**입니다.

### 비용 계산에 필요한 카탈로그 정보

이러한 비용을 실제로 계산하려면 **데이터 사전(카탈로그, Catalog)**에 저장된 정보를 참조해야 합니다:

- **레코드 개수**: 테이블에 저장된 데이터가 몇 건인지 (10건과 100만 건은 완전히 다름)
- **블록 수**: 디스크에서 읽어야 하는 I/O 단위(블록)의 개수
- **블로킹 팩터(Blocking Factor)**: 하나의 블록에 레코드가 몇 개 저장되는지
- **인덱스 단계 수**: 인덱스가 몇 단계로 구성되어 있는지 (1단계, 2단계, 3단계 등)
- **제1단계 인덱스의 블록 수**: 첫 번째 인덱스의 크기 (성능에 가장 큰 영향)
- **인덱스의 고유 값 범위**: 인덱스 컬럼에 서로 다른 값이 얼마나 있는지
- **선택도(Selectivity)**: 하나의 조건을 만족하는 레코드의 평균 개수

:::note 왜 카탈로그 정보가 중요한가?
단순히 "I/O 횟수가 몇 번이다"만으로 비용을 계산하는 것이 아니라, 레코드 수, 블록 수, 인덱스 단계 등의 **카탈로그 정보를 조합**해서 실제 비용을 추정합니다. 마치 택배비를 계산할 때 무게, 크기, 거리를 모두 고려하는 것과 같습니다.
:::

---

## 🔧 데이터베이스 튜닝의 단계별 방법

데이터베이스 성능을 향상시키기 위한 튜닝은 크게 **3단계**로 나눌 수 있습니다. 아래에서 위로 갈수록 더 정교하고 전문적인 방법입니다.

### 1단계: 하드웨어 교체 (가장 낮은 단계)

가장 단순하면서도 직접적인 방법입니다. **컴퓨터가 느려지면 좋은 부품으로 교체**하는 것이죠.

- **디스크 성능 저하** → 더 빠른 디스크(SSD 등)로 교체 또는 디스크 추가
- **메모리 부족** → 메모리 용량 증설
- **CPU 성능 부족** → 더 좋은 CPU로 교체
- **네트워크 속도 저하** → 더 빠른 네트워크로 업그레이드

:::info 메모리 크기 결정의 규칙
- **5분 규칙**: 메모리에 올린 데이터가 5분 내에 다시 이용될 가능성이 있다면, 메모리를 충분히 크게 설정하는 것이 좋습니다.
- **1분 규칙**: 1분마다 계속 메모리가 사용된다면 1분 규칙을 적용하여 메모리 크기를 결정합니다.
:::

### 2단계: 인스턴스 파라미터 조정 (중간 단계)

데이터베이스의 **설정 값(파라미터)을 조정**하여 성능을 향상시키는 방법입니다.

마치 워드프로세서의 **자동 저장 간격**을 조정하는 것과 같습니다. 자동 저장이 1분마다로 설정되어 있으면 문서 작성 중 1분마다 저장이 일어나 컴퓨터가 잠시 멈추는 현상이 발생합니다. 이를 30분으로 늘리면 그만큼 작업이 끊기지 않고 원활하게 진행됩니다.

조정 가능한 파라미터의 예시:
- **체크포인트 간격**: 자동 저장 주기 설정 (너무 짧으면 성능 저하)
- **버퍼 크기**: 메모리에 데이터를 얼마나 올려놓을지
- **블로킹 팩터**: I/O 단위 크기 설정
- **데이터베이스 세션 수**: 동시 접속 수 조정

### 3단계: SQL 및 구조 최적화 (가장 위 단계)

가장 전문적이고 효과가 큰 방법입니다. **정규화, 인덱스 추가/제거, 뷰 활용, 쿼리 최적화** 등이 포함됩니다.

#### 인덱스 관리

```sql
-- ✅ 검색 성능이 떨어질 때: 인덱스를 추가
-- WHERE 절, JOIN 조건, 기본키/외래키에 자주 사용되는 컬럼에 설정
CREATE INDEX idx_employee_dept 
ON employees(dept_id);  -- dept_id 컬럼에 인덱스 생성

-- ❌ 갱신 성능이 떨어질 때: 불필요한 인덱스를 제거
-- INSERT, UPDATE, DELETE가 빈번한 테이블에 인덱스가 너무 많으면 역효과
DROP INDEX idx_employee_dept;  -- 불필요한 인덱스 제거
```

**한 줄씩 설명:**
- `CREATE INDEX idx_employee_dept ON employees(dept_id)`: employees 테이블의 dept_id 컬럼에 인덱스를 생성합니다. 검색 시 전체를 뒤지지 않고 인덱스를 통해 빠르게 찾을 수 있습니다.
- `DROP INDEX idx_employee_dept`: 인덱스를 삭제합니다. 갱신 작업이 많은 환경에서는 인덱스가 오히려 성능을 저하시킬 수 있기 때문입니다.

:::danger 인덱스의 양면성
인덱스는 **검색 성능은 향상**시키지만, **갱신(INSERT/UPDATE/DELETE) 성능은 저하**시킵니다. 인덱스가 있으면 데이터를 변경할 때마다 인덱스도 함께 업데이트해야 하기 때문입니다. 따라서 **검색보다 갱신이 많은 테이블**에는 인덱스를 과도하게 설정하지 않는 것이 좋습니다.
:::

#### 불필요한 연산 줄이기

```sql
-- ❌ 잘못된 예시: 불필요한 정렬과 중복 제거
-- UNION은 중복을 제거하고 정렬까지 수행 → 불필요한 비용 발생
SELECT name FROM employees WHERE dept_id = 1
UNION
SELECT name FROM employees WHERE dept_id = 2;

-- ✅ 올바른 예시: 중복 제거가 필요 없다면 UNION ALL 사용
-- UNION ALL은 중복 제거와 정렬을 하지 않아 성능이 좋음
SELECT name FROM employees WHERE dept_id = 1
UNION ALL
SELECT name FROM employees WHERE dept_id = 2;
```

```sql
-- ❌ 잘못된 예시: 불필요한 DISTINCT 사용
-- DISTINCT는 중복을 제거하기 위해 정렬 연산을 수행
SELECT DISTINCT dept_id FROM employees;

-- ✅ 올바른 예시: 중복 제거가 필요 없다면 DISTINCT를 빼기
SELECT dept_id FROM employees;
```

```sql
-- ❌ 잘못된 예시: 존재 여부만 확인하면 되는데 COUNT를 사용
-- COUNT(*)는 전체 레코드 수를 세기 위해 모든 행을 읽음
SELECT COUNT(*) FROM employees WHERE dept_id = 1;

-- ✅ 올바른 예시: 데이터 존재 여부만 확인할 때는 EXISTS 사용
SELECT EXISTS(SELECT 1 FROM employees WHERE dept_id = 1);
```

```sql
-- ✅ 정렬 없이 그룹핑이 가능한 경우: SORT AGGREGATE 방식 활용
-- 물리적 정렬 없이 결과를 그룹핑하여 집계할 수 있음
SELECT dept_id, COUNT(*) 
FROM employees 
GROUP BY dept_id;  -- 실제 물리적 정렬 없이도 처리 가능
```

**핵심 원칙 정리:**
- **정렬할 필요가 없으면** 정렬하지 마라 → `UNION ALL`, `SORT AGGREGATE` 활용
- **중복 제거가 필요 없으면** 중복 제거하지 마라 → `DISTINCT` 사용 자제
- **전체 개수가 필요 없으면** 카운트하지 마라 → `EXISTS` 활용
- **집합 중심의 처리**가 효율적이다 → 조건에 맞는 데이터를 묶어서 처리
- **미니 배치 트랜잭션** 활용 → 한꺼번에 처리하지 말고 작은 단위로 분할 처리

---

## 📊 성능 평가와 데이터 품질 관리

### TPC 성능 평가 기준

데이터베이스 성능이 "좋다" 또는 "나쁘다"를 주관적으로 판단하는 것이 아니라, **국제적으로 표준화된 기준**으로 평가합니다. 이를 **TPC(Transaction Processing Performance Council)**라고 합니다.

**성능 측정의 핵심 기준:** 1초에 몇 건의 트랜잭션(Transaction, 작업 묶음)을 처리할 수 있느냐

예를 들어, 시스템 A는 1초에 10건을 처리하고, 시스템 B는 1초에 100건을 처리한다면 시스템 B가 10배 더 좋은 성능을 가진 것입니다.

비즈니스에서는 단순 처리량보다 **Price per TPS(단위 시간당 처리 비용)**를 더 많이 사용합니다. "1초에 100건 처리하는데 비용이 25만 원이다"라는 식으로 **가성비**를 따지는 것입니다.

| TPC 종류 | 평가 대상 | 적용 예시 |
|----------|-----------|-----------|
| **TPC-A** | 단순 입출금 시스템 | 은행 ATM 시스템 |
| **TPC-B** | 운영체제 평가 | 서버 OS 성능 비교 |
| **TPC-C** | 일반 주문 처리 시스템 | 항공권 예약, 온라인 주문 |
| **TPC-D** | 의사결정 시스템 | 경영 분석, 데이터 분석 |
| **TPC-H** | 예측 불가능한 대량 쿼리 | 빅데이터 분석, 복잡한 질의 |
| **TPC-R** | 보고서 기능 | 매출 요약 보고서 생성 |
| **TPC-W** | 웹/인터넷 기반 시스템 | 이커머스 사이트 |

:::tip 어떤 TPC를 써야 할까?
- 온라인 주문 처리 시스템을 평가한다면 → **TPC-C**
- 의사결정 시스템을 평가한다면 → **TPC-D**
- 인터넷 환경에서 평가해야 한다면 → **TPC-W**
- 객체지향 데이터베이스라면 → **OO1, OO7** 등 별도 벤치마크 사용
:::

### 데이터 품질 관리

성능이 아무리 좋아도 **데이터의 품질(Quality)**이 나쁘면 의미가 없습니다. 마치 슈퍼카의 성능이 아무리 좋아도 가끔 폭발하면 사용할 수 없는 것처럼, **성능과 품질은 동시에 충족**되어야 합니다.

> **데이터 품질** = 데이터 이용자를 만족시킬 수 있는 수준  
> **데이터 품질 관리** = 그 수준을 유지하고 관리하는 모든 활동

데이터 품질 진단은 크게 세 가지로 나뉩니다:

**1. 값 진단(Value Diagnosis)**
- 테이블, 속성, 코드, 관계, 비즈니스 규칙 기준으로 **데이터 값** 자체를 분석
- 값이 정확한지, 오류가 있는지, 변경되지 않아야 할 값이 변경되었는지 확인
- 마치 **요리의 맛을 보는 것**과 같음

**2. 구조 진단(Structure Diagnosis)**
- 모델링, 스키마 구조가 제대로 설계되어 있는지 확인
- **리버스 모델링**(완성된 결과물에서 거꾸로 설계도를 찾아가는 방법)을 통해 진단
- 마치 **건물의 설계도가 올바른지 점검하는 것**과 같음

**3. 관리 프로세스 진단(Process Diagnosis)**
- 값과 구조가 **전체 수명 주기에 걸쳐 체계적으로 관리**되고 있는지 확인
- 마치 **식당에서 음식의 맛(값)뿐 아니라 위생 관리 프로세스 전체가 잘 운영되는지** 점검하는 것

---

## ⚠️ 주의사항 및 실무 팁

### 조인 관련 주의사항

:::warning 조인 시 꼭 기억할 것
1. **조인은 피할 수 없다**: 정규화된 DB에서 여러 테이블의 데이터가 필요하면 조인은 필수입니다.
2. **조인 방식 선택이 핵심**: 같은 조인이라도 방식에 따라 성능 차이가 수십 배 날 수 있습니다.
3. **인덱스 활용**: 중첩 루프 조인 시 후행 테이블에 인덱스가 있으면 성능이 크게 향상됩니다.
4. **데이터 양 고려**: 소량이면 중첩 루프, 대량이면 정렬 병합이나 해시 조인을 고려하세요.
:::

### 튜닝 관련 실무 팁

:::tip 초보자를 위한 튜닝 체크리스트
- ✅ WHERE 절에 자주 사용하는 컬럼에 **인덱스를 설정**했는지 확인
- ✅ 불필요한 **DISTINCT**, **UNION**(UNION ALL로 대체 가능한지) 확인
- ✅ **SELECT ***보다 필요한 컬럼만 명시했는지 확인
- ✅ 존재 여부만 확인할 때 **COUNT 대신 EXISTS** 사용했는지 확인
- ✅ 대량 데이터 처리 시 **미니 배치(작은 단위로 나눠 처리)**를 적용했는지 확인
- ✅ 갱신이 잦은 테이블에 **불필요한 인덱스가 과도하게 설정**되어 있지 않은지 확인
:::

### 커리어 관점에서의 조언

데이터베이스 튜닝은 단순 개발 업무를 넘어서 **DBA(데이터베이스 관리자)**, **IT 컨설턴트** 영역의 전문 기술입니다. 조인 연산의 원리, 접근 루틴의 알고리즘, 비용 계산 방법 등을 깊이 이해하면 단순 개발자를 넘어 **시스템 성능 최적화 전문가**로 성장할 수 있습니다. 이러한 지식을 갖추면 설계, 개발, 유지보수, 성능 컨설팅까지 업무 영역을 넓히고 전문성과 몸값을 높일 수 있습니다.

---

## 📌 핵심 정리

- **데이터베이스 튜닝**이란 성능을 향상시키기 위해 여러 설정과 구조를 조정하는 모든 작업이다
- **조인 연산**은 여러 테이블을 읽고 비교해야 하므로 성능 저하의 주요 원인이 된다
- **Selection 연산**의 검색 방법에는 선형 탐색, 이진 탐색, 인덱스 탐색, 해싱 등이 있다
- **정렬 병합 조인**은 양쪽을 정렬 후 동시에 비교하며, 대량 전체 데이터 처리에 유리하다
- **중첩 루프 조인**은 선행 테이블의 범위를 정하고 후행 테이블을 반복 탐색하며, 부분 범위 처리에 유리하다
- **해시 조인**은 해시 함수로 주소를 계산하여 매칭하며, 동일(Equi) 조인에서만 사용 가능하다
- 쿼리 처리 비용에는 **디스크 I/O, 저장, 계산(CPU), 메모리, 네트워크** 5가지가 있다
- 튜닝은 **하드웨어 교체 → 파라미터 조정 → SQL/구조 최적화** 3단계로 접근한다
- **인덱스**는 검색 성능은 높이지만 갱신 성능은 떨어뜨리므로 균형 있게 설정해야 한다
- **불필요한 정렬, 중복 제거, 카운트 연산**을 줄이는 것만으로도 성능이 개선된다
- **TPC**는 국제 표준 성능 평가 기준이며, 시스템 유형에 맞는 벤치마크를 선택해야 한다
- 성능뿐 아니라 **데이터 품질(값, 구조, 프로세스)**도 함께 관리해야 좋은 시스템이다

작성일: 2026-02-21