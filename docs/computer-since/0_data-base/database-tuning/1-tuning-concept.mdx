---
title: "데이터베이스 튜닝의 개념"
description: "데이터베이스 튜닝의 개념에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/database-tuning/1-tuning-concept"
sidebar_label: "튜닝 개념"
date: "2026-02-21"
---

## 🎯 데이터베이스 튜닝이란 무엇인가?

여러분은 "튜닝"이라는 단어를 일상생활에서 자주 들어보셨을 겁니다. 자동차를 튜닝한다, 기타 줄을 튜닝한다, 피아노를 튜닝한다... 이 모든 경우에서 튜닝이란 **"뭔가 잘 맞지 않을 때 성능을 향상시키기 위해 조절하는 행위"**를 의미합니다.

기타 줄의 음이 안 맞으면 줄을 조이거나 풀어서 음을 맞추고, 피아노 건반의 소리가 안 맞으면 내부 줄을 조절해서 소리를 맞추죠. 이 모든 과정이 바로 "튜닝"입니다.

**데이터베이스 튜닝**도 마찬가지입니다. 데이터베이스의 성능을 향상시키기 위해 여러 가지 조치를 취하는 것, 이러한 모든 활동을 묶어서 "데이터베이스 튜닝"이라고 말합니다. 마치 자동차 엔진을 튜닝해서 더 빠르게, 더 효율적으로 달리게 만드는 것처럼, 데이터베이스도 더 빠르게 데이터를 검색하고 처리할 수 있도록 최적화하는 과정인 것입니다.

> **데이터베이스 튜닝** = 데이터베이스 응용 프로그램, DBMS, 운영체제(OS) 등을 일부 조절하여 데이터베이스 관리 시스템(Oracle, MSSQL, MySQL 등)의 성능을 향상시켜주는 방법

:::info 튜닝은 누가 하나요?
튜닝은 일반 응용 프로그래머가 하는 일이 아닙니다. 보통 **DBA(Database Administrator, 데이터베이스 관리자)** 급에서 주로 수행하는 작업입니다. IT 분야에서 설계, 개발을 넘어 성능 향상과 컨설팅 영역까지 확장하면 전문 IT 컨설턴트로 성장할 수 있고, 그만큼 몸값도 크게 올라갑니다.
:::

---

## 🔍 왜 데이터베이스 튜닝이 필요한가?

### 조인(Join) 연산의 성능 문제

관계형 데이터베이스에서는 **Selection(선택)**, **Projection(투영)**, **Join(결합)** 등 다양한 관계대수 연산이 존재합니다. 이 중에서 특히 **Join 연산**은 성능을 매우 크게 떨어뜨리는 주범입니다.

왜 그럴까요? 비유를 들어보겠습니다. 만약 냉장고 하나에서 재료를 꺼내면 되는 상황이라면 간단하겠죠. 하지만 냉장고가 여러 대에 흩어져 있고, 각 냉장고에서 재료를 꺼낸 뒤 서로 비교해서 맞는 조합을 찾아야 한다면 어떨까요? 훨씬 시간이 오래 걸릴 겁니다.

Join 연산이 바로 이런 상황입니다:

- **하나의 테이블**에서 결과를 가져올 수 있다면 → 간단하고 빠름
- **여러 테이블**에서 결과를 가져와야 한다면 → 외래 키(Foreign Key)를 기준으로 비교하고, 맞는 값을 찾아내야 함

여러 테이블을 읽어야 하고, 값을 비교해야 하고, 그중에서 맞는 값을 추출해야 하는 과정을 거치면 그만큼 연산을 여러 번 해야 하기 때문에 성능이 떨어지게 됩니다.

그렇다고 Join 연산을 안 할 수는 없습니다. 여러 테이블에서 원하는 결과를 가져오려면 결국 Join이 필수적이기 때문입니다. 그래서 **어떻게 하면 더 효율적으로 Join을 수행할 수 있는가**가 바로 튜닝의 핵심 주제가 되는 것입니다.

### 알고리즘의 이해가 중요한 이유

관계대수 연산을 C, Java 같은 프로그래밍 언어로 구현할 때, 그 내부 알고리즘(문제를 해결하는 절차)을 이해하면 훨씬 효율적인 프로그램을 만들 수 있습니다. 정렬하는 방법, Join하는 방법을 이론적으로 이해하고 구현하는 것과, 아무것도 모르고 그냥 구현하는 것은 천지 차이입니다.

---

## 📚 접근 루틴(Access Routine)의 개념

### 접근 루틴이란?

데이터에 접근하는 방법, 즉 **접근 경로(Access Path)**를 통해 데이터를 찾아가는 프로시저(절차)를 **접근 루틴**이라고 합니다. 관계대수 연산(Selection, Join 등)이나 결합 연산, 집단 함수(SUM, AVG 등)를 실행하는 루틴을 전부 접근 루틴이라고 부릅니다.

> 하나의 연산(예: Selection)도 **여러 가지 접근 루틴**으로 구현할 수 있습니다. 그리고 각 접근 루틴은 특정 저장 구조와 접근 경로에 적용해서 처리할 수 있습니다.

쉽게 말해, 같은 목적지를 가더라도 고속도로로 갈 수도 있고, 국도로 갈 수도 있고, 지름길로 갈 수도 있는 것처럼, 같은 데이터를 찾더라도 여러 방법이 존재한다는 뜻입니다.

---

## 🔎 Selection 연산의 접근 방법

Selection(선택 연산)은 **조건에 맞는 데이터를 찾는 것**입니다. 예를 들어 학생 테이블에서 "점수가 50점 이하인 학생의 번호를 찾아라"라는 질의가 있다고 가정해봅시다.

| 학번 | 점수 |
|------|------|
| 1 | 100 |
| 2 | 80 |
| 3 | 50 |
| 4 | 70 |
| 5 | 90 |

이 테이블(R)에서 `점수 ≤ 50`인 학번을 찾으면, **3번 학생**이 결과가 됩니다.

그렇다면 이 50점 이하인 학생을 **어떻게 찾을 것인가?** 여기에 네 가지 방법이 있습니다.

### 1️⃣ 선형 탐색 (Linear Search)

**모든 레코드를 처음부터 끝까지 순서대로 하나씩 검사하는 방법**입니다. 마치 책장에서 원하는 책을 찾기 위해 첫 번째 칸부터 마지막 칸까지 하나씩 살펴보는 것과 같습니다.

데이터가 정렬되어 있지 않아도 상관없이, 그냥 순서대로 처리합니다.

```text
# 선형 탐색 과정
1번 학생: 점수 100 → 50 이하? ❌ (패스)
2번 학생: 점수 80  → 50 이하? ❌ (패스)
3번 학생: 점수 50  → 50 이하? ✅ (찾았다!)
4번 학생: 점수 70  → 50 이하? ❌ (패스)
5번 학생: 점수 90  → 50 이하? ❌ (패스)
```

찾고자 하는 데이터가 **맨 앞에 있으면 첫 번째에 찾고**, **맨 뒤에 있으면 마지막에 찾게** 됩니다. 따라서 **평균적으로 전체 데이터의 약 50%**를 탐색해야 합니다. 데이터가 100만 건이라면 평균 50만 건을 봐야 하니, 대량 데이터에서는 상당히 비효율적입니다.

### 2️⃣ 이진 탐색 (Binary Search)

이진 탐색은 **데이터가 반드시 정렬되어 있어야** 사용할 수 있는 방법입니다. 정렬된 데이터를 **반반씩 잘라가며** 찾는 방식입니다.

먼저 점수를 기준으로 오름차순 정렬합니다:

| 학번 | 점수 |
|------|------|
| 3 | 50 |
| 4 | 70 |
| 2 | 80 |
| 5 | 90 |
| 1 | 100 |

이제 50점을 찾는 과정을 살펴봅시다:

```text
# 이진 탐색 과정 (50점 찾기)
전체: [50, 70, 80, 90, 100]

1단계: 가운데 값 = 80 → 50 < 80 → 왼쪽에 있다!
2단계: 왼쪽 부분 [50, 70] → 가운데 값 = 50 → 찾았다! ✅
```

반씩 잘라가기 때문에 **탐색 횟수를 크게 줄여줍니다**. 선형 탐색이 최악의 경우 N번을 봐야 한다면, 이진 탐색은 최악의 경우 **log₂N번**만 보면 됩니다. 100만 건의 데이터도 약 20번이면 찾을 수 있습니다.

:::warning 이진 탐색의 전제 조건
이진 탐색을 사용하려면 **데이터가 반드시 정렬되어 있어야 합니다.** 정렬되지 않은 데이터에는 이진 탐색을 적용할 수 없으므로, 먼저 정렬 작업이 선행되어야 합니다.
:::

### 3️⃣ 인덱스를 이용한 탐색

마치 **책의 목차**를 이용하는 것과 같습니다. 120페이지의 내용을 찾고 싶다면, 책을 처음부터 한 장씩 넘기는 것이 아니라 **목차를 먼저 펴서** 120페이지가 어디에 해당하는지 확인한 뒤, 바로 그 페이지로 이동하는 방식입니다.

데이터베이스에서도 마찬가지로, 인덱스(색인)라는 별도의 자료 구조를 만들어 놓고, 그 인덱스를 통해 원하는 데이터의 위치를 빠르게 찾아가는 방법입니다.

### 4️⃣ 해싱(Hashing)을 이용한 탐색

해싱은 **해시 함수(Hash Function)**라는 수학적 함수에 값을 넣으면, **바로 데이터의 주소가 나오는 방식**입니다. 마치 택배 송장 번호를 입력하면 바로 택배의 위치가 나오는 것처럼, 함수에 검색할 값을 넣으면 즉시 해당 데이터의 저장 위치를 알 수 있습니다.

```text
# 해싱의 개념
h("db") → 120  → 바로 120번 주소로 이동!
```

| 탐색 방법 | 정렬 필요 | 속도 | 특징 |
|-----------|-----------|------|------|
| 선형 탐색 | ❌ | 느림 | 모든 데이터를 순서대로 검사 |
| 이진 탐색 | ✅ | 빠름 | 반씩 나눠서 검색 |
| 인덱스 탐색 | ❌ | 빠름 | 목차(인덱스)를 통해 위치 파악 |
| 해싱 탐색 | ❌ | 매우 빠름 | 함수로 주소를 직접 계산 |

---

## 🔗 Join 연산의 구현 방법

Join 연산은 Selection보다 **훨씬 복잡**합니다. 하나의 테이블이 아니라, **두 개 이상의 테이블**에서 특정 열의 값을 비교하여 결합하는 연산이기 때문입니다.

R 테이블과 S 테이블이 있을 때, R에 있는 어떤 열의 값과 S에 있는 어떤 열의 값을 비교해서 같은 것을 찾아 합치는 것이 Join 연산입니다.

### 1️⃣ 정렬 합병 조인 (Sort-Merge Join)

**"정렬해서 합병하는 방식"**입니다. 이름 그대로 두 테이블을 모두 정렬한 뒤, 동시에 비교하면서 같은 값을 찾아가는 방법입니다.

비유를 들어보겠습니다. 왼쪽에 종이 카드 묶음(R)이 있고, 오른쪽에 종이 카드 묶음(S)이 있다고 합시다. 양쪽에서 같은 카드를 찾으려 합니다.

❌ **비효율적인 방법:**
왼쪽에서 A 카드를 꺼내고, 오른쪽 전체를 뒤져서 A를 찾고. 다시 왼쪽에서 B 카드를 꺼내고, 오른쪽 전체를 다시 뒤져서 B를 찾고... 이러면 너무 비효율적입니다.

✅ **정렬 합병 조인 방법:**
먼저 왼쪽 카드를 A, B, C, D 순으로 정렬하고, 오른쪽 카드도 A, B, C, D 순으로 정렬합니다. 그러면 양쪽 모두 맨 앞에 A가 있으니 쉽게 찾을 수 있겠죠! 정렬이 되어 있으니까 순서대로 하나씩 비교하면 되는 것입니다.

```python
# 정렬 합병 조인 의사코드 (Python 스타일)

# 1단계: 양쪽 테이블을 정렬한다
R_sorted = sorted(R, key=lambda x: x['join_key'])  # R 테이블을 조인 키 기준으로 정렬
S_sorted = sorted(S, key=lambda x: x['join_key'])  # S 테이블을 조인 키 기준으로 정렬

# 2단계: 양쪽 포인터를 처음에 놓고 동시에 비교하며 진행
i = 0  # R 테이블의 현재 위치
j = 0  # S 테이블의 현재 위치
result = []  # 조인 결과를 저장할 리스트

while i < len(R_sorted) and j < len(S_sorted):
    if R_sorted[i]['join_key'] == S_sorted[j]['join_key']:
        # 같은 값을 찾았으면 결과에 추가
        result.append((R_sorted[i], S_sorted[j]))
        i += 1  # R의 다음 레코드로 이동
        j += 1  # S의 다음 레코드로 이동
    elif R_sorted[i]['join_key'] < S_sorted[j]['join_key']:
        # R의 값이 더 작으면 R을 앞으로 이동
        i += 1
    else:
        # S의 값이 더 작으면 S을 앞으로 이동
        j += 1
```

**한 줄씩 설명:**
- `R_sorted = sorted(R, ...)` → R 테이블을 조인 키(비교할 열) 기준으로 오름차순 정렬합니다.
- `S_sorted = sorted(S, ...)` → S 테이블도 마찬가지로 정렬합니다.
- `i = 0`, `j = 0` → 양쪽 테이블의 시작 위치를 가리키는 포인터입니다.
- `while` 루프 → 양쪽 모두 끝에 도달할 때까지 반복합니다.
- `==` 비교 → 값이 같으면 결과에 추가하고 양쪽 모두 다음으로 이동합니다.
- `<` 비교 → R의 값이 더 작으면 R만 앞으로 이동합니다 (S에서 맞는 값을 찾을 가능성이 없으므로).
- `else` → S의 값이 더 작으면 S만 앞으로 이동합니다.

:::tip 정렬 합병 조인은 언제 유리한가?
- **전체 데이터를 처리해야 하는 경우**에 주로 적용됩니다.
- **처리량이 많은 경우**, 왼쪽과 오른쪽을 전부 다 처리해야 할 때 유용합니다.
- 가장 기본적인 조건은 **데이터가 정렬되어 있어야 한다**는 것입니다.
:::

### 2️⃣ 중첩 루프 조인 (Nested Loop Join)

중첩 루프 조인은 **전체가 아니라 부분 범위를 처리할 때 유리한** 방식입니다. 정렬 합병 조인이 양쪽 모두 전체를 대상으로 하는 것에 비해, 중첩 루프 조인은 **한쪽(선행 테이블)에서 범위를 정하고, 다른 쪽(후행 테이블)에서 루프를 돌며 찾는 방식**입니다.

여기서 두 가지 중요한 용어가 등장합니다:

| 용어 | 다른 이름 | 역할 |
|------|-----------|------|
| **선행 테이블** | 드라이빙 테이블 (Driving Table) | 범위를 결정하는 테이블 (바깥 루프) |
| **후행 테이블** | 내부 릴레이션 (Inner Relation) | 루프를 돌며 값을 찾는 테이블 (안쪽 루프) |

예를 들어, "생산부에 있는 직원들의 주소를 찾아라"라는 질의가 있다면:
- **선행 테이블(R)**: 부서 테이블 → "생산부"에 해당하는 직원들만 추출 (범위 결정)
- **후행 테이블(S)**: 직원 테이블 → 추출된 직원에 해당하는 주소를 루프를 돌며 검색

```python
# 중첩 루프 조인 의사코드 (Python 스타일)

result = []  # 조인 결과를 저장할 리스트

# 바깥 루프: 선행(드라이빙) 테이블에서 조건에 맞는 레코드를 순회
for r_row in R_driving:  # R에서 범위가 결정된 레코드들
    # 안쪽 루프: 후행(내부) 테이블 전체를 반복하며 매칭 검색
    for s_row in S_inner:  # S 전체를 루프 돌며 확인
        if r_row['join_key'] == s_row['join_key']:
            # 조인 키가 같으면 결과에 추가
            result.append((r_row, s_row))
```

**한 줄씩 설명:**
- `for r_row in R_driving` → 선행 테이블(범위가 결정된 R)에서 한 건씩 가져옵니다. 이 루프의 범위가 전체 처리량을 결정합니다.
- `for s_row in S_inner` → 후행 테이블(S) 전체를 순회하면서 매칭되는 값을 찾습니다.
- `if r_row['join_key'] == s_row['join_key']` → 양쪽의 조인 키 값을 비교합니다.
- `result.append(...)` → 값이 같으면 조인 결과로 추가합니다.

:::tip 후행 테이블에 인덱스가 있으면?
후행 테이블에 **인덱스가 설정되어 있으면** 훨씬 효율적으로 검색할 수 있습니다. 인덱스를 통해 빠르게 찾아갈 수 있기 때문에, 안쪽 루프를 전부 돌지 않아도 됩니다. 따라서 중첩 루프 조인에서는 **후행 테이블에 인덱스가 존재하는 경우** 훨씬 효율적입니다.
:::

> **핵심:** 선행 드라이브(드라이빙 테이블)가 **어느 범위까지 처리할 것인지**가 결국 전체 처리량을 결정합니다.

### 3️⃣ 해시 조인 (Hash Join)

해시 조인은 정렬도 필요 없고, 인덱스도 필요 없는 방식입니다. 대신 **해시 함수를 이용하여 양쪽 테이블의 주소를 계산**하고, 주소 값이 같은 것끼리 한 번에 찾아가는 방식입니다.

R 테이블의 조인 키에 해시 함수를 적용하여 주소를 계산하고, S 테이블의 조인 키에도 같은 해시 함수를 적용하여 주소를 계산합니다. 주소가 같으면 같은 값이므로, 한 번에 매칭을 찾아갈 수 있습니다.

```python
# 해시 조인 의사코드 (Python 스타일)

# 1단계: R 테이블의 데이터를 해시 테이블에 저장
hash_table = {}  # 해시 테이블 (딕셔너리)
for r_row in R:
    key = hash_function(r_row['join_key'])  # 해시 함수로 주소 계산
    hash_table[key] = r_row  # 해시 테이블에 저장

# 2단계: S 테이블을 순회하며 해시 테이블에서 매칭 검색
result = []  # 조인 결과
for s_row in S:
    key = hash_function(s_row['join_key'])  # 같은 해시 함수로 주소 계산
    if key in hash_table:
        # 같은 주소에 데이터가 있으면 조인 성공
        result.append((hash_table[key], s_row))
```

**한 줄씩 설명:**
- `hash_table = {}` → 해시 테이블을 빈 딕셔너리로 초기화합니다.
- `hash_function(r_row['join_key'])` → R의 조인 키에 해시 함수를 적용하여 주소(키)를 계산합니다.
- `hash_table[key] = r_row` → 계산된 주소에 R의 데이터를 저장합니다.
- 두 번째 루프에서 S의 조인 키에도 **같은 해시 함수**를 적용합니다.
- `if key in hash_table` → 같은 주소에 R의 데이터가 있으면 매칭이 성공한 것입니다.

:::warning 해시 조인의 제한사항
- **동일 조인(Equi Join)에서만** 사용할 수 있습니다. 즉, `=` 조건일 때만 가능합니다. 해시 함수는 하나의 입력에 하나의 출력만 나오기 때문에, "같은 값"인 경우에만 처리할 수 있습니다.
- CPU에서 **주소를 계산하는 데 시간이 걸린다**는 것이 단점입니다.
- **비용 기반 옵티마이저(Cost-Based Optimizer)**에서 주로 사용되는 방식입니다.
:::

### 세 가지 조인 방식 비교

| 구분 | 정렬 합병 조인 | 중첩 루프 조인 | 해시 조인 |
|------|---------------|---------------|-----------|
| **정렬 필요** | ✅ 양쪽 모두 | ❌ 불필요 | ❌ 불필요 |
| **인덱스 필요** | ❌ | ✅ 후행 테이블에 있으면 유리 | ❌ |
| **적합한 상황** | 전체 데이터 처리 | 부분 범위 처리 | 동일 조인(=) |
| **핵심 원리** | 정렬 후 동시 비교 | 바깥-안쪽 이중 루프 | 해시 함수로 주소 계산 |
| **성능 관건** | 정렬 비용 | 드라이빙 테이블 범위 | CPU 계산 비용 |

---

## 💰 질의 처리 비용의 종류

데이터베이스에서 질의(Query)를 처리할 때는 다양한 **비용(Cost)**이 발생합니다. 어떤 조인 방식이 가장 효율적인지 판단하려면, 이러한 비용을 계산해야 합니다.

### I/O 비용 (보조기억장치 접근 비용)

하드디스크에서 데이터를 찾아오고, 데이터를 저장하는 데 들어가는 비용입니다. 마치 창고에서 물건을 꺼내오는 데 드는 시간과 노력이라고 생각하면 됩니다.

### 저장 비용

R과 S를 조인하면 그 결과는 **중간 결과(임시 데이터)**입니다. 예를 들어 `R × S × T`를 계산한다면, 먼저 `R × S`의 결과를 어딘가에 저장해두고, 그 결과에 다시 T를 곱해야 합니다. 이런 중간 결과를 저장하는 데 들어가는 비용이 저장 비용입니다.

### 계산 비용 (CPU 처리 비용)

CPU에서 연산을 수행할 때 드는 비용입니다. 해시 함수로 주소를 계산한다거나, 값을 비교하는 등의 작업에 CPU 자원이 소모됩니다.

### 메모리 사용 비용

질의를 처리하는 동안 메모리에 데이터를 올려놓고 CPU가 처리해야 하기 때문에, 메모리 사용에 대한 비용도 고려해야 합니다.

### 네트워크 통신 비용

분산 데이터베이스(데이터가 여러 서버에 나뉘어 있는 경우)에서는 네트워크를 통해 데이터를 주고받아야 하므로, 통신 비용이 추가로 필요합니다.

### 비용 계산에 필요한 정보 (카탈로그)

이러한 비용들을 계산하기 위해서는 **데이터 사전(카탈로그, Catalog)**에 저장된 다양한 정보가 필요합니다:

| 정보 | 설명 | 왜 중요한가? |
|------|------|-------------|
| **레코드 수** | 테이블에 저장된 전체 행의 수 | 10건과 100만 건은 처리 방식이 완전히 다름 |
| **블록 수** | I/O 단위인 블록의 개수 | 읽어야 할 블록이 많으면 I/O 비용 증가 |
| **블로킹 팩터(BFR)** | 하나의 블록에 저장할 수 있는 레코드 수 | I/O 횟수를 결정하는 핵심 요소 |
| **인덱스 단계 수** | 인덱스가 몇 단계로 구성되어 있는지 | 첫 번째 인덱스의 블록 수가 성능에 가장 큰 영향 |
| **인덱스의 고유 값 범위** | 인덱스 값이 얼마나 서로 다른지 | 고유 값이 적으면 인덱스 효과가 떨어짐 |
| **선택도** | 하나의 조건에 맞는 평균 레코드 수 | 비용 계산의 핵심 입력 값 |

:::note 카탈로그란?
카탈로그는 마치 도서관의 서지 목록과 같습니다. 데이터베이스 내의 모든 테이블, 인덱스, 열 등에 대한 **메타 정보(데이터에 대한 데이터)**가 저장되어 있으며, 옵티마이저(최적화기)가 이 정보를 참조하여 가장 효율적인 실행 계획을 수립합니다.
:::

---

## 🛠️ 데이터베이스 튜닝의 3단계

튜닝은 크게 **세 가지 단계**로 나뉩니다. 가장 아래(하드웨어)부터 가장 위(설계/쿼리 수준)까지, 피라미드처럼 생각하면 됩니다.

### 1단계: 하드웨어 튜닝 (가장 낮은 단계)

가장 기본적이고 직관적인 방법입니다. 컴퓨터가 느려졌으면? **돈이 허락한다면 가장 좋은 방법은 컴퓨터를 바꾸는 것**입니다.

- **디스크 성능이 떨어지면** → 디스크를 추가하거나 SSD로 교체
- **버퍼 메모리가 병목이면** → 메모리를 늘림
- **CPU에 문제가 있으면** → CPU를 교체
- **인터넷 속도가 느리면** → 더 빠른 네트워크로 교체

:::info 메모리 크기 결정 규칙
- **5분 규칙**: 메모리에 데이터가 5분 정도 머물러야 한다면, 메모리가 충분히 커야 합니다. 5분 내에 다시 이용될 가능성이 있는 페이지가 메모리에 남아있어야 하기 때문입니다.
- **1분 규칙**: 1분마다 계속 메모리가 사용되는 경우, 1분 규칙을 적용해서 메모리 크기를 설정할 수 있습니다.

이러한 규칙들은 메모리 크기를 어느 정도로 설정해야 하는지에 대한 경험적 지침입니다.
:::

### 2단계: 인스턴스 파라미터 조정 (중간 단계)

하드웨어를 바꾸지 않고, **DBMS의 설정 값(파라미터)**을 조정하여 성능을 향상시키는 방법입니다.

실생활 비유를 들어보겠습니다. 한글(워드프로세서)에서 자동 저장 간격이 **1분**으로 설정되어 있다면 어떻게 될까요? 1분마다 자동으로 저장을 하니까, 문서 작성 중에 갑자기 프로그램이 멈추는 현상이 발생합니다. 이것을 **30분**으로 늘려놓으면 훨씬 쾌적하게 작업할 수 있겠죠.

이것이 바로 **체크포인트 간격 조정**이라는 파라미터 튜닝입니다.

조정 가능한 파라미터 예시:

| 파라미터 | 설명 |
|----------|------|
| **체크포인트 간격** | 자동 저장(검사점) 간격을 조절 |
| **버퍼 크기** | 메모리 버퍼의 크기를 조절 |
| **블로킹 팩터** | 한 블록에 저장할 레코드 수 조절 |
| **데이터베이스 세션 수** | 동시 접속 허용 수 조절 |

### 3단계: 설계/쿼리 튜닝 (가장 높은 단계)

가장 상위 단계이며, **정규화, 인덱스 추가/제거, 트랜잭션 방법 변경** 등을 통해 성능을 향상시키는 방법입니다.

#### 인덱스 활용 전략

**인덱스는 검색 성능을 향상시키지만, 갱신(삽입/삭제/수정) 성능은 떨어뜨립니다.**

이것은 매우 중요한 개념입니다. 마치 책에 목차를 아주 상세하게 만들어 놓으면 원하는 내용을 빨리 찾을 수 있지만, 책 내용이 바뀔 때마다 목차도 함께 수정해야 하는 것과 같습니다.

```sql
-- ✅ 인덱스를 추가해야 하는 경우: 검색 작업이 많을 때
-- WHERE 절에 자주 사용되는 컬럼
-- JOIN에 자주 사용되는 컬럼
-- 기본키, 외래키로 자주 연결되는 컬럼
CREATE INDEX idx_employee_dept ON employee(department_id);
-- department_id 컬럼에 인덱스를 생성하여 부서별 검색 속도 향상
```

```sql
-- ❌ 인덱스를 제거해야 하는 경우: 갱신 작업이 많을 때
-- 삽입, 삭제, 수정이 빈번한 테이블에 인덱스가 많으면
-- 오히려 성능이 떨어집니다!
DROP INDEX idx_log_timestamp ON system_log;
-- 로그 테이블처럼 삽입이 매우 빈번한 테이블에서는
-- 불필요한 인덱스를 제거하는 것이 더 효율적
```

:::danger 인덱스 남용 주의
하나의 테이블에 인덱스를 여러 개 설정해두었는데, 실제 작업이 검색보다 **삽입/삭제/갱신 위주**라면, 인덱스가 오히려 성능을 떨어뜨립니다. 인덱스가 있으면 데이터가 변경될 때마다 인덱스도 함께 업데이트해야 하기 때문입니다. 이런 경우에는 **인덱스를 과감히 제거하는 것이 더 효율적**입니다.
:::

#### 불필요한 연산 제거

성능 향상을 위해 **불필요한 작업을 줄이는 것**도 중요한 튜닝 방법입니다.

**1. 불필요한 정렬 제거**

100만 건의 데이터를 일일이 정렬하는 것은 그만큼 부하가 큽니다. 꼭 필요한 경우에만 정렬을 수행해야 합니다.

```sql
-- ❌ 불필요한 정렬: UNION은 자동으로 정렬 + 중복 제거를 수행
SELECT name FROM employee WHERE dept = '개발부'
UNION
SELECT name FROM employee WHERE dept = '기획부';
-- UNION은 내부적으로 정렬을 수행하여 중복을 제거합니다
-- 중복 제거가 필요 없다면 불필요한 정렬이 발생합니다!
```

```sql
-- ✅ UNION ALL 사용: 정렬 없이 결과를 합침 (중복 허용)
SELECT name FROM employee WHERE dept = '개발부'
UNION ALL
SELECT name FROM employee WHERE dept = '기획부';
-- UNION ALL은 정렬을 수행하지 않아 훨씬 빠릅니다
-- 중복 제거가 필요 없는 경우에 사용하세요
```

**2. 불필요한 중복 제거 방지**

`DISTINCT` 키워드는 중복을 제거하는 명령입니다. 하지만 결과에서 중복이 있어도 상관없다면 굳이 사용할 필요가 없습니다.

```sql
-- ❌ 불필요한 DISTINCT: 이미 유일한 값인 경우
SELECT DISTINCT employee_id FROM employee;
-- employee_id가 기본키라면 이미 유일하므로 DISTINCT가 불필요
-- DISTINCT는 내부적으로 정렬을 수행하므로 성능 저하 발생
```

```sql
-- ✅ DISTINCT 제거: 불필요한 중복 제거를 하지 않음
SELECT employee_id FROM employee;
-- 기본키는 이미 유일하므로 DISTINCT 없이도 동일한 결과
-- 불필요한 정렬 비용을 절약할 수 있습니다
```

**3. 불필요한 COUNT 연산 방지**

레코드가 존재하는지만 확인하면 되는데, 전체 건수를 세는 것은 낭비입니다.

```sql
-- ❌ 불필요한 COUNT: 존재 여부만 확인하면 되는데 전체를 셈
SELECT COUNT(*) FROM orders WHERE customer_id = 100;
-- 전체 몇 건인지 알 필요 없이, 있는지 없는지만 확인하면 될 때
```

```sql
-- ✅ EXISTS 사용: 존재 여부만 빠르게 확인
SELECT EXISTS(SELECT 1 FROM orders WHERE customer_id = 100);
-- 하나라도 찾으면 바로 True를 반환하므로 전체를 셀 필요 없음
-- 훨씬 빠르게 결과를 얻을 수 있습니다
```

**4. SORT AGGREGATE 방식 활용**

`SORT AGGREGATE`는 실제로 물리적 정렬을 수행하지 않고, 결과만 묶어서 합계 같은 값을 보여주는 방식입니다. 정렬이 필요 없기 때문에 `SORT UNIQUE`(정렬 + 중복 제거)보다 효율적입니다.

#### 집합 중심 처리와 미니 배치

- **집합 중심 처리**: 하나의 조건을 만족하는 데이터를 묶어서 집합 형태로 처리하는 것이 건건이 처리하는 것보다 효율적입니다.
- **미니 배치 트랜잭션**: 한 시간 분량의 데이터를 한꺼번에 처리하는 대신, **10분 단위로 쪼개서** 파일 사이즈를 줄이고 분할 처리하면 훨씬 효율적입니다.

---

## 📊 성능 평가 기준: TPC

### TPC란?

**TPC(Transaction Processing Performance Council)**는 데이터베이스 시스템의 **성능 평가 표준**입니다. 글로벌 스탠다드로 정해져 있어, 모든 벤더가 동일한 기준으로 성능을 비교할 수 있습니다.

### 성능 측정 기준

> **핵심 기준: 1초에 몇 건의 트랜잭션(Transaction)을 처리하느냐** = TPS (Transactions Per Second)

- 1초에 10건 처리 → 10 TPS
- 1초에 100건 처리 → 100 TPS
- 1초에 1000건 처리 → 1000 TPS

비즈니스 관점에서는 단순히 처리량보다 **비용 대비 처리량**, 즉 **Price per TPS(단위 시간당 처리되는 비용)**로 평가하기도 합니다.

### TPC 종류

| 종류 | 대상 시스템 | 설명 |
|------|------------|------|
| **TPC-A** | 은행 입출금 | 단순한 입출금 시스템 평가 |
| **TPC-B** | 운영체제 | 운영체제 수준의 트랜잭션 평가 |
| **TPC-C** | 주문 처리 | 일반 전자상거래, 항공권 예약, 주문 처리 등 (가장 보편적) |
| **TPC-D** | 의사결정 지원 | 의사결정 시스템(DSS) 성능 평가 |
| **TPC-H** | 대량 분석 | 예측 불가능한 대량 데이터의 다양한 질의 처리 평가 |
| **TPC-R** | 보고서 기능 | 보고서 이미지화, 요약 정보 표시 등 보고서 기능 평가 |
| **TPC-W** | 웹/인터넷 | 웹 E-커머스 시스템 성능 평가 |

:::note 객체지향 데이터베이스의 벤치마크
객체지향 데이터베이스는 기존 관계형 데이터베이스와 트랜잭션 처리 개념이 다르기 때문에, **001, 007** 등 별도의 벤치마크 표준이 존재합니다.
:::

---

## 🏆 데이터 품질 관리

### 성능과 품질은 함께 가야 한다

성능이 아무리 좋아도 **품질이 나쁘면** 쓸모가 없습니다. 슈퍼카의 성능이 아무리 좋아도 한 번씩 차가 폭발한다면 누가 타겠습니까? 항상 **성능과 품질, 두 가지가 동시에 충족**되어야 합니다.

> **데이터 품질** = 데이터 이용자를 만족시킬 수 있는 수준

데이터 품질 관리란, 이 수준을 유지하고 관리하는 모든 활동을 말합니다. 특정 사람만 하는 것이 아니라, **전 부서에서 전체 주기에 걸쳐** 관리하는 것이 훨씬 효율적입니다.

### 품질 진단의 세 가지 유형

마치 요리사가 중간중간 맛을 보면서 간이 맞는지 확인하는 것처럼, 데이터도 주기적으로 품질을 점검해야 합니다.

#### 1️⃣ 값 진단

테이블, 속성, 코드, 관계, 비즈니스 규칙 등을 기준으로 **데이터 값 자체를 분석**하는 것입니다.

- 값이 변경되지 않았는지
- 오류가 있거나 잘못된 값이 들어가 있지 않은지
- 값이 정확한지

이러한 것들을 평가하는 것이 값 진단입니다.

#### 2️⃣ 구조 진단

모델링, 스키마 구조가 제대로 설계되어 있는지 확인하는 것입니다. 마치 집의 구조가 제대로 설계되어 있는지 확인하는 것처럼, 전반적인 시스템 스키마 구조를 점검합니다.

주로 **설계 관점**에서 품질을 진단할 때 사용하며, **리버스 모델링(Reverse Modeling)**이라는 기법을 활용합니다. 완성된 결과물을 놓고 거꾸로 구조를 찾아가는 방식입니다.

:::tip 리버스 모델링이란?
우리나라 자동차 산업 초창기에 외국 완성차를 수입해서 분해하고, "이게 왜 이런 구조로 만들어졌을까?"를 거꾸로 분석하여 설계도를 만들어낸 것을 **리버스 엔지니어링**이라고 합니다. 데이터베이스에서도 완성된 시스템을 분석하여 원래의 설계 구조를 파악하는 것을 **리버스 모델링**이라고 합니다.
:::

#### 3️⃣ 관리 프로세스 진단

값과 구조를 관리하는 것은 물론이고, **전체 프로세스(관리 과정)가 정해진 규칙대로 잘 운영되고 있는지**를 확인하는 것입니다. 전체 품질 관리 주기가 체계적으로 잘 관리되고 있는지, 정해진 절차를 따르고 있는지를 점검합니다.

---

## ⚙️ 튜닝의 종류와 영역

데이터베이스 튜닝에는 다양한 영역이 존재합니다:

| 튜닝 영역 | 설명 |
|-----------|------|
| **비즈니스 규칙** | 업무 규칙 자체의 효율성 개선 |
| **설계** | ERD, 정규화/역정규화 등 데이터 모델 개선 |
| **프로그램(SQL)** | 쿼리문 최적화, 불필요한 연산 제거 |
| **구조** | 테이블, 인덱스, 파티션 등 물리적 구조 변경 |
| **접근 방식** | 데이터 접근 방법(풀스캔, 인덱스스캔 등) 변경 |
| **접근 경로** | 옵티마이저의 실행 계획 최적화 |
| **메모리** | 버퍼 캐시, SGA/PGA 등 메모리 영역 조정 |
| **물리적 구조** | 테이블스페이스, 데이터 파일 배치 최적화 |
| **I/O** | 디스크 읽기/쓰기 횟수 최소화 |
| **동시성(경합)** | 락(Lock) 경합, 동시 접근 문제 해결 |

---

## 📌 핵심 정리

- **데이터베이스 튜닝**이란 DB 응용 프로그램, DBMS, OS를 조절하여 성능을 향상시키는 모든 활동이다
- **Join 연산**은 여러 테이블을 비교해야 하므로 성능 저하의 주범이며, 튜닝의 핵심 대상이다
- **접근 루틴(Access Routine)**은 관계대수 연산을 프로그래밍적으로 구현한 절차이다
- **Selection 탐색 방법** 4가지: 선형 탐색, 이진 탐색, 인덱스 탐색, 해싱 탐색
- **Join 구현 방법** 3가지: 정렬 합병 조인(전체 데이터), 중첩 루프 조인(부분 범위), 해시 조인(동일 조인)
- **질의 처리 비용** 5가지: I/O 비용, 저장 비용, 계산 비용, 메모리 비용, 네트워크 통신 비용
- **카탈로그(데이터 사전)**에 저장된 레코드 수, 블록 수, 블로킹 팩터 등의 정보가 비용 계산에 활용된다
- **튜닝 3단계**: 하드웨어 튜닝(최하위) → 인스턴스 파라미터 조정(중간) → 설계/쿼리 튜닝(최상위)
- **인덱스**는 검색 성능은 올리지만 갱신 성능은 떨어뜨리므로, 작업 유형에 따라 추가/제거를 결정해야 한다
- 불필요한 **정렬(UNION→UNION ALL)**, **중복 제거(DISTINCT 제거)**, **COUNT(→EXISTS)** 등을 줄여야 한다
- **TPC**는 데이터베이스 성능 평가의 글로벌 표준이며, TPC-C(주문처리)가 가장 보편적이다
- **데이터 품질 관리**는 값 진단, 구조 진단, 관리 프로세스 진단으로 나뉘며, 성능과 품질은 함께 충족되어야 한다

---

작성일: 2026-02-21