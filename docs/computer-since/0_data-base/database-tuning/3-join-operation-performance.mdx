---
title: "조인 연산과 성능 저하"
description: "조인 연산과 성능 저하에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/database-tuning/3-join-operation-performance"
sidebar_label: "조인 연산 성능"
date: "2026-02-21"
---

## 🎯 데이터베이스 튜닝이란 무엇인가?

여러분은 **"튜닝"**이라는 단어를 일상에서 자주 접해보셨을 겁니다. 자동차를 튜닝한다는 말도 있고, 기타 줄을 튜닝한다거나 피아노를 튜닝한다는 말도 있죠. 이 모든 맥락에서 튜닝이란 **"무언가의 성능이나 상태가 제대로 맞지 않을 때, 그것을 조정해서 최적의 상태로 만드는 과정"**을 의미합니다.

기타 줄의 음이 맞지 않으면 튜닝을 통해 음을 맞추고, 피아노 건반의 음이 맞지 않으면 튜닝을 통해 조율합니다. 마찬가지로 **데이터베이스 튜닝(Database Tuning)**이란 데이터베이스의 성능을 향상시키기 위해 여러 가지 조치를 취하는 모든 과정을 말합니다.

> 마치 자동차의 엔진을 교체하거나, 타이어 공기압을 조정하거나, 서스펜션을 세팅하는 것처럼, 데이터베이스에서도 다양한 요소들을 조절하여 최상의 성능을 끌어내는 것이 튜닝입니다.

데이터베이스 튜닝에는 **하드웨어 교체**, **인스턴스 파라미터 조정**, **인덱스 추가/제거**, **SQL 쿼리 최적화** 등 매우 다양한 방법이 포함됩니다. 이번 문서에서는 특히 **조인(Join) 연산이 왜 성능 저하의 주범인지**, 그리고 이를 어떻게 효율적으로 처리할 수 있는지에 초점을 맞추어 살펴보겠습니다.

---

## 📚 왜 조인 연산이 성능 저하의 주범인가?

### 관계형 데이터베이스의 기본 연산

관계형 데이터베이스(Relational Database)에서는 여러 가지 **관계대수 연산**(데이터를 다루는 수학적 연산)이 존재합니다. 대표적으로 다음 세 가지가 있습니다:

| 연산 | 설명 | 비유 |
|------|------|------|
| **Selection(셀렉션)** | 조건에 맞는 행(레코드)을 골라내는 연산 | 도서관에서 "2024년 출판 도서"만 골라내기 |
| **Projection(프로젝션)** | 특정 열(컬럼)만 추출하는 연산 | 학생 명부에서 "이름"과 "학번"만 뽑기 |
| **Join(조인)** | 두 개 이상의 테이블을 연결하는 연산 | 학생 명부와 성적표를 학번으로 연결하기 |

이 중에서 **조인 연산**은 성능을 **가장 크게 떨어뜨리는 주범**입니다.

### 조인이 느린 이유

왜 조인이 성능을 떨어뜨릴까요? 그 이유를 차근차근 살펴봅시다.

하나의 테이블에서 결과를 가져올 수 있다면, 그냥 그 테이블 하나만 읽으면 됩니다. 빠르고 간단하죠. 하지만 현실에서는 **하나의 테이블에서 원하는 모든 정보를 가져올 수 없는 경우**가 대부분입니다. 예를 들어 "학생 정보"는 학생 테이블에 있고, "수강 과목 정보"는 수강 테이블에 있습니다. 학생별 수강 과목을 알고 싶다면 두 테이블을 **연결(조인)**해야 합니다.

조인을 하면 다음과 같은 작업이 필요합니다:

1. **여러 개의 테이블을 읽어야** 합니다 (I/O 비용 증가)
2. 테이블 간의 **값을 비교해야** 합니다 (CPU 비용 증가)
3. 비교 결과에서 **일치하는 값을 추출해야** 합니다 (추가 연산 비용)

> 마치 두 개의 전화번호부에서 같은 사람을 찾아 연결하는 것과 같습니다. 전화번호부 하나만 뒤지면 되는 것과, 두 개의 전화번호부를 번갈아가며 대조하는 것은 당연히 후자가 훨씬 오래 걸리겠죠.

그렇다고 조인을 안 할 수는 없습니다. 여러 테이블에서 원하는 결과를 가져오려면 **조인은 필수**이기 때문입니다. 따라서 우리가 할 수 있는 것은 **조인을 더 효율적으로 수행하는 방법**을 이해하고 적용하는 것입니다.

---

## 🔍 셀렉션(Selection) 연산의 접근 루틴 이해하기

조인 연산을 이해하기 전에, 먼저 더 단순한 **셀렉션 연산**에서 데이터를 찾는 방법(접근 루틴)부터 살펴보겠습니다. 이 기초를 이해해야 조인 연산의 다양한 알고리즘을 제대로 이해할 수 있습니다.

:::info 접근 루틴(Access Routine)이란?
**접근 루틴**이란 관계대수 연산(셀렉션, 조인 등)을 프로그래밍적으로 구현하는 절차(프로시저)를 말합니다. 쉽게 말해, 데이터를 찾아가는 **구체적인 방법이자 알고리즘**입니다.
:::

### 예시 상황 설정

다음과 같은 학생 성적 테이블 `R`이 있다고 가정합시다:

| 학번 | 점수 |
|------|------|
| 1 | 100 |
| 2 | 80 |
| 3 | 50 |
| 4 | 70 |
| 5 | 90 |

여기서 **"점수가 50점 이하인 학생의 학번을 찾아라"**는 질의를 수행한다고 해봅시다. 관계대수로 표현하면 다음과 같습니다:

```
π학번(σ점수≤50(R))
```

R 테이블에서 점수가 50점 이하인 레코드를 선택(σ)하고, 그중에서 학번만 추출(π)하라는 의미입니다. 그렇다면 이 50점 이하인 학생을 **어떻게 찾을 것인가?** 여기에 여러 가지 방법이 있습니다.

### 방법 1: 선형 탐색 (Linear Search)

**선형 탐색(Sequential Search)**은 가장 기본적인 방법입니다. 데이터가 정렬되어 있지 않고, 아무런 순서도 없는 상태에서 **처음부터 끝까지 하나씩 차례로 확인**하는 방식입니다.

```python
# ❌ 비효율적이지만 가장 기본적인 방법: 선형 탐색
def linear_search(table, target_score):
    """
    테이블의 모든 레코드를 처음부터 끝까지 하나씩 확인합니다.
    정렬이 되어 있지 않아도 사용 가능합니다.
    """
    result = []
    for record in table:           # 모든 레코드를 하나씩 순회
        if record['점수'] <= target_score:  # 조건을 만족하는지 확인
            result.append(record['학번'])   # 조건 만족 시 학번 추가
    return result

# 테이블 데이터 (정렬되어 있지 않음)
students = [
    {'학번': 1, '점수': 100},
    {'학번': 2, '점수': 80},
    {'학번': 3, '점수': 50},   # ← 세 번째에서 발견!
    {'학번': 4, '점수': 70},
    {'학번': 5, '점수': 90},
]

print(linear_search(students, 50))  # 결과: [3]
```

위 코드를 한 줄씩 살펴보겠습니다:

- `for record in table:` → 테이블에 있는 모든 레코드를 **처음부터 끝까지** 하나씩 반복합니다
- `if record['점수'] <= target_score:` → 현재 레코드의 점수가 조건(50점 이하)을 만족하는지 검사합니다
- `result.append(record['학번'])` → 조건을 만족하면 해당 학번을 결과 목록에 추가합니다

선형 탐색의 특징은 다음과 같습니다:
- 찾고자 하는 데이터가 **맨 앞에 있으면** 한 번만에 찾습니다
- 찾고자 하는 데이터가 **맨 뒤에 있으면** 전체를 다 뒤져야 합니다
- 평균적으로 전체 데이터의 **약 50%**를 탐색해야 합니다

### 방법 2: 이진 탐색 (Binary Search)

**이진 탐색(Binary Search)**은 데이터가 **미리 정렬되어 있을 때** 사용할 수 있는 효율적인 방법입니다. 반씩 잘라가며 탐색하기 때문에 탐색 횟수를 크게 줄일 수 있습니다.

```python
# ✅ 정렬된 데이터에서 효율적인 방법: 이진 탐색
def binary_search(sorted_table, target_score):
    """
    정렬된 데이터를 반씩 나누어 찾아가는 방법입니다.
    반드시 데이터가 정렬되어 있어야 합니다!
    """
    low = 0                          # 탐색 범위의 시작 인덱스
    high = len(sorted_table) - 1     # 탐색 범위의 끝 인덱스

    while low <= high:
        mid = (low + high) // 2      # 중간 위치를 계산
        mid_score = sorted_table[mid]['점수']

        if mid_score == target_score:    # 정확히 일치하면 찾음!
            return sorted_table[mid]['학번']
        elif mid_score > target_score:   # 중간 값이 더 크면
            high = mid - 1               # → 왼쪽 절반에서 다시 찾기
        else:                            # 중간 값이 더 작으면
            low = mid + 1                # → 오른쪽 절반에서 다시 찾기

    return None  # 찾지 못함

# 점수 기준으로 정렬된 테이블
sorted_students = [
    {'학번': 3, '점수': 50},   # 정렬 후 첫 번째
    {'학번': 4, '점수': 70},
    {'학번': 2, '점수': 80},   # ← 중간값 (여기서 시작)
    {'학번': 5, '점수': 90},
    {'학번': 1, '점수': 100},
]

print(binary_search(sorted_students, 50))  # 결과: 3
```

코드를 한 줄씩 살펴보겠습니다:

- `mid = (low + high) // 2` → 현재 탐색 범위의 **정확히 중간 위치**를 계산합니다
- `if mid_score > target_score:` → 중간 값(80)이 찾는 값(50)보다 크면, 50은 **왼쪽 절반**에 있다는 뜻입니다
- `high = mid - 1` → 오른쪽 절반은 볼 필요가 없으므로, 탐색 범위를 왼쪽으로 줄입니다

> 비유하면, 사전에서 "강아지"라는 단어를 찾을 때 사전을 정확히 반으로 펼친 후 "강아지"가 현재 페이지보다 앞에 있는지 뒤에 있는지를 판단하고, 해당 방향으로 다시 반을 펼치는 것과 같습니다.

### 방법 3: 인덱스를 이용한 탐색

**인덱스(Index)**를 이용하는 방법은 책의 **목차**를 활용하는 것과 같습니다. 120페이지의 내용을 찾고 싶다면 1페이지부터 넘기는 것이 아니라, 먼저 **목차를 보고** 120페이지가 어디에 있는지 확인한 후 바로 해당 페이지로 이동합니다.

### 방법 4: 해싱(Hashing)을 이용한 탐색

**해싱(Hashing)**은 **해시 함수(Hash Function)**라는 특별한 수학 공식에 값을 넣으면 **바로 저장 위치(주소)**가 계산되는 방식입니다. 목차를 볼 필요도 없이 함수에 값을 넣으면 즉시 데이터의 위치를 알 수 있습니다.

| 탐색 방법 | 정렬 필요 여부 | 평균 탐색 시간 | 비유 |
|-----------|:-------------:|:-------------:|------|
| 선형 탐색 | ❌ | O(n) | 서류더미를 하나씩 뒤지기 |
| 이진 탐색 | ✅ | O(log n) | 사전에서 반씩 펼치며 찾기 |
| 인덱스 탐색 | ❌ (인덱스 필요) | O(log n) | 책 목차를 보고 페이지 이동 |
| 해싱 | ❌ | O(1) | GPS 좌표로 바로 이동 |

---

## ⚙️ 조인 연산의 세 가지 핵심 알고리즘

이제 본격적으로 **조인 연산을 수행하는 세 가지 방법**에 대해 알아보겠습니다. 두 개의 테이블 `R`과 `S`가 있고, R의 특정 컬럼 값과 S의 특정 컬럼 값을 비교하여 일치하는 레코드를 연결하는 것이 조인의 핵심입니다.

### 1️⃣ 정렬 합병 조인 (Sort-Merge Join)

**정렬 합병 조인(Sort-Merge Join)**은 이름 그대로 **양쪽 테이블을 먼저 정렬한 후, 동시에 훑으며 합병하는 방식**입니다.

#### 왜 필요한가?

두 무더기의 종이가 있다고 상상해 봅시다. 왼쪽 무더기에서 "A"라는 종이를 꺼낸 다음, 오른쪽 무더기에서 "A"를 찾으려면 오른쪽 전체를 뒤져야 합니다. 다시 왼쪽에서 "B"를 꺼내면, 또 오른쪽 전체를 뒤져야 하죠. 이건 **매우 비효율적**입니다.

하지만 **양쪽을 모두 알파벳순으로 정렬해 두면** 어떨까요? 왼쪽 맨 위에 "A"가 있고, 오른쪽 맨 위에도 "A"가 있으니 바로 매칭됩니다. 그 다음 "B"끼리, "C"끼리... 순서대로 쉽게 찾아갈 수 있습니다.

#### 작동 원리

1. **R 테이블을 조인 컬럼 기준으로 정렬**합니다
2. **S 테이블도 같은 조인 컬럼 기준으로 정렬**합니다
3. 양쪽을 **동시에 위에서 아래로 훑으며** 같은 값을 찾아 연결합니다

```python
# ✅ 정렬 합병 조인 구현 예시
def sort_merge_join(R, S, key):
    """
    정렬 합병 조인: 양쪽 테이블을 정렬한 후 동시에 비교하며 합병
    R: 왼쪽 테이블 (리스트 of 딕셔너리)
    S: 오른쪽 테이블 (리스트 of 딕셔너리)
    key: 조인할 컬럼명
    """
    # 1단계: 양쪽 테이블을 조인 키 기준으로 정렬
    R_sorted = sorted(R, key=lambda x: x[key])  # R을 key 기준 오름차순 정렬
    S_sorted = sorted(S, key=lambda x: x[key])  # S를 key 기준 오름차순 정렬

    result = []       # 조인 결과를 저장할 리스트
    i, j = 0, 0       # R과 S의 현재 위치를 가리키는 포인터

    # 2단계: 양쪽을 동시에 훑으며 비교
    while i < len(R_sorted) and j < len(S_sorted):
        r_val = R_sorted[i][key]    # R의 현재 조인 키 값
        s_val = S_sorted[j][key]    # S의 현재 조인 키 값

        if r_val == s_val:          # 값이 같으면 → 조인 성공!
            # 같은 값을 가진 모든 레코드를 연결
            merged = {**R_sorted[i], **S_sorted[j]}
            result.append(merged)
            j += 1                   # S의 다음 레코드로 이동
        elif r_val < s_val:         # R의 값이 더 작으면
            i += 1                   # → R을 다음으로 이동
        else:                       # S의 값이 더 작으면
            j += 1                   # → S를 다음으로 이동

    return result

# 테이블 데이터
R = [
    {'학번': 3, '이름': '김철수'},
    {'학번': 1, '이름': '이영희'},
    {'학번': 2, '이름': '박민수'},
]

S = [
    {'학번': 2, '과목': '수학'},
    {'학번': 1, '과목': '영어'},
    {'학번': 3, '과목': '과학'},
]

# 학번 기준으로 정렬 합병 조인 수행
print(sort_merge_join(R, S, '학번'))
```

코드를 한 줄씩 살펴보겠습니다:

- `R_sorted = sorted(R, key=lambda x: x[key])` → R 테이블을 조인 키(학번) 기준으로 **오름차순 정렬**합니다. 정렬이 이 알고리즘의 핵심 전제조건입니다.
- `i, j = 0, 0` → 두 개의 포인터를 준비합니다. `i`는 R의 현재 위치, `j`는 S의 현재 위치입니다. 마치 두 손가락으로 양쪽 종이더미의 맨 위를 가리키는 것과 같습니다.
- `if r_val == s_val:` → 양쪽의 조인 키 값이 같으면 조인 성공입니다. 두 레코드를 합쳐서 결과에 추가합니다.
- `elif r_val < s_val:` → R의 값이 더 작으면, R쪽에서 다음 레코드로 넘어갑니다. 양쪽이 정렬되어 있으므로, 현재 R 값에 대응하는 S 값은 더 이상 없다는 뜻입니다.

#### 정렬 합병 조인의 특성

:::tip 정렬 합병 조인은 언제 유리한가?
- **전체 데이터를 처리**해야 할 때 가장 유리합니다
- 양쪽 테이블의 **처리량이 많은 경우** 적합합니다
- 양쪽을 **모두 정렬한 후**, 처음부터 끝까지 전체를 동시에 비교합니다
- 데이터가 **이미 정렬되어 있다면** 정렬 비용이 줄어들어 더욱 효율적입니다
:::

> 마치 두 줄로 키 순서대로 세워진 학생들을 맨 앞부터 한 명씩 비교하며 짝을 짓는 것과 같습니다. 양쪽 모두 정렬되어 있기 때문에 한 번의 통과로 모든 짝을 찾을 수 있습니다.

---

### 2️⃣ 중첩 루프 조인 (Nested Loop Join)

**중첩 루프 조인(Nested Loop Join)**은 **한쪽 테이블의 범위를 먼저 정한 후, 그 범위의 각 레코드마다 다른 쪽 테이블 전체를 반복(루프)하며 찾는 방식**입니다.

#### 왜 필요한가?

정렬 합병 조인은 **전체 데이터를 대상**으로 할 때 좋습니다. 하지만 전체가 아니라 **일부 범위만 조인**하면 되는 경우는 어떨까요? 예를 들어, "생산부서에 소속된 직원들의 주소를 찾아라"라는 질의라면, 전체 직원이 아니라 **생산부서에 해당하는 직원들만** 대상으로 조인하면 됩니다.

이때 사용하는 것이 **중첩 루프 조인**입니다.

#### 선행 테이블과 후행 테이블

중첩 루프 조인에서는 두 가지 역할의 테이블이 있습니다:

| 역할 | 다른 이름 | 설명 | 비유 |
|------|-----------|------|------|
| **선행 테이블** | 드라이빙(Driving) 테이블, 외부 릴레이션 | 조인의 **범위를 결정**하는 테이블 | 목록에서 찾을 이름을 정하는 쪽 |
| **후행 테이블** | 피드리븐(Driven) 테이블, 내부 릴레이션 | 선행 테이블의 각 레코드마다 **반복 탐색**되는 테이블 | 전화번호부에서 실제로 찾는 쪽 |

#### 작동 원리

1. **선행 테이블(R)**에서 처리 범위가 결정됩니다 (예: 생산부 직원만)
2. 선행 테이블에서 추출된 **각 레코드마다** 후행 테이블(S) 전체를 **반복 탐색**합니다
3. 후행 테이블에 **인덱스가 있으면** 탐색이 훨씬 빨라집니다

```python
# ✅ 중첩 루프 조인 구현 예시
def nested_loop_join(R, S, r_key, s_key, r_condition=None):
    """
    중첩 루프 조인: 선행 테이블의 각 레코드마다 후행 테이블을 반복 탐색
    R: 선행(드라이빙) 테이블
    S: 후행(피드리븐) 테이블
    r_key: R의 조인 키
    s_key: S의 조인 키
    r_condition: R에 적용할 조건 함수 (선택사항)
    """
    result = []

    for r_record in R:                          # 외부 루프: 선행 테이블 순회
        # 선행 테이블에 조건이 있으면 필터링
        if r_condition and not r_condition(r_record):
            continue                             # 조건 불만족 시 건너뛰기

        for s_record in S:                      # 내부 루프: 후행 테이블 전체 반복
            if r_record[r_key] == s_record[s_key]:  # 조인 키 값 비교
                merged = {**r_record, **s_record}
                result.append(merged)            # 일치하면 결과에 추가

    return result

# 선행 테이블: 직원 정보
employees = [
    {'사원번호': 101, '이름': '김철수', '부서': '생산부'},
    {'사원번호': 102, '이름': '이영희', '부서': '영업부'},
    {'사원번호': 103, '이름': '박민수', '부서': '생산부'},
    {'사원번호': 104, '이름': '최지은', '부서': '인사부'},
]

# 후행 테이블: 주소 정보
addresses = [
    {'사원번호': 101, '주소': '서울'},
    {'사원번호': 102, '주소': '부산'},
    {'사원번호': 103, '주소': '대전'},
    {'사원번호': 104, '주소': '인천'},
]

# 생산부 직원의 주소만 조인 (선행 테이블에 조건 적용)
result = nested_loop_join(
    employees, addresses,
    '사원번호', '사원번호',
    r_condition=lambda x: x['부서'] == '생산부'  # 생산부만 필터링
)
print(result)
# 결과: 생산부 김철수(서울), 박민수(대전)만 출력
```

코드를 한 줄씩 살펴보겠습니다:

- `for r_record in R:` → **외부 루프**입니다. 선행(드라이빙) 테이블의 레코드를 하나씩 꺼냅니다.
- `if r_condition and not r_condition(r_record):` → 선행 테이블에 조건이 있으면 조건을 확인합니다. "생산부"가 아니면 `continue`로 건너뜁니다. 이것이 바로 **처리 범위를 결정**하는 부분입니다.
- `for s_record in S:` → **내부 루프**입니다. 선행 테이블에서 꺼낸 **하나의 레코드에 대해**, 후행 테이블 **전체를 반복**하며 매칭되는 것을 찾습니다.
- `if r_record[r_key] == s_record[s_key]:` → 양쪽의 조인 키가 같은지 비교합니다.

:::warning 중첩 루프 조인의 핵심 포인트
**후행 테이블에 인덱스가 존재하면** 성능이 **크게 향상**됩니다. 인덱스가 없으면 후행 테이블 전체를 매번 처음부터 끝까지 탐색해야 하지만, 인덱스가 있으면 목차처럼 바로 해당 위치로 이동할 수 있기 때문입니다.
:::

#### 중첩 루프 조인의 특성

- **전체가 아닌 부분 범위를 처리**할 때 유리합니다
- 처리량이 적거나, **부분 범위 처리**가 필요한 경우에 적합합니다
- **선행 드라이브 테이블의 처리 범위**가 전체 처리량을 결정하는 핵심 요소입니다
- 후행 테이블에 **인덱스가 있으면** 효율이 대폭 증가합니다

---

### 3️⃣ 해시 조인 (Hash Join)

**해시 조인(Hash Join)**은 **해시 함수(Hash Function)**를 이용하여 양쪽 테이블의 조인 키 값으로 **주소를 계산**한 뒤, 같은 주소끼리 매칭하는 방식입니다.

#### 왜 필요한가?

정렬 합병 조인은 정렬이 필요하고, 중첩 루프 조인은 반복 탐색이 필요합니다. 해시 조인은 이 두 가지 **모두 불필요**합니다. 정렬도 필요 없고, 인덱스도 필요 없습니다. 대신 **해시 함수를 통해 주소를 계산**하여 한 번에 찾아가는 방식입니다.

```python
# ✅ 해시 조인 구현 예시
def hash_join(R, S, r_key, s_key):
    """
    해시 조인: 해시 테이블을 이용하여 빠르게 조인
    정렬 불필요, 인덱스 불필요
    R: 왼쪽 테이블
    S: 오른쪽 테이블
    """
    # 1단계: R 테이블로 해시 테이블 생성 (빌드 단계)
    hash_table = {}                          # 빈 해시 테이블 생성
    for r_record in R:
        key_val = r_record[r_key]            # R의 조인 키 값을 가져옴
        hash_table[key_val] = r_record       # 해시 테이블에 저장 (키: 조인 값)

    # 2단계: S 테이블을 순회하며 해시 테이블에서 매칭 (프로브 단계)
    result = []
    for s_record in S:
        key_val = s_record[s_key]            # S의 조인 키 값을 가져옴
        if key_val in hash_table:            # 해시 테이블에 같은 키가 있는지 확인
            merged = {**hash_table[key_val], **s_record}
            result.append(merged)            # 매칭되면 결과에 추가

    return result

# 테이블 데이터
R = [
    {'학번': 1, '이름': '이영희'},
    {'학번': 2, '이름': '박민수'},
    {'학번': 3, '이름': '김철수'},
]

S = [
    {'학번': 2, '과목': '수학'},
    {'학번': 3, '과목': '영어'},
    {'학번': 1, '과목': '과학'},
]

print(hash_join(R, S, '학번', '학번'))
```

코드를 한 줄씩 살펴보겠습니다:

- `hash_table = {}` → 빈 해시 테이블(딕셔너리)을 만듭니다. 이것은 마치 **사물함 배열**을 준비하는 것과 같습니다.
- `hash_table[key_val] = r_record` → R의 각 레코드를 조인 키 값을 기준으로 해시 테이블에 넣습니다. 학번 1번은 1번 사물함에, 2번은 2번 사물함에 넣는 셈입니다.
- `if key_val in hash_table:` → S의 레코드를 하나씩 꺼내면서, 해당 조인 키 값이 해시 테이블에 있는지 **즉시 확인**합니다. 정렬할 필요도 없고, 반복 탐색할 필요도 없습니다.

#### 해시 조인의 특성

:::danger 해시 조인의 제약사항
해시 조인은 반드시 **동일 조인(Equi Join)**에서만 사용할 수 있습니다. 즉, `=` 조건으로 비교할 때만 사용 가능합니다. `>`, `<`, `>=`, `<=` 같은 범위 비교에는 사용할 수 없습니다. 해시 함수는 하나의 키에 대해 **하나의 주소**만 계산하기 때문입니다.
:::

- **정렬이 불필요**합니다
- **인덱스가 불필요**합니다
- 대신 **CPU에서 해시 값을 계산하는 비용**이 발생합니다
- **비용 기반 옵티마이저(Cost-Based Optimizer)**에서 주로 사용됩니다

---

### 📊 세 가지 조인 방법 비교

| 특성 | 정렬 합병 조인 | 중첩 루프 조인 | 해시 조인 |
|------|:-----------:|:-----------:|:-------:|
| **정렬 필요** | ✅ 양쪽 모두 | ❌ 불필요 | ❌ 불필요 |
| **인덱스 필요** | ❌ 불필요 | ✅ 후행 테이블에 있으면 유리 | ❌ 불필요 |
| **적합한 상황** | 전체 데이터 처리 | 부분 범위 처리 | 동일 조인(=) |
| **주요 비용** | 정렬 비용 | 반복 탐색 비용 | 해시 계산 비용(CPU) |
| **데이터 규모** | 대용량에 적합 | 소·중규모에 적합 | 대용량에 적합 |

---

## 💰 질의 처리 비용의 종류

조인 연산의 방법을 선택할 때는 **"어떤 방법이 가장 비용이 적게 드는가?"**를 계산해야 합니다. 여기서 말하는 비용에는 다음 다섯 가지가 있습니다:

### 1. 보조기억장치 접근 비용 (I/O 비용)

하드디스크에서 데이터를 읽어오고 저장하는 데 드는 비용입니다. 하드디스크는 메모리보다 **수백~수천 배 느리기** 때문에, 데이터베이스 성능에서 I/O 비용이 가장 큰 비중을 차지하는 경우가 많습니다.

> 마치 창고에서 물건을 꺼내오는 시간입니다. 창고가 멀수록, 물건이 많을수록 시간이 더 걸립니다.

### 2. 저장 비용

중간 연산 결과를 저장하는 데 드는 비용입니다. 예를 들어 `R × S × T`를 계산할 때, R과 S를 먼저 조인한 **중간 결과**를 어딘가에 저장해 두어야 다시 T와 조인할 수 있습니다. 이 중간 파일을 저장하는 비용입니다.

### 3. 계산 비용 (CPU 비용)

CPU에서 연산을 수행하는 데 드는 비용입니다. 해시 함수로 주소를 계산하거나, 두 값을 비교하거나, 정렬을 수행하는 등 모든 CPU 연산이 여기에 해당합니다.

### 4. 메모리 사용 비용

질의를 처리하는 동안 메모리에 데이터를 올려놓고 CPU 코어로 처리해야 하기 때문에, 메모리 공간을 사용하는 비용이 발생합니다.

### 5. 통신 비용

분산 데이터베이스(여러 서버에 데이터가 나뉘어 저장된 경우)에서는 네트워크를 통해 데이터를 주고받아야 하므로 추가적인 통신 비용이 필요합니다.

:::note 비용 계산에 필요한 정보 (카탈로그)
이러한 비용을 계산하려면 다음 정보가 필요하며, 이 정보들은 **데이터 사전(카탈로그)**에 저장되어 있습니다:
- **레코드 수**: 테이블에 데이터가 몇 건인가
- **블록 수**: 디스크에서 읽어야 할 블록(I/O 단위)이 몇 개인가
- **블로킹 팩터(BFR)**: 하나의 블록에 레코드가 몇 개 들어가는가
- **인덱스 단계 수**: 인덱스가 몇 단계로 구성되어 있는가
- **인덱스의 선택도**: 인덱스 값이 얼마나 고유한가
:::

---

## 🔧 데이터베이스 튜닝의 단계별 방법

### 가장 낮은 단계: 하드웨어 교체

가장 기본적인 튜닝은 **하드웨어를 업그레이드**하는 것입니다.

- **디스크 성능이 떨어지면** → 더 빠른 디스크(SSD 등)를 추가합니다
- **버퍼 메모리가 병목이면** → 메모리 용량을 늘립니다
- **CPU에 문제가 있으면** → CPU를 교체합니다
- **네트워크가 느리면** → 더 빠른 네트워크로 업그레이드합니다

> 컴퓨터가 느려졌을 때, 돈이 충분하다면 **가장 확실한 방법은 컴퓨터 자체를 바꾸는 것**입니다.

:::info 메모리 크기 결정의 5분 규칙과 1분 규칙
- **5분 규칙**: 메모리에 올린 데이터가 **5분 이내에 다시 사용될 가능성**이 있다면, 메모리에 유지하는 것이 효율적입니다. 이를 만족하려면 충분한 메모리가 필요합니다.
- **1분 규칙**: **1분마다 계속 사용되는 데이터**라면, 반드시 메모리에 상주시켜야 합니다.
:::

### 중간 단계: 인스턴스 파라미터 조정

데이터베이스 시스템의 **설정값(파라미터)**을 조정하는 방법입니다.

- **체크포인트 간격**: 자동 저장 주기를 조절합니다. 너무 짧으면 성능이 떨어지고, 너무 길면 장애 시 데이터 손실이 커집니다.
- **버퍼 크기**: 메모리 버퍼의 크기를 조절합니다.
- **블로킹 팩터**: I/O 단위의 크기를 조절합니다.

> 한글이나 워드에서 **자동 저장 간격**을 1분으로 설정하면 매우 자주 저장되어 안전하지만, 저장할 때마다 프로그램이 잠시 멈추는 현상이 생깁니다. 이것을 30분으로 늘리면 멈추는 빈도가 줄어들지만, 갑자기 프로그램이 종료되면 최대 30분치 작업을 잃을 수 있습니다. 이처럼 **적절한 균형점을 찾는 것**이 파라미터 튜닝입니다.

### 가장 높은 단계: 구조적 개선

가장 효과적이지만 가장 어려운 단계입니다:

- **정규화/역정규화**: 테이블 구조를 재설계합니다
- **인덱스 추가/제거**: 검색 패턴에 맞게 인덱스를 조정합니다
- **뷰(View)나 실체화된 뷰(Materialized View)** 활용
- **SQL 쿼리 최적화**: 쿼리 자체를 효율적으로 다시 작성합니다

---

## ⚠️ 성능 향상을 위한 실전 팁과 주의사항

### 인덱스 관련 주의사항

```sql
-- ❌ 잘못된 예: 갱신이 많은 테이블에 인덱스를 과도하게 설정
CREATE INDEX idx_col1 ON orders(column1);
CREATE INDEX idx_col2 ON orders(column2);
CREATE INDEX idx_col3 ON orders(column3);
CREATE INDEX idx_col4 ON orders(column4);
-- 검색보다 INSERT, UPDATE, DELETE가 많다면 오히려 성능 저하!

-- ✅ 올바른 예: WHERE절이나 JOIN에 자주 사용되는 컬럼에만 인덱스 설정
CREATE INDEX idx_customer_id ON orders(customer_id);
-- customer_id가 WHERE절과 JOIN에 자주 사용된다면 인덱스 설정
```

:::warning 인덱스의 양면성
- **인덱스를 추가하면**: 검색(SELECT) 성능은 향상되지만, 갱신(INSERT/UPDATE/DELETE) 성능은 저하됩니다
- **인덱스를 제거하면**: 갱신 성능은 향상되지만, 검색 성능은 저하됩니다
- 따라서 **검색이 많은 테이블에는 인덱스를 추가**하고, **갱신이 많은 테이블에서는 불필요한 인덱스를 제거**하는 것이 좋습니다
:::

### 불필요한 정렬 제거

```sql
-- ❌ 잘못된 예: 굳이 정렬이 필요 없는데 ORDER BY 사용
SELECT name FROM employees ORDER BY name;
-- 100만 건의 데이터를 일일이 정렬하는 것은 큰 부하

-- ✅ 올바른 예: 정렬이 꼭 필요한 경우에만 사용
SELECT name FROM employees;
-- 정렬 없이 결과를 빠르게 반환
```

정렬은 데이터 양이 많을수록 비용이 급격히 증가합니다. 100만 건의 데이터를 정렬하는 것은 상당한 부하를 발생시키므로, **꼭 필요한 경우에만 정렬**해야 합니다.

### UNION ALL vs UNION / DISTINCT 사용 최소화

```sql
-- ❌ 비효율적: UNION은 중복 제거를 위해 정렬 + 비교 수행
SELECT city FROM employees
UNION
SELECT city FROM customers;
-- 중복 제거를 위해 결과를 정렬하고 비교하는 추가 작업 발생

-- ✅ 효율적: 중복 제거가 불필요하면 UNION ALL 사용
SELECT city FROM employees
UNION ALL
SELECT city FROM customers;
-- 중복 제거 없이 그대로 합치므로 빠름
```

```sql
-- ❌ 비효율적: 굳이 중복 제거가 필요 없는데 DISTINCT 사용
SELECT DISTINCT department FROM employees;
-- DISTINCT는 정렬 후 중복 제거하는 추가 연산 발생

-- ✅ 효율적: 중복이 있어도 괜찮다면 DISTINCT 생략
SELECT department FROM employees;
-- 추가 연산 없이 바로 결과 반환
```

- **UNION**: 중복을 제거합니다 → 내부적으로 **정렬 + 비교** 작업이 필요 → 느림
- **UNION ALL**: 중복을 그대로 둡니다 → 추가 작업 없음 → 빠름
- **DISTINCT**: 중복을 제거합니다 → 마찬가지로 정렬 + 비교 필요 → 느림

> 중복 제거가 꼭 필요한 경우에만 UNION이나 DISTINCT를 사용하고, 그렇지 않으면 UNION ALL을 사용하는 것이 성능에 도움이 됩니다.

### EXISTS vs COUNT 활용

```sql
-- ❌ 비효율적: 전체를 세어서 존재 여부 확인
SELECT COUNT(*) FROM orders WHERE customer_id = 100;
-- 해당 고객의 주문이 100건이든 1건이든 전체를 다 세야 함

-- ✅ 효율적: 존재 여부만 확인하면 되는 경우
SELECT EXISTS(SELECT 1 FROM orders WHERE customer_id = 100);
-- 하나만 찾으면 바로 종료 → 훨씬 빠름
```

레코드가 **있는지 없는지만** 확인하면 되는데, 굳이 전체 건수를 세는 것은 불필요한 연산입니다.

### SORT AGGREGATE 대신 HASH AGGREGATE 활용

**SORT AGGREGATE**는 물리적으로 데이터를 정렬한 후 집계하는 방식이고, **HASH AGGREGATE**는 정렬 없이 해시를 이용하여 그룹화하고 집계하는 방식입니다. 정렬이 필요 없는 집계에서는 HASH AGGREGATE가 더 효율적입니다.

---

## 📈 성능 평가 기준: TPC

데이터베이스의 성능이 "좋다" 또는 "나쁘다"를 단순히 감으로 판단할 수는 없습니다. **객관적인 기준**이 필요하죠. 이를 위해 전 세계적으로 사용되는 표준이 바로 **TPC(Transaction Processing Performance Council)**입니다.

### 성능 측정의 기본 단위

성능 측정의 기본은 **처리율(Throughput)**입니다.

> **1초에 몇 건의 트랜잭션(Transaction, 작업 단위)을 처리할 수 있는가?**

예를 들어 1초에 10건을 처리하는 시스템과 100건을 처리하는 시스템이 있다면, 당연히 후자가 성능이 좋습니다.

비즈니스에서는 단순 처리량보다 **Price per TPS**(단위 시간당 처리 비용)를 더 중시합니다. "이 시스템은 1초에 100건을 처리하는데, 비용이 25만 원이다"처럼 **가성비**를 따지는 것이죠.

### TPC 벤치마크 종류

| 종류 | 용도 | 예시 |
|------|------|------|
| **TPC-A** | 단순 입출금 평가 | 은행 ATM 시스템 |
| **TPC-B** | 운영체제 평가 | OS 레벨 성능 측정 |
| **TPC-C** | 일반 주문 처리 평가 | 항공권 예약, 온라인 주문 |
| **TPC-D** | 의사결정 시스템 평가 | 경영 분석 시스템 |
| **TPC-H** | 대용량 예측 불가 질의 평가 | 다양한 분석 질의 처리 |
| **TPC-R** | 보고서 기능 평가 | 요약 보고서 생성 |
| **TPC-W** | 웹/인터넷 평가 | 이커머스 시스템 |

:::tip 성능만이 아닌 품질도 함께 고려하라
아무리 빠른 시스템이라도 **자주 오류가 발생하면** 쓸 수 없습니다. 슈퍼카가 시속 500km로 달릴 수 있지만 자주 고장난다면 위험하죠. 따라서 **성능(Performance)**과 **품질(Quality)**은 반드시 함께 평가해야 합니다.
:::

---

## 🏥 데이터 품질 관리와 진단

### 품질 진단의 세 가지 유형

데이터베이스의 건강 상태를 점검하는 것을 **품질 진단**이라고 합니다. 마치 사람이 건강검진을 받는 것과 같습니다.

| 진단 유형 | 대상 | 설명 | 비유 |
|-----------|------|------|------|
| **값 진단** | 데이터 값 자체 | 테이블, 속성, 코드, 관계, 비즈니스 규칙 기준으로 값이 정확한지 | 혈액 검사 (수치가 정상인지) |
| **구조 진단** | 시스템 스키마 구조 | 모델링과 설계가 제대로 되어 있는지 (리버스 모델링 활용) | X-ray 검사 (뼈 구조가 정상인지) |
| **프로세스 진단** | 전체 관리 프로세스 | 값과 구조의 관리가 체계적으로 이루어지고 있는지 | 생활습관 검진 (전체 건강 관리가 되는지) |

**값 진단**은 데이터에 잘못된 값이 들어가 있지 않은지, 누락된 값은 없는지를 확인하는 것입니다. **구조 진단**은 테이블 설계가 올바른지, 스키마 구조에 문제가 없는지를 확인하는 것입니다. 여기서 **리버스 모델링(Reverse Modeling)**이 활용되는데, 이는 완성된 결과물을 거꾸로 분해하여 설계를 역추적하는 방법입니다. **프로세스 진단**은 전체 품질 관리 주기가 체계적으로 운영되고 있는지를 확인합니다.

> 요리사가 음식을 만든 후, 중간중간 맛을 보며(값 진단) 레시피가 올바른지 확인하고(구조 진단), 전체 조리 과정이 위생 규칙을 따르는지 점검하는(프로세스 진단) 것과 같습니다.

---

## 📌 핵심 정리

- **데이터베이스 튜닝**이란 DB의 성능을 향상시키기 위해 다양한 요소를 조정하는 모든 과정이다
- **조인 연산**은 여러 테이블을 읽고, 비교하고, 추출해야 하므로 성능 저하의 주범이다
- **셀렉션 접근 루틴**에는 선형 탐색, 이진 탐색, 인덱스 탐색, 해싱 방식이 있다
- **정렬 합병 조인**은 양쪽을 정렬 후 동시에 비교하며, 전체 데이터 처리에 적합하다
- **중첩 루프 조인**은 선행 테이블 범위만큼 후행 테이블을 반복 탐색하며, 부분 범위 처리에 적합하다
- **해시 조인**은 해시 함수로 주소를 계산하여 매칭하며, 동일 조인(=)에서만 사용 가능하다
- 질의 처리 비용에는 I/O 비용, 저장 비용, CPU 비용, 메모리 비용, 통신 비용이 있다
- 튜닝 단계는 하드웨어 교체(가장 낮음) → 파라미터 조정(중간) → 구조적 개선(가장 높음) 순이다
- **인덱스**는 검색 성능을 높이지만 갱신 성능을 떨어뜨리므로, 사용 패턴에 맞게 설정해야 한다
- 불필요한 **정렬(ORDER BY)**, **중복 제거(DISTINCT, UNION)**를 줄이는 것이 성능 향상의 기본이다
- 성능 평가는 **TPC 표준**을 기준으로 하며, 성능뿐 아니라 **품질**도 함께 고려해야 한다
- 데이터 품질 진단은 **값 진단**, **구조 진단**, **프로세스 진단** 세 가지로 나뉜다

작성일: 2026-02-21