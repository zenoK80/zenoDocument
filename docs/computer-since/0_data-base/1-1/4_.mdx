---
title: 파일 시스템의 문제점
description: 파일 시스템이 가진 종속성과 중복성 문제를 이해하고, 왜 데이터베이스가 필요한지 학습합니다.
slug: file-system-problems
sidebar_position: 4
---

# 파일 시스템의 문제점

파일 시스템이 왜 데이터베이스로 발전해야 했는지, 어떤 근본적인 문제점들이 있었는지 살펴보겠습니다.

---

## 파일 시스템의 2대 문제점

### 핵심 요약

```
파일 시스템의 문제 = 종속성 + 중복성
```

1. **종속성 (Dependency)**: 데이터 구조와 프로그램의 강한 결합
2. **중복성 (Redundancy)**: 동일한 데이터의 반복 저장

---

## 1. 종속성 문제 (Data Dependency)

### 개념
데이터의 저장 구조나 접근 방법이 변경되면 응용 프로그램도 함께 변경해야 하는 문제입니다.

### 종속성이 발생하는 이유

**파일 시스템의 특징:**
```
응용 프로그램 ←──강하게 결합──→ 데이터 파일

프로그램이 파일의 물리적 구조를 직접 알아야 함
```

### 종속성의 구체적 사례

#### 사례 1: 파일 구조 변경

**변경 전:**
```c
struct Student {
    char id[10];      // 학번
    char name[50];    // 이름
    char dept[30];    // 학과
};
```

**변경 후:**
```c
struct Student {
    char id[10];      // 학번
    char name[50];    // 이름
    char dept[30];    // 학과
    char email[100];  // 이메일 추가 ← 새 필드
};
```

**문제 발생:**
```
→ 모든 관련 프로그램을 수정해야 함
→ 재컴파일 필요
→ 대규모 시스템에서는 수백 개의 프로그램 수정
```

#### 사례 2: 저장 방식 변경

**변경 전:**
```
순차 파일 (Sequential File)
학생1 → 학생2 → 학생3 → ...
```

**변경 후:**
```
인덱스 파일 (Indexed File)
인덱스 → 학생1
       → 학생2
       → 학생3
```

**문제 발생:**
```
→ 파일 접근 코드 전체 수정
→ 읽기/쓰기 로직 변경
→ 기존 프로그램 사용 불가
```

### 종속성의 문제점

| 문제 | 설명 | 영향 |
|------|------|------|
| **유지보수 어려움** | 작은 변경도 큰 수정 필요 | 개발 비용 증가 |
| **개발 생산성 저하** | 데이터 구조 파악 필수 | 개발 시간 증가 |
| **이식성 문제** | 다른 시스템 이전 어려움 | 확장성 제한 |
| **표준화 불가능** | 각자 다른 방식 사용 | 호환성 문제 |

### 종속성 예시

```python
# 파일 시스템 코드 (종속적)
def read_student():
    file = open("student.dat", "rb")
    # 파일의 정확한 구조를 알아야 함
    id = file.read(10)      # 10바이트 읽기
    name = file.read(50)    # 50바이트 읽기
    dept = file.read(30)    # 30바이트 읽기
    file.close()
    
    # 구조가 바뀌면 이 코드 전체를 수정해야 함!
```

---

## 2. 중복성 문제 (Data Redundancy)

### 개념
동일한 데이터가 여러 곳에 중복되어 저장되는 문제입니다.

### 중복성이 발생하는 이유

**파일 시스템의 특성:**
```
사용자A → 파일A (학생정보.xlsx)
사용자B → 파일B (학생정보_복사본.xlsx)
사용자C → 파일C (학생정보_최신.xlsx)

각자 파일을 가지고 작업 → 중복 발생
```

### 중복성의 구체적 사례

#### 사례 1: 부서별 파일 관리

```
인사부: 직원명부.xlsx
  - 사번, 이름, 부서, 연락처

총무부: 직원연락처.xlsx
  - 사번, 이름, 연락처, 주소

회계부: 급여대장.xlsx
  - 사번, 이름, 계좌번호, 급여

→ 사번, 이름이 3곳에 중복 저장됨!
```

#### 사례 2: 데이터 불일치 발생

**초기 상태:**
```
파일A: 홍길동, 010-1234-5678
파일B: 홍길동, 010-1234-5678
파일C: 홍길동, 010-1234-5678
```

**사용자A가 파일A 수정:**
```
파일A: 홍길동, 010-9999-8888 ← 변경됨
파일B: 홍길동, 010-1234-5678
파일C: 홍길동, 010-1234-5678

→ 데이터 불일치 발생!
→ 어떤 정보가 정확한지 알 수 없음!
```

### 중복성으로 인한 문제점

#### 1. 데이터 불일치 (Data Inconsistency)

**문제:**
```
같은 데이터가 다른 값을 가짐
→ 정확한 정보를 알 수 없음
→ 신뢰성 저하
```

**예시:**
```
직원명부.xlsx: 홍길동 부서 → 개발팀
급여대장.xlsx: 홍길동 부서 → 영업팀

어느 것이 맞는가? 🤔
```

#### 2. 일관성 결여 (Lack of Consistency)

**문제:**
```
하나를 수정해도 다른 곳은 수정 안 됨
→ 전체 데이터의 일관성 깨짐
```

**예시:**
```
이메일 변경:
파일1: hong@old.com → hong@new.com (수정됨)
파일2: hong@old.com (수정 안 됨)
파일3: hong@old.com (수정 안 됨)
```

#### 3. 정확성 저하 (Reduced Accuracy)

**문제:**
```
여러 버전의 데이터가 존재
→ 최신 데이터인지 확인 불가
→ 잘못된 의사결정 가능
```

**예시:**
```
재고 관리:
창고A 파일: 재고 100개
창고B 파일: 재고 80개
본사 파일: 재고 120개

실제 재고는? 알 수 없음!
```

#### 4. 보안 유지 어려움 (Security Issues)

**문제:**
```
여러 곳에 흩어진 데이터
→ 모든 곳에 동일한 보안 적용 어려움
→ 보안 취약점 발생
```

**예시:**
```
파일A: 암호화됨 ✅
파일B: 암호화 안 됨 ❌ ← 보안 취약
파일C: 접근 제한 설정 안 됨 ❌ ← 보안 취약
```

#### 5. 경제성 저하 (Economic Inefficiency)

**저장 비용 증가:**
```
동일 데이터를 여러 번 저장
→ 저장 공간 낭비
→ 저장 비용 증가
```

**갱신 비용 증가:**
```
하나의 데이터 변경 시
→ 모든 복사본 찾아서 수정
→ 갱신 비용 증가
```

**예시 계산:**
```
직원 1명의 연락처 변경

파일 시스템:
- 3개 파일에 중복 저장
- 3번 수정 작업 필요
- 비용: 3배

데이터베이스:
- 1개 위치에 저장
- 1번 수정으로 모든 곳에 반영
- 비용: 1배
```

#### 6. 무결성 유지 어려움 (Integrity Maintenance)

**무결성(Integrity) = 정확성**

**문제:**
```
중복 데이터 간 동기화 실패
→ 데이터 정확성 보장 불가
```

**예시:**
```
학생 성적 관리:
교수 파일: 중간고사 85점
학생 파일: 중간고사 90점

→ 무결성 위반!
→ 정확한 성적을 알 수 없음
```

---

## 3. 중복성의 장단점

### 단점 (압도적으로 많음)

```
❌ 데이터 불일치
❌ 일관성 결여
❌ 정확성 저하
❌ 보안 유지 어려움
❌ 저장 공간 낭비
❌ 갱신 비용 증가
❌ 무결성 유지 어려움
```

### 장점 (일부 존재)

```
✅ 가용성 향상 (Availability)
   - 한 곳이 고장나도 다른 곳 사용 가능

✅ 사이트 간 데이터 이동 최소화
   - 각자 데이터를 가지고 있음

✅ 장애 복구 용이
   - 백업 데이터가 여러 곳에 존재
```

### 장단점 비교

| 측면 | 장점 | 단점 | 결론 |
|------|------|------|------|
| 데이터 정확성 | - | 불일치 발생 | ❌ 심각 |
| 저장 공간 | - | 공간 낭비 | ❌ 비효율 |
| 비용 | - | 갱신 비용 증가 | ❌ 경제성 저하 |
| 가용성 | 백업 효과 | - | ✅ 일부 유용 |
| 보안 | - | 관리 어려움 | ❌ 취약 |

**결론:**
```
장점 < 단점

동시 사용 환경에서는 치명적!
→ 데이터베이스 필요성 대두
```

---

## 4. 파일 시스템 문제 해결: 데이터베이스

### 데이터베이스의 해결 방법

#### 종속성 해결

**데이터 독립성 제공:**
```
응용 프로그램 ←─독립적─→ 데이터베이스

물리적 저장 구조 변경해도
프로그램 수정 불필요
```

**예시:**
```sql
-- 데이터베이스 사용
SELECT 학번, 이름, 학과 FROM 학생;

-- 테이블에 새 컬럼 추가해도
-- 이 쿼리는 여전히 작동함!
ALTER TABLE 학생 ADD COLUMN 이메일 VARCHAR(100);
```

#### 중복성 해결

**데이터 통합:**
```
여러 파일 → 하나의 데이터베이스

중복 최소화
통제된 중복만 허용
```

**예시:**
```
파일 시스템:
├─ 직원명부.xlsx (사번, 이름, 부서)
├─ 연락처.xlsx (사번, 이름, 연락처)
└─ 급여.xlsx (사번, 이름, 급여)

데이터베이스:
직원 테이블: 사번(PK), 이름, 부서, 연락처, 급여
→ 사번, 이름 중복 제거!
```

---

## 5. 실제 사례로 이해하기

### 사례 1: 학교 학사 관리

**파일 시스템 방식:**
```
학생과: 학생정보.xlsx
교무과: 수강신청.xlsx
학적과: 성적관리.xlsx

문제:
- 학생 이름 변경 시 3개 파일 모두 수정
- 각 파일마다 다른 학점 정보 (불일치)
- 파일 구조 변경 시 모든 프로그램 수정
```

**데이터베이스 방식:**
```sql
학생 테이블: 학번, 이름, 학과
수강 테이블: 수강번호, 학번, 강의코드
성적 테이블: 학번, 강의코드, 성적

해결:
- 이름 변경 시 1번만 수정 → 모든 곳에 반영
- 성적 정보 1곳에만 저장 → 일관성 유지
- 테이블 구조 변경해도 기존 쿼리 동작
```

### 사례 2: 은행 업무

**파일 시스템 방식:**
```
본점: 고객정보.dat
지점A: 고객정보_A.dat
지점B: 고객정보_B.dat

문제:
- 고객 주소 변경 시 모든 지점 파일 수정 필요
- 잔액 정보 불일치 발생 가능
- 보안 관리 각자 다르게 적용
```

**데이터베이스 방식:**
```sql
고객 테이블: 계좌번호, 이름, 주소, 잔액

해결:
- 중앙 DB 1번 수정 → 모든 지점에서 즉시 반영
- 실시간 잔액 정보 일치
- 통합 보안 정책 적용
```

---

## 핵심 정리

### 파일 시스템의 2대 문제

```
1. 종속성 (Dependency)
   → 데이터 독립성 부족
   → 유지보수 어려움

2. 중복성 (Redundancy)
   → 데이터 불일치
   → 무결성 유지 어려움
```

### 중복성으로 인한 7가지 문제

```
1. 데이터 불일치
2. 일관성 결여
3. 정확성 저하
4. 보안 유지 어려움
5. 저장 공간 낭비
6. 갱신 비용 증가
7. 무결성 유지 어려움
```

### 데이터베이스가 필요한 이유

```
파일 시스템의 문제점
      ↓
데이터베이스로 해결
      ↓
- 데이터 독립성 제공
- 중복 최소화
- 무결성 보장
- 보안 강화
- 동시 접근 제어
```

### 암기 팁

```
종중 (종속성-중복성) → 파일 시스템의 2대 문제

불일보저갱무 → 중복성의 6가지 문제
(불일치, 일관성결여, 보안, 저장공간, 갱신비용, 무결성)
```

### 핵심 메시지

```
"나 혼자 쓰면 괜찮지만,
 동시에 많은 사람이 사용하면
 파일 시스템은 문제가 발생한다.
 
 이것이 데이터베이스가 탄생한 이유다!"
```