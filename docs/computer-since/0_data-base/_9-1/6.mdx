---
title: "정규화 (Normalization)"
description: "데이터베이스 정규화의 개념, 목적, 단계 및 실무 적용 방법"
slug: "normalization"
sidebar_position: 6
---

# 정규화 (Normalization)

## 개요

정규화(Normalization)는 **이상현상을 제거**하고 **데이터 무결성을 유지**하기 위해 릴레이션을 여러 개의 릴레이션으로 분해하는 과정입니다.

## 정규화의 정의

### 개념

**속성들 간의 종속성을 분석하여, 하나의 종속성이 하나의 릴레이션이 되도록 분해하는 과정**

```
정규화 = 릴레이션 분해
하나의 테이블 → 여러 개의 테이블

목표:
- 중복 최소화
- 종속성 보존
- 이상현상 제거
```

### 정규화가 수행되는 단계

데이터베이스 설계 3단계:
1. **개념적 설계**: ERD 작성
2. **논리적 설계**: 정규화 수행 ← 여기서 정규화!
3. **물리적 설계**: 역정규화, 인덱스 설계

## 정규화의 목적

### 1. 이상현상 제거

```
삽입 이상 ✗
삭제 이상 ✗
갱신 이상 ✗
→ 정규화로 해결!
```

### 2. 데이터 무결성 유지

**논리적 품질 향상**
- 데이터 일관성 보장
- 중복 최소화
- 정보 손실 방지

### 3. 데이터 구조의 안정성

**개체와 개체 간의 관계를 명확히 파악**
- 독립된 개체는 별도 릴레이션
- 명확한 관계 설정

## 정규화의 특징

### 정규화는 성능 향상이 아닌 무결성 유지

```
❌ 정규화 ≠ 성능 향상
✅ 정규화 = 이상현상 제거 + 무결성 유지
```

**성능에 미치는 영향:**
```
정규화 전:
학생수강(학번, 과목, 성적, 학년)  ← 1개 테이블

정규화 후:
학생(학번, 학년)                  ← 2개 테이블
수강(학번, 과목, 성적)

조회 시:
정규화 전: SELECT * FROM 학생수강
정규화 후: SELECT * FROM 학생 JOIN 수강
           ↑ 조인 연산 필요 → 성능 저하
```

### 릴레이션 수 증가 → 조인 연산 증가

**정규화의 딜레마:**
- 정규화 ↑ → 무결성 ↑, 성능 ↓
- 정규화 ↓ → 무결성 ↓, 성능 ↑

## 정규화의 단계

### 정규형의 종류

```
1NF (제1정규형)
  ↓
2NF (제2정규형)
  ↓
3NF (제3정규형)
  ↓
BCNF (보이스-코드 정규형)
  ↓
4NF (제4정규형)
  ↓
5NF (제5정규형)
```

### 실무에서의 정규화 수준

```
일반적 실무: 3NF 또는 BCNF까지

이유:
- 3NF/BCNF: 대부분의 이상현상 제거
- 성능과 무결성의 균형점
- 4NF, 5NF: 과도한 분해 → 성능 저하
```

## 정규형별 특징

### 1NF (제1정규형)

**조건**: 모든 속성의 도메인이 원자값(Atomic Value)

```
❌ 1NF 위반:
학생(학번, 이름, 전화번호)
100, 홍길동, "010-1111-1111, 010-2222-2222"
              ↑ 반복 그룹 (여러 값)

✅ 1NF 만족:
학생(학번, 이름)
전화번호(학번, 전화번호)
```

### 2NF (제2정규형)

**조건**: 1NF + 부분 함수 종속 제거

```
❌ 2NF 위반:
수강(학번, 과목, 성적, 학년)
기본키: (학번, 과목)
학번 → 학년  ← 부분 함수 종속!

✅ 2NF 만족:
학생(학번, 학년)
수강(학번, 과목, 성적)
```

### 3NF (제3정규형)

**조건**: 2NF + 이행적 함수 종속 제거

```
❌ 3NF 위반:
학생(학번, 학과코드, 학과사무실)
학번 → 학과코드 → 학과사무실  ← 이행적 종속!

✅ 3NF 만족:
학생(학번, 학과코드)
학과(학과코드, 학과사무실)
```

### BCNF (Boyce-Codd 정규형)

**조건**: 3NF + 모든 결정자가 후보키

```
❌ BCNF 위반:
수업(학생, 과목, 교수)
(학생, 과목) → 교수
교수 → 과목  ← 교수가 결정자이지만 후보키 아님!

✅ BCNF 만족:
학생수업(학생, 교수)
교수과목(교수, 과목)
```

## 정규화 과정 예시

### 예시: 수강 테이블

**0단계: 비정규형**
```
수강(학번, 과목1, 성적1, 과목2, 성적2, 학년)
- 반복 그룹 존재
```

**1NF 적용**
```
수강(학번, 과목, 성적, 학년)
- 원자값만 존재
- 기본키: (학번, 과목)
```

**2NF 적용**
```
문제: 학번 → 학년 (부분 함수 종속)

해결:
학생(학번, 학년)
수강(학번, 과목, 성적)
```

**3NF 확인**
```
이행적 종속 없음 → 3NF 만족 ✓
```

## 정규화 vs 역정규화

### 비교표

| 구분 | 정규화 | 역정규화 |
|------|--------|----------|
| **시기** | 논리적 설계 | 물리적 설계 |
| **목적** | 무결성, 이상현상 제거 | 성능 향상 |
| **방법** | 테이블 분해 | 테이블 통합 |
| **장점** | 중복 제거, 일관성 유지 | 조회 속도 향상 |
| **단점** | 조인 증가, 성능 저하 | 중복 증가, 이상현상 위험 |
| **결과** | 릴레이션 수 ↑ | 릴레이션 수 ↓ |

## 요약

정규화의 핵심 원칙:

1. **목적**: 이상현상 제거, 무결성 유지
2. **방법**: 종속성 분석 후 테이블 분해
3. **수준**: 실무에서는 3NF/BCNF까지
4. **단계**: 논리적 설계에서 수행
5. **원칙**: 정보 무손실, 종속성 보존, 중복 최소화

**정규화는 성능보다 논리적 품질을 위한 과정**입니다. 성능이 필요한 경우 물리적 설계 단계에서 선택적으로 역정규화를 고려합니다.