---
title: "3단계 스키마 구조 개요"
description: "3단계 스키마 구조 개요에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/three-level-database-architecture/1-three-level-schema-overview"
sidebar_label: "3단계 스키마 개요"
date: "2026-02-20"
---

## 🎯 3단계 데이터베이스란 무엇인가?

데이터베이스를 처음 공부하다 보면 **"3단계 데이터베이스"** 또는 **"3단계 스키마 구조"**라는 용어를 만나게 됩니다. 이름 그대로 데이터베이스의 구조를 **3개의 단계(레벨)**로 나눠서 바라보는 개념입니다.

이 3단계는 각각 다음과 같습니다.

| 단계 | 이름 | 한 줄 설명 |
|---|---|---|
| 1단계 | **외부 스키마** (External Schema) | 개별 사용자가 보는 관점의 구조 |
| 2단계 | **개념 스키마** (Conceptual Schema) | 조직 전체가 하나로 보는 통합 구조 |
| 3단계 | **내부 스키마** (Internal Schema) | 저장 장치(하드디스크) 관점의 물리적 구조 |

비유를 하나 들어볼까요? 마치 **아파트 한 동**을 생각해 보세요.

- **외부 스키마**: 각 세대 거주자가 자기 집 내부만 보는 것 (101호 거주자는 101호만, 202호 거주자는 202호만 봅니다)
- **개념 스키마**: 아파트 관리사무소에서 전체 동의 구조(몇 층, 몇 호, 배관 구조 등)를 하나로 파악하는 것
- **내부 스키마**: 건설사가 실제 철근·콘크리트·배관이 어떻게 물리적으로 배치되어 있는지 보는 것

이 3단계 구조의 **핵심 목표**는 바로 **"데이터 독립성"**을 확보하는 것입니다. 각 단계가 서로 독립적으로 운영되기 때문에, 한 단계가 변경되더라도 다른 단계에 영향을 주지 않습니다.

> **3단계 데이터베이스 구조**는 데이터 독립성을 지키기 위해 만들어진 **표준 이론**입니다. ANSI/SPARC에서 제안한 이 구조 덕분에, 데이터베이스의 한 부분이 바뀌어도 나머지 부분은 그대로 사용할 수 있게 됩니다.

---

## 🔑 왜 필요한가? — 데이터 독립성의 이해

### 파일 시스템의 문제점에서 출발

3단계 스키마 구조가 왜 필요한지 이해하려면, 데이터베이스가 등장하기 이전의 **파일 시스템**이 가지고 있던 문제점부터 알아야 합니다.

과거 파일 시스템에서는 **두 가지 큰 문제**가 있었습니다.

1. **중복성**: 같은 데이터가 여러 파일에 중복 저장되어 공간 낭비와 불일치가 발생
2. **종속성**: 파일의 구조(자료 구조)가 바뀌면 그 파일을 사용하는 **프로그램도 함께 수정**해야 하는 문제

특히 **종속성**이 심각한 문제였습니다. 예를 들어볼게요. 학생 정보를 저장하는 파일의 "전화번호" 필드 길이를 10자리에서 11자리로 바꿨다고 해 봅시다. 그러면 이 파일을 읽는 **모든 프로그램**을 찾아서 하나하나 수정해야 했습니다. 프로그램이 10개면 10개를 다 고쳐야 했죠. 마치 **집 주소가 바뀌면 모든 택배 회사에 일일이 전화해서 새 주소를 알려줘야 하는 것**과 같습니다.

### 독립성이란?

**데이터 독립성(Data Independence)**이란, 자료 구조(데이터베이스의 구조)가 바뀌어도 **프로그램은 수정 없이 그대로 사용할 수 있는 능력**을 말합니다.

이것이 바로 **DBMS(데이터베이스 관리 시스템)가 추구하는 궁극적인 목표**입니다.

> **독립성의 핵심 원칙**: 상위 단계 스키마에 영향을 주지 않고, **하위 단계 스키마를 수정할 수 있는 능력**입니다. 항상 "아래가 바뀌어도 위는 그대로"라고 기억하세요!

:::warning 방향을 헷갈리지 마세요!
"응용 프로그램을 변경했을 때 자료 구조를 그대로 사용할 수 있다"는 것은 독립성이 **아닙니다**. 독립성은 항상 **하위 단계가 변경됐을 때** 상위 단계를 그대로 사용할 수 있느냐를 따져보는 것입니다. 방향을 반대로 이해하면 시험에서 틀리기 쉬우니 주의하세요!
:::

### 논리적 데이터 독립성

**논리적 데이터 독립성**은 **사용자 관점**에서의 독립성입니다.

쉽게 말해, **데이터베이스의 논리적 구조(테이블 구조 등)가 변경되더라도** 기존 응용 프로그램은 영향을 받지 않고 **그대로 사용할 수 있는 능력**입니다.

전체 흐름을 그림으로 표현하면 이렇습니다:

```
사용자 → 응용 프로그램 → 데이터베이스(논리적 구조) → 하드디스크
```

여기서 **데이터베이스의 논리적 구조가 변경**되었을 때, 앞에 있는 **응용 프로그램을 수정하지 않아도** 되는 것이 논리적 데이터 독립성입니다.

비유하자면, **도서관의 책 분류 체계가 바뀌었다고 해서 도서관 이용자가 책을 빌리는 방법까지 바뀌지는 않는 것**과 같습니다. 내부 분류 방식은 달라졌지만, 이용자는 여전히 검색 시스템에 제목을 입력하면 책을 찾을 수 있죠.

:::info 논리적 vs 물리적, 기본 구분법
- **논리적(Logical)** = **사용자 관점**. 사람이 데이터를 바라보는 방식
- **물리적(Physical)** = **하드웨어 관점**. 하드디스크가 데이터를 저장하는 방식

이 두 가지 관점은 데이터베이스 전반에 걸쳐 반복적으로 등장하므로 확실히 구분해 두세요!
:::

### 물리적 데이터 독립성

**물리적 데이터 독립성**은 **하드웨어(저장 장치) 관점**에서의 독립성입니다.

**하드웨어(하드디스크 등)가 변경되더라도** 데이터베이스의 논리적 구조나 응용 프로그램을 **수정 없이 그대로 사용할 수 있는 능력**입니다.

```
사용자 → 응용 프로그램 → 데이터베이스(논리적 구조) → 하드디스크(물리적 구조)
```

여기서 맨 뒤의 **하드디스크(물리적 구조)가 변경**되었을 때, 앞에 있는 **데이터베이스 구조와 응용 프로그램이 영향받지 않는 것**이 물리적 데이터 독립성입니다.

그렇다면 물리적 데이터 독립성은 **언제 필요**할까요? 바로 **시스템 성능 향상**을 위해 하드웨어를 교체할 때입니다. 여러분 집의 컴퓨터 성능이 떨어지면 CPU를 바꾸고, 메모리를 추가하고, 하드디스크를 SSD로 교체하잖아요? 이렇게 **저장 장치를 바꾸더라도** 기존에 만들어놓은 프로그램과 데이터베이스 구조는 손대지 않고 그대로 쓸 수 있어야 합니다.

마치 **냉장고를 새 제품으로 바꿔도 안에 들어 있는 음식 레시피나 식단 계획표를 다시 작성할 필요가 없는 것**과 같습니다.

또한, 논리적 구조와 물리적 구조는 별도의 데이터베이스가 아닙니다. **하나의 데이터베이스**를 사용자가 보는 관점이 논리적 관점이고, 저장 장치가 보는 관점이 물리적 관점입니다. 이 두 관점 사이에는 서로 **매핑(Mapping, 대응 관계)**이 존재해서, 한쪽이 변경되면 다른 쪽에도 반영될 수 있어야 합니다.

| 구분 | 논리적 데이터 독립성 | 물리적 데이터 독립성 |
|---|---|---|
| **관점** | 사용자 관점 | 하드웨어(저장 장치) 관점 |
| **변경 대상** | 데이터베이스의 논리적 구조 | 하드디스크 등 물리적 저장 구조 |
| **영향받지 않는 대상** | 응용 프로그램 | 논리적 구조 + 응용 프로그램 |
| **필요한 상황** | 테이블 구조 변경 시 | 성능 향상을 위한 하드웨어 교체 시 |

---

## 📐 스키마와 인스턴스 — 구조와 값의 차이

3단계 데이터베이스를 본격적으로 이해하기 전에, 반드시 알아야 할 두 가지 핵심 용어가 있습니다. 바로 **스키마(Schema)**와 **인스턴스(Instance)**입니다.

### 스키마(Schema) — 데이터베이스의 "설계도"

**스키마**는 데이터베이스의 **구조**를 의미합니다. 마치 건물의 **설계도(청사진)**와 같습니다. 설계도에는 방이 몇 개인지, 크기가 어떤지, 어디에 문이 있는지 등의 **구조 정보**만 담겨 있지, 실제로 그 방에 누가 사는지는 적혀 있지 않죠.

스키마에는 다음과 같은 정보들이 포함됩니다:

- **개체(Entity)**: 데이터의 대상. 예를 들어 "학생 테이블", "교수 테이블" 같은 것
- **속성(Attribute)**: 개체가 갖고 있는 특성. 예를 들어 학생 테이블의 "학번", "이름", "전화번호" 같은 것
- **관계(Relationship)**: 개체와 개체 사이의 연관성. 예를 들어 학생과 교수 사이의 "지도" 관계, 학생과 과목 사이의 "수강" 관계
- **제약 조건(Constraint)**: 데이터가 지켜야 할 규칙. 예를 들어 "점수는 0점에서 100점까지만 가능하다"

이러한 정보들은 데이터 정의어(DDL)를 통해 정의되고, **컴파일**되어 **데이터 사전(Data Dictionary)**에 **메타데이터(데이터에 대한 데이터)** 형태로 저장됩니다.

### 인스턴스(Instance) — 데이터베이스의 "실제 값"

**인스턴스**는 스키마의 반대 개념으로, **어느 특정 순간에 데이터베이스에 실제로 저장되어 있는 정보**를 말합니다.

설계도(스키마)에 따라 지어진 건물에 **실제로 살고 있는 사람, 들어 있는 가구**가 인스턴스라고 생각하면 됩니다.

```sql
-- ✅ 스키마(구조)의 예시: 학생 테이블의 구조를 정의
CREATE TABLE 학생 (
    학번 VARCHAR(10),       -- 학번 속성: 최대 10자리 문자열
    이름 VARCHAR(20),       -- 이름 속성: 최대 20자리 문자열
    지도교수 VARCHAR(20),   -- 지도교수 속성: 최대 20자리 문자열
    점수 INT                -- 점수 속성: 정수형
);
```

```sql
-- ✅ 인스턴스(실제 값)의 예시: 테이블에 실제 데이터를 삽입
INSERT INTO 학생 VALUES ('20001', '홍길동', '김교수', 80);
-- 학번 '20001', 이름 '홍길동', 지도교수 '김교수', 점수 80
-- 이렇게 실제 들어간 값이 바로 인스턴스입니다.
```

:::tip 스키마 vs 인스턴스, 한 줄 정리
- **스키마** = 구조 = 설계도 = "어떤 형태로 데이터를 담을 것인가?"
- **인스턴스** = 값 = 실제 데이터 = "지금 이 순간 어떤 데이터가 들어 있는가?"

이 두 가지는 데이터베이스에서 가장 기본적인 이론이므로 반드시 구분할 수 있어야 합니다!
:::

---

## 🏗️ 3단계 스키마 구조 — 외부·개념·내부 스키마

이제 본격적으로 3단계 스키마 구조의 각 단계를 자세히 살펴보겠습니다. 하나의 데이터베이스 구조를 **어떤 관점에서 보느냐**에 따라 세 가지로 나뉩니다.

### 📌 외부 스키마 (External Schema) — 사용자 개인의 관점

**외부 스키마**는 **개별 사용자가 보는 관점**의 데이터베이스 구조입니다. 사용자를 위해 보여지는 자료 구조이며, 사용자마다 필요한 정보가 다르기 때문에 **여러 개가 존재**합니다.

전체 데이터베이스에서 **부분 부분을 꺼내서 보여주는 것**이기 때문에, **서브 스키마(Sub Schema)**라고도 부릅니다.

은행을 예로 들어볼까요? 은행에는 **"은행 계좌"**라는 하나의 큰 테이블이 있습니다. 하지만 사용자가 하려는 일은 서로 다릅니다.

- **입금하려는 사용자**: 계좌번호, 입금액만 보면 됨 → **입금 뷰(View)**
- **출금하려는 사용자**: 계좌번호, 잔액, 출금액만 보면 됨 → **출금 뷰**
- **이체하려는 사용자**: 보내는 계좌, 받는 계좌, 이체 금액 등을 보면 됨 → **이체 뷰**

이처럼 하나의 테이블에서 **사용자 요구에 맞게 부분적으로 꺼내 보여주는 것**이 외부 스키마이고, 이를 데이터베이스에서는 **뷰(View)**라고 합니다.

```sql
-- ✅ 외부 스키마의 예시: 입금에 필요한 정보만 보여주는 뷰 생성
CREATE VIEW 입금_뷰 AS
SELECT 계좌번호, 고객명, 잔액   -- 입금에 필요한 속성만 선택
FROM 은행계좌;                  -- 전체 은행계좌 테이블에서 가져옴
-- 사용자는 이 뷰를 통해 입금에 필요한 정보만 볼 수 있습니다.
```

```sql
-- ✅ 외부 스키마의 예시: 이체에 필요한 정보만 보여주는 뷰 생성
CREATE VIEW 이체_뷰 AS
SELECT 계좌번호, 고객명, 잔액, 이체한도  -- 이체에 필요한 속성만 선택
FROM 은행계좌;                           -- 전체 은행계좌 테이블에서 가져옴
-- 이체 사용자는 이 뷰를 통해 이체 관련 정보만 확인합니다.
```

> **외부 스키마 핵심 정리**: 사용자 관점의 구조, **여러 개 존재**, 전체의 부분이므로 **서브 스키마**, 뷰(View)로 구현

### 📌 개념 스키마 (Conceptual Schema) — 조직 전체의 관점

**개념 스키마**는 **기관(조직) 전체 입장**에서 데이터베이스를 통합적으로 기술한 구조입니다. 모든 사용자의 관점을 하나로 합친 것이기 때문에 **단 하나만 존재**합니다.

일반적으로 우리가 아무런 수식어 없이 그냥 **"스키마"**라고 부르면, 이것은 **개념 스키마**를 의미합니다. 또한 조직 차원에서 논리적으로 하나로 보는 것이기 때문에 **"조직 논리 단계"**라고도 표현합니다.

개념 스키마에는 다음과 같은 정보들이 포함됩니다:

- 개체(Entity)와 속성(Attribute)
- 개체 간의 관계(Relationship)
- 제약 조건(Constraint)
- 접근 권한(Access Control)
- 보안(Security) 규칙
- 무결성(Integrity) 규칙

위의 은행 예시에서 **"은행 계좌 테이블" 자체**가 바로 개념 스키마입니다. 입금·출금·이체 등으로 나뉘기 전의, **전체 통합된 하나의 테이블 구조**입니다.

```sql
-- ✅ 개념 스키마의 예시: 은행 계좌 테이블 전체 구조
CREATE TABLE 은행계좌 (
    계좌번호 VARCHAR(20) PRIMARY KEY,  -- 기본 키: 계좌를 고유하게 식별
    고객명 VARCHAR(50) NOT NULL,       -- 고객 이름: 반드시 입력해야 함
    잔액 INT DEFAULT 0,                -- 잔액: 기본값 0
    이체한도 INT,                       -- 일일 이체 한도
    계좌유형 VARCHAR(10),               -- 계좌 종류 (저축, 당좌 등)
    개설일 DATE                         -- 계좌 개설 날짜
);
-- 이것이 조직 전체 관점에서 본 하나의 통합 구조 = 개념 스키마
```

### 📌 내부 스키마 (Internal Schema) — 저장 장치의 관점

**내부 스키마**는 **저장 장치(하드디스크) 입장**에서 데이터가 실제로 어떻게 물리적으로 저장되는지를 명세한 구조입니다. 저장 장치는 하나이므로 내부 스키마도 **단 하나만 존재**합니다.

내부 스키마에는 다음과 같은 정보들이 포함됩니다:

- 실제 저장될 **내부 레코드의 형식**
- **인덱스(Index)** 존재 여부 및 구조
- 각 항목의 **데이터 표현 방식** (정수형, 실수형, 문자형 등)
- 데이터의 **물리적 저장 순서**

위의 은행 예시에서, 은행 계좌 테이블이 **하드디스크에 어떤 방식으로 저장되는지**, 인덱스는 무엇을 사용하는지, 데이터 타입은 INTEGER인지 VARCHAR인지 DATE인지 등을 정의한 것이 내부 스키마입니다.

```
-- 내부 스키마 예시 (개념적 표현)
-- 실제 SQL이 아니라, 물리적 저장 방식을 설명하는 명세입니다.

저장 구조: 은행계좌
  - 레코드 길이: 128 bytes
  - 저장 방식: 순차 저장 (Sequential)
  - 인덱스: 계좌번호에 B+Tree 인덱스 적용
  - 계좌번호: CHAR(20), 고정 길이
  - 잔액: INT(4 bytes), 리틀 엔디안 방식 저장
  - 개설일: DATE(8 bytes), YYYYMMDD 형식
```

:::note 내부 스키마와 물리적 단계의 차이
실제 하드디스크를 직접 관리하는 것은 **운영체제(OS)**의 역할입니다. 사용자가 DBMS를 통해 저장 명령을 내리면, 그 권한이 **운영체제로 넘어가**서 실제 저장이 이루어집니다. 따라서 내부 스키마는 실제 물리적 단계(운영체제 단)보다는 **한 단계 위에** 존재하는 스키마 구조라고 이해하면 됩니다.
:::

### 3단계 간의 사상(매핑)과 인터페이스

이 세 가지 스키마는 서로 **매핑(Mapping, 사상)**을 통해 연결됩니다. 각 단계 사이에는 인터페이스가 존재하여 데이터가 올바르게 변환되고 전달됩니다.

| 인터페이스 | 연결 구간 | 설명 |
|---|---|---|
| **사용자 인터페이스** | 사용자 ↔ 외부 스키마 | 사용자가 뷰를 통해 데이터에 접근 |
| **응용 인터페이스** | 외부 스키마 ↔ 개념 스키마 | 뷰와 실제 테이블 간의 변환 |
| **저장 인터페이스** | 개념 스키마 ↔ 내부 스키마 | 논리적 구조와 물리적 저장 방식 간의 변환 |

전체 구조를 한눈에 정리하면 이렇습니다:

```
사용자A  사용자B  사용자C
  │        │        │
  ▼        ▼        ▼        ← 사용자 인터페이스
[입금뷰] [출금뷰] [이체뷰]   ← 외부 스키마 (여러 개)
  │        │        │
  └────────┼────────┘
           ▼                  ← 응용 인터페이스
     [은행계좌 테이블]        ← 개념 스키마 (1개)
           │
           ▼                  ← 저장 인터페이스
  [물리적 저장 명세]          ← 내부 스키마 (1개)
           │
           ▼
     [하드디스크]             ← 물리적 단계 (운영체제 관할)
```

---

## 📚 데이터 사전과 데이터 디렉터리

### 데이터 사전(Data Dictionary) — 메타데이터의 보관소

**데이터 사전**은 데이터베이스에 포함되는 **모든 데이터에 대한 정의와 명세 정보가 저장되어 있는 곳**입니다. 다른 말로 **시스템 카탈로그(System Catalog)**라고도 부릅니다.

데이터 사전에는 구체적으로 다음과 같은 정보들이 컴파일되어 저장됩니다:

- **외부 스키마, 개념 스키마, 내부 스키마**에 대한 정보
- 사용자 인터페이스, 응용 인터페이스, 저장 인터페이스 등 **매핑 정보**
- **권한(Authorization)** 정보
- **보안(Security)** 관련 정보
- **질의 최적화(Query Optimization)** 관련 정보

마치 **도서관의 목록 카드 시스템**과 같습니다. 도서관에 어떤 책이 있고, 어느 서가에 꽂혀 있고, 누가 빌릴 수 있는지 등의 **"데이터에 대한 데이터(메타데이터)"**가 정리되어 있는 곳이죠.

데이터 사전(시스템 카탈로그) 자체도 **일반 테이블과 같은 형태**로 되어 있기 때문에, 사용자가 **SQL 질의어로 검색(조회)**할 수 있습니다.

:::danger 데이터 사전은 직접 수정할 수 없습니다!
데이터 사전에 저장된 정보는 **메타데이터**이기 때문에, 사용자가 `INSERT`, `UPDATE`, `DELETE` 명령으로 **직접 내용을 삽입하거나 수정할 수 없습니다**. 

일반 테이블에 삽입·삭제·갱신 작업을 하면, DBMS가 **자동으로** 해당 내용을 컴파일해서 메타데이터 형태로 데이터 사전에 반영합니다. 이것을 **"자기 정의(Self-describing)"** 특성이라고 합니다. 데이터베이스는 스스로 컴파일하고, 스스로 메타데이터를 만들어서, 스스로 저장하는 것입니다.
:::

```sql
-- ❌ 잘못된 예시: 데이터 사전에 직접 값을 삽입하려는 시도
INSERT INTO SYSTEM_CATALOG VALUES ('학생', 'VARCHAR', 20);
-- 데이터 사전은 사용자가 직접 INSERT로 수정할 수 없습니다!

-- ✅ 올바른 방법: 일반 테이블을 조작하면 DBMS가 자동으로 사전에 반영
CREATE TABLE 학생 (
    학번 VARCHAR(10),    -- 이 구조 정보가 자동으로 데이터 사전에 저장됨
    이름 VARCHAR(20)     -- DBMS가 알아서 메타데이터로 변환하여 관리함
);
-- 위 CREATE TABLE 명령을 실행하면, DBMS가 자동으로
-- "학생 테이블이 있고, 학번은 VARCHAR(10), 이름은 VARCHAR(20)"이라는
-- 메타데이터를 생성하여 데이터 사전에 저장합니다.
```

### 데이터 디렉터리(Data Directory) — 사전에 접근하는 길잡이

**데이터 디렉터리**는 데이터 사전에 **접근하기 위한 정보를 관리하는 시스템**입니다.

운영체제의 탐색기를 생각해 보세요. 폴더(디렉터리)가 있고, 그 폴더 안에 실제 파일이 들어 있잖아요? 이와 비슷하게, 데이터 디렉터리는 데이터 사전 안에 있는 정보를 **찾아가는 경로를 관리**하는 역할을 합니다.

| 구분 | 데이터 사전 (카탈로그) | 데이터 디렉터리 |
|---|---|---|
| **역할** | 메타데이터 저장 | 사전 접근 경로 관리 |
| **접근 권한** | **사용자 접근 가능** (조회만) | **시스템만 접근 가능** |
| **공통점** | 메타데이터를 관리한다는 점에서 동일 | 메타데이터를 관리한다는 점에서 동일 |

:::tip 카탈로그 vs 디렉터리 핵심 차이
둘 다 메타데이터를 관리한다는 점에서는 같지만, **카탈로그(데이터 사전)는 사용자가 접근할 수 있고**, **디렉터리는 시스템만 접근할 수 있다**는 점이 가장 큰 차이입니다!
:::

---

## 🗣️ 데이터 언어 — 정의어, 조작어, 제어어

데이터베이스를 다루기 위해서는 **데이터 언어**가 필요합니다. 데이터 언어는 크게 세 가지로 나뉩니다.

### DDL — 데이터 정의어 (Data Definition Language)

**데이터 정의어(DDL)**는 데이터베이스의 **구조(스키마)를 만들고, 변경하고, 삭제**하는 데 사용되는 언어입니다. 쉽게 말해 **테이블의 "틀"을 만드는 명령어**입니다.

주로 **DBA(데이터베이스 관리자)**가 사용합니다.

| 명령어 | 기능 | 비유 |
|---|---|---|
| `CREATE` | 테이블(구조)을 **생성** | 새 건물 설계도를 만드는 것 |
| `ALTER` | 테이블(구조)을 **변경** | 기존 건물에 방을 추가/수정하는 것 |
| `DROP` | 테이블(구조)을 **삭제** | 건물을 철거하는 것 |

```sql
-- ✅ CREATE: 새로운 테이블 생성
CREATE TABLE 교수 (
    교수번호 VARCHAR(10) PRIMARY KEY,  -- 교수를 고유하게 식별하는 기본 키
    교수명 VARCHAR(20) NOT NULL,       -- 교수 이름, 반드시 입력 필요
    학과 VARCHAR(30)                   -- 소속 학과
);
-- 이 명령은 '교수' 테이블의 구조(스키마)를 새로 만드는 것입니다.

-- ✅ ALTER: 기존 테이블에 새 속성 추가
ALTER TABLE 교수 ADD 이메일 VARCHAR(50);
-- 기존 교수 테이블에 '이메일' 속성(열)을 추가합니다.
-- 구조를 변경하는 것이지, 데이터를 넣는 것이 아닙니다.

-- ✅ DROP: 테이블 자체를 삭제
DROP TABLE 교수;
-- 교수 테이블의 구조와 데이터 모두 완전히 삭제됩니다.
-- 되돌릴 수 없으므로 매우 신중하게 사용해야 합니다!
```

### DML — 데이터 조작어 (Data Manipulation Language)

**데이터 조작어(DML)**는 데이터베이스에 저장된 **실제 데이터를 검색, 삽입, 삭제, 수정**하는 데 사용되는 언어입니다. 일반 프로그래머나 사용자들이 **가장 많이, 가장 보편적으로 사용하는 명령어**입니다.

데이터 조작어는 다시 두 가지로 나뉩니다.

#### 절차적 데이터 조작어 (Procedural DML)

**무슨 데이터(What)**를 **어떤 방식(How)**으로 처리할지 **모두 명세**해야 하는 언어입니다.

특징을 정리하면:
- **저급 언어**에 해당합니다
- **독자적으로 사용할 수 없고**, 반드시 응용 프로그램(호스트 프로그램) 안에 **내장(삽입)**해서만 사용해야 합니다
- 한 번에 **하나의 레코드(한 줄)**만 처리할 수 있습니다

```c
// ✅ 절차적 데이터 조작어 개념 예시 (C 프로그램 안에 내장)
// "어떤 데이터를" + "어떻게 처리할지" 모두 명시해야 합니다.

// 파일을 연다 (어떻게: 파일 열기 절차)
FILE *fp = fopen("student.dat", "r");

// 레코드를 하나씩 읽는다 (어떻게: 한 줄씩 순차 접근)
while (fread(&record, sizeof(Student), 1, fp)) {
    // 조건을 확인한다 (어떤 데이터: 학번이 20001인 학생)
    if (record.학번 == 20001) {
        printf("찾았습니다: %s\n", record.이름);
        break;  // 찾으면 중단
    }
}
fclose(fp);
// 한 번에 하나의 레코드만 읽으면서 처리하는 방식입니다.
```

#### 비절차적 데이터 조작어 (Non-procedural DML)

**무슨 데이터(What)**만 명세하면 되고, **어떤 방식(How)**으로 처리할지는 명세할 필요가 없는 언어입니다. 우리가 흔히 사용하는 **SQL이 대표적인 비절차적 데이터 조작어**입니다.

특징을 정리하면:
- **고급 언어**에 해당합니다
- **독자적으로도 사용**할 수 있고, 응용 프로그램에 삽입해서도 사용할 수 있습니다
- 한 번에 **여러 개의 레코드를 집합 단위로 처리**할 수 있습니다

```sql
-- ✅ 비절차적 데이터 조작어 예시 (SQL)
-- "어떤 데이터를 원하는지(What)"만 명세하면 됩니다.
-- "어떻게 찾을지(How)"는 DBMS가 알아서 처리합니다.

SELECT 이름, 학번       -- 원하는 데이터: 이름과 학번
FROM 학생               -- 어디서: 학생 테이블에서
WHERE 점수 >= 80;       -- 조건: 점수가 80점 이상인 학생
-- 하드디스크에서 어떤 순서로 읽을지, 인덱스를 쓸지 등은
-- 우리가 신경 쓸 필요 없이 DBMS가 최적의 방법을 선택합니다.
-- 조건에 맞는 여러 레코드가 한꺼번에 결과로 나옵니다.
```

두 조작어의 차이를 표로 정리하면:

| 구분 | 절차적 데이터 조작어 | 비절차적 데이터 조작어 |
|---|---|---|
| **명세 방식** | What + How 모두 명세 | What만 명세 |
| **언어 수준** | 저급 언어 | 고급 언어 |
| **독자 사용** | 불가능 (프로그램에 삽입만 가능) | 가능 (독자적 + 삽입 모두 가능) |
| **처리 단위** | 한 번에 **하나의 레코드** | 한 번에 **여러 레코드 (집합 단위)** |
| **대표 예시** | 호스트 언어 내장 방식 | SQL |

:::warning What과 How를 헷갈리지 마세요!
- **What(무엇)**: "학번이 20001인 학생의 이름을 알려줘" → **원하는 데이터**
- **How(어떻게)**: "파일을 열고, 첫 번째 레코드부터 순서대로 읽으면서, 학번이 20001인지 비교하고..." → **처리 절차**

비절차적 언어(SQL)에서는 What만 말하면 되고, How는 DBMS가 알아서 처리합니다!
:::

### DCL — 데이터 제어어 (Data Control Language)

**데이터 제어어(DCL)**는 데이터베이스를 **안전하고 정확하게 관리**하기 위해 사용되는 언어입니다. 주로 **DBA(관리자)**가 사용합니다.

데이터 제어어가 담당하는 주요 기능은 다음과 같습니다:

- **보안(Security)**: 인가되지 않은 사용자의 접근을 차단
- **무결성(Integrity)**: 데이터의 정확성을 유지 (잘못된 데이터가 들어가지 않도록)
- **회복(Recovery)**: 장애가 발생했을 때 데이터를 복구
- **병행 제어(Concurrency Control)**: 동시에 많은 사용자가 접속할 때 충돌이 발생하지 않도록 우선순위를 정하여 관리

```sql
-- ✅ 데이터 제어어 예시: 사용자에게 권한 부여
GRANT SELECT, INSERT ON 학생 TO user01;
-- user01에게 학생 테이블에 대한 조회(SELECT)와 삽입(INSERT) 권한을 부여합니다.
-- 보안을 위해 필요한 최소한의 권한만 부여하는 것이 원칙입니다.

-- ✅ 데이터 제어어 예시: 사용자의 권한 회수
REVOKE INSERT ON 학생 FROM user01;
-- user01에게서 학생 테이블에 대한 삽입(INSERT) 권한을 회수합니다.
```

---

## 👥 데이터베이스 사용자와 시스템 구조

### 데이터베이스 사용자의 종류

데이터베이스를 사용하는 사람은 크게 세 부류로 나뉩니다:

1. **일반 사용자(End User)**: 데이터베이스를 가장 많이 사용하는 일반적인 사용자입니다. 주로 응용 프로그램이나 질의어를 통해 데이터를 검색하고 입력합니다. 은행 창구에서 고객 정보를 조회하는 직원이 대표적인 예입니다.

2. **프로그래머(Application Programmer)**: 응용 프로그램을 개발하는 개발자입니다. 데이터 조작어(DML)를 활용하여 데이터를 처리하는 프로그램을 만듭니다.

3. **데이터베이스 관리자(DBA, Database Administrator)**: 데이터베이스 시스템에 대한 **모든 책임을 지고 있는 사람**입니다. 주로 데이터 정의어(DDL)와 데이터 제어어(DCL)를 사용하여 데이터베이스를 설계하고, 보안을 관리하고, 성능을 최적화합니다. DB와 관련된 모든 일은 DBA가 수행한다고 보면 됩니다.

### 데이터베이스 시스템(DBS)의 구성

**데이터베이스 시스템(Database System, DBS)**은 다음 요소들을 모두 합친 전체 시스템을 말합니다:

- **데이터베이스(DB)**: 실제 데이터가 저장된 곳
- **DBMS**: 데이터베이스를 관리하는 소프트웨어
- **데이터 언어**: DDL, DML, DCL
- **사용자**: 일반 사용자, 프로그래머
- **DBA**: 데이터베이스 관리자
- **컴퓨터(하드웨어)**: 서버, 저장 장치 등

:::warning DBMS와 DBS를 혼동하지 마세요!
- **DBMS(데이터베이스 관리 시스템)**: 데이터베이스를 관리하는 **소프트웨어**
- **DBS(데이터베이스 시스템)**: DB + DBMS + 사용자 + DBA + 언어 + 하드웨어를 모두 포함한 **전체 시스템**

**DBS 안에 DBMS가 포함**되어 있는 것입니다. DBMS는 부분, DBS는 전체입니다!
:::

---

## 🖥️ 데이터베이스 시스템의 구조 유형

데이터베이스 시스템은 그 규모와 구성 방식에 따라 여러 유형으로 나뉩니다.

### 중앙 집중 데이터베이스 시스템

데이터베이스가 **한 곳에 집중**되어 있는 방식입니다. 분산되어 있지 않고 하나의 중앙 서버에 모든 데이터가 모여 있습니다. 범용 컴퓨터(메인프레임)를 중앙에 놓고, 여러 사용자가 단말기를 통해 연결하여 사용하는 전통적인 방식입니다.

- **단일 사용자 시스템**: 하나의 CPU, 하나의 하드디스크, 하나의 운영체제에서 한 사람이 사용하는 시스템입니다. 여러분 집에 있는 개인 PC가 대표적인 예입니다.
- **다수 사용자 시스템**: 훨씬 많은 사용자가 동시에 접속하는 대규모 시스템입니다. 구글 서버, 네이버 서버 같은 것들이 이에 해당합니다.

### 클라이언트-서버 시스템

인터넷 환경에서 가장 흔히 볼 수 있는 구조입니다. 기능이 **전처리(Front-end)**와 **후처리(Back-end)**로 나뉘어 있습니다.

| 구분 | 전처리 기능 (클라이언트) | 후처리 기능 (서버) |
|---|---|---|
| **역할** | 사용자와의 상호작용 | 데이터 관리 및 처리 |
| **구체적 기능** | 화면 표시, 입력 처리, 출력 표시 | DB 관리, 질의 최적화, 동시성 제어, 회복 |
| **비유** | 은행 창구 (고객 응대) | 은행 금고 + 전산실 (돈 관리, 시스템 운영) |

마치 **레스토랑**과 같습니다. 홀(클라이언트)에서는 손님과 소통하고 주문을 받으며, 주방(서버)에서는 실제 음식을 만들고 재료를 관리하는 것이죠.

### 병렬 데이터베이스 시스템

**여러 개의 CPU를 고속 네트워크로 연결**하여 동시에 빠르게 처리하는 시스템입니다. 슈퍼컴퓨터가 대표적인 예이며, 수천 개의 CPU가 연결되어 대량의 데이터를 병렬로 처리합니다.

병렬 데이터베이스 시스템의 구조는 네 가지로 나뉩니다:

**1. 공유 메모리 구조 (Shared Memory)**

여러 CPU가 **하나의 메모리를 공유**하는 방식입니다.

- **장점**: 메모리에 데이터가 있으면 모든 CPU에서 바로 접근 가능. 데이터를 소프트웨어로 이동시킬 필요가 없습니다.
- **단점**: 모든 CPU가 하나의 메모리로 몰리기 때문에 **메모리에 병목 현상**이 발생합니다. CPU를 아무리 많이 추가해도 메모리가 병목이 되어 성능 향상에 한계가 있습니다.
- **적합한 경우**: 병렬 정도가 **낮은** 경우

**2. 공유 디스크 구조 (Shared Disk)**

각 CPU가 **자체 메모리를 보유**하고, **디스크만 공유**하는 방식입니다.

- **장점**: 메모리 병목 현상은 발생하지 않습니다.
- **단점**: 이번에는 **디스크에서 병목 현상**이 발생합니다. CPU 간에 데이터를 주고받을 때 성능이 떨어집니다.

**3. 무공유 구조 (Shared Nothing)**

각 CPU가 **자체 메모리와 자체 디스크를 모두 보유**하고, **네트워크로만 연결**하는 방식입니다.

- **장점**: 메모리 병목도, 디스크 병목도 발생하지 않습니다. 간섭이 전혀 없습니다.
- **특징**: 각자 자기 것을 독립적으로 사용하므로 확장성이 가장 좋습니다.

**4. 계층 구조 (Hierarchical)**

위의 여러 구조를 **복합적으로 조합**한 방식입니다. 예를 들어, 메모리를 공유하는 그룹 여러 개를 다시 네트워크로 묶어서 전체적으로는 무공유처럼 운영하는 식입니다.

| 구조 | 메모리 | 디스크 | 병목 구간 | 확장성 |
|---|---|---|---|---|
| 공유 메모리 | 공유 | 공유 | **메모리** | 낮음 |
| 공유 디스크 | 개별 | 공유 | **디스크** | 중간 |
| 무공유 | 개별 | 개별 | **없음** | 높음 |
| 계층 | 복합 | 복합 | 구조에 따라 다름 | 유연함 |

### 분산 데이터베이스 시스템

데이터를 **여러 지역(사이트)에 분산**시켜 놓고, **네트워크로 연결**하여 사용하는 방식입니다. 각 지역에 있는 사이트들은 **자체 제어권을 가지고 독자적으로 관리**됩니다.

- **장점**: 데이터가 중복되어 있어 **가용성(Availability)**이 좋습니다. 한 곳이 고장 나도 다른 곳에서 서비스를 계속할 수 있으므로 **신뢰성**도 높습니다.
- **단점**: 시스템이 **복잡**하고, 구축과 운영에 **비용이 많이** 들며, **오류가 잠재**되어 있을 수 있습니다.

마치 **전국에 지점을 둔 은행**과 같습니다. 서울 지점, 부산 지점, 대구 지점이 각각 자체 시스템을 운영하면서 네트워크로 연결되어 있어, 한 지점이 멈춰도 다른 지점에서 서비스가 가능합니다.

---

## ⚠️ 주의사항과 실전 팁

### 시험에서 자주 나오는 함정

:::danger 독립성의 방향을 꼭 확인하세요!
독립성은 항상 **"하위 단계가 변경될 때 → 상위 단계가 영향받지 않는다"**입니다.
- ✅ "내부 스키마가 변경되어도 개념 스키마는 그대로" → 물리적 독립성 맞음
- ✅ "개념 스키마가 변경되어도 외부 스키마는 그대로" → 논리적 독립성 맞음
- ❌ "외부 스키마가 변경되어도 개념 스키마는 그대로" → 이것은 독립성의 정의가 **아닙니다**
:::

### 스키마 개수 기억법

:::tip 외부-개념-내부 스키마 개수
- **외부 스키마**: **여러 개** (사용자마다 다르니까!)
- **개념 스키마**: **1개** (조직 전체를 하나로 통합하니까!)
- **내부 스키마**: **1개** (저장 장치는 하나니까!)

"여-하-하"로 외우세요: **여**러 개 - **하**나 - **하**나
:::

### 절차적 vs 비절차적 DML 구분 요령

:::tip 쉽게 외우는 방법
- **절차적**: "길 안내를 처음부터 끝까지 다 말해줘야 하는 것" → 한 번에 하나씩, 저급, 내장만
- **비절차적**: "목적지만 말하면 네비게이션이 알아서 가는 것" → 한꺼번에 여러 개, 고급, 독자 사용 가능

SQL은 비절차적 언어입니다. "학생 테이블에서 점수 80 이상인 학생 보여줘"라고만 하면, DBMS가 알아서 최적의 경로로 찾아줍니다!
:::

### 데이터 사전 관련 주의사항

- 데이터 사전(시스템 카탈로그)은 SQL로 **조회(SELECT)**는 할 수 있지만, **직접 수정(INSERT, UPDATE, DELETE)**은 할 수 없습니다.
- 일반 테이블을 DDL로 생성·변경·삭제하면 DBMS가 **자동으로** 데이터 사전에 반영합니다.
- 데이터 디렉터리는 **시스템만** 접근할 수 있고, 사용자는 접근할 수 없습니다.

---

## 📌 핵심 정리

- **3단계 스키마 구조**는 데이터 독립성을 확보하기 위해 데이터베이스를 외부·개념·내부 세 단계로 나눈 표준 이론이다
- **데이터 독립성**이란 하위 단계 스키마가 변경되어도 상위 단계 스키마에 영향을 주지 않는 능력이다
- **논리적 독립성**: 논리적 구조(개념 스키마)가 변경되어도 응용 프로그램(외부 스키마)은 그대로 사용 가능
- **물리적 독립성**: 물리적 구조(내부 스키마)가 변경되어도 논리적 구조와 프로그램은 그대로 사용 가능
- **스키마** = 구조(설계도), **인스턴스** = 실제 값(데이터)
- **외부 스키마**: 사용자 개인 관점, 여러 개 존재, 서브 스키마 = 뷰(View)
- **개념 스키마**: 조직 전체 관점, 1개만 존재, 그냥 "스키마"라 하면 이것을 의미
- **내부 스키마**: 저장 장치 관점, 1개만 존재, 물리적 저장 방식 명세
- **데이터 사전(시스템 카탈로그)**: 메타데이터 저장소, 사용자 조회 가능, 직접 수정 불가
- **데이터 디렉터리**: 사전 접근 경로 관리, 시스템만 접근 가능
- **DDL(정의어)**: CREATE, ALTER, DROP — 구조를 만들고 변경하고 삭제
- **DML(조작어)**: SELECT, INSERT, UPDATE, DELETE — 데이터를 검색·삽입·수정·삭제
- **DCL(제어어)**: GRANT, REVOKE — 보안, 무결성, 회복, 병행 제어 담당
- **DBMS** ⊂ **DBS**: 데이터베이스 관리 시스템은 데이터베이스 시스템의 일부이다
- 병렬 DB 구조: 공유 메모리(메모리 병목) / 공유 디스크(디스크 병목) / 무공유(병목 없음) / 계층(복합)
- 분산 DB 시스템: 가용성·신뢰성 높지만, 복잡하고 비용이 많이 들며 오류 잠재 가능성 있음

작성일: 2026-02-20