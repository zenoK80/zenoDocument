---
title: "스키마 간 매핑과 논리적·물리적 구조의 관계"
description: "스키마 간 매핑과 논리적·물리적 구조의 관계에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/three-level-database-architecture/5-schema-mapping-and-relationship"
sidebar_label: "스키마 매핑"
date: "2026-02-20"
---

## 🎯 3단계 데이터베이스와 스키마 매핑이란?

데이터베이스를 공부하다 보면 **"3단계 데이터베이스 구조"**라는 표현을 자주 만나게 됩니다. 이름 그대로 데이터베이스를 **세 개의 단계(계층)**로 나누어 바라보는 이론인데요, 각 단계는 **외부 스키마**, **개념 스키마**, **내부 스키마**라는 세 가지 스키마(구조)로 구성됩니다.

그리고 이 세 스키마 사이에는 서로를 연결해주는 **매핑(Mapping, 대응 관계)**이 존재합니다. 마치 같은 건물을 **입주민 시점(외부)**, **건물 설계도 시점(개념)**, **철근·배관 시점(내부)**으로 바라보는 것과 비슷합니다. 보는 관점은 다르지만 결국 **같은 하나의 건물**을 가리키고 있으므로, 서로 어떤 부분이 어떤 부분에 해당하는지 **대응(매핑)** 정보가 필요한 것이죠.

> **핵심 한 줄 요약:** 3단계 데이터베이스의 스키마 매핑이란, 외부 ↔ 개념 ↔ 내부 스키마 사이를 **연결·변환**해 주는 대응 관계이며, 이것이 바로 **데이터 독립성**을 실현하는 열쇠입니다.

---

## 🤔 왜 스키마를 세 단계로 나누고, 매핑이 필요한가?

### 파일 시스템 시절의 고통

DBMS가 등장하기 전에는 **파일 시스템**으로 데이터를 관리했습니다. 이때 가장 큰 문제 두 가지가 **중복성**과 **종속성**이었습니다.

- **종속성**: 파일의 구조(자료 구조)가 조금만 바뀌어도, 그 파일을 사용하는 **응용 프로그램 전체를 수정**해야 했습니다. 마치 냉장고 선반 위치를 바꾸면 요리 레시피 책을 전부 다시 써야 하는 것처럼 비효율적이죠.
- **중복성**: 같은 데이터가 여러 파일에 흩어져 있어 일관성 유지가 어려웠습니다.

### DBMS의 궁극적 목표 — 데이터 독립성

DBMS가 갖는 **궁극적 목표**는 바로 **"응용 프로그램이 데이터에 종속되지 않는 것"**, 즉 **데이터 독립성(Data Independence)**입니다.

- 자료 구조나 저장 방식이 바뀌어도 **프로그램은 수정 없이 그대로** 사용할 수 있어야 합니다.
- 이것을 정확히 표현하면, **"상위 단계 스키마 정의에 영향을 주지 않고, 하위 단계 스키마 정의를 수정할 수 있게 하는 능력"**입니다.

:::info 상위·하위 단계 이해하기
3단계를 위에서 아래로 번호를 매기면 ① 외부 스키마 → ② 개념 스키마 → ③ 내부 스키마 순서입니다. **③(하위)이 바뀌어도 ②(상위)는 그대로**, **②(하위)가 바뀌어도 ①(상위)는 그대로** 쓸 수 있는 것이 독립성입니다. 반대로 "응용 프로그램(상위)을 바꿨을 때 자료 구조(하위)가 영향받지 않는 것"은 독립성이 **아닙니다**. 항상 **하위가 변경될 때 상위가 영향받지 않는 방향**으로 따지는 점을 꼭 기억하세요.
:::

이 독립성을 실현하기 위해 **스키마를 세 단계로 분리**하고, 단계 사이를 **매핑(사상, Mapping)**으로 연결한 것이 바로 **ANSI/SPARC 3단계 데이터베이스 구조**입니다.

---

## 📚 스키마와 인스턴스 — 기초 개념 다지기

스키마 간 매핑을 이해하려면, 먼저 **스키마**와 **인스턴스**라는 두 단어를 확실히 구분해야 합니다.

### 스키마(Schema) = 구조

스키마는 데이터베이스의 **구조(틀)**입니다. 마치 건물의 **설계 도면**과 같습니다. 설계 도면에는 방이 몇 개인지, 화장실 위치가 어디인지, 각 방의 크기 제한은 어떤지 등의 정보가 담겨 있죠.

데이터베이스 스키마에는 다음 정보가 포함됩니다:

| 구성 요소 | 설명 | 예시 |
|---|---|---|
| **개체(Entity)** | 데이터로 표현하려는 대상 | 학생 테이블, 교수 테이블 |
| **속성(Attribute)** | 개체가 가진 특성 | 학번, 이름, 점수 |
| **관계(Relationship)** | 개체 간의 연결 | 학생 ↔ 교수 : "지도" 관계 |
| **제약 조건(Constraint)** | 데이터가 지켜야 할 규칙 | 점수는 0~100 사이만 가능 |

이 모든 정보가 **컴파일**되어 **데이터 사전(Data Dictionary)**에 **메타데이터(데이터에 대한 데이터)** 형태로 저장됩니다.

### 인스턴스(Instance) = 실제 값

인스턴스는 **어느 특정 순간에 데이터베이스에 저장되어 있는 실제 정보(값)**입니다. 설계 도면이 스키마라면, 그 건물에 **실제로 살고 있는 사람들과 가구 배치**가 인스턴스에 해당합니다.

```sql
-- 스키마(구조) 예시: 학생 테이블의 틀
CREATE TABLE 학생 (
    학번 INT PRIMARY KEY,     -- 학번은 정수형, 기본키
    이름 VARCHAR(50),          -- 이름은 가변 문자열
    점수 INT CHECK (점수 >= 0 AND 점수 <= 100)  -- 점수 제약 조건
);

-- 인스턴스(실제 값) 예시: 테이블에 들어간 데이터
-- 학번: 20001, 이름: '홍길동', 점수: 80
INSERT INTO 학생 VALUES (20001, '홍길동', 80);
```

:::tip 스키마 vs 인스턴스 한눈에 비교
- **스키마**: "학생 테이블에는 학번·이름·점수 칼럼이 있고, 점수는 0~100이어야 한다" → **구조·규칙**
- **인스턴스**: "학번 20001, 이름 홍길동, 점수 80" → **실제 데이터 값**
:::

---

## 🏗️ 3단계 스키마 구조 — 외부·개념·내부

데이터베이스의 구조(스키마)를 **어떤 관점으로 보느냐**에 따라 세 가지로 나뉩니다. 같은 데이터베이스를 보는 **렌즈(관점)**가 세 개라고 생각하면 됩니다.

### 1️⃣ 외부 스키마 (External Schema) — 사용자 개인의 관점

외부 스키마는 **개별 사용자(또는 응용 프로그램)가 보는 데이터 구조**입니다. 전체 데이터베이스의 **일부분만 골라서** 보여주기 때문에 **서브 스키마(Sub Schema)**라고도 부릅니다.

**은행 계좌 테이블** 예시로 이해해 봅시다:

- **입금 담당자**는 계좌번호·입금액·입금일자만 봅니다 → 입금 뷰(View)
- **출금 담당자**는 계좌번호·출금액·잔액만 봅니다 → 출금 뷰
- **이체 담당자**는 보내는계좌·받는계좌·이체금액을 봅니다 → 이체 뷰

이처럼 **사용자마다 필요한 정보가 다르기 때문에** 외부 스키마는 **여러 개 존재**합니다. 마치 같은 뷔페에서 사람마다 **자기 접시에 다른 음식을 담아오는 것**과 비슷합니다.

```sql
-- 외부 스키마 예시: 입금 담당자를 위한 뷰
CREATE VIEW 입금_뷰 AS
SELECT 계좌번호, 입금액, 입금일자  -- 필요한 칼럼만 선택
FROM 은행계좌;                     -- 전체 테이블에서 부분만 추출

-- 외부 스키마 예시: 출금 담당자를 위한 뷰
CREATE VIEW 출금_뷰 AS
SELECT 계좌번호, 출금액, 잔액      -- 다른 칼럼 조합
FROM 은행계좌;
```

### 2️⃣ 개념 스키마 (Conceptual Schema) — 조직 전체의 관점

개념 스키마는 **기관·조직 전체 차원에서 통합한 하나의 데이터 구조**입니다. 우리가 흔히 그냥 **"스키마"**라고 부르면 **개념 스키마**를 가리킵니다. **하나만 존재**합니다.

위 은행 예시에서는 **은행 계좌 테이블 전체**가 개념 스키마에 해당합니다. 여기에는 개체·속성·관계·제약 조건·접근 권한·보안·무결성 규칙 등 **모든 정보**가 포함됩니다.

개념 스키마는 **조직 논리 단계**라고도 표현합니다. 마치 **학교 전체의 교육과정표**와 같습니다. 학생 개인은 자기 시간표(외부 스키마)만 보지만, 학교 행정실에는 전체 교육과정(개념 스키마)이 하나로 정리되어 있는 것이죠.

### 3️⃣ 내부 스키마 (Internal Schema) — 저장 장치의 관점

내부 스키마는 **물리적 저장 장치(하드디스크) 관점에서의 데이터 구조**입니다. 역시 **하나만 존재**합니다.

여기에는 다음과 같은 물리적 정보가 포함됩니다:

- 실제 저장될 **내부 레코드 형식** (데이터가 어떤 바이트 구조로 저장되는가)
- **인덱스(Index, 색인)** 가 있는지, 어떤 칼럼에 설정되어 있는지
- 데이터 항목의 **표현 방식** (INTEGER인지, VARCHAR인지, DATE인지)
- 데이터의 **물리적 저장 순서**

마치 도서관에서 책의 **내용(개념 스키마)**은 같지만, 실제로 책이 **어느 서가 몇 번째 칸에 꽂혀 있는지(내부 스키마)**는 별개의 정보인 것과 같습니다.

:::warning 내부 스키마 ≠ 물리적 단계
내부 스키마는 DBMS 수준에서 저장 방식을 기술하는 것이고, **실제 하드디스크에 물리적으로 기록하는 것은 운영체제(OS)**가 담당합니다. 사용자가 DBMS를 통해 저장 명령을 내리면, DBMS가 내부 스키마를 참고하여 운영체제에 권한을 넘기고, OS가 실제 디스크에 기록합니다. 따라서 내부 스키마는 물리적 단계보다 **한 단계 위**에 존재합니다.
:::

### 📊 세 스키마 비교 정리

| 구분 | 외부 스키마 | 개념 스키마 | 내부 스키마 |
|---|---|---|---|
| **관점** | 사용자 개인 | 조직 전체 | 저장 장치 |
| **개수** | 여러 개 | 1개 | 1개 |
| **별명** | 서브 스키마, 뷰 | 그냥 "스키마" | 저장 스키마 |
| **포함 내용** | 사용자별 필요 데이터 | 개체·속성·관계·제약조건 | 레코드 형식·인덱스·데이터 타입 |
| **은행 예시** | 입금 뷰, 출금 뷰, 이체 뷰 | 은행 계좌 테이블 전체 | 저장 형식·인덱스·물리 순서 |

---

## 🔗 스키마 간 매핑(사상) — 세 단계를 연결하는 다리

### 매핑이란 무엇인가?

**매핑(Mapping, 사상)**이란 한쪽 스키마의 요소가 다른 쪽 스키마의 어떤 요소에 **대응(연결)되는지를 정의하는 것**입니다. 마치 한국어-영어 사전에서 "사과 → apple"이라고 대응시켜 놓은 것처럼, 외부 스키마의 칼럼이 개념 스키마의 어떤 칼럼에 해당하는지, 개념 스키마의 테이블이 내부 스키마에서 어떤 저장 형식으로 대응되는지를 정의합니다.

> **왜 매핑이 필요한가?** 하나의 데이터베이스를 세 관점으로 나누어 보기 때문에, "내가 외부 스키마에서 보는 '입금액' 칼럼은 실제 개념 스키마의 어떤 칼럼인지?", "개념 스키마의 '은행계좌' 테이블은 하드디스크에 어떤 형태로 저장되는지?" 라는 **대응 정보**가 반드시 있어야 세 단계가 유기적으로 작동할 수 있습니다.

### 세 가지 인터페이스(매핑 지점)

3단계 구조에서는 **세 가지 인터페이스(접점)**가 존재합니다:

| 인터페이스 | 연결 대상 | 역할 |
|---|---|---|
| **사용자 인터페이스** | 사용자 ↔ 외부 스키마 | 사용자가 질의어·응용 프로그램을 통해 외부 스키마에 접근 |
| **응용 인터페이스 (외부/개념 매핑)** | 외부 스키마 ↔ 개념 스키마 | 사용자의 부분적 뷰를 전체 논리 구조로 변환 |
| **저장 인터페이스 (개념/내부 매핑)** | 개념 스키마 ↔ 내부 스키마 | 논리적 구조를 물리적 저장 형태로 변환 |

이 매핑 정보는 모두 **데이터 사전(Data Dictionary)**에 컴파일되어 저장됩니다.

### 🔄 외부/개념 매핑 (외부 스키마 ↔ 개념 스키마)

외부/개념 매핑은 **사용자가 보는 부분적인 뷰(외부 스키마)**와 **전체 테이블(개념 스키마)** 사이의 대응 관계입니다.

```sql
-- ✅ 올바른 예시: 외부/개념 매핑이 정상적으로 작동하는 경우
-- 개념 스키마(전체 테이블)
CREATE TABLE 은행계좌 (
    계좌번호 VARCHAR(20) PRIMARY KEY,  -- 계좌번호
    고객이름 VARCHAR(50),              -- 고객 이름
    잔액 INT,                          -- 현재 잔액
    입금액 INT,                        -- 최근 입금액
    출금액 INT,                        -- 최근 출금액
    입금일자 DATE                      -- 입금 날짜
);

-- 외부 스키마(입금 담당자 뷰)
CREATE VIEW 입금_뷰 AS
SELECT 계좌번호, 입금액, 입금일자    -- 전체 6개 칼럼 중 3개만 매핑
FROM 은행계좌;
```

위 코드에서 `입금_뷰`의 `계좌번호`는 `은행계좌` 테이블의 `계좌번호`에 매핑됩니다. `입금액`은 `은행계좌`의 `입금액`에, `입금일자`는 `은행계좌`의 `입금일자`에 대응됩니다. 이 대응 정보가 바로 **외부/개념 매핑**입니다.

```sql
-- ❌ 잘못된 이해: 매핑 없이 외부 스키마를 직접 만들려는 경우
-- 아래처럼 별도 테이블을 만들면 매핑이 아니라 데이터 중복이 됨
CREATE TABLE 입금_테이블 (
    계좌번호 VARCHAR(20),
    입금액 INT,
    입금일자 DATE
);
-- 이렇게 하면 은행계좌와 입금_테이블에 같은 데이터가 중복 저장됨!
-- 외부 스키마는 별도 테이블이 아니라, 원본을 "바라보는 창문(뷰)"임
```

:::note 외부/개념 매핑이 독립성과 어떻게 연결되나요?
개념 스키마(전체 테이블)에 새로운 칼럼이 추가되거나 구조가 변경되더라도, 외부/개념 매핑만 적절히 수정하면 **외부 스키마(사용자 뷰)는 변경하지 않아도** 됩니다. 이것이 바로 **논리적 데이터 독립성**입니다.
:::

### 🔄 개념/내부 매핑 (개념 스키마 ↔ 내부 스키마)

개념/내부 매핑은 **논리적 테이블 구조(개념 스키마)**와 **물리적 저장 형태(내부 스키마)** 사이의 대응 관계입니다.

예를 들어, 개념 스키마에서 `잔액`이라는 칼럼이 논리적으로 정의되어 있다면, 내부 스키마에서는 이것이 **4바이트 정수(INT)로 저장**되고, **B-트리 인덱스**가 걸려 있으며, **디스크의 특정 블록 위치**에 기록된다는 물리적 정보가 매핑됩니다.

```sql
-- 개념 스키마 수준: 논리적으로 정의된 테이블
-- 사용자는 이 수준만 이해하면 됨
SELECT 잔액 FROM 은행계좌 WHERE 계좌번호 = 'A001';

-- 내부 스키마 수준 (의사 코드로 표현)
-- DBMS 내부에서 실제로 일어나는 일:
-- 1. 인덱스(B-tree)에서 'A001' 키 검색
-- 2. 해당 레코드가 저장된 디스크 블록 번호 확인 (예: Block #1542)
-- 3. 블록 내에서 잔액 필드 오프셋 위치 계산 (예: 바이트 16~19)
-- 4. 4바이트 정수값 읽어서 반환
```

:::note 개념/내부 매핑이 독립성과 어떻게 연결되나요?
하드디스크를 교체하거나, 인덱스 구조를 B-트리에서 해시(Hash)로 바꾸는 등 **물리적 저장 방식(내부 스키마)**이 변경되더라도, 개념/내부 매핑만 수정하면 **개념 스키마(논리적 테이블)와 외부 스키마(사용자 뷰)는 그대로** 사용할 수 있습니다. 이것이 바로 **물리적 데이터 독립성**입니다.
:::

---

## 🛡️ 논리적 독립성과 물리적 독립성 — 매핑이 지켜주는 것

### 논리적 데이터 독립성

**논리적 데이터 독립성**은 **사용자 관점의 독립성**입니다. 그림으로 표현하면:

```
사용자 → [응용 프로그램] → [데이터베이스(논리적 구조)] → [하드디스크]
                                    ↑
                              여기가 변경되어도
                    응용 프로그램은 영향받지 않는 것!
```

- **핵심**: 데이터베이스의 **논리적 구조(개념 스키마)**가 변경되어도, **응용 프로그램(외부 스키마)**은 수정 없이 그대로 사용할 수 있는 능력
- **외부/개념 매핑**이 이 독립성을 보장해 줍니다

실생활 비유로 설명하면, 마트에서 **상품 진열 위치(논리적 구조)**가 바뀌어도 **장바구니 앱의 쇼핑 목록(외부 스키마)**은 바꿀 필요가 없는 것과 같습니다. 앱은 "우유를 산다"는 정보만 알면 되지, 우유가 3번 통로에서 5번 통로로 옮겨졌는지는 신경 쓸 필요가 없으니까요.

### 물리적 데이터 독립성

**물리적 데이터 독립성**은 **하드웨어(저장 장치) 관점의 독립성**입니다.

```
사용자 → [응용 프로그램] → [데이터베이스(논리적 구조)] → [하드디스크]
                                                              ↑
                                                     여기가 변경되어도
                                  데이터베이스 구조와 프로그램은 영향받지 않는 것!
```

- **핵심**: **물리적 저장 구조(내부 스키마)**가 변경되어도, **논리적 구조(개념 스키마)와 응용 프로그램(외부 스키마)**은 수정 없이 그대로 사용할 수 있는 능력
- **개념/내부 매핑**이 이 독립성을 보장해 줍니다

**왜 물리적 독립성이 필요할까요?** 시스템의 **성능 향상**을 위해서입니다. 집 컴퓨터가 느려지면 하드디스크를 SSD로 바꾸거나, CPU·메모리를 업그레이드하죠. 기업 서버도 마찬가지입니다. 하드웨어를 교체할 때마다 프로그램과 테이블 구조를 전부 다시 만들어야 한다면 엄청난 비용이 들 것입니다.

### 논리적 구조와 물리적 구조의 매핑 관계

여기서 반드시 이해해야 할 점이 있습니다. 데이터베이스가 **논리적인 것 따로, 물리적인 것 따로** 두 개가 존재하는 것이 **아닙니다**. **하나의 데이터베이스**를 바라보는 관점이 다를 뿐입니다.

- **사용자가 보는 관점** → 논리적 관점 (테이블, 칼럼, 관계로 이해)
- **저장 장치가 보는 관점** → 물리적 관점 (바이트, 블록, 인덱스로 이해)

따라서 논리적 구조와 물리적 구조 사이에는 **매핑(대응)**이 반드시 존재해야 합니다. 사용자가 화면에서 데이터를 변경하면, 하드디스크에도 당연히 반영되어야 하니까요. 이 매핑 능력이 있기 때문에 한쪽을 바꿔도 다른 쪽에 영향을 주지 않을 수 있는 것입니다.

| 구분 | 논리적 독립성 | 물리적 독립성 |
|---|---|---|
| **변경되는 것** | 개념 스키마 (논리적 구조) | 내부 스키마 (물리적 구조) |
| **영향받지 않는 것** | 외부 스키마 (응용 프로그램) | 개념 스키마 + 외부 스키마 |
| **담당 매핑** | 외부/개념 매핑 | 개념/내부 매핑 |
| **변경 이유** | 테이블 구조 변경, 칼럼 추가 등 | 성능 향상, 저장 장치 교체 등 |

---

## 🗄️ 데이터 사전과 매핑 정보의 저장

### 데이터 사전(Data Dictionary) = 시스템 카탈로그

스키마 간 매핑 정보는 어디에 저장될까요? 바로 **데이터 사전(Data Dictionary)**입니다. **시스템 카탈로그(System Catalog)**라고도 부릅니다.

데이터 사전에는 다음 정보들이 컴파일되어 저장됩니다:

- **외부 스키마·개념 스키마·내부 스키마**에 대한 정보
- **사용자 인터페이스·응용 인터페이스·저장 인터페이스** 등 매핑에 대한 정보
- **접근 권한·보안·무결성 규칙**에 대한 정보
- **질의 최적화**에 대한 정보

데이터 사전 자체도 **일반 테이블처럼** 구성되어 있기 때문에 SQL로 **검색(조회)** 할 수 있습니다.

```sql
-- ✅ 올바른 사용: 데이터 사전 조회 (읽기만 가능)
-- Oracle 예시: 모든 테이블 목록 조회
SELECT table_name 
FROM user_tables;  -- 데이터 사전 뷰를 SQL로 검색

-- ❌ 잘못된 사용: 데이터 사전에 직접 데이터 삽입/수정/삭제
-- 아래와 같이 직접 INSERT/UPDATE/DELETE 하면 안 됨!
INSERT INTO user_tables VALUES ('임의테이블');  -- 이렇게 하면 오류 발생!
-- 데이터 사전의 내용은 직접 갱신할 수 없음
```

:::danger 데이터 사전은 직접 수정 불가!
데이터 사전에 저장된 메타데이터는 사용자가 INSERT, UPDATE, DELETE 명령으로 **직접 삽입하거나 수정할 수 없습니다**. 사용자가 일반 테이블에 대해 구조를 변경(CREATE, ALTER, DROP)하면, DBMS가 **자동으로** 그 변경 내용을 컴파일하여 데이터 사전에 반영합니다. 이것을 **자기정의(Self-describing)** 특성이라고 합니다. 데이터베이스가 스스로 메타데이터를 만들고, 스스로 저장한다는 뜻입니다.
:::

### 데이터 디렉터리(Data Directory)

**데이터 디렉터리**는 데이터 사전에 **접근하기 위한 경로 정보를 관리하는 시스템**입니다. 운영체제의 탐색기(Explorer)에서 폴더 구조를 통해 파일에 접근하는 것과 비슷한 개념입니다.

| 구분 | 데이터 사전 (카탈로그) | 데이터 디렉터리 |
|---|---|---|
| **관리 대상** | 메타데이터 (스키마·매핑 정보) | 사전 접근 경로 정보 |
| **접근 권한** | 사용자 접근 가능 (읽기만) | 시스템만 접근 가능 |
| **공통점** | 메타데이터를 관리한다는 점은 동일 | 메타데이터를 관리한다는 점은 동일 |

---

## 💡 실제 예시로 전체 흐름 이해하기

### 은행 계좌 시스템 전체 흐름

지금까지 배운 내용을 은행 계좌 시스템 하나로 통합해서 정리해 보겠습니다.

**1단계: 개념 스키마 정의 (DBA가 수행)**

```sql
-- 개념 스키마: 조직 전체 관점의 테이블 구조
CREATE TABLE 은행계좌 (
    계좌번호 VARCHAR(20) PRIMARY KEY,  -- 계좌 고유 식별자
    고객이름 VARCHAR(50) NOT NULL,     -- 고객 이름 (필수)
    잔액 INT DEFAULT 0,               -- 현재 잔액 (기본값 0)
    계좌유형 VARCHAR(10),             -- 보통예금, 적금 등
    개설일자 DATE                     -- 계좌 개설 날짜
);
-- 이 구조 정보가 데이터 사전에 메타데이터로 저장됨
```

**2단계: 외부 스키마 정의 (사용자별 뷰)**

```sql
-- 외부 스키마 1: 입금 담당자 뷰
CREATE VIEW 입금_뷰 AS
SELECT 계좌번호, 고객이름, 잔액
FROM 은행계좌;
-- 매핑: 입금_뷰.계좌번호 → 은행계좌.계좌번호
-- 매핑: 입금_뷰.고객이름 → 은행계좌.고객이름
-- 매핑: 입금_뷰.잔액 → 은행계좌.잔액

-- 외부 스키마 2: 계좌 관리자 뷰
CREATE VIEW 계좌관리_뷰 AS
SELECT 계좌번호, 계좌유형, 개설일자
FROM 은행계좌;
-- 같은 테이블에서 다른 칼럼 조합을 보여줌
```

**3단계: 내부 스키마 (DBMS 내부에서 자동 관리)**

```
-- 내부 스키마 (의사 코드, 실제 SQL이 아닌 개념 설명용)
-- 저장 구조 정의:
--   테이블명: 은행계좌
--   저장 방식: 힙(Heap) 파일
--   인덱스: 계좌번호 칼럼에 B+ 트리 인덱스
--   레코드 크기: 약 94바이트
--     - 계좌번호: VARCHAR(20) → 최대 20바이트
--     - 고객이름: VARCHAR(50) → 최대 50바이트  
--     - 잔액: INT → 4바이트
--     - 계좌유형: VARCHAR(10) → 최대 10바이트
--     - 개설일자: DATE → 8바이트
--   블록 크기: 4KB, 한 블록에 약 40개 레코드 저장
```

**4단계: 매핑을 통한 독립성 확인**

```sql
-- 시나리오: 개념 스키마에 새 칼럼 추가 (논리적 구조 변경)
ALTER TABLE 은행계좌 ADD 전화번호 VARCHAR(15);
-- 개념 스키마가 변경됨!

-- 하지만 기존 외부 스키마(입금_뷰)는 그대로 사용 가능
SELECT * FROM 입금_뷰;  -- 정상 작동! (논리적 독립성)
-- 왜? 입금_뷰는 계좌번호, 고객이름, 잔액만 매핑하고 있으므로
-- 전화번호 칼럼이 추가되어도 영향을 받지 않음
```

```sql
-- 시나리오: 내부 스키마 변경 (인덱스 추가로 물리적 구조 변경)
CREATE INDEX idx_잔액 ON 은행계좌(잔액);
-- 내부 스키마가 변경됨! (새로운 인덱스 구조가 추가)

-- 하지만 개념 스키마와 외부 스키마는 전혀 변경 불필요
SELECT 계좌번호, 잔액 FROM 은행계좌 WHERE 잔액 > 100000;
-- 정상 작동! (물리적 독립성)
-- 인덱스가 추가되어 검색이 빨라졌지만, SQL 문법은 동일
```

---

## 🗣️ 데이터 언어와 사용자 역할

스키마 간 매핑을 실제로 작동시키려면 **데이터 언어**가 필요합니다. 데이터 언어는 세 가지로 나뉩니다.

### 데이터 정의어 (DDL, Data Definition Language)

데이터베이스의 **구조(스키마)를 만들고, 변경하고, 삭제**하는 언어입니다. 주로 **DBA(데이터베이스 관리자)**가 사용합니다.

| 명령어 | 기능 | 예시 |
|---|---|---|
| `CREATE` | 테이블(스키마) 생성 | `CREATE TABLE 학생 (...)` |
| `ALTER` | 테이블(스키마) 변경 | `ALTER TABLE 학생 ADD 전화번호 VARCHAR(15)` |
| `DROP` | 테이블(스키마) 삭제 | `DROP TABLE 학생` |

DDL로 스키마를 정의하거나 수정하면, 그 정보가 **컴파일되어 데이터 사전에 메타데이터로 자동 저장**됩니다.

### 데이터 조작어 (DML, Data Manipulation Language)

데이터를 **검색(SELECT), 삽입(INSERT), 삭제(DELETE), 갱신(UPDATE)**하는 언어입니다. **일반 프로그래머나 사용자**가 가장 많이 사용하는 보편적 명령어입니다.

DML은 다시 두 가지로 나뉩니다:

| 구분 | 절차적 DML | 비절차적 DML |
|---|---|---|
| **명세 방식** | What(무엇을) + How(어떻게) 모두 기술 | What(무엇을)만 기술 |
| **언어 수준** | 저급 언어 | 고급 언어 |
| **독자 사용** | 불가능 (프로그램 내장 필수) | 가능 (독자적으로도 사용 가능) |
| **처리 단위** | 한 번에 레코드 1개 | 한 번에 여러 개 (집합 단위) |
| **사용 방식** | 호스트 프로그램에 삽입 | 독자적 또는 프로그램 삽입 |

:::tip 비절차적 DML의 대표적 예시
우리가 흔히 사용하는 **SQL의 SELECT 문**이 대표적인 비절차적 DML입니다. `SELECT 이름 FROM 학생 WHERE 점수 > 80` 이라고만 쓰면, "점수 80점 초과인 학생의 이름을 달라"는 **무엇(What)**만 명세한 것입니다. 디스크에서 어떻게 읽고, 어떤 순서로 비교하고, 메모리에 어떻게 올리는지 등의 **방법(How)**은 DBMS가 알아서 처리합니다.
:::

### 데이터 제어어 (DCL, Data Control Language)

데이터를 **제어(보안·무결성·회복·병행제어)**하는 언어입니다. 주로 **DBA**가 사용합니다.

- **보안(Security)**: 권한이 없는 사용자의 접근 차단
- **무결성(Integrity)**: 데이터의 정확성·일관성 유지
- **회복(Recovery)**: 장애 발생 시 데이터 복구
- **병행 제어(Concurrency Control)**: 여러 사용자가 동시 접속할 때 충돌 방지

---

## ⚙️ 데이터베이스 시스템 구조 개관

스키마 매핑이 작동하는 **전체 시스템**의 큰 그림을 살펴보겠습니다.

### 데이터베이스 시스템 vs DBMS

| 구분 | DBMS (데이터베이스 관리 시스템) | 데이터베이스 시스템 |
|---|---|---|
| **범위** | 데이터를 관리하는 소프트웨어 | DBMS + DB + 데이터 언어 + 사용자 + DBA + 컴퓨터 **전체** |
| **관계** | 데이터베이스 시스템의 **일부분** | **전체 시스템** |

즉, 데이터베이스 시스템은 **데이터베이스 + DBMS + 데이터 언어 + 사용자 + DBA + 컴퓨터 하드웨어**를 모두 합친 총체적 개념입니다.

### 시스템 구조의 종류

데이터베이스 시스템은 규모와 연결 방식에 따라 여러 구조로 나뉩니다:

**중앙 집중 데이터베이스**: 하나의 중앙 컴퓨터에 데이터베이스가 집중되어 있고, 여러 사용자가 연결해서 사용하는 방식입니다. 범용 컴퓨터 시스템이 대표적인 예시로, 여러 CPU와 공유 메모리가 공동 버스로 연결되어 있습니다.

**클라이언트-서버 시스템**: 인터넷 환경에서 흔히 사용되는 구조입니다. **전처리(Front-end)**는 사용자 화면에 데이터를 보여주고 입력받는 역할을 하고, **후처리(Back-end)**는 데이터베이스 관리·최적화·동시성 제어·회복 등을 담당합니다.

**분산 데이터베이스 시스템**: 데이터가 여러 지역의 사이트에 분산 저장되어 네트워크로 연결된 구조입니다. 각 사이트가 독자적으로 제어권을 가지고 관리합니다. 데이터가 중복 저장되므로 **가용도(Availability)**와 **신뢰성**이 높지만, 구조가 복잡하고 비용이 많이 드는 단점이 있습니다.

**병렬 데이터베이스 시스템**: 여러 처리기(CPU)를 고속 네트워크로 연결하여 대량 데이터를 빠르게 처리하는 구조입니다. 슈퍼컴퓨터가 대표적입니다.

병렬 시스템의 구조는 다시 네 가지로 나뉩니다:

| 구조 | 특징 | 병목 지점 | 장점 |
|---|---|---|---|
| **공유 메모리** | 여러 CPU가 하나의 메모리 공유 | 메모리 | 데이터 이동 없이 모든 처리기 접근 가능 |
| **공유 디스크** | 각 CPU별 개별 메모리, 디스크만 공유 | 디스크 | 메모리 병목 없음 |
| **무공유** | CPU·메모리·디스크 모두 개별, 네트워크만 연결 | 없음 (간섭 없음) | 간섭이나 병목 없음 |
| **계층** | 위 구조들을 복합 결합 | 구조에 따라 다름 | 각 구조의 장점을 결합 |

---

## ⚠️ 주의사항과 실수하기 쉬운 포인트

:::warning 독립성 방향을 헷갈리지 마세요!
데이터 독립성은 항상 **"하위 단계가 변경될 때, 상위 단계가 영향받지 않는 것"**입니다.

- ✅ 맞음: "내부 스키마(물리적 구조)가 변경되어도 개념 스키마는 그대로" → 물리적 독립성
- ✅ 맞음: "개념 스키마(논리적 구조)가 변경되어도 외부 스키마는 그대로" → 논리적 독립성
- ❌ 틀림: "응용 프로그램을 변경해도 자료 구조가 그대로" → 이건 독립성이 **아닙니다!**
:::

:::warning 논리적 vs 물리적 관점 구분
- **논리적(사용자 관점)**: 테이블, 칼럼, 관계, 제약조건 등 사람이 이해하는 수준
- **물리적(하드웨어 관점)**: 바이트, 블록, 인덱스, 저장 순서 등 기계가 이해하는 수준
- 데이터베이스가 "논리적인 것 따로, 물리적인 것 따로" 두 개 있는 게 **아닙니다**. **하나의 DB를 두 가지 관점으로 보는 것**입니다.
:::

:::warning 데이터 사전 vs 일반 테이블
- **일반 테이블**: 사용자가 INSERT, UPDATE, DELETE로 자유롭게 데이터 조작 가능
- **데이터 사전**: SQL로 **조회(SELECT)**만 가능. 직접 INSERT/UPDATE/DELETE **불가능**
- 사전의 내용은 DDL(CREATE, ALTER, DROP) 실행 시 DBMS가 **자동으로 반영**
:::

:::tip 스키마와 인스턴스를 항상 구분하세요
시험이나 면접에서 가장 기본적으로 묻는 질문입니다.
- **스키마** = 구조, 틀, 설계도 (시간이 지나도 잘 바뀌지 않음)
- **인스턴스** = 실제 값, 데이터 (시시각각 바뀜)

"학생 테이블에 학번·이름·점수 칼럼이 있다" → **스키마**  
"학번 20001, 이름 홍길동, 점수 80" → **인스턴스**
:::

:::tip 외부 스키마의 핵심은 "뷰(View)"
외부 스키마를 이해하는 가장 쉬운 방법은 SQL의 VIEW를 떠올리는 것입니다. 전체 테이블(개념 스키마)에서 필요한 부분만 골라 **창문(View)**처럼 보여주는 것이 외부 스키마입니다. 별도의 테이블을 새로 만드는 것이 아니라, 원본 테이블을 **참조**하는 것임을 꼭 기억하세요.
:::

---

## 📌 핵심 정리

- **3단계 데이터베이스 구조**는 외부 스키마·개념 스키마·내부 스키마로 나뉘며, **데이터 독립성**을 실현하기 위한 표준 이론이다
- **스키마**는 데이터베이스의 구조(틀)이고, **인스턴스**는 특정 시점의 실제 데이터 값이다
- **외부 스키마**는 사용자 개인의 관점(뷰)으로 **여러 개** 존재하고, **개념 스키마**는 조직 전체 관점으로 **1개**, **내부 스키마**는 저장 장치 관점으로 **1개** 존재한다
- **스키마 간 매핑**은 세 단계 사이를 연결하는 대응 관계이며, 외부/개념 매핑과 개념/내부 매핑이 있다
- **논리적 독립성**: 개념 스키마(논리적 구조)가 변경되어도 외부 스키마(응용 프로그램)에 영향 없음 → 외부/개념 매핑이 보장
- **물리적 독립성**: 내부 스키마(물리적 구조)가 변경되어도 개념 스키마와 외부 스키마에 영향 없음 → 개념/내부 매핑이 보장
- **독립성 방향**은 항상 "하위 단계 변경 → 상위 단계 영향 없음"이다 (반대가 아님!)
- **데이터 사전(시스템 카탈로그)**에 스키마·매핑·권한 등 모든 메타데이터가 저장되며, 직접 수정 불가(DBMS가 자동 반영)
- **데이터 디렉터리**는 사전 접근 경로를 관리하며 시스템만 접근 가능하다
- 데이터 언어는 **DDL(정의어)**, **DML(조작어)**, **DCL(제어어)** 세 가지로 나뉜다
- **물리적 독립성**이 필요한 핵심 이유는 **시스템 성능 향상**을 위한 하드웨어 교체 시 프로그램을 수정하지 않기 위해서이다

---

작성일: 2026-02-20