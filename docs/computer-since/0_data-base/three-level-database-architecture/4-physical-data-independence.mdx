---
title: "물리적 데이터 독립성"
description: "물리적 데이터 독립성에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/three-level-database-architecture/4-physical-data-independence"
sidebar_label: "물리적 독립성"
date: "2026-02-20"
---

## 🎯 물리적 데이터 독립성이란 무엇인가?

여러분이 스마트폰에 저장된 사진을 떠올려 보세요. 사진은 갤러리 앱에서 날짜별·앨범별로 깔끔하게 보입니다. 그런데 어느 날 스마트폰의 **내장 저장소(하드웨어)를 더 큰 용량으로 교체**했다고 가정해 봅시다. 저장소를 바꿨다고 해서 갤러리 앱 화면이 갑자기 달라지거나, 사진을 보는 방식이 변하지는 않죠? 앱은 그대로, 사진 목록도 그대로입니다. 바뀐 것은 오직 **물리적인 저장 장치**뿐입니다.

이것이 바로 **물리적 데이터 독립성(Physical Data Independence)** 의 핵심 개념입니다.

> **물리적 데이터 독립성이란?**
> 데이터베이스의 **물리적 구조(저장 장치, 저장 방식, 인덱스 등)를 변경하더라도** 데이터베이스의 논리적 구조(테이블, 관계 등)나 응용 프로그램을 **수정 없이 그대로 사용할 수 있는 능력**을 말합니다.

좀 더 정확하게 표현하면, **하위 단계인 내부 스키마(물리적 저장 구조)가 변경되더라도 상위 단계인 개념 스키마(논리적 구조)와 외부 스키마(사용자 관점)에 영향을 주지 않는 것**입니다. 여기서 "스키마"란 데이터베이스의 구조(뼈대)를 의미하는데, 뒤에서 자세히 설명하겠습니다.

:::info 논리적 vs 물리적, 관점의 차이
- **논리적(Logical)** = **사용자 관점**. 사용자가 데이터를 어떻게 바라보고 사용하는지에 초점을 맞춥니다.
- **물리적(Physical)** = **하드웨어(저장 장치) 관점**. 데이터가 하드 디스크에 실제로 어떻게 저장되고 관리되는지에 초점을 맞춥니다.

하나의 데이터베이스를 두 가지 관점에서 바라보는 것이지, 데이터베이스가 두 개 있는 것이 아닙니다.
:::

---

## 🤔 왜 물리적 데이터 독립성이 필요한가?

### 파일 시스템의 한계: 종속성 문제

데이터베이스가 등장하기 이전, 데이터는 **파일 시스템**으로 관리되었습니다. 파일 시스템에서는 프로그램이 데이터 파일의 구조에 **종속(의존)** 되어 있었습니다. 마치 퍼즐 조각처럼 딱 맞물려 있어서, 파일 구조를 조금이라도 바꾸면 프로그램도 같이 수정해야 했습니다.

예를 들어, 은행 계좌 데이터를 저장하는 파일의 **저장 위치나 저장 형식**을 바꿨다고 합시다. 파일 시스템에서는 이 파일을 읽는 **모든 프로그램을 일일이 수정**해야 했습니다. 프로그램이 10개면 10개 전부, 100개면 100개 전부 수정해야 합니다. 이것이 바로 **종속성(Dependency)** 의 문제입니다.

| 구분 | 파일 시스템 | 데이터베이스 시스템 |
|------|-----------|-------------------|
| 저장 구조 변경 시 | 프로그램도 **반드시 수정** 필요 | 프로그램 **수정 불필요** |
| 독립성 | ❌ 종속적 | ✅ 독립적 |
| 유지보수 비용 | 높음 | 낮음 |
| 성능 개선 유연성 | 매우 낮음 | 높음 |

### 성능 향상을 위한 현실적 필요

여러분 집의 컴퓨터를 생각해 보세요. 컴퓨터가 느려지면 우리는 무엇을 하나요? **하드웨어를 업그레이드**합니다. CPU를 더 빠른 것으로 바꾸고, 메모리를 추가하고, HDD를 SSD로 교체합니다. 기업의 데이터베이스 서버도 마찬가지입니다.

데이터가 폭발적으로 증가하면, 또는 사용자가 급격히 늘어나면, **저장 장치를 더 빠르고 큰 것으로 교체**해야 합니다. 이때 물리적 데이터 독립성이 보장되지 않는다면 어떻게 될까요?

- 하드 디스크를 바꿨더니 **모든 응용 프로그램을 다시 작성**해야 합니다.
- 인덱스(색인)를 추가했더니 **기존 프로그램이 작동하지 않습니다.**
- 데이터 저장 형식을 최적화했더니 **논리적 구조까지 뒤틀립니다.**

이런 상황은 현실에서 절대 일어나서는 안 됩니다. 그래서 DBMS(데이터베이스 관리 시스템)는 **물리적 데이터 독립성을 궁극적인 목표 중 하나**로 삼고 있습니다.

> 💡 **핵심 포인트**: 물리적 데이터 독립성은 **시스템 성능 향상을 위해 저장 장치를 변경할 때**, 자료 구조(논리적 구조)와 응용 프로그램을 변경하지 않고 그대로 사용할 수 있게 해주는 능력입니다.

---

## 🏗️ 3단계 데이터베이스 구조와 스키마의 이해

물리적 데이터 독립성을 제대로 이해하려면, 먼저 **3단계 데이터베이스 구조**와 **스키마**라는 개념을 알아야 합니다. 이 두 가지는 물리적 데이터 독립성의 이론적 토대이기 때문입니다.

### 스키마(Schema)란?

**스키마(Schema)** 는 데이터베이스의 **구조(뼈대)** 를 의미합니다. 마치 건물의 **설계도**와 같습니다. 설계도에는 방이 몇 개인지, 어디에 화장실이 있는지, 복도는 어떻게 연결되는지가 그려져 있죠. 하지만 설계도에는 실제로 방 안에 어떤 가구가 놓여 있는지, 누가 살고 있는지는 나오지 않습니다.

스키마도 마찬가지입니다. 스키마에는 다음과 같은 정보가 담겨 있습니다:

- **개체(Entity)**: 테이블 자체. 예를 들어 "학생 테이블", "교수 테이블"
- **속성(Attribute)**: 테이블이 가진 특성. 예를 들어 학번, 이름, 전화번호
- **관계(Relationship)**: 개체 간의 연결. 예를 들어 "학생-교수" 사이의 "지도" 관계, "학생-과목" 사이의 "수강" 관계
- **제약 조건(Constraint)**: 데이터가 지켜야 할 규칙. 예를 들어 "점수는 0~100 사이여야 한다"

이 스키마 정보는 **데이터 정의어(DDL)** 로 만들어지고, 컴파일(번역)되어 **데이터 사전(Data Dictionary)** 이라는 곳에 **메타데이터(데이터에 대한 데이터)** 형태로 저장됩니다.

:::note 스키마 vs 인스턴스
- **스키마(Schema)** = 구조, 설계도. "학생 테이블에는 학번·이름·점수 컬럼이 있다."
- **인스턴스(Instance)** = 실제 값, 실제 데이터. "학번 20001, 이름 홍길동, 점수 85점"

스키마는 잘 바뀌지 않지만, 인스턴스는 데이터가 삽입·삭제·수정될 때마다 수시로 바뀝니다.
:::

### 3단계 데이터베이스 구조

3단계 데이터베이스 구조는 **데이터 독립성을 지키기 위해** 만들어진 표준 이론입니다. 하나의 데이터베이스를 **세 가지 관점(단계)** 으로 나누어 바라봅니다.

| 단계 | 스키마 이름 | 관점 | 개수 | 설명 |
|------|-----------|------|------|------|
| 1단계 | **외부 스키마** | 사용자 개인 관점 | 여러 개 | 사용자마다 다르게 보이는 부분적 구조 |
| 2단계 | **개념 스키마** | 조직 전체 관점 | 1개 | 전체 데이터베이스의 논리적 구조 |
| 3단계 | **내부 스키마** | 저장 장치 관점 | 1개 | 데이터가 실제로 저장되는 물리적 구조 |

**은행 계좌 테이블**을 예로 들어보겠습니다:

- **외부 스키마**: "입금 화면"에서는 계좌번호와 입금액만 보입니다. "출금 화면"에서는 계좌번호, 잔액, 출금액이 보입니다. "이체 화면"에서는 보내는 계좌, 받는 계좌, 이체금액이 보입니다. 이렇게 **사용자마다 다르게 부분적으로** 보여주는 것이 외부 스키마이며, 이를 **뷰(View)** 라고도 부릅니다. 사용자의 요구사항이 다르기 때문에 **여러 개**가 존재합니다.
- **개념 스키마**: 은행 계좌 테이블 그 자체입니다. 계좌번호, 예금주명, 잔액, 계좌유형 등 **모든 정보가 하나로 통합**되어 있습니다. 단순히 "스키마"라고만 부르면 보통 이 개념 스키마를 의미합니다.
- **내부 스키마**: 이 은행 계좌 테이블이 **하드 디스크에 어떤 형식으로 저장되는지**를 정의합니다. 계좌번호는 `INTEGER` 타입인지 `VARCHAR` 타입인지, 인덱스는 어떤 컬럼에 걸려 있는지, 레코드는 어떤 순서로 저장되는지 등의 정보가 여기에 있습니다.

각 단계 사이에는 **사상(매핑, Mapping)** 이 존재합니다:
- **사용자 인터페이스**: 사용자 ↔ 외부 스키마
- **응용 인터페이스(외부/개념 사상)**: 외부 스키마 ↔ 개념 스키마
- **저장 인터페이스(개념/내부 사상)**: 개념 스키마 ↔ 내부 스키마

---

## ⚙️ 물리적 데이터 독립성의 핵심 원리

### 독립성의 방향: 항상 "하위 → 상위"

데이터 독립성에서 가장 중요한 원칙이 있습니다. **독립성은 항상 하위 단계 스키마가 변경되었을 때, 상위 단계 스키마를 그대로 사용할 수 있는지**를 따지는 것입니다.

3단계 구조에서 단계의 상하 관계는 다음과 같습니다:

```
상위  ←  외부 스키마 (사용자 관점)
          ↑
중간  ←  개념 스키마 (조직 전체 관점)
          ↑
하위  ←  내부 스키마 (저장 장치 관점)
```

**물리적 데이터 독립성**은 이 중에서 **내부 스키마(하위)가 변경되었을 때, 개념 스키마(상위)에 영향을 주지 않는 것**을 의미합니다. 그리고 개념 스키마가 영향을 받지 않으니, 그 위의 외부 스키마와 응용 프로그램도 당연히 영향을 받지 않습니다.

:::warning 헷갈리기 쉬운 포인트
"응용 프로그램을 변경했을 때 자료 구조를 그대로 사용할 수 있다" → 이것은 독립성이 **아닙니다!**

독립성은 항상 **하위 단계가 변경될 때 상위 단계가 영향을 받지 않는 것**입니다. 방향을 절대 헷갈리지 마세요.
:::

### 논리적 독립성과 물리적 독립성 비교

데이터 독립성은 크게 **논리적 데이터 독립성**과 **물리적 데이터 독립성** 두 가지로 나뉩니다. 둘의 차이를 명확히 이해해야 합니다.

| 구분 | 논리적 데이터 독립성 | 물리적 데이터 독립성 |
|------|--------------------|--------------------|
| **정의** | 논리적 구조(개념 스키마)를 변경해도 응용 프로그램(외부 스키마)에 영향 없음 | 물리적 구조(내부 스키마)를 변경해도 논리적 구조(개념 스키마)에 영향 없음 |
| **관점** | 사용자 관점 | 하드웨어(저장 장치) 관점 |
| **변경 대상** | 개념 스키마 (테이블 구조 등) | 내부 스키마 (저장 방식, 인덱스 등) |
| **영향 안 받는 대상** | 외부 스키마, 응용 프로그램 | 개념 스키마, 외부 스키마, 응용 프로그램 |
| **관련 사상** | 외부/개념 사상 | 개념/내부 사상 |
| **필요한 상황** | 테이블에 컬럼 추가/삭제 시 | 하드 디스크 교체, 인덱스 변경 시 |

비유로 설명하면 이렇습니다:

- **논리적 독립성**: 도서관에서 책 분류 체계(문학/과학/역사)를 바꿨지만, 도서관 이용자는 여전히 검색 시스템으로 원하는 책을 찾을 수 있는 것
- **물리적 독립성**: 도서관의 **서고(책장) 자체를 새것으로 교체**했지만, 책 분류 체계도 그대로이고 이용자의 검색 방법도 그대로인 것

### 물리적 데이터 독립성이 작동하는 구체적 상황

물리적 데이터 독립성이 실제로 필요한 상황들을 구체적으로 살펴봅시다:

1. **저장 장치 교체**: HDD를 SSD로 교체하는 경우. 데이터의 물리적 위치가 완전히 바뀌지만, 논리적 구조(테이블, 관계)는 그대로 유지됩니다.

2. **인덱스 추가/삭제**: 검색 성능을 높이기 위해 특정 컬럼에 인덱스를 새로 만들거나, 불필요한 인덱스를 제거하는 경우. 물리적 저장 방식이 바뀌지만 테이블 구조 자체는 변하지 않습니다.

3. **데이터 저장 순서 변경**: 레코드가 디스크에 저장되는 물리적 순서를 변경하는 경우. 예를 들어 날짜순으로 저장하던 것을 계좌번호순으로 변경해도, 사용자는 여전히 같은 SQL 쿼리로 데이터를 조회할 수 있습니다.

4. **데이터 파일 재구성**: 데이터 파일의 물리적 구조를 재배치하거나 압축하는 경우에도, 응용 프로그램은 아무 수정 없이 동작합니다.

---

## 💻 실제 예시로 이해하기

### 개념/내부 사상을 통한 물리적 독립성

물리적 데이터 독립성은 **개념 스키마와 내부 스키마 사이의 사상(매핑)** 을 통해 실현됩니다. 내부 스키마가 바뀌면 이 매핑만 수정하면 되고, 개념 스키마와 외부 스키마는 건드리지 않아도 됩니다.

아래 예시로 살펴보겠습니다.

**은행 계좌 테이블의 개념 스키마 (논리적 구조):**

```sql
-- ✅ 개념 스키마: 사용자가 인식하는 테이블 구조
-- 이 구조는 물리적 변경과 무관하게 항상 동일합니다
CREATE TABLE 은행계좌 (
    계좌번호  VARCHAR(20) PRIMARY KEY,  -- 계좌를 식별하는 고유 번호
    예금주명  VARCHAR(50),              -- 계좌 소유자 이름
    잔액      DECIMAL(15, 2),           -- 현재 잔액 (소수점 2자리까지)
    계좌유형  VARCHAR(10),              -- 보통예금, 정기예금 등
    개설일자  DATE                       -- 계좌를 개설한 날짜
);
```

위 코드를 한 줄씩 설명하겠습니다:
- `CREATE TABLE 은행계좌`: "은행계좌"라는 이름의 테이블을 생성하는 명령입니다.
- `계좌번호 VARCHAR(20) PRIMARY KEY`: 계좌번호 컬럼은 최대 20자의 가변 문자열이며, 이 테이블의 기본 키(각 행을 유일하게 식별하는 열)입니다.
- `예금주명 VARCHAR(50)`: 예금주 이름은 최대 50자의 가변 문자열입니다.
- `잔액 DECIMAL(15, 2)`: 잔액은 총 15자리, 소수점 이하 2자리의 숫자 타입입니다.
- `계좌유형 VARCHAR(10)`: 계좌의 종류를 나타내는 최대 10자의 문자열입니다.
- `개설일자 DATE`: 날짜 타입으로 계좌 개설일을 저장합니다.

**내부 스키마 변경 전 (물리적 구조 - 변경 전):**

```sql
-- 내부 스키마 예시 (의사 코드, pseudo code)
-- 변경 전: 인덱스 없이, HDD에 순차 저장
STORAGE TABLE 은행계좌 (
    저장장치: HDD_DISK_01,              -- HDD 디스크 1번에 저장
    저장방식: SEQUENTIAL,               -- 순차적으로 저장 (입력 순서대로)
    블록크기: 4096 BYTES,               -- 한 블록의 크기는 4KB
    인덱스: 없음                         -- 별도 인덱스 없음
);
```

위 코드를 한 줄씩 설명하겠습니다:
- `저장장치: HDD_DISK_01`: 데이터가 "HDD_DISK_01"이라는 물리적 하드 디스크에 저장됩니다.
- `저장방식: SEQUENTIAL`: 레코드가 입력된 순서대로 하드 디스크에 차례차례 저장됩니다.
- `블록크기: 4096 BYTES`: 디스크에서 데이터를 읽고 쓰는 최소 단위가 4KB입니다.
- `인덱스: 없음`: 검색을 빠르게 해주는 인덱스가 설정되어 있지 않습니다.

**내부 스키마 변경 후 (물리적 구조 - 변경 후):**

```sql
-- 내부 스키마 예시 (의사 코드, pseudo code)
-- 변경 후: SSD로 교체, 인덱스 추가, 저장 방식 변경
STORAGE TABLE 은행계좌 (
    저장장치: SSD_DISK_01,              -- SSD 디스크 1번으로 교체!
    저장방식: CLUSTERED,                -- 클러스터형(계좌번호 기준 정렬 저장)
    블록크기: 8192 BYTES,               -- 한 블록의 크기를 8KB로 확대!
    인덱스: B_TREE ON 계좌번호           -- 계좌번호에 B-트리 인덱스 추가!
);
```

위 코드를 한 줄씩 설명하겠습니다:
- `저장장치: SSD_DISK_01`: 기존 HDD에서 **SSD로 저장 장치가 교체**되었습니다.
- `저장방식: CLUSTERED`: 순차 저장에서 **계좌번호 기준으로 정렬하여 저장**하는 방식으로 바뀌었습니다.
- `블록크기: 8192 BYTES`: 블록 크기가 4KB에서 **8KB로 두 배 커졌습니다.**
- `인덱스: B_TREE ON 계좌번호`: 계좌번호 컬럼에 **B-트리 인덱스가 새로 추가**되었습니다.

:::tip 핵심 확인
내부 스키마(물리적 구조)가 크게 변경되었지만, 개념 스키마의 `CREATE TABLE 은행계좌 (...)` 구조는 **한 글자도 바뀌지 않았습니다**. 이것이 바로 물리적 데이터 독립성입니다!
:::

### 응용 프로그램도 영향을 받지 않는다

물리적 구조가 바뀌어도, 사용자가 작성한 응용 프로그램(SQL 쿼리)은 전혀 수정할 필요가 없습니다.

```sql
-- ✅ 올바른 이해: 물리적 구조 변경 전이든 후이든, 이 쿼리는 동일하게 작동합니다
SELECT 계좌번호, 예금주명, 잔액     -- 계좌번호, 예금주명, 잔액을 조회
FROM 은행계좌                       -- 은행계좌 테이블에서
WHERE 잔액 >= 1000000              -- 잔액이 100만 원 이상인 행만 필터링
ORDER BY 잔액 DESC;                -- 잔액이 큰 순서대로 정렬
```

위 코드를 한 줄씩 설명하겠습니다:
- `SELECT 계좌번호, 예금주명, 잔액`: 조회하고 싶은 컬럼 3개를 지정합니다.
- `FROM 은행계좌`: 어떤 테이블에서 데이터를 가져올지 지정합니다.
- `WHERE 잔액 >= 1000000`: 조건을 걸어서 잔액이 100만 원 이상인 데이터만 가져옵니다.
- `ORDER BY 잔액 DESC`: 결과를 잔액 기준 내림차순(큰 것부터)으로 정렬합니다.

이 SQL 쿼리는 데이터가 HDD에 있든 SSD에 있든, 인덱스가 있든 없든, 순차 저장이든 클러스터 저장이든 **완전히 동일하게 작동**합니다. DBMS가 내부적으로 개념/내부 사상(매핑)을 통해 물리적 변경 사항을 자동으로 처리해 주기 때문입니다.

### ❌ 잘못된 예시 vs ✅ 올바른 예시

**❌ 물리적 데이터 독립성이 없는 경우 (파일 시스템 방식):**

```c
// ❌ 잘못된 예시: 파일 시스템에서 물리적 경로가 코드에 하드코딩되어 있음
// 저장 장치를 바꾸면 이 코드를 반드시 수정해야 합니다!

#include <stdio.h>

int main() {
    FILE *fp;
    // 물리적 파일 경로가 프로그램에 직접 포함되어 있음
    fp = fopen("/hdd_disk_01/bank/account.dat", "r");  // HDD 경로 하드코딩!
    
    // 만약 SSD로 교체하면...
    // fp = fopen("/ssd_disk_01/bank/account.dat", "r"); 로 수정해야 함!
    // 이런 코드가 100개 파일에 있다면? 100개 전부 수정해야 합니다!
    
    if (fp == NULL) {
        printf("파일을 열 수 없습니다.\n");  // 파일 열기 실패 메시지
        return 1;
    }
    
    // 파일 구조(레코드 크기)도 직접 명시해야 함
    char record[128];  // 레코드 크기가 128바이트로 고정되어 있음
    // 레코드 크기가 바뀌면 이 숫자도 바꿔야 합니다!
    
    fread(record, 128, 1, fp);  // 128바이트 단위로 읽음
    fclose(fp);
    return 0;
}
```

위 코드의 문제점:
- `/hdd_disk_01/bank/account.dat`처럼 **물리적 저장 경로가 프로그램에 직접 들어가 있습니다.** 저장 장치를 바꾸면 모든 프로그램의 경로를 일일이 수정해야 합니다.
- `char record[128]`처럼 **레코드의 물리적 크기가 프로그램에 고정**되어 있습니다. 레코드 구조가 바뀌면 프로그램도 수정해야 합니다.

**✅ 물리적 데이터 독립성이 보장되는 경우 (데이터베이스 방식):**

```sql
-- ✅ 올바른 예시: DBMS를 사용하면 물리적 구조를 전혀 신경 쓸 필요 없음
-- 저장 장치가 HDD이든 SSD이든, 인덱스가 있든 없든
-- 아래 쿼리는 항상 동일하게 동작합니다

SELECT 예금주명, 잔액           -- 어떤 데이터를 원하는지만 명세 (WHAT)
FROM 은행계좌                   -- 어디서 가져올지만 지정
WHERE 계좌유형 = '보통예금';    -- 조건만 명시

-- 물리적 세부사항(어떤 디스크에서 읽을지, 인덱스를 쓸지 말지,
-- 블록 크기는 얼마인지)은 DBMS가 알아서 처리합니다!
```

이것이 바로 **비절차적 데이터 조작어**의 특성이기도 합니다. 사용자는 **무엇(WHAT)** 을 원하는지만 말하면 되고, **어떻게(HOW)** 가져올지는 DBMS가 자동으로 결정합니다. 물리적 구조가 바뀌어도 DBMS가 내부적으로 최적의 방법을 알아서 선택하기 때문에, 사용자의 쿼리는 수정할 필요가 없습니다.

---

## 🔍 개념/내부 사상(매핑)의 역할

물리적 데이터 독립성이 실현되는 **기술적 비밀**은 바로 **개념/내부 사상(Conceptual/Internal Mapping)** 에 있습니다.

### 매핑이란 무엇인가?

매핑(사상)은 쉽게 말해 **"번역표"** 입니다. 마치 한국어와 영어 사이에 사전이 있어서 서로 통역해주듯이, 개념 스키마와 내부 스키마 사이에도 매핑 정보가 있어서 **논리적 구조와 물리적 구조를 서로 연결**해 줍니다.

```
개념 스키마: "은행계좌 테이블의 계좌번호 컬럼"
        ↕  (개념/내부 사상 = 번역표)
내부 스키마: "SSD_DISK_01의 블록 #37~#42에 B-트리 인덱스로 저장"
```

내부 스키마가 변경되면(예: SSD로 교체, 인덱스 추가), DBMS는 이 **매핑 정보만 업데이트**합니다. 개념 스키마 자체는 건드리지 않습니다. 그래서 개념 스키마를 기반으로 작동하는 응용 프로그램도 영향을 받지 않는 것입니다.

### 매핑 정보는 어디에 저장되나?

이 매핑 정보는 앞서 언급한 **데이터 사전(Data Dictionary)** 에 저장됩니다. 데이터 사전에는 다음과 같은 정보가 들어 있습니다:

- 외부 스키마, 개념 스키마, 내부 스키마에 대한 정보
- 각 스키마 간의 매핑(사상) 정보
- 접근 권한, 보안 정보
- 질의 최적화 정보

데이터 사전은 **시스템 카탈로그(System Catalog)** 라고도 불리며, 일반 테이블처럼 SQL로 **조회(SELECT)** 는 할 수 있지만, 사용자가 직접 **삽입(INSERT), 수정(UPDATE), 삭제(DELETE)** 할 수는 없습니다. 일반 테이블을 조작하면 DBMS가 자동으로 데이터 사전을 갱신합니다. 이를 **자기정의(Self-describing)** 특성이라고 합니다.

:::info 데이터 사전 vs 데이터 디렉터리
- **데이터 사전(시스템 카탈로그)**: 메타데이터가 저장된 곳. **사용자가 조회 가능**.
- **데이터 디렉터리**: 데이터 사전에 접근하기 위한 경로 정보를 관리하는 시스템. **시스템만 접근 가능**.

컴퓨터의 "파일 탐색기"에서 폴더(디렉터리) 안에 파일(사전)이 들어있는 것과 비슷한 구조입니다.
:::

---

## ⚠️ 주의사항과 실전 팁

### 주의사항 1: 독립성의 방향을 혼동하지 말 것

:::danger 가장 흔한 실수
"프로그램을 변경했을 때 물리적 구조를 그대로 사용할 수 있다" → ❌ 이것은 독립성이 **아닙니다!**

독립성은 반드시 **하위 단계(물리적 구조)가 변경될 때 → 상위 단계(논리적 구조, 응용 프로그램)에 영향이 없는 것**입니다.

방향을 항상 "아래에서 위로" 확인하세요.
:::

### 주의사항 2: 논리적 독립성과 물리적 독립성을 구분할 것

시험이나 면접에서 자주 혼동되는 부분입니다.

- **"테이블에 컬럼을 추가했는데 프로그램은 수정 안 해도 된다"** → 이것은 **논리적** 독립성입니다. 개념 스키마(테이블 구조)가 바뀌었지만 외부 스키마(프로그램)에 영향이 없는 것이니까요.
- **"하드 디스크를 SSD로 바꿨는데 테이블 구조도 프로그램도 수정 안 해도 된다"** → 이것은 **물리적** 독립성입니다. 내부 스키마(저장 방식)가 바뀌었지만 개념 스키마(테이블 구조)에 영향이 없는 것이니까요.

### 주의사항 3: 물리적 독립성은 "완전한 분리"를 의미하지 않는다

물리적 구조가 변경되면 **개념/내부 사상(매핑)은 수정**해야 합니다. 완전히 아무것도 안 바뀌는 것이 아닙니다. 핵심은 **개념 스키마 자체와 응용 프로그램은 수정할 필요가 없다**는 것이고, 매핑은 DBMS가 내부적으로 알아서 처리해 줍니다.

### 실전 팁

:::tip 실무에서 물리적 독립성이 빛나는 순간들
1. **서버 마이그레이션**: 온프레미스(자체 서버실) 서버에서 클라우드(AWS, Azure 등)로 데이터베이스를 이전할 때, 저장 장치가 완전히 바뀌지만 애플리케이션 코드는 그대로 유지됩니다.

2. **성능 튜닝**: DBA(데이터베이스 관리자)가 인덱스를 추가하거나 파티셔닝(대용량 테이블을 분할 저장)을 적용해도, 개발자의 SQL 쿼리는 수정할 필요가 없습니다.

3. **스토리지 확장**: 데이터가 급증해서 저장소를 늘리거나, RAID 구성을 변경해도, 응용 프로그램에는 영향이 없습니다.
:::

### 물리적 독립성이 필요한 이유를 한 문장으로

> **시스템의 성능을 향상하기 위해 저장 장치(하드웨어)를 변경할 때, 자료 구조와 프로그램은 변경하지 않고 그대로 사용할 수 있게 하는 것.** 이것이 물리적 데이터 독립성의 존재 이유입니다.

---

## 📐 DBMS의 계층 구조 속에서의 물리적 독립성 위치

물리적 데이터 독립성이 전체 데이터베이스 시스템에서 어디에 위치하는지를 그림으로 이해하면 더 명확합니다.

```
┌─────────────────────────────────────────┐
│              사용자 (Users)               │
│   일반 사용자 / 프로그래머 / DBA          │
├─────────────────────────────────────────┤
│         ↓ 사용자 인터페이스 ↓              │
├─────────────────────────────────────────┤
│       외부 스키마 (여러 개 존재)            │
│   입금 뷰 | 출금 뷰 | 이체 뷰 | ...       │
├─────────────────────────────────────────┤
│   ↕ 응용 인터페이스 (외부/개념 사상) ↕      │  ← 논리적 독립성 보장
├─────────────────────────────────────────┤
│       개념 스키마 (1개만 존재)              │
│   은행계좌 테이블 (전체 논리적 구조)         │
├─────────────────────────────────────────┤
│   ↕ 저장 인터페이스 (개념/내부 사상) ↕      │  ← ⭐ 물리적 독립성 보장
├─────────────────────────────────────────┤
│       내부 스키마 (1개만 존재)              │
│   저장 방식, 인덱스, 레코드 형식 등          │
├─────────────────────────────────────────┤
│         ↓ DBMS → 운영체제 ↓               │
├─────────────────────────────────────────┤
│      물리적 단계 (하드 디스크)              │
│   실제 데이터가 저장되는 하드웨어            │
└─────────────────────────────────────────┘
```

여기서 중요한 점은, **내부 스키마와 물리적 단계(실제 하드 디스크)는 다른 것**이라는 점입니다. 내부 스키마는 DBMS 레벨에서 물리적 저장 방식을 **정의**하는 것이고, 실제 하드 디스크에 데이터를 **물리적으로 저장하는 것은 운영체제(OS)** 가 담당합니다. 즉, 사용자가 DBMS를 통해 저장 명령을 내리면, DBMS는 내부 스키마의 정의에 따라 운영체제에게 권한을 넘기고, 운영체제가 실제로 디스크에 기록하는 것입니다.

:::note 내부 스키마 ≠ 물리적 단계
내부 스키마는 실제 운영체제의 물리적 단계보다 **한 단계 위에** 존재합니다. 내부 스키마는 "어떻게 저장할지를 정의"하는 것이고, 물리적 단계는 "실제로 저장하는 행위"입니다. 이 구분을 기억해 두세요.
:::

---

## 🗂️ 데이터 언어와 물리적 독립성의 관계

데이터베이스에서 사용하는 언어는 크게 세 가지로 나뉘는데, 물리적 독립성과의 관계를 이해하면 전체 그림이 더 선명해집니다.

### 데이터 정의어(DDL, Data Definition Language)

데이터베이스의 **구조를 만들고, 변경하고, 삭제**하는 언어입니다. 주로 DBA(데이터베이스 관리자)가 사용합니다.

| 명령어 | 기능 | 예시 |
|--------|------|------|
| `CREATE` | 테이블(구조) 생성 | `CREATE TABLE 은행계좌 (...)` |
| `ALTER` | 테이블 구조 변경 | `ALTER TABLE 은행계좌 ADD 전화번호 VARCHAR(15)` |
| `DROP` | 테이블 삭제 | `DROP TABLE 은행계좌` |

DDL로 생성한 스키마 정보는 컴파일되어 데이터 사전에 메타데이터 형태로 저장됩니다. 물리적 독립성의 관점에서, DDL로 정의한 **개념 스키마는 물리적 구조가 바뀌어도 변경할 필요가 없습니다.**

### 데이터 조작어(DML, Data Manipulation Language)

데이터를 **검색, 삽입, 삭제, 수정**하는 언어입니다. 일반 프로그래머와 사용자가 가장 많이 사용합니다.

| 조작어 종류 | 특성 | WHAT/HOW | 사용 방식 | 처리 단위 |
|------------|------|----------|----------|----------|
| **절차적 DML** | 저급 언어 | WHAT + HOW 모두 명세 | 호스트 프로그램에 내장 | 한 번에 하나의 레코드 |
| **비절차적 DML** | 고급 언어 | WHAT만 명세 | 독자적 사용 가능 | 한 번에 여러 레코드(집합 단위) |

물리적 독립성과 관련하여, 비절차적 DML(예: SQL)이 특히 중요합니다. 사용자가 **"무엇을 원하는지(WHAT)"만 말하면** DBMS가 물리적 구조에 맞는 최적의 방법을 알아서 결정하기 때문에, 물리적 구조가 바뀌어도 사용자의 쿼리는 수정할 필요가 없습니다.

### 데이터 제어어(DCL, Data Control Language)

데이터의 **보안, 무결성, 동시성 제어, 회복** 등을 담당하는 언어입니다. 주로 DBA가 사용합니다.

- **보안(Security)**: 권한이 없는 사용자의 접근을 차단
- **무결성(Integrity)**: 데이터의 정확성을 유지
- **회복(Recovery)**: 장애 발생 시 데이터를 복구
- **병행 제어(Concurrency Control)**: 여러 사용자가 동시에 접속할 때 충돌 방지

물리적 독립성 덕분에 저장 장치를 교체하더라도, 이미 설정된 보안 정책이나 무결성 규칙은 그대로 유지됩니다.

---

## 📌 핵심 정리

- **물리적 데이터 독립성**이란 물리적 구조(내부 스키마)를 변경해도 논리적 구조(개념 스키마)와 응용 프로그램에 영향을 주지 않는 능력이다.
- 독립성의 방향은 항상 **"하위 단계 변경 → 상위 단계 영향 없음"** 이다.
- **논리적 독립성**은 개념 스키마 변경 시 외부 스키마에 영향 없음, **물리적 독립성**은 내부 스키마 변경 시 개념 스키마에 영향 없음이다.
- 물리적 독립성은 **개념/내부 사상(매핑)** 을 통해 실현되며, 이 매핑 정보는 **데이터 사전(시스템 카탈로그)** 에 저장된다.
- **스키마**는 데이터베이스의 구조(뼈대)이고, **인스턴스**는 실제 저장된 데이터 값이다.
- 3단계 데이터베이스 구조는 **외부 스키마(여러 개) → 개념 스키마(1개) → 내부 스키마(1개)** 로 구성된다.
- 물리적 독립성이 필요한 가장 대표적인 상황은 **시스템 성능 향상을 위한 저장 장치(하드웨어) 교체**이다.
- DBMS는 데이터의 **종속성을 없애고 독립성을 보장**하는 것을 궁극적인 목표로 삼는다.
- **비절차적 DML(SQL)** 은 WHAT만 명세하므로 물리적 구조 변경에 자연스럽게 대응된다.
- 내부 스키마는 물리적 단계(실제 디스크)보다 **한 단계 위**에 존재하며, 실제 저장은 운영체제가 담당한다.

작성일: 2026-02-20