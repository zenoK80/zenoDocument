---
title: "논리적 데이터 독립성"
description: "논리적 데이터 독립성에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/three-level-database-architecture/3-logical-data-independence"
sidebar_label: "논리적 독립성"
date: "2026-02-20"
---

## 🎯 데이터 독립성이란 무엇인가?

데이터베이스를 공부하다 보면 **"데이터 독립성"**이라는 용어를 자주 만나게 됩니다. 이 개념은 데이터베이스 관리 시스템(DBMS, 데이터를 체계적으로 관리해 주는 소프트웨어)이 존재하는 **궁극적인 이유**이자 **가장 중요한 목표**입니다.

과거에는 파일 시스템(데이터를 단순 파일로 저장·관리하는 방식)을 사용했는데, 이 방식에는 치명적인 문제가 있었습니다. 파일의 구조가 조금만 바뀌어도 그 파일을 사용하는 **응용 프로그램(사용자가 실행하는 소프트웨어)** 전체를 함께 수정해야 했습니다. 이것을 **종속성**이라고 합니다.

> **데이터 독립성**이란, 데이터베이스의 내용이나 구조가 바뀌더라도 응용 프로그램은 수정 없이 그대로 사용할 수 있는 능력을 말합니다.

비유를 들어볼까요? 여러분이 매일 사용하는 스마트폰 앱을 떠올려 보세요. 은행 앱을 쓰고 있는데, 은행이 내부적으로 서버의 데이터 저장 방식을 바꾸었다고 해서 여러분이 앱을 새로 깔거나 사용법을 다시 배워야 한다면 너무 불편하겠죠? **데이터 독립성이 잘 지켜지면**, 은행이 내부적으로 어떤 변경을 하든 여러분은 아무런 차이를 느끼지 못하고 그대로 앱을 사용할 수 있습니다.

### 핵심 포인트: "하위가 바뀌어도 상위는 그대로"

데이터 독립성에서 가장 중요한 원칙은 다음과 같습니다:

- **하위 단계 스키마(구조)**가 변경되더라도
- **상위 단계 스키마**는 영향을 받지 않고 그대로 사용할 수 있어야 한다

마치 건물의 지하 배관 공사를 해도 3층에 사는 사람은 아무런 불편 없이 수도를 쓸 수 있는 것과 같습니다. 아래쪽(하위)에서 무언가 바뀌어도 위쪽(상위)은 영향을 받지 않는 것, 이것이 바로 독립성의 핵심입니다.

:::warning 자주 헷갈리는 포인트
"응용 프로그램을 변경했을 때 자료 구조를 그대로 사용할 수 있다"는 독립성이 **아닙니다**. 독립성은 항상 **하위 단계가 변경되었을 때 상위 단계를 그대로 사용할 수 있느냐**를 따지는 것입니다. 방향을 헷갈리지 마세요!
:::

---

## 🏗️ 3단계 데이터베이스 구조와 스키마의 이해

데이터 독립성을 본격적으로 이해하려면, 먼저 **3단계 데이터베이스 구조**와 **스키마**라는 개념을 알아야 합니다.

### 스키마(Schema)란?

**스키마(Schema)**는 데이터베이스의 **구조**를 의미합니다. 쉽게 말해, "데이터를 어떤 틀에 담을 것인가"를 정해놓은 **설계도**입니다.

예를 들어, "학생"이라는 테이블(표)을 만든다면:

- **개체(Entity)**: 학생 테이블 그 자체
- **속성(Attribute)**: 학번, 이름, 학과 같은 각 항목
- **관계(Relationship)**: "학생"과 "교수" 사이의 "지도" 관계, "학생"과 "과목" 사이의 "수강" 관계
- **제약 조건(Constraint)**: "점수는 0~100 사이여야 한다" 같은 규칙

이 모든 정보가 **컴파일(번역·처리)되어** 데이터 사전(Data Dictionary, 데이터에 대한 정보를 모아둔 저장소)에 **메타데이터(데이터에 대한 데이터)** 형태로 저장됩니다.

### 인스턴스(Instance)란?

스키마의 반대 개념은 **인스턴스(Instance)**입니다. 인스턴스는 **어느 특정 순간에 데이터베이스에 실제로 저장되어 있는 값**을 말합니다.

| 구분 | 의미 | 예시 |
|------|------|------|
| **스키마** | 구조, 설계도 | "학생 테이블에는 학번(정수), 이름(문자열), 점수(0~100) 항목이 있다" |
| **인스턴스** | 실제 값, 데이터 | "학번: 20001, 이름: 김철수, 점수: 85" |

냉장고에 비유하면, 스키마는 **냉장고의 칸 구조**(냉동실, 냉장실, 야채칸)이고, 인스턴스는 **실제로 들어있는 음식들**(우유, 계란, 당근)입니다. 칸의 구조가 바뀌지 않아도 안에 들어있는 음식은 매일 바뀔 수 있죠.

### 3단계 스키마 구조

하나의 데이터베이스를 **어떤 관점에서 보느냐**에 따라 세 가지 스키마로 나뉩니다:

| 스키마 | 관점 | 개수 | 설명 |
|--------|------|------|------|
| **외부 스키마** | 사용자 개인 | 여러 개 | 각 사용자에게 필요한 부분만 보여주는 뷰(View) |
| **개념 스키마** | 조직 전체 | 1개 | 데이터베이스 전체를 하나로 통합한 구조 |
| **내부 스키마** | 저장 장치 | 1개 | 데이터가 물리적으로 어떻게 저장되는지의 구조 |

:::info 스키마라고만 하면?
아무 수식어 없이 그냥 **"스키마"**라고 하면, 보통 **개념 스키마**를 의미합니다. 개념 스키마가 데이터베이스 전체를 대표하는 하나의 통합 구조이기 때문입니다.
:::

#### 은행 계좌 예시로 이해하기

은행에 **"은행 계좌"**라는 하나의 테이블이 있다고 가정해 봅시다.

- **외부 스키마**: 사용자에 따라 "입금 화면", "출금 화면", "이체 화면" 등 **필요한 부분만** 뽑아서 보여줍니다. 이것을 **뷰(View)**라고 합니다. 각 사용자의 요구사항이 다르기 때문에 **여러 개**가 존재합니다.
- **개념 스키마**: "은행 계좌 테이블" 그 자체. 계좌번호, 이름, 잔액, 거래일시 등 모든 항목이 포함된 **전체 구조** 하나입니다.
- **내부 스키마**: 이 테이블이 하드디스크에 **어떤 데이터 타입(정수, 문자열, 날짜 등)**으로, **어떤 인덱스(검색을 빠르게 해주는 색인)**를 사용해서 저장되는지를 정의한 구조입니다.

외부 스키마는 마치 **한 권의 백과사전에서 필요한 페이지만 복사해서 보는 것**과 같습니다. 원본 백과사전은 하나(개념 스키마)이지만, 각 사람이 보는 복사본(외부 스키마)은 여러 개인 셈이죠.

### 3단계 간의 매핑(사상)

각 단계 사이에는 **인터페이스(서로 연결해 주는 접점)**가 존재합니다:

- **사용자 인터페이스**: 사용자 ↔ 외부 스키마
- **응용 인터페이스**: 외부 스키마 ↔ 개념 스키마
- **저장 인터페이스**: 개념 스키마 ↔ 내부 스키마

이 인터페이스들이 있기 때문에, 한 단계에서 변경이 일어나도 다른 단계에 영향을 주지 않을 수 있습니다. 마치 **통역사**가 있어서 서로 다른 언어를 쓰는 사람들이 소통할 수 있는 것처럼, 매핑이 중간에서 변환을 해주는 것입니다.

---

## 🔍 논리적 데이터 독립성 — 핵심 원리

이제 이 문서의 핵심 주제인 **논리적 데이터 독립성**을 깊이 있게 살펴보겠습니다.

### 정의

> **논리적 데이터 독립성**이란, 응용 프로그램에 영향을 주지 않고 데이터베이스의 **논리적 구조(개념 스키마)**를 변경할 수 있는 능력입니다.

다시 말해, **데이터베이스의 구조가 바뀌더라도 응용 프로그램은 수정 없이 그대로 사용할 수 있는 것**을 의미합니다.

### "논리적"이 의미하는 것

여기서 **"논리적"**이라는 말은 **사용자 관점**을 의미합니다. 사용자가 데이터를 바라보는 방식, 즉 "테이블은 이런 항목들로 구성되어 있고, 이런 관계가 있다"라고 이해하는 **추상적인 구조**가 논리적 구조입니다.

반대로 **"물리적"**이라는 말은 **하드웨어(저장 장치) 관점**입니다. 하드디스크에 데이터가 실제로 어떤 형태로, 어떤 순서로 저장되어 있는지가 물리적 구조입니다.

| 관점 | 용어 | 누가 관심을 가지나? |
|------|------|---------------------|
| 사용자가 바라보는 구조 | **논리적** 관점 | 프로그래머, 일반 사용자 |
| 저장 장치가 바라보는 구조 | **물리적** 관점 | DBA(데이터베이스 관리자), 시스템 |

### 3단계 구조에서의 위치

논리적 데이터 독립성은 **외부 스키마**와 **개념 스키마** 사이의 관계에서 발생합니다.

```
사용자 → 외부 스키마 → [응용 인터페이스] → 개념 스키마 → [저장 인터페이스] → 내부 스키마 → 하드디스크
```

**개념 스키마(하위)**가 변경되더라도, **외부 스키마(상위)**는 영향을 받지 않고 그대로 사용할 수 있어야 합니다. 이것이 바로 논리적 데이터 독립성입니다.

:::tip 기억하기 쉬운 비유
도서관을 생각해 보세요. 도서관 내부에서 책의 분류 체계를 변경해도(개념 스키마 변경), 여러분이 검색 컴퓨터에서 책을 찾는 방법(외부 스키마)은 바뀌지 않습니다. 사서가 뒤에서 분류 체계를 아무리 바꿔도, 이용자가 사용하는 검색 화면은 그대로인 것이죠. 이것이 논리적 데이터 독립성입니다.
:::

---

## 💻 실제 예시로 이해하기

### 은행 계좌 시나리오

은행의 **"계좌"** 테이블을 예로 들어보겠습니다.

```sql
-- 개념 스키마: 은행 계좌 테이블 (전체 구조)
CREATE TABLE 계좌 (
    계좌번호  VARCHAR(20) PRIMARY KEY,  -- 계좌를 고유하게 식별하는 번호
    이름      VARCHAR(50),              -- 계좌 소유자 이름
    잔액      DECIMAL(15, 2),           -- 현재 잔액
    계좌유형  VARCHAR(10),              -- 보통예금, 정기예금 등
    개설일    DATE                      -- 계좌를 개설한 날짜
);
```

이 테이블에서 사용자별로 **외부 스키마(뷰)**를 만들어 줍니다:

```sql
-- 외부 스키마 1: 입금 담당자가 보는 뷰
CREATE VIEW 입금_뷰 AS
SELECT 계좌번호, 이름, 잔액   -- 입금에 필요한 항목만 선택
FROM 계좌;

-- 외부 스키마 2: 출금 담당자가 보는 뷰
CREATE VIEW 출금_뷰 AS
SELECT 계좌번호, 이름, 잔액   -- 출금에 필요한 항목만 선택
FROM 계좌;

-- 외부 스키마 3: 계좌 관리자가 보는 뷰
CREATE VIEW 관리_뷰 AS
SELECT 계좌번호, 이름, 계좌유형, 개설일  -- 관리에 필요한 항목만 선택
FROM 계좌;
```

### 논리적 구조가 변경되는 상황

이제 은행에서 업무 요구사항이 바뀌어, **계좌 테이블에 "지점코드"라는 새 항목을 추가**해야 한다고 합시다:

```sql
-- 개념 스키마 변경: 새로운 항목 추가
ALTER TABLE 계좌
ADD 지점코드 VARCHAR(10);  -- 지점코드라는 새 항목을 테이블에 추가
```

개념 스키마(전체 테이블 구조)가 변경되었습니다. 하지만 **입금 담당자가 사용하는 뷰**를 다시 볼까요?

```sql
-- 입금_뷰는 계좌번호, 이름, 잔액만 보여주므로
-- 지점코드가 추가되어도 이 뷰에는 아무 영향이 없습니다!
SELECT * FROM 입금_뷰;
-- 결과: 계좌번호, 이름, 잔액 (이전과 동일)
```

> 이것이 바로 **논리적 데이터 독립성**입니다! 개념 스키마(하위)가 변경되었지만, 외부 스키마(상위)인 `입금_뷰`는 전혀 영향을 받지 않았습니다. 입금 담당자는 이전과 똑같이 업무를 볼 수 있습니다.

### ❌ 잘못된 예시 — 독립성이 깨진 경우

만약 데이터 독립성이 없는 파일 시스템이었다면 어떨까요?

```c
// ❌ 파일 시스템 방식: 구조가 바뀌면 프로그램도 수정해야 함
struct 계좌 {
    char 계좌번호[20];
    char 이름[50];
    double 잔액;
    char 계좌유형[10];
    char 개설일[11];
    // 지점코드를 추가하면... 이 구조체를 사용하는 모든 프로그램을 수정해야 함!
};

// 입금 프로그램도 수정해야 하고
// 출금 프로그램도 수정해야 하고
// 이체 프로그램도 수정해야 하고...
// 모든 곳을 다 고쳐야 합니다!
```

파일 시스템에서는 자료 구조(struct)가 바뀌면 **이 구조를 사용하는 모든 프로그램**을 찾아서 하나하나 수정해야 합니다. 프로그램이 100개라면 100개를 모두 고쳐야 하는 것입니다. 이것이 바로 **종속성**이며, 데이터베이스가 해결하려는 문제입니다.

### ✅ 올바른 예시 — 독립성이 지켜진 경우

```sql
-- ✅ 데이터베이스 방식: 개념 스키마가 변경되어도 외부 스키마(뷰)는 그대로

-- 1단계: 개념 스키마 변경 (테이블에 항목 추가)
ALTER TABLE 계좌
ADD 지점코드 VARCHAR(10);  -- 새 항목 추가

-- 2단계: 기존 외부 스키마(뷰)는 수정 필요 없음!
-- 입금_뷰: 계좌번호, 이름, 잔액만 보여주므로 영향 없음
-- 출금_뷰: 계좌번호, 이름, 잔액만 보여주므로 영향 없음
-- 관리_뷰: 계좌번호, 이름, 계좌유형, 개설일만 보여주므로 영향 없음

-- 3단계: 필요한 경우에만 새로운 뷰를 추가하면 됨
CREATE VIEW 지점별_계좌_뷰 AS
SELECT 계좌번호, 이름, 잔액, 지점코드  -- 새 항목을 포함한 뷰 생성
FROM 계좌;
```

한 줄씩 설명하겠습니다:

1. `ALTER TABLE 계좌 ADD 지점코드 VARCHAR(10);` — 기존 계좌 테이블에 "지점코드"라는 최대 10자짜리 문자열 항목을 추가합니다. 이것은 **개념 스키마의 변경**입니다.
2. 기존에 만들어 둔 `입금_뷰`, `출금_뷰`, `관리_뷰`는 **지점코드를 참조하지 않으므로** 아무런 수정이 필요 없습니다. 이것이 논리적 독립성의 핵심입니다.
3. 지점코드를 사용해야 하는 새로운 업무가 생기면, 그때 **새 뷰를 추가**하기만 하면 됩니다. 기존 것을 건드릴 필요가 없습니다.

---

## ⚖️ 논리적 독립성 vs 물리적 독립성

데이터 독립성은 **두 가지**로 나뉩니다. 논리적 독립성을 더 잘 이해하기 위해 물리적 독립성과 비교해 보겠습니다.

### 전체 그림

```
사용자
  ↕  (사용자 인터페이스)
외부 스키마 (여러 개)
  ↕  (응용 인터페이스)  ← 논리적 데이터 독립성이 작동하는 곳
개념 스키마 (1개)
  ↕  (저장 인터페이스)  ← 물리적 데이터 독립성이 작동하는 곳
내부 스키마 (1개)
  ↕
하드디스크 (물리적 저장 장치)
```

### 비교 표

| 구분 | 논리적 데이터 독립성 | 물리적 데이터 독립성 |
|------|---------------------|---------------------|
| **뭐가 바뀌나?** | 개념 스키마(논리적 구조) | 내부 스키마(물리적 구조) |
| **뭐가 영향 안 받나?** | 외부 스키마, 응용 프로그램 | 개념 스키마, 응용 프로그램 |
| **관점** | 사용자 관점 | 하드웨어(저장 장치) 관점 |
| **매핑 위치** | 외부 스키마 ↔ 개념 스키마 | 개념 스키마 ↔ 내부 스키마 |
| **언제 필요?** | 테이블 구조 변경, 항목 추가/삭제 시 | 하드디스크 교체, 성능 튜닝 시 |
| **비유** | 백과사전 목차가 바뀌어도 내가 보던 페이지는 그대로 | 도서관이 이사해도 책 내용은 그대로 |

### 물리적 독립성은 왜 필요한가?

여러분 집의 컴퓨터 성능이 떨어지면 무엇을 하시나요? **하드디스크를 교체하거나, CPU를 업그레이드하거나, 메모리를 추가**하죠. 즉, 물리적 장치를 변경합니다.

이렇게 **시스템 성능 향상**을 위해 하드웨어를 바꿀 때, 기존의 데이터베이스 구조(개념 스키마)와 응용 프로그램은 수정 없이 그대로 사용할 수 있어야 합니다. 이것이 **물리적 데이터 독립성**입니다.

:::note 하나의 데이터베이스, 두 가지 관점
데이터베이스가 논리적인 것과 물리적인 것 두 개가 따로 존재하는 것이 **아닙니다**. **하나의 데이터베이스**를 사용자가 보면 논리적 관점이고, 저장 장치가 보면 물리적 관점인 것입니다. 마치 하나의 동전에 앞면과 뒷면이 있는 것처럼요.
:::

---

## 🧩 데이터 사전과 데이터 언어

논리적 데이터 독립성을 실제로 구현하기 위해서는 **데이터 사전**과 **데이터 언어**에 대한 이해도 필요합니다.

### 데이터 사전(Data Dictionary)

**데이터 사전**은 데이터베이스에 포함되는 **모든 데이터에 대한 정의와 명세 정보가 저장되어 있는 곳**입니다. 다른 말로 **시스템 카탈로그(System Catalog)**라고도 합니다.

데이터 사전에는 다음과 같은 정보가 들어 있습니다:

- 외부 스키마, 개념 스키마, 내부 스키마에 대한 정보
- 각 스키마 간의 매핑(인터페이스) 정보
- 접근 권한, 보안에 대한 정보
- 질의 최적화(검색을 빠르게 해주는 방법)에 대한 정보

마치 **도서관의 사서가 관리하는 장부**와 같습니다. 어떤 책이 어디에 있는지, 누가 빌릴 수 있는지, 분류 체계는 어떤지 등의 정보가 이 장부에 기록되어 있는 것이죠.

:::warning 데이터 사전은 직접 수정할 수 없습니다
데이터 사전도 일반 테이블처럼 생겼기 때문에 SQL로 **검색(SELECT)**은 할 수 있습니다. 하지만 INSERT, UPDATE, DELETE 같은 명령으로 **직접 내용을 삽입하거나 수정할 수는 없습니다**. 사용자가 일반 테이블을 변경하면, DBMS가 자동으로 사전 정보를 갱신합니다. 이것을 **자기 정의(Self-describing)** 특성이라고 합니다.
:::

### 데이터 디렉터리(Data Directory)

데이터 사전에 접근하기 위한 경로 정보를 관리하는 시스템을 **데이터 디렉터리**라고 합니다. 운영체제의 탐색기에서 폴더 구조를 떠올리면 됩니다. 폴더(디렉터리) 안에 실제 파일(사전 정보)이 들어있는 구조입니다.

| 구분 | 데이터 사전(카탈로그) | 데이터 디렉터리 |
|------|----------------------|----------------|
| 접근 주체 | 사용자가 접근 가능(읽기) | 시스템만 접근 가능 |
| 역할 | 메타데이터 저장 | 사전에 접근하는 경로 관리 |

### 데이터 언어 3가지

데이터베이스를 다루기 위해 사용하는 언어는 세 가지로 나뉩니다:

#### 1. 데이터 정의어(DDL, Data Definition Language)

데이터베이스의 **구조를 만들고, 변경하고, 삭제**하는 언어입니다. 주로 DBA(데이터베이스 관리자)가 사용합니다.

```sql
-- 데이터 정의어 예시
CREATE TABLE 학생 (학번 INT, 이름 VARCHAR(50));  -- 테이블 생성
ALTER TABLE 학생 ADD 학과 VARCHAR(30);             -- 테이블 구조 변경
DROP TABLE 학생;                                    -- 테이블 삭제
```

- `CREATE`: 새로운 테이블(구조)을 **생성**합니다.
- `ALTER`: 기존 테이블의 구조를 **변경**합니다. (항목 추가, 삭제, 타입 변경 등)
- `DROP`: 테이블 자체를 **삭제**합니다.

#### 2. 데이터 조작어(DML, Data Manipulation Language)

데이터를 **검색, 삽입, 삭제, 갱신**하는 언어입니다. 가장 보편적으로 사용되는 명령어들입니다.

```sql
-- 데이터 조작어 예시
SELECT * FROM 학생;                       -- 데이터 검색
INSERT INTO 학생 VALUES (20001, '김철수'); -- 데이터 삽입
UPDATE 학생 SET 이름='이영희' WHERE 학번=20001; -- 데이터 갱신
DELETE FROM 학생 WHERE 학번=20001;        -- 데이터 삭제
```

데이터 조작어는 다시 두 가지로 나뉩니다:

| 구분 | 절차적 DML | 비절차적 DML |
|------|-----------|-------------|
| **명세** | What(무엇) + How(어떻게) 모두 | What(무엇)만 |
| **언어 수준** | 저급 언어 | 고급 언어 |
| **독자 사용** | 불가능 (프로그램에 내장) | 가능 |
| **처리 단위** | 한 번에 하나의 레코드 | 한 번에 여러 레코드 (집합 단위) |
| **예시** | 호스트 프로그램 내 삽입 SQL | 일반 SQL 질의문 |

비절차적 DML이 우리가 흔히 사용하는 SQL입니다. "이 조건에 맞는 데이터를 보여줘"라고 **무엇을 원하는지만** 말하면, **어떻게 찾을지는 DBMS가 알아서** 처리합니다.

#### 3. 데이터 제어어(DCL, Data Control Language)

데이터의 **보안, 무결성(정확성), 회복(복구), 병행 제어(동시 접근 관리)**를 위한 언어입니다. 주로 DBA가 사용합니다.

```sql
-- 데이터 제어어 예시
GRANT SELECT ON 학생 TO 사용자A;   -- 사용자A에게 학생 테이블 조회 권한 부여
REVOKE SELECT ON 학생 FROM 사용자A; -- 사용자A의 조회 권한 회수
COMMIT;                              -- 작업 확정 (변경 내용 저장)
ROLLBACK;                            -- 작업 취소 (변경 이전으로 되돌림)
```

---

## ⚠️ 주의사항과 실무 팁

### 흔히 하는 실수들

:::danger 독립성의 방향을 헷갈리지 마세요
- ❌ "응용 프로그램이 바뀌어도 데이터베이스가 영향 없다" → 이것은 독립성이 **아닙니다**
- ✅ "데이터베이스(하위)가 바뀌어도 응용 프로그램(상위)이 영향 없다" → 이것이 독립성입니다

독립성은 항상 **하위 → 상위** 방향으로 "하위가 바뀌어도 상위는 괜찮은가?"를 따집니다.
:::

### 논리적 독립성 vs 물리적 독립성 구분 팁

시험이나 실무에서 자주 헷갈리는 부분을 정리하겠습니다:

- **"테이블에 새 항목을 추가했는데 기존 프로그램이 잘 돌아간다"** → 이것은 **논리적** 데이터 독립성
- **"하드디스크를 SSD로 교체했는데 기존 프로그램이 잘 돌아간다"** → 이것은 **물리적** 데이터 독립성
- **"인덱스를 새로 만들었는데 기존 프로그램이 잘 돌아간다"** → 이것은 **물리적** 데이터 독립성 (인덱스는 저장 방식에 관한 것이므로)

:::tip 실무에서 논리적 독립성을 잘 지키려면
1. **뷰(View)를 적극 활용하세요.** 사용자에게 직접 테이블을 노출하지 말고, 뷰를 통해 필요한 부분만 보여주면 테이블 구조가 바뀌어도 뷰만 조정하면 됩니다.
2. **응용 프로그램에서 `SELECT *`를 사용하지 마세요.** 필요한 항목만 명시적으로 지정하면, 테이블에 새 항목이 추가되어도 프로그램이 영향을 받지 않습니다.
3. **개념 스키마를 안정적으로 설계하세요.** 처음 설계할 때 확장 가능성을 고려하면, 나중에 구조를 변경할 일이 줄어듭니다.
:::

### SELECT * 를 피해야 하는 이유

```sql
-- ❌ 나쁜 예시: SELECT * 사용
SELECT * FROM 계좌;
-- 테이블에 새 항목이 추가되면 결과 구조가 바뀌어서
-- 이 결과를 처리하는 프로그램이 오류를 일으킬 수 있음

-- ✅ 좋은 예시: 필요한 항목만 명시
SELECT 계좌번호, 이름, 잔액 FROM 계좌;
-- 테이블에 새 항목이 추가되어도
-- 이 쿼리의 결과는 항상 3개 항목으로 동일
-- → 논리적 독립성이 잘 지켜짐!
```

한 줄씩 살펴보겠습니다:

- `SELECT * FROM 계좌;` — 별표(*)는 "모든 항목"을 의미합니다. 테이블에 항목이 추가되면 결과에도 새 항목이 포함되어 프로그램이 예상치 못한 데이터를 받게 됩니다.
- `SELECT 계좌번호, 이름, 잔액 FROM 계좌;` — 필요한 항목만 명시했으므로, 테이블 구조가 바뀌어도 이 쿼리의 결과는 항상 동일합니다. 논리적 독립성이 잘 지켜지는 패턴입니다.

---

## 🗂️ 데이터베이스 시스템의 전체 구조

논리적 독립성이 데이터베이스 시스템에서 어떤 위치에 있는지 전체 그림으로 확인해 봅시다.

### 데이터베이스 시스템 구성 요소

데이터베이스 시스템(DBS)은 다음 요소들을 **모두 합친 것**입니다:

- **데이터베이스(DB)**: 실제 데이터가 저장된 곳
- **DBMS(데이터베이스 관리 시스템)**: 데이터베이스를 관리하는 소프트웨어
- **데이터 언어**: DDL, DML, DCL
- **사용자**: 일반 사용자, 프로그래머, DBA
- **컴퓨터(하드웨어)**: CPU, 메모리, 하드디스크

:::info DBMS와 데이터베이스 시스템은 다릅니다
- **DBMS** = 데이터베이스 **관리 시스템** (소프트웨어)
- **데이터베이스 시스템** = DB + DBMS + 언어 + 사용자 + 하드웨어 (전체)

DBMS는 데이터베이스 시스템의 **일부**입니다. 마치 자동차의 엔진(DBMS)과 자동차 전체(데이터베이스 시스템)의 관계와 같습니다.
:::

### 사용자의 종류

| 사용자 | 역할 | 주로 사용하는 언어 |
|--------|------|-------------------|
| **일반 사용자** | 데이터베이스를 일상적으로 사용 | DML (검색, 입력) |
| **프로그래머** | 응용 프로그램 개발 | DML (프로그램에 내장) |
| **DBA (관리자)** | DB 시스템 전체의 관리와 책임 | DDL + DCL |

DBA는 데이터베이스 시스템에 대한 **모든 책임**을 지고 있습니다. 테이블 구조를 만들고(DDL), 접근 권한을 관리하고(DCL), 장애 시 복구하고, 성능을 최적화하는 등 DB와 관련된 모든 업무를 수행합니다.

### 데이터 저장 흐름

사용자가 데이터를 저장하는 전체 흐름을 살펴보면:

1. **사용자**가 DBMS를 통해 저장 명령을 내립니다
2. **DBMS**가 명령을 처리하고, 권한을 **운영체제(OS)**에 넘깁니다
3. **운영체제**가 실제 하드디스크에 데이터를 저장합니다

여기서 내부 스키마는 DBMS 단계에 존재하고, 실제 물리적 저장은 운영체제가 담당합니다. 내부 스키마는 **실제 물리적 단계보다 한 단계 위**에 존재하는 구조입니다.

---

## 🏛️ 데이터베이스 시스템의 구조 유형

데이터베이스 시스템은 규모와 목적에 따라 여러 가지 구조로 나뉩니다.

### 중앙 집중 데이터베이스

모든 데이터가 **한 곳에 집중**되어 있는 구조입니다. 하나의 대형 컴퓨터(범용 컴퓨터)를 중앙에 두고, 여러 사용자가 연결해서 사용하는 방식입니다. 단일 사용자 시스템(개인 PC)부터 다수 사용자 시스템(구글, 네이버 서버)까지 규모가 다양합니다.

### 클라이언트-서버 시스템

인터넷 환경에서 가장 흔한 구조입니다. 기능이 **전처리(클라이언트)**와 **후처리(서버)**로 나뉩니다:

- **전처리(클라이언트)**: 사용자 화면 표시, 데이터 입력 등 → 사용자와 직접 소통하는 역할
- **후처리(서버)**: 데이터베이스 관리, 질의 최적화, 동시성 제어, 회복 등 → 뒤에서 무거운 작업을 처리하는 역할

### 병렬 데이터베이스 시스템

여러 개의 CPU를 **고속 네트워크로 연결**하여 동시에 빠르게 처리하는 시스템입니다. 슈퍼컴퓨터와 같은 구조로, 대량의 데이터를 고속으로 처리해야 할 때 사용합니다.

| 구조 | 공유 대상 | 병목 구간 | 특징 |
|------|----------|----------|------|
| **공유 메모리** | 메모리를 공유 | 메모리 | 데이터 공유가 쉽지만, CPU를 많이 추가해도 성능 향상에 한계 |
| **공유 디스크** | 디스크를 공유 | 디스크 | 각자 메모리는 있지만, 디스크 접근 시 병목 발생 |
| **무공유** | 공유 없음 | 없음 | 각자 독립, 네트워크로만 연결. 간섭 없음 |
| **계층 구조** | 복합 | 복합 | 위 구조들을 계층적으로 조합한 것 |

### 분산 데이터베이스 시스템

데이터를 여러 지역의 사이트에 **분산 저장**하고, 네트워크로 연결하여 사용하는 시스템입니다. 각 사이트는 독자적인 제어권을 가지고 자체적으로 데이터를 관리합니다.

| 장점 | 단점 |
|------|------|
| 가용도가 높음 (일부 고장 나도 사용 가능) | 시스템이 복잡함 |
| 신뢰성이 좋음 | 비용이 많이 듦 |
| 데이터 중복으로 안정성 확보 | 오류가 잠재되어 있을 수 있음 |

---

## 📌 핵심 정리

- **데이터 독립성**이란 데이터베이스의 구조나 내용이 바뀌어도 응용 프로그램을 수정 없이 사용할 수 있는 능력이다
- **논리적 데이터 독립성**은 개념 스키마(논리적 구조)가 변경되어도 외부 스키마(사용자 뷰)와 응용 프로그램에 영향을 주지 않는 것이다
- **물리적 데이터 독립성**은 내부 스키마(물리적 저장 방식)가 변경되어도 개념 스키마와 응용 프로그램에 영향을 주지 않는 것이다
- 독립성의 방향은 항상 **"하위 단계가 변경 → 상위 단계는 그대로"**이다
- **스키마**는 데이터베이스의 구조(설계도)이고, **인스턴스**는 실제 저장된 값이다
- 3단계 스키마: **외부 스키마**(사용자 관점, 여러 개) → **개념 스키마**(조직 전체, 1개) → **내부 스키마**(저장 장치 관점, 1개)
- **뷰(View)**를 활용하면 논리적 독립성을 효과적으로 지킬 수 있다
- 데이터 사전(시스템 카탈로그)에는 모든 스키마 정보가 메타데이터로 저장되며, 직접 수정은 불가능하다
- 데이터 언어는 **DDL**(정의), **DML**(조작), **DCL**(제어) 세 가지로 나뉜다
- DBMS와 데이터베이스 시스템은 다른 개념이며, DBMS는 데이터베이스 시스템의 일부이다

작성일: 2026-02-20