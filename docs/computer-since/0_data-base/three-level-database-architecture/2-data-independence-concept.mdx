---
title: "데이터 독립성의 개념과 DBMS의 목표"
description: "데이터 독립성의 개념과 DBMS의 목표에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/three-level-database-architecture/2-data-independence-concept"
sidebar_label: "데이터 독립성 개념"
date: "2026-02-20"
---

## 🎯 데이터 독립성이란 무엇인가?

여러분이 스마트폰의 배경화면을 바꿨다고 해서, 카카오톡이나 유튜브 앱이 갑자기 작동을 멈추면 어떨까요? 굉장히 불편하겠죠. **배경화면(데이터의 구조)을 바꿔도 앱(응용 프로그램)은 아무 문제 없이 돌아가야 합니다.** 이것이 바로 데이터 독립성의 핵심 개념입니다.

**데이터 독립성(Data Independence)**이란, 데이터베이스의 구조나 내용이 변경되더라도 응용 프로그램은 수정 없이 그대로 사용할 수 있는 능력을 말합니다. 쉽게 말해, **데이터와 프로그램이 서로에게 종속되지 않고 독립적으로 운영되는 것**입니다.

> **DBMS(데이터베이스 관리 시스템)가 갖는 궁극적인 목표는 바로 이 "데이터 독립성"을 보장하는 것입니다.** 응용 프로그램이 데이터에 종속되지 않도록 만들어주는 것, 그것이 DBMS가 존재하는 이유입니다.

이전 시간에 배운 **파일 시스템의 문제점** 두 가지를 떠올려 보세요. 바로 **중복성**과 **종속성**이었습니다. 파일 시스템에서는 파일 구조가 바뀌면 프로그램도 함께 변경해야 했습니다. 이것이 바로 **종속성**이죠. DBMS는 이 종속성 문제를 해결하기 위해 탄생한 것이고, 그 해결책이 바로 **데이터 독립성**입니다.

:::info 종속성 vs 독립성
- **종속성**: 자료 구조가 바뀌면 프로그램도 같이 바뀌어야 하는 상태 (파일 시스템의 문제점)
- **독립성**: 자료 구조나 내용이 바뀌어도 프로그램은 그대로 사용할 수 있는 능력 (DBMS의 목표)
:::

데이터 독립성을 좀 더 정확하게 정의하면 이렇습니다: **상위 단계 스키마(구조) 정의에 영향을 주지 않고, 하위 단계 스키마 정의를 수정할 수 있게 하는 능력**입니다. 여기서 핵심은 **"하위 단계가 바뀌어도 상위 단계는 그대로"**라는 점입니다.

마치 건물에 비유하면, 1층 가게의 인테리어를 바꿔도 2층, 3층 사무실은 아무런 영향을 받지 않는 것과 같습니다. 아래층(하위 단계)이 변경되어도 윗층(상위 단계)은 그대로 사용할 수 있는 것, 이것이 독립성입니다.

---

## 🔍 왜 데이터 독립성이 필요한가?

### 파일 시스템 시절의 고통

데이터 독립성이 왜 필요한지 이해하려면, 먼저 독립성이 없던 시절의 고통을 알아야 합니다. 파일 시스템 시대에는 **프로그램과 데이터가 꽁꽁 묶여 있었습니다**. 마치 리모컨의 버튼 배치를 바꾸면 TV 자체가 고장 나는 것과 같은 상황이었죠.

예를 들어, 회사에서 직원 정보를 관리하는 프로그램이 있었다고 해봅시다. 직원 파일의 구조가 `이름, 나이, 부서`에서 `이름, 나이, 부서, 이메일`로 바뀌면, 그 파일을 사용하는 **모든 프로그램을 다 수정해야** 했습니다. 프로그램이 10개면 10개 모두, 100개면 100개 모두 손을 봐야 했죠. 시간도 돈도 엄청나게 들었습니다.

### DBMS가 해결하고자 하는 것

DBMS는 이 문제를 해결하기 위해 **데이터와 프로그램 사이에 중간 관리자 역할**을 합니다. 데이터베이스의 내용이 바뀌거나 구조가 바뀌어도, 프로그램은 DBMS를 통해 접근하기 때문에 프로그램 자체를 수정할 필요가 없습니다.

| 구분 | 파일 시스템 | DBMS |
|------|-----------|------|
| 데이터 구조 변경 시 | 프로그램도 반드시 수정 필요 | 프로그램 수정 불필요 |
| 프로그램-데이터 관계 | 종속적 (묶여 있음) | 독립적 (분리됨) |
| 유지보수 비용 | 매우 높음 | 상대적으로 낮음 |
| 유연성 | 매우 낮음 | 높음 |

:::warning 자주 하는 실수
독립성은 **항상 "하위 단계가 변경됐을 때 상위 단계를 그대로 사용할 수 있느냐"**를 따지는 것입니다. "응용 프로그램을 변경했을 때 자료 구조를 그대로 사용할 수 있다"는 것은 독립성의 정의가 **아닙니다**. 방향을 헷갈리지 마세요!
:::

---

## 🧠 핵심 원리: 논리적 독립성과 물리적 독립성

데이터 독립성은 크게 **논리적 독립성**과 **물리적 독립성** 두 가지로 나뉩니다. 이 두 가지를 이해하려면 먼저 하나의 그림을 머릿속에 그려보세요.

```
사용자 → 응용 프로그램 → 데이터베이스 → 하드디스크(저장 장치)
```

이 구조에서 **왼쪽(사용자 쪽)으로 갈수록 논리적 관점**, **오른쪽(하드디스크 쪽)으로 갈수록 물리적 관점**입니다.

### 📘 논리적 데이터 독립성

**논리적(Logical)**이라는 말은 곧 **"사용자 관점"**입니다. 사용자가 데이터를 바라보는 시각, 사용자가 이해하는 데이터의 구조, 이런 것들이 논리적 관점입니다.

**논리적 데이터 독립성**이란, **기존 응용 프로그램에 영향을 주지 않고 데이터베이스의 논리적 구조를 변경할 수 있는 능력**입니다. 다시 말해, 데이터베이스의 테이블 구조가 변경되더라도 기존에 동작하던 응용 프로그램은 수정 없이 그대로 사용할 수 있어야 한다는 것입니다.

비유를 들어볼게요. 도서관에서 책의 분류 체계(구조)를 바꿨다고 합시다. 기존에 "문학 → 소설 → 한국소설" 이렇게 분류하던 것을 "한국문학 → 현대소설"로 바꿨어요. 그런데 도서관 이용자는 여전히 검색 시스템에서 책 제목만 입력하면 원하는 책을 찾을 수 있습니다. **뒷단의 분류 체계(논리적 구조)가 바뀌어도, 이용자(응용 프로그램)의 사용법은 변하지 않는 것**이죠.

> 핵심 포인트: **데이터베이스 구조가 변경되어도 → 응용 프로그램은 영향받지 않는다** = 논리적 데이터 독립성

### 📗 물리적 데이터 독립성

**물리적(Physical)**이라는 말은 곧 **"하드웨어 관점"**, 즉 **저장 장치(하드디스크) 관점**입니다.

**물리적 데이터 독립성**이란, **응용 프로그램이나 논리적 구조에 영향을 주지 않고 물리적 구조(저장 장치)를 변경할 수 있는 능력**입니다. 하드웨어를 교체하거나 저장 방식을 바꾸더라도, 데이터베이스의 논리적 구조나 프로그램은 아무런 변경 없이 그대로 사용할 수 있어야 한다는 뜻입니다.

이건 마치 여러분 집의 냉장고를 바꾸는 것과 비슷합니다. 삼성 냉장고에서 LG 냉장고로 바꿨다고 해서, 냉장고 안에 넣는 음식이나 요리법이 달라지지는 않잖아요? **저장 장치(냉장고)를 바꿔도 데이터(음식)와 프로그램(요리법)은 그대로** 사용할 수 있는 것입니다.

그렇다면 물리적 변경은 **왜** 일어날까요? 바로 **시스템 성능 향상**을 위해서입니다. 여러분이 집 컴퓨터의 성능이 떨어지면 뭘 하나요? HDD를 SSD로 바꾸고, CPU를 업그레이드하고, 메모리를 늘리죠. 이렇게 **하드웨어를 교체할 때 프로그램이나 데이터 구조를 건드릴 필요 없이 그대로 사용할 수 있게 하는 것**, 이것이 물리적 데이터 독립성입니다.

> 핵심 포인트: **하드웨어(저장 장치)가 변경되어도 → 데이터베이스 구조와 프로그램은 영향받지 않는다** = 물리적 데이터 독립성

### 두 독립성 비교

| 구분 | 논리적 데이터 독립성 | 물리적 데이터 독립성 |
|------|-------------------|-------------------|
| **관점** | 사용자 관점 | 저장 장치(하드웨어) 관점 |
| **무엇이 변경?** | 데이터베이스의 논리적 구조(테이블 등) | 물리적 구조(하드디스크, 저장 방식 등) |
| **무엇이 영향받지 않아야?** | 응용 프로그램 | 데이터베이스 구조 + 응용 프로그램 |
| **목적** | 응용 프로그램과 자료 구조의 분리 | 성능 향상을 위한 하드웨어 변경 자유 |
| **비유** | 도서관 분류 체계를 바꿔도 검색 시스템은 그대로 | 냉장고를 바꿔도 요리법은 그대로 |

:::tip 논리적 vs 물리적 구분 팁
하나의 데이터베이스가 "논리적 데이터베이스"와 "물리적 데이터베이스" 두 개로 따로 존재하는 것이 **아닙니다**. 하나의 데이터베이스를 **사용자가 보는 관점은 논리적 관점**, **저장 장치가 보는 관점은 물리적 관점**인 것입니다. 그리고 이 논리적 구조와 물리적 구조 사이에는 서로 **매핑(연결)**할 수 있는 능력이 존재합니다. 사용자가 변경한 내용이 하드디스크에도 반영되어야 하니까요!
:::

---

## 🏗️ 3단계 데이터베이스 구조와 스키마

### 스키마와 인스턴스: 구조 vs 값

3단계 데이터베이스를 이해하기 전에, 먼저 **스키마(Schema)**라는 개념을 확실히 알아야 합니다.

**스키마**는 한마디로 **"구조"**입니다. 데이터베이스의 뼈대, 설계도라고 생각하면 됩니다. 반대말은 **인스턴스(Instance)**로, 이는 **"실제 값"**을 의미합니다.

마치 엑셀 파일에 비유하면:
- **스키마**: 엑셀의 열 제목 (학번, 이름, 학과, 점수) → 구조
- **인스턴스**: 실제 입력된 데이터 (20001, 김철수, 컴퓨터공학, 85점) → 값

스키마에는 다음과 같은 정보들이 포함됩니다:

- **개체(Entity)**: 데이터의 대상. 예를 들어 "학생 테이블", "교수 테이블"
- **속성(Attribute)**: 개체가 가진 특성. 예를 들어 학생 테이블의 "학번", "이름", "학과"
- **관계(Relationship)**: 개체와 개체 사이의 연결. 예를 들어 학생과 교수 사이의 "지도" 관계, 학생과 과목 사이의 "수강" 관계
- **제약 조건(Constraint)**: 데이터가 지켜야 할 규칙. 예를 들어 "점수는 0점에서 100점까지만 가능하다"

이러한 정보들이 컴파일(번역·처리)되어 **데이터 사전(Data Dictionary)**이라는 곳에 **메타데이터(데이터에 대한 데이터)** 형태로 저장됩니다.

```sql
-- ✅ 스키마의 예: 학생 테이블의 구조를 정의하는 것
CREATE TABLE 학생 (
    학번 INT PRIMARY KEY,        -- 학번: 정수형, 기본키(고유 식별자)
    이름 VARCHAR(50),             -- 이름: 가변 문자열, 최대 50자
    학과 VARCHAR(100),            -- 학과: 가변 문자열, 최대 100자
    점수 INT CHECK (점수 >= 0 AND 점수 <= 100)  -- 점수: 0~100 사이만 허용 (제약 조건)
);
```

```sql
-- ✅ 인스턴스의 예: 실제 데이터 값을 넣는 것
INSERT INTO 학생 (학번, 이름, 학과, 점수) VALUES (20001, '김철수', '컴퓨터공학', 85);
INSERT INTO 학생 (학번, 이름, 학과, 점수) VALUES (20002, '이영희', '경영학', 92);
```

```sql
-- ❌ 잘못된 예: 제약 조건 위반 (점수가 100을 초과)
INSERT INTO 학생 (학번, 이름, 학과, 점수) VALUES (20003, '박민수', '물리학', 150);
-- 오류 발생! 점수는 0~100 사이만 가능하도록 스키마에서 제약 조건을 걸었기 때문
```

위 코드를 한 줄씩 살펴보겠습니다:

1. `CREATE TABLE 학생`: "학생"이라는 이름의 테이블(표)을 만드는 명령입니다. 이것이 바로 스키마를 정의하는 것입니다.
2. `학번 INT PRIMARY KEY`: "학번"이라는 열(속성)을 만드는데, 정수(INT) 타입이고 기본키(PRIMARY KEY)로 지정합니다. 기본키란 각 행을 고유하게 구별하는 식별자입니다.
3. `이름 VARCHAR(50)`: "이름"이라는 열을 만드는데, 최대 50글자까지 저장할 수 있는 가변 문자열(VARCHAR) 타입입니다.
4. `점수 INT CHECK (점수 >= 0 AND 점수 <= 100)`: "점수"라는 열에 **제약 조건**을 걸어서, 0점 미만이거나 100점 초과인 값은 입력할 수 없게 막습니다.
5. `INSERT INTO 학생 ... VALUES ...`: 실제 데이터 값을 테이블에 넣는 명령입니다. 이것이 인스턴스를 생성하는 것입니다.

### 3단계 스키마 구조

이 스키마(구조)를 **어떤 관점에서 보느냐**에 따라 세 가지로 나뉩니다. 이것이 바로 **3단계 데이터베이스 구조**이며, 데이터 독립성을 지키기 위해 만들어진 표준 이론입니다.

```
[사용자 A] [사용자 B] [사용자 C]
     ↓          ↓          ↓
[외부 스키마1] [외부 스키마2] [외부 스키마3]   ← 사용자 개인 관점 (여러 개)
            ↓
         [개념 스키마]                        ← 조직 전체 관점 (1개)
            ↓
         [내부 스키마]                        ← 저장 장치 관점 (1개)
            ↓
         [하드디스크]                          ← 물리적 저장 장치
```

#### 📌 외부 스키마 (External Schema)

**외부 스키마**는 **사용자 개인이 보는 관점의 구조**입니다. 사용자마다 필요한 데이터가 다르기 때문에, 전체 데이터베이스에서 **부분적으로 필요한 것만 꺼내서 보여주는 것**입니다. 그래서 외부 스키마는 **여러 개 존재**합니다.

외부 스키마는 전체의 부분이기 때문에 **서브 스키마(Sub Schema)**라고도 부릅니다. 이것이 바로 우리가 아는 **뷰(View)**의 개념입니다.

**은행 계좌 예시**로 이해해 봅시다:

```sql
-- ✅ 개념 스키마: 은행 계좌 테이블 전체 (하나)
CREATE TABLE 은행계좌 (
    계좌번호 VARCHAR(20) PRIMARY KEY,   -- 계좌를 구별하는 고유 번호
    고객명 VARCHAR(50),                  -- 계좌 소유자 이름
    잔액 DECIMAL(15, 2),                 -- 현재 잔액
    계좌유형 VARCHAR(20),                -- 입출금/적금/외화 등
    개설일 DATE,                         -- 계좌를 만든 날짜
    지점코드 VARCHAR(10)                 -- 계좌가 속한 은행 지점
);
```

```sql
-- ✅ 외부 스키마 1: 입금 업무에 필요한 뷰 (부분만 보여줌)
CREATE VIEW 입금뷰 AS
SELECT 계좌번호, 고객명, 잔액    -- 입금에 필요한 정보만 선택
FROM 은행계좌;

-- ✅ 외부 스키마 2: 출금 업무에 필요한 뷰
CREATE VIEW 출금뷰 AS
SELECT 계좌번호, 고객명, 잔액, 계좌유형    -- 출금 시 계좌유형도 필요
FROM 은행계좌;

-- ✅ 외부 스키마 3: 이체 업무에 필요한 뷰
CREATE VIEW 이체뷰 AS
SELECT 계좌번호, 고객명, 잔액, 지점코드    -- 이체 시 지점코드도 필요
FROM 은행계좌;
```

```sql
-- ❌ 잘못된 이해: 외부 스키마가 별도의 독립 테이블이라고 생각하는 것
-- 외부 스키마(뷰)는 독립적인 테이블이 아니라, 개념 스키마(원본 테이블)에서
-- 부분적으로 꺼내서 보여주는 "창문" 같은 것입니다.
```

위 코드를 한 줄씩 설명합니다:

1. `CREATE VIEW 입금뷰 AS`: "입금뷰"라는 이름의 뷰(외부 스키마)를 만드는 명령입니다.
2. `SELECT 계좌번호, 고객명, 잔액`: 전체 테이블에서 입금 업무에 필요한 세 가지 열만 선택합니다.
3. `FROM 은행계좌`: 원본 데이터가 있는 "은행계좌" 테이블에서 가져온다는 뜻입니다.

이처럼 하나의 은행계좌 테이블(개념 스키마)에서, 입금·출금·이체 등 각각의 업무에 필요한 부분만 꺼내서 보여주는 것이 외부 스키마입니다. 사용자마다 요구사항이 다르니, 자연스럽게 여러 개가 존재하게 됩니다.

#### 📌 개념 스키마 (Conceptual Schema)

**개념 스키마**는 **기관·조직 전체 입장에서 통합하여 기술한 구조**입니다. 위의 은행 예시에서 "은행계좌" 테이블 전체가 바로 개념 스키마입니다. 개념 스키마는 조직 전체를 하나로 통합한 것이므로 **단 하나만 존재**합니다.

우리가 일반적으로 아무 수식어 없이 그냥 **"스키마"**라고 하면, 이것은 **개념 스키마**를 가리킵니다. 개념 스키마에는 개체, 속성, 관계, 제약 조건은 물론이고 접근 권한, 보안 규칙, 무결성 규칙 등 모든 정보가 포함되어 있습니다. 다른 말로 **조직 논리 단계**라고도 표현합니다.

#### 📌 내부 스키마 (Internal Schema)

**내부 스키마**는 **저장 장치 입장에서 데이터가 실제로 어떻게 저장되는지를 명세한 구조**입니다. 저장 장치는 하나이므로 내부 스키마도 **단 하나만 존재**합니다.

내부 스키마에는 다음과 같은 정보가 담깁니다:
- 실제 저장될 **내부 레코드 형식**이 어떤지
- **인덱스(색인)**가 있는지, 어떤 방식인지
- 데이터의 **타입** (정수인지, 실수인지, 문자열인지, 날짜인지)
- 데이터의 **물리적 저장 순서**는 어떻게 할 것인지

여기서 중요한 점이 하나 있습니다. 내부 스키마는 **물리적 단계(실제 하드디스크) 그 자체가 아니라, 물리적 단계보다 한 단계 위에 존재하는 구조**입니다. 실제 하드디스크를 관리하는 것은 **운영체제(OS)**가 담당합니다. 사용자가 DBMS를 통해 저장 명령을 내리면, 그 권한이 운영체제로 넘어가고, 운영체제가 실제 저장을 수행하는 것입니다.

| 스키마 종류 | 관점 | 개수 | 포함 정보 | 별칭 |
|------------|------|------|----------|------|
| 외부 스키마 | 사용자 개인 | 여러 개 | 사용자별 필요한 부분적 구조 | 서브 스키마, 뷰 |
| 개념 스키마 | 조직 전체 | 1개 | 개체, 속성, 관계, 제약 조건, 보안 등 전체 | 그냥 "스키마" |
| 내부 스키마 | 저장 장치 | 1개 | 레코드 형식, 인덱스, 데이터 타입, 저장 순서 | - |

### 3단계 간의 매핑(사상)과 인터페이스

이 3단계 스키마들은 서로 **매핑(Mapping, 사상)**을 통해 연결됩니다. 각 단계 사이의 연결 통로를 **인터페이스**라고 부릅니다.

- **사용자 ↔ 외부 스키마**: **사용자 인터페이스** (사용자가 데이터에 접근하는 창구)
- **외부 스키마 ↔ 개념 스키마**: **응용 인터페이스** (부분과 전체를 연결)
- **개념 스키마 ↔ 내부 스키마**: **저장 인터페이스** (논리적 구조와 물리적 저장을 연결)

:::note 인스턴스 복습
스키마의 반대말인 **인스턴스**는 "어느 특정 순간에 데이터베이스에 저장되어 있는 **실제 정보(값)**"를 의미합니다. 스키마가 건물의 설계도라면, 인스턴스는 그 건물에 실제로 살고 있는 사람들의 정보인 셈이죠. 이 두 용어는 데이터베이스의 가장 기본적인 용어이므로 반드시 기억해 두세요!
:::

---

## 🗄️ 데이터 사전, 데이터 언어, 사용자

### 데이터 사전 (Data Dictionary)

**데이터 사전**이란, 데이터베이스에 포함되는 **모든 데이터에 대한 정의·명세 정보가 저장되어 있는 곳**입니다. **시스템 카탈로그(System Catalog)**라고도 부릅니다.

데이터 정의어(DDL)를 통해 구조를 만들면, 이 구조가 컴파일되어 데이터 사전에 **메타데이터(데이터에 대한 데이터)** 형태로 저장됩니다. 데이터 사전에는 다음과 같은 정보들이 들어 있습니다:

- 외부 스키마, 개념 스키마, 내부 스키마에 대한 정보
- 사용자 인터페이스, 응용 인터페이스, 저장 인터페이스 등 매핑 정보
- 질의 최적화(검색을 빠르게 하기 위한 최적 경로 정보)에 대한 정보
- 보안, 권한, 무결성에 대한 정보

데이터 사전 자체도 일반 테이블처럼 구성되어 있어서, 사용자가 **SQL 질의어로 조회(검색)**할 수는 있습니다. 하지만 매우 중요한 주의사항이 있습니다:

:::danger 절대 하면 안 되는 것
데이터 사전(시스템 카탈로그)에 저장된 정보는 **메타데이터**이기 때문에, 사용자가 `INSERT`, `UPDATE`, `DELETE` 명령으로 **직접 내용을 삽입하거나 갱신할 수 없습니다.** 일반 테이블에 대해 삽입·삭제·갱신을 하면, DBMS가 **자동으로** 컴파일하여 메타데이터를 만들어 사전에 반영합니다. 이것을 **자기정의(Self-describing)** 특성이라고 합니다. 데이터베이스는 스스로 컴파일해서, 스스로 메타데이터를 만들어서, 스스로 저장합니다.
:::

```sql
-- ✅ 올바른 방법: 일반 테이블을 변경하면 DBMS가 자동으로 사전에 반영
ALTER TABLE 학생 ADD 이메일 VARCHAR(100);
-- 학생 테이블에 '이메일' 열을 추가하면,
-- DBMS가 자동으로 데이터 사전의 메타데이터를 갱신합니다.
```

```sql
-- ❌ 잘못된 방법: 데이터 사전을 직접 수정하려는 시도
-- UPDATE 시스템카탈로그 SET ... WHERE ...;
-- 이런 방식으로 데이터 사전의 내용을 직접 바꿀 수 없습니다!
```

**데이터 디렉터리(Data Directory)**라는 것도 있는데, 이것은 데이터 사전에 접근하기 위한 정보를 관리하는 시스템입니다. 운영체제 탐색기의 폴더처럼, 사전 안에 들어있는 정보를 관리하는 역할입니다.

| 구분 | 데이터 사전 (시스템 카탈로그) | 데이터 디렉터리 |
|------|---------------------------|---------------|
| **역할** | 메타데이터 자체를 저장 | 사전에 접근하기 위한 정보 관리 |
| **사용자 접근** | 가능 (조회만) | 불가능 (시스템만 접근) |
| **공통점** | 메타데이터 관리 | 메타데이터 관리 |

### 데이터 언어 (Data Language)

데이터베이스에서 사용하는 언어는 크게 세 가지로 나뉩니다.

#### 1️⃣ 데이터 정의어 (DDL - Data Definition Language)

데이터베이스를 **만들고, 수정하고, 삭제**하는 목적으로 사용되는 언어입니다. 마치 건축가가 건물의 설계도를 그리고, 수정하고, 폐기하는 것과 같습니다.

| 명령어 | 기능 | 쉬운 설명 |
|--------|------|----------|
| `CREATE` | 생성 | 테이블(구조)을 새로 만든다 |
| `ALTER` | 변경 | 이미 만든 테이블의 구조를 수정한다 |
| `DROP` | 삭제 | 테이블 자체를 완전히 없앤다 |

DDL은 주로 **DBA(데이터베이스 관리자)**가 사용합니다.

```sql
-- ✅ CREATE: 새로운 테이블 생성
CREATE TABLE 교수 (
    교수번호 INT PRIMARY KEY,    -- 교수 고유 번호
    교수명 VARCHAR(50),          -- 교수 이름
    학과 VARCHAR(100)            -- 소속 학과
);

-- ✅ ALTER: 기존 테이블에 열 추가
ALTER TABLE 교수 ADD 연락처 VARCHAR(20);
-- 교수 테이블에 '연락처' 열을 새로 추가

-- ✅ DROP: 테이블 자체를 삭제
DROP TABLE 교수;
-- 교수 테이블이 완전히 사라짐 (데이터도 구조도 모두 삭제)
```

#### 2️⃣ 데이터 조작어 (DML - Data Manipulation Language)

일반 프로그래머나 사용자가 데이터를 **검색, 삽입, 삭제, 갱신**하는 데 사용하는 언어입니다. 가장 많이, 보편적으로 사용되는 명령어들이죠.

데이터 조작어는 다시 **절차적 데이터 조작어**와 **비절차적 데이터 조작어**로 나뉩니다.

| 구분 | 절차적 데이터 조작어 | 비절차적 데이터 조작어 |
|------|-------------------|---------------------|
| **명세 범위** | What(무엇) + How(어떻게) 둘 다 | What(무엇)만 |
| **언어 수준** | 저급 언어 | 고급 언어 |
| **독자 사용** | 불가능 (프로그램 안에서만) | 가능 (독자적으로도 사용 가능) |
| **사용 방식** | 호스트 프로그램에 내장 | 독자적 또는 프로그램에 삽입 |
| **처리 단위** | 한 번에 하나의 레코드 | 한 번에 여러 개 레코드 (집합 단위) |

비유를 들어볼게요. **절차적 데이터 조작어**는 마치 요리사에게 "김치찌개를 만들어 주세요. 먼저 물을 끓이고, 김치를 넣고, 돼지고기를 넣고, 두부를 넣고, 10분간 끓이세요"라고 **과정까지 모두 설명**하는 것입니다.

반면 **비절차적 데이터 조작어**는 "김치찌개 하나요!"라고 **원하는 결과만 말하는 것**입니다. 어떻게 만들지는 요리사(DBMS)가 알아서 처리합니다. 우리가 흔히 사용하는 **SQL**이 바로 비절차적 데이터 조작어의 대표적인 예입니다.

```sql
-- ✅ 비절차적 데이터 조작어 (SQL) 예시
-- "무엇(What)"만 명세: 컴퓨터공학과 학생의 이름과 점수를 알고 싶다
SELECT 이름, 점수           -- 원하는 데이터(What)만 지정
FROM 학생                   -- 어디서 가져올지 지정
WHERE 학과 = '컴퓨터공학';  -- 조건 지정
-- "어떻게(How)" 찾을지는 DBMS가 알아서 최적의 방법으로 처리!
```

```sql
-- ✅ 데이터 삽입
INSERT INTO 학생 (학번, 이름, 학과, 점수) VALUES (20003, '박민수', '물리학', 78);
-- 학생 테이블에 새로운 학생 데이터를 한 줄 삽입

-- ✅ 데이터 갱신
UPDATE 학생 SET 점수 = 90 WHERE 학번 = 20001;
-- 학번이 20001인 학생의 점수를 90으로 변경

-- ✅ 데이터 삭제
DELETE FROM 학생 WHERE 학번 = 20002;
-- 학번이 20002인 학생의 데이터를 삭제
```

위 SQL 코드를 한 줄씩 살펴보겠습니다:

1. `SELECT 이름, 점수`: 결과로 보고 싶은 열(속성)을 지정합니다. "이름과 점수를 보여줘"라는 의미입니다.
2. `FROM 학생`: 데이터를 가져올 테이블을 지정합니다. "학생 테이블에서"라는 의미입니다.
3. `WHERE 학과 = '컴퓨터공학'`: 조건을 걸어서 원하는 행만 필터링합니다. "학과가 컴퓨터공학인 것만"이라는 의미입니다.
4. `INSERT INTO 학생 ... VALUES ...`: 학생 테이블에 새로운 행(레코드)을 추가합니다.
5. `UPDATE 학생 SET 점수 = 90 WHERE 학번 = 20001`: 학번이 20001인 학생의 점수 값을 90으로 바꿉니다.
6. `DELETE FROM 학생 WHERE 학번 = 20002`: 학번이 20002인 학생의 행을 완전히 삭제합니다.

#### 3️⃣ 데이터 제어어 (DCL - Data Control Language)

데이터를 **제어**하는 언어입니다. 프로그램이 올바르게, 무결성을 유지하면서, 동시에 많은 사람들이 사용할 수 있도록 관리하는 데 필요합니다. 주로 **DBA(관리자)**가 사용합니다.

데이터 제어어가 담당하는 기능:
- **보안(Security)**: 권한이 없는 사용자의 접근을 차단
- **무결성(Integrity)**: 데이터의 정확성을 유지
- **회복(Recovery)**: 장애가 발생했을 때 데이터를 복구
- **병행 제어(Concurrency Control)**: 동시에 많은 사용자가 접속할 때 충돌 방지, 우선순위 관리

### 사용자 유형

데이터베이스를 사용하는 사람은 크게 세 유형으로 나뉩니다:

- **일반 사용자**: 데이터베이스를 일상적으로 사용하는 사람. 주로 검색, 조회 등을 수행합니다.
- **프로그래머(응용 프로그래머)**: 프로그램을 개발하는 개발자. DML을 사용하여 데이터를 조작하는 프로그램을 만듭니다.
- **DBA(Database Administrator, 데이터베이스 관리자)**: 데이터베이스 시스템에 대한 **모든 책임**을 지는 사람. 주로 DDL과 DCL을 사용하여 데이터를 정의하고 제어합니다. DB와 관련된 모든 일은 DBA가 수행한다고 보면 됩니다.

---

## 💻 데이터베이스 시스템의 구조

### 데이터베이스 시스템 vs DBMS

이 두 용어를 혼동하는 분들이 많은데, 분명히 다른 개념입니다.

- **DBMS(데이터베이스 관리 시스템)**: 데이터베이스를 관리하는 **소프트웨어** (예: MySQL, Oracle, PostgreSQL)
- **데이터베이스 시스템(DBS)**: 데이터베이스 + DBMS + 데이터 언어 + 사용자 + DBA + 컴퓨터를 **모두 합친 전체 시스템**

> **데이터베이스 시스템 안에 DBMS가 포함**되어 있습니다. DBMS는 시스템의 일부이고, 데이터베이스 시스템은 전체를 아우르는 큰 개념입니다.

### 시스템 구조의 유형

데이터베이스 시스템은 규모와 방식에 따라 여러 구조로 나뉩니다.

#### 중앙 집중 데이터베이스

데이터베이스가 **한 곳에만 집중**되어 있는 구조입니다. 범용 컴퓨터(메인프레임) 하나를 가운데 놓고, 여러 사용자가 연결하여 사용하는 전통적인 방식입니다. 여러 개의 CPU와 공유 메모리, 공동 버스로 연결된 장치 제어기를 갖추고 있습니다.

| 구분 | 단일 사용자 시스템 | 다수 사용자 시스템 |
|------|-------------------|-------------------|
| **규모** | 개인용 컴퓨터 | 대형 서버 (구글, 네이버 등) |
| **CPU** | 1개 | 다수 |
| **사용자** | 나 혼자 | 수많은 동시 접속자 |

#### 클라이언트-서버 시스템

우리가 사용하는 **인터넷 환경**이 바로 이 구조입니다. 기능이 두 가지로 나뉘어 있습니다:

- **전처리(Front-end) 기능 = 클라이언트 단**: 사용자 화면에 보여주는 것, 입력받는 것, 출력하는 것. 즉, 사용자와 직접 만나는 부분입니다.
- **후처리(Back-end) 기능 = 서버 단**: 데이터베이스를 관리하고, 질의를 최적화하고, 동시성을 제어하고, 장애 시 회복하는 것. 즉, 뒤에서 묵묵히 일하는 부분입니다.

#### 병렬 데이터베이스 시스템

**슈퍼컴퓨터**처럼 여러 개의 강력한 처리기(CPU)를 고속 네트워크로 연결하여 **동시에 빠르게 처리**하는 시스템입니다. 대량의 CPU(수천 개)가 연결되어 처리됩니다.

병렬 시스템의 구조는 네 가지로 나뉩니다:

**1. 공유 메모리 구조**: 여러 CPU가 **하나의 메모리를 공유**합니다.
- 장점: 메모리에 데이터만 있으면 모든 처리기에서 바로 접근 가능, 데이터를 소프트웨어로 이동시킬 필요 없음
- 단점: **메모리가 병목 구간**이 됩니다. 모든 CPU가 하나의 메모리로 몰리니까요. CPU를 아무리 많이 늘려도 메모리 병목 때문에 성능이 비례해서 향상되지 않습니다.
- 사용 환경: 병렬 정도가 낮은 경우에 적합

**2. 공유 디스크 구조**: 각 CPU가 **자기만의 메모리**를 갖고 있지만, **디스크는 공유**합니다.
- 장점: 메모리 병목은 발생하지 않음
- 단점: **디스크가 병목 구간**이 됩니다. 처리기 간 데이터를 주고받을 때 성능이 떨어집니다.

**3. 무공유(Shared-Nothing) 구조**: 각 CPU가 **자기만의 메모리와 디스크**를 갖고 있고, **네트워크로만 연결**됩니다.
- 장점: 간섭이나 병목 현상이 거의 발생하지 않음
- 각자 자기 것을 알아서 사용하는 방식

**4. 계층 구조**: 위의 구조들을 **복합적으로 조합**한 것입니다. 예를 들어, 메모리를 공유하는 그룹끼리 다시 계층적으로 묶어서 사용합니다.

| 구조 | 공유 자원 | 병목 구간 | 특징 |
|------|----------|----------|------|
| 공유 메모리 | 메모리 | 메모리 | CPU 추가해도 성능 한계 |
| 공유 디스크 | 디스크 | 디스크 | 처리기간 데이터 교환 시 성능 저하 |
| 무공유 | 없음 (네트워크만) | 거의 없음 | 간섭 최소, 각자 독립 |
| 계층 | 복합 | 복합 | 여러 구조의 장점 통합 |

#### 분산 데이터베이스 시스템

데이터를 **여러 지역에 분산**시켜서 네트워크로 연결하여 사용하는 시스템입니다. 각 지역(사이트)은 자기 데이터에 대한 **제어권을 갖고 독자적으로 관리**합니다.

- **장점**: 데이터가 중복 저장되어 있으므로 **가용성(고장 나도 이용 가능)**이 높고 **신뢰성**이 좋습니다.
- **단점**: 시스템이 **복잡**하고, 비용이 많이 들며, **오류가 잠재**되어 있습니다.

:::tip 데이터베이스 시스템 구조 요약
- **중앙 집중**: 한 곳에 모아서 관리 (전통적)
- **클라이언트-서버**: 화면 담당(클라이언트)과 데이터 담당(서버) 분리 (인터넷)
- **병렬**: 여러 CPU를 연결해서 빠르게 처리 (슈퍼컴퓨터)
- **분산**: 여러 지역에 데이터를 나눠서 저장·관리 (네트워크)
:::

---

## ⚠️ 주의사항과 실전 팁

### 자주 혼동하는 개념들

**1. 독립성의 방향을 헷갈리지 마세요!**

독립성은 항상 **"하위 단계가 변경되었을 때 → 상위 단계가 영향받지 않는다"**의 방향입니다. 이 방향을 거꾸로 이해하면 시험에서 틀리게 됩니다.

```
❌ 잘못된 이해: "응용 프로그램을 변경했을 때 → 자료 구조를 그대로 사용할 수 있다"
✅ 올바른 이해: "자료 구조를 변경했을 때 → 응용 프로그램을 그대로 사용할 수 있다"
```

**2. "그냥 스키마" = 개념 스키마**

아무 수식어 없이 "스키마"라고 하면 외부 스키마도 내부 스키마도 아닌, **개념 스키마**를 가리킵니다. 시험 문제에서 "스키마는 하나만 존재한다"라는 표현이 나오면, 이것은 개념 스키마를 말하는 것입니다.

**3. 데이터 사전은 직접 수정 불가**

데이터 사전(시스템 카탈로그)은 조회(SELECT)는 가능하지만, 직접적인 삽입(INSERT)·수정(UPDATE)·삭제(DELETE)는 **불가능**합니다. 일반 테이블을 조작하면 DBMS가 **자동으로** 사전을 갱신합니다.

**4. 논리적 = 사용자 관점 / 물리적 = 저장 장치 관점**

이 매핑만 확실히 기억하면 논리적 독립성과 물리적 독립성을 절대 헷갈리지 않습니다.

### 실전에서 만나는 데이터 독립성

실제 개발 현장에서 데이터 독립성은 어떻게 체감될까요?

**논리적 독립성 예시**: 회사에서 고객 테이블에 "SNS 계정"이라는 새로운 열을 추가했습니다. 기존에 돌아가던 주문 관리 프로그램은 "SNS 계정" 열과 아무 관계가 없으므로, 수정 없이 그대로 정상 작동합니다. 이것이 논리적 독립성이 작동하는 모습입니다.

**물리적 독립성 예시**: 서버실의 HDD(하드 디스크 드라이브)를 SSD(솔리드 스테이트 드라이브)로 교체했습니다. 저장 장치가 완전히 바뀌었지만, 데이터베이스의 테이블 구조도, 응용 프로그램도 아무것도 바꿀 필요가 없습니다. 그저 속도만 빨라졌을 뿐이죠. 이것이 물리적 독립성이 작동하는 모습입니다.

:::warning 절차적 vs 비절차적 조작어 구분 팁
- **절차적**: What + How 모두 명세 / 저급 언어 / 독자 사용 불가 / 한 번에 1개 레코드
- **비절차적**: What만 명세 / 고급 언어 / 독자 사용 가능 / 한 번에 여러 개 레코드 (집합 단위)
- 우리가 보통 사용하는 **SQL은 비절차적** 데이터 조작어입니다!
:::

---

## 📌 핵심 정리

- **데이터 독립성**은 데이터베이스의 구조나 내용이 변경되어도 응용 프로그램을 수정 없이 그대로 사용할 수 있는 능력이다
- **DBMS의 궁극적 목표**는 응용 프로그램이 데이터에 종속되지 않도록 하는 것, 즉 데이터 독립성을 보장하는 것이다
- 독립성의 방향: **하위 단계가 변경되어도 → 상위 단계는 영향받지 않는다**
- **논리적 독립성**: 사용자 관점. DB의 논리적 구조가 바뀌어도 응용 프로그램은 그대로
- **물리적 독립성**: 저장 장치 관점. 하드웨어가 바뀌어도 DB 구조와 프로그램은 그대로 (성능 향상 목적)
- **스키마**: 데이터베이스의 구조 / **인스턴스**: 실제 저장된 값
- **외부 스키마**: 사용자 개인 관점, 여러 개 존재, 뷰(View), 서브 스키마라고도 함
- **개념 스키마**: 조직 전체 관점, 1개만 존재, 그냥 "스키마"라고 하면 이것
- **내부 스키마**: 저장 장치 관점, 1개만 존재, 레코드 형식·인덱스·데이터 타입 등 포함
- **데이터 사전(시스템 카탈로그)**: 메타데이터가 저장되는 곳, 조회만 가능하고 직접 수정 불가
- **데이터 언어**: 정의어(DDL: CREATE/ALTER/DROP), 조작어(DML: SELECT/INSERT/UPDATE/DELETE), 제어어(DCL: 보안/무결성/회복/병행제어)
- **비절차적 조작어(SQL)**: What만 명세, 고급 언어, 독자 사용 가능, 집합 단위 처리
- **데이터베이스 시스템 = DB + DBMS + 데이터 언어 + 사용자 + DBA + 컴퓨터** (DBMS보다 큰 개념)
- 시스템 구조: 중앙 집중, 클라이언트-서버, 병렬(공유 메모리/공유 디스크/무공유/계층), 분산

작성일: 2026-02-20