---
title: "무결성 규정과 제약 조건 설정"
description: "무결성 규정과 제약 조건 설정에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/database-integrity-and-security/4-integrity-rules-and-constraints"
sidebar_label: "무결성 규정"
date: "2026-02-21"
---

## 🎯 무결성이란 무엇인가?

데이터베이스를 공부하다 보면 **무결성(Integrity)**이라는 단어를 정말 자주 만나게 됩니다. 개체 무결성, 참조 무결성, 도메인 무결성, 키 무결성… 여기저기서 "무결성"이라는 말이 등장하죠. 그런데 이 "무결성"이라는 단어가 처음에는 꽤 어렵게 느껴질 수 있습니다.

**무결(無缺)**이라는 한자를 풀어보면, "결점이 없다"는 뜻입니다. 즉, 데이터베이스에서 무결성이란 **"데이터가 갖고 있는 값이 정확하다"**는 의미입니다. 한마디로 바꿔 말하면, 무결성은 곧 **정확성**입니다.

> **무결성(Integrity) = 데이터의 정확성**
> 데이터베이스에 저장된 데이터가 결점 없이 정확한 상태를 유지하는 것을 의미합니다.

### 🏦 왜 무결성이 중요한가?

아무리 성능이 뛰어난 시스템이라도, 만약 **만 번에 한 번씩 잘못된 결과**가 나온다면 그 시스템은 현업에서 절대 사용할 수 없습니다.

은행 시스템을 떠올려 보세요. 예금을 입금하고, 출금하고, 이체하고, 조회하는 시스템이 있다고 합시다. 이 시스템이 만 번에 한 번씩이라도 이상 현상이 생긴다면 어떻게 될까요?

- 내 통장에 잔액이 **1만 원**밖에 없었는데, 갱신 오류로 갑자기 **10억 원**이 들어와 버린다면?
- 반대로, **10억 원**이 있던 통장이 갑자기 잔액이 **0원**으로 되어버린다면?

이런 상황이 발생하면, 아무리 드문 확률이라도 그 시스템은 **사용 불가**입니다. 마치 비행기가 만 번에 한 번 추락한다고 하면 아무도 그 비행기를 타지 않는 것과 같은 이치입니다.

### ⚖️ 성능과 무결성의 트레이드오프(Trade-off)

여기서 중요한 개념이 하나 등장합니다. 바로 **성능(Performance)**과 **무결성(Integrity)**은 **트레이드오프(한쪽을 올리면 다른 쪽이 내려가는) 관계**라는 것입니다.

| 구분 | 설명 |
|------|------|
| **무결성을 높이면** | 이것저것 검사하고 제약을 걸어야 하므로 → **성능이 떨어짐** |
| **성능을 높이면** | 검사를 줄이고 빠르게 처리하므로 → **무결성이 떨어짐** |

무결성을 높인다는 것은 "잠깐만, 이거 검사해야 돼!", "이건 규정에 맞지 않으니까 안 돼!"처럼 **제약이 많아진다**는 뜻입니다. 제약이 많아지면 당연히 처리 속도는 느려질 수밖에 없죠.

하지만 데이터베이스 시스템에서는 **성능을 향상시키는 것보다 무결성을 유지하는 것이 더 중요**합니다. 아무리 빨라도 결과가 틀리면 의미가 없기 때문입니다.

:::info 무결성은 누가 유지하나요?
무결성은 사용자나 개발자, 데이터베이스 관리자(DBA)가 직접 하나하나 확인하는 것이 **아닙니다**. 사용자가 **무결성 규정(규칙)을 설정**해 놓으면, DBMS(데이터베이스 관리 시스템) 안에 있는 **무결성 서브시스템**이 자동으로 무결성을 유지해 줍니다. 마치 보안 카메라를 설치해 놓으면 사람이 직접 감시하지 않아도 카메라가 알아서 녹화하는 것과 같습니다.
:::

---

## 🔐 무결성과 보안의 차이

무결성을 공부할 때 **보안(Security)**이라는 개념과 헷갈리기 쉽습니다. 이 둘은 비슷해 보이지만 **완전히 다른 개념**입니다.

| 구분 | 무결성(Integrity) | 보안(Security) |
|------|-------------------|----------------|
| **대상** | 승인된(정상적인) 사용자 | 승인되지 않은(불법적인) 사용자 |
| **목적** | 데이터의 **정확성** 유지 | 불법 접근으로부터 데이터 **보호** |
| **동작 시점** | 정상적인 작업(검색, 삽입, 삭제, 갱신) 과정에서 | 시스템에 접근하는 단계에서 |
| **비유** | 요리사가 레시피대로 정확하게 요리하는 것 | 주방에 허가받지 않은 사람이 들어오지 못하게 막는 것 |

사용자가 데이터베이스에 접근하면, 가장 먼저 만나는 것이 **보안 서브시스템**입니다. 여기서 아이디와 패스워드를 확인하고, 권한이 정상적인지 검증합니다. 이 과정을 통과하면, 그 다음에 만나는 것이 **무결성 서브시스템**입니다. 정상적인 사용자가 작업을 수행할 때 데이터의 정확성이 깨지지 않도록 지켜주는 역할을 합니다.

> 🔑 **보안** = 문 앞의 경비원 (허가받지 않은 사람의 출입을 막는다)
> 🛡️ **무결성** = 건물 안의 품질 관리자 (허가받은 사람이 일할 때 실수가 없도록 검사한다)

---

## 📋 무결성 규정(Integrity Rule)의 구조

### 무결성 규정이란?

무결성 규정이란, **"데이터가 만족해야 하는 조건을 정의해 놓고, 그 조건을 위반했을 때 어떤 조치를 취할 것인지 명세해 둔 것"**입니다. 영어로는 **Integrity Rule**이라고 합니다.

예를 들어 볼게요. "시험 점수는 0점에서 100점까지만 입력할 수 있다"라는 규정을 만들어 놓았다고 합시다. 누군가 120점을 입력하면, 무결성 서브시스템이 자동으로 이를 감지하고 "입력 값을 다시 확인해 주세요"라는 오류 메시지를 보여주며 **갱신을 거부**합니다. 이렇게 하면 자연스럽게 무결성이 유지됩니다.

### 무결성 규정의 4가지 구성 요소

무결성 규정은 다음 **4가지 요소**로 정의됩니다:

| 구성 요소 | 설명 | 예시 |
|-----------|------|------|
| **① 규정 이름** | 규정을 식별하기 위한 고유한 이름 (식별자) | R1, R2, R3... |
| **② 검사 시기** | 언제 무결성 검사를 수행할 것인지 | 삽입할 때, 갱신할 때, 삭제할 때 |
| **③ 제약 조건** | 데이터가 만족해야 하는 조건 | 점수 ≥ 0 AND 점수 ≤ 100 |
| **④ 위반 시 조치** | 제약 조건을 위반했을 때 취할 행동 | 오류 메시지 출력, 갱신 거부 |

**① 규정 이름**은 마치 법률에 "제1조", "제2조"처럼 번호를 붙이는 것과 같습니다. 하나의 시스템에는 수많은 무결성 규정이 존재하므로, 각 규정을 유일하게 식별하고 관리하기 위해 이름이 필요합니다.

**② 검사 시기**는 "언제 검사할 것인가?"를 결정합니다. 여기서 중요한 점은, **검색(SELECT) 작업은 데이터를 변경하지 않으므로 무결성 위반이 발생하지 않습니다**. 눈으로 보기만 하는 것이니까요. 따라서 무결성 검사는 **갱신(UPDATE), 삽입(INSERT), 삭제(DELETE)** 작업에서만 의미가 있습니다.

**③ 제약 조건(Constraint)**은 데이터가 반드시 만족해야 하는 규칙입니다. "점수는 0점 이상 100점 이하", "학년은 1~4학년", "성별은 남 또는 여" 같은 것들이 여기에 해당합니다.

**④ 위반 시 조치**는 제약 조건을 어겼을 때 시스템이 취하는 행동입니다. 보통은 오류 메시지를 출력하고 해당 작업을 거부(reject)합니다.

### 실제 무결성 규정 예시

아래는 무결성 규정을 프로그래밍한 예시입니다:

```sql
-- 무결성 규정 R1: STUDENT 테이블의 YEAR(학년) 값이 0보다 커야 한다
R1:                              -- ① 규정 이름: R1
AFTER UPDATING STUDENT.YEAR      -- ② 검사 시기: STUDENT 테이블의 YEAR를 갱신(UPDATE)한 후에
CHECK (STUDENT.YEAR > 0)         -- ③ 제약 조건: YEAR 값이 0보다 커야 한다
ELSE                             -- ④ 위반 시 조치:
  PRINT 'R1 VIOLATED'            --    오류 메시지 출력
  REJECT UPDATE                  --    갱신(UPDATE) 거부
END                              --    규정 종료
```

이 코드를 한 줄씩 자세히 살펴보겠습니다:

- **`R1:`** — 이 무결성 규정의 이름입니다. 나중에 이 규정을 참조하거나 수정할 때 이 이름으로 찾을 수 있습니다.
- **`AFTER UPDATING STUDENT.YEAR`** — "STUDENT 테이블의 YEAR 속성을 업데이트한 **후에(AFTER)** 검사하겠다"는 의미입니다. `BEFORE`를 쓰면 "업데이트 **전에**" 검사합니다.
- **`CHECK (STUDENT.YEAR > 0)`** — 제약 조건입니다. YEAR 값이 0보다 큰지 확인합니다. 학년이 0이거나 음수일 수는 없으니까요.
- **`ELSE`** — 위의 CHECK 조건을 **위반했을 때** 실행할 내용을 정의합니다.
- **`PRINT 'R1 VIOLATED'`** — "R1 규정을 위반했습니다"라는 메시지를 화면에 출력합니다.
- **`REJECT UPDATE`** — 해당 갱신 작업을 **거부**합니다. 잘못된 값이 데이터베이스에 저장되지 않도록 막아주는 것입니다.
- **`END`** — 규정 정의가 끝났음을 알립니다.

:::tip 핵심 패턴: AFTER → CHECK → ELSE
무결성 규정은 일반적으로 `AFTER(또는 BEFORE)` → `CHECK` → `ELSE` 순서로 작성됩니다. "**언제** 검사하고, **무엇을** 검사하고, **위반하면** 어떻게 할 것인가"라는 3단계 구조를 기억하세요!
:::

이렇게 사용자가 프로그래밍으로 규정을 설정해 놓으면, 시스템이 자동으로 무결성을 유지합니다. 위반 상황이 발생하면 자동으로 거부하고, 정상적인 값이면 자동으로 반영합니다. 사람이 일일이 감시할 필요가 없는 것이죠.

---

## 🗂️ 무결성의 종류

### 1. 도메인 무결성 (Domain Integrity)

**도메인(Domain)**이란 **속성이 가질 수 있는 값의 범위**를 말합니다. 넓게 보면 "이 속성은 정수 타입이다", "이 속성은 문자 타입이다" 같은 데이터 타입이 도메인이 될 수 있고, 좀 더 구체적으로 보면 "학년은 1~4학년까지만", "나이는 0~200까지만" 같은 값의 범위가 도메인입니다.

마치 자판기에 동전을 넣는 구멍이 있는데, 그 구멍에는 100원, 500원짜리만 들어갈 수 있고 다른 물건은 못 넣는 것과 비슷합니다. 속성(동전 구멍)에 넣을 수 있는 값(동전 종류)의 범위가 정해져 있는 것이죠.

**도메인 무결성**은 이 값의 범위가 유지되도록 하는 것입니다. 주어진 속성 값이 그 속성이 갖고 있는 도메인에 반드시 속해야 한다는 규정이죠.

```sql
-- ✅ 올바른 예시: 도메인 무결성 설정
-- 몸무게(WEIGHT) 속성의 도메인을 정의
CREATE DOMAIN WEIGHT AS DECIMAL(5, 1)  -- 전체 5자리, 소수점 이하 1자리
  CHECK (WEIGHT > 0 AND WEIGHT < 300); -- 몸무게는 0보다 크고 300보다 작아야 함
```

이 코드를 한 줄씩 살펴볼게요:

- **`CREATE DOMAIN WEIGHT`** — `WEIGHT`라는 이름의 도메인을 생성합니다. `CREATE DOMAIN`은 도메인 무결성을 만드는 명령어입니다.
- **`AS DECIMAL(5, 1)`** — 데이터 타입을 정의합니다. 전체 5자리 숫자이고, 그 중 소수점 이하가 1자리입니다. 예를 들어 `123.4`나 `85.7` 같은 형태입니다.
- **`CHECK (WEIGHT > 0 AND WEIGHT < 300)`** — 제약 조건입니다. 몸무게 값은 반드시 **0보다 크고 300보다 작아야** 합니다.

```sql
-- ❌ 잘못된 예시: 도메인 무결성을 위반하는 입력
INSERT INTO PERSON (NAME, WEIGHT) VALUES ('홍길동', 500);
-- 500은 300보다 크므로 도메인 무결성 위반! → 삽입 거부됨

INSERT INTO PERSON (NAME, WEIGHT) VALUES ('김철수', -10);
-- -10은 0보다 작으므로 도메인 무결성 위반! → 삽입 거부됨
```

```sql
-- ✅ 올바른 예시: 도메인 무결성을 만족하는 입력
INSERT INTO PERSON (NAME, WEIGHT) VALUES ('홍길동', 75.5);
-- 75.5는 0보다 크고 300보다 작으므로 정상 삽입됨

INSERT INTO PERSON (NAME, WEIGHT) VALUES ('김철수', 120.3);
-- 120.3도 범위 안에 있으므로 정상 삽입됨
```

:::warning 도메인 무결성이 없으면?
몸무게에 `-50`이나 `9999`가 입력되어도 시스템이 막지 못합니다. 이런 잘못된 데이터가 쌓이면 통계를 내거나 보고서를 작성할 때 엉터리 결과가 나올 수 있습니다. 도메인 무결성은 **데이터 품질의 첫 번째 방어선**입니다.
:::

### 2. 릴레이션 무결성 (Relation Integrity)

**릴레이션(Relation)**은 **테이블**을 의미합니다. 릴레이션 무결성은 하나의 테이블에 적용할 수 있는 **모든 종류의 무결성을 광범위하게 포함**하는 개념입니다. 도메인 무결성, 기본키 무결성, NULL 값 제약, 외래키 참조 무결성 등이 모두 릴레이션 무결성에 포함됩니다.

데이터베이스는 **일관된 상태(consistent state)**를 유지하는 것이 매우 중요합니다. 데이터가 항상 정확한 상태를 계속 유지해야 하는 것이죠. 릴레이션 무결성은 이 일관성 있는 상태를 명시하고 유지되도록 하는 포괄적인 규정입니다.

릴레이션 무결성 규정 안에는 여러 세부적인 제약이 포함됩니다. 하나씩 자세히 살펴보겠습니다.

#### 과도 제약 (Transition Constraint)

**과도 제약**은 데이터의 **상태가 A에서 B로 변화될 때**, 그 변화가 논리적으로 올바른지 확인하는 제약 조건입니다.

쉬운 예를 들어보겠습니다:
- **나이**: 작년 나이가 25살이었다면, 올해 나이는 26살 이상이어야 합니다. 나이가 갑자기 줄어드는 것은 말이 안 되죠.
- **주문과 배송**: 주문한 수량이 10개인데, 배송 수량이 15개가 되면 안 됩니다. 배송 수량은 주문 수량 이하여야 합니다.

마치 엘리베이터 층수 표시기처럼, 3층에서 5층으로 올라갔다가 갑자기 -2층으로 표시되면 뭔가 문제가 있다는 것을 알 수 있는 것과 같습니다.

```sql
-- ✅ 올바른 예시: 과도 제약 설정
-- 직원의 급여(SALARY)를 갱신할 때, 새 급여가 기존 급여보다 크거나 같아야 함
WHEN UPDATE EMP.SALARY                      -- EMP 테이블의 SALARY를 갱신할 때
CHECK (EMP.NEW.SALARY >= EMP.OLD.SALARY)    -- 새 급여 >= 기존 급여 (급여는 줄어들 수 없다)
```

- **`EMP.NEW.SALARY`** — 갱신 후의 새로운 급여 값입니다 (예: 2024년 연봉).
- **`EMP.OLD.SALARY`** — 갱신 전의 기존 급여 값입니다 (예: 2023년 연봉).
- 새 급여가 기존 급여보다 크거나 같아야 한다는 조건입니다. 연봉이 삭감되는 것을 방지하는 규정이죠.

```sql
-- ❌ 잘못된 상황: 과도 제약 위반
-- 기존 급여: 3000만원 → 새 급여: 2500만원
-- 새 급여가 기존 급여보다 작으므로 → 갱신 거부!
```

#### 집합 제약 (Aggregate Constraint)

**집합 제약**은 개별 레코드가 아니라, **튜플(레코드) 집합 전체에 대한 규정**입니다.

회사에서 이런 규칙이 있다고 해봅시다: "올해 전 직원의 급여 총합은 10억 원을 초과할 수 없다." 개별 직원의 급여가 올라갈 수는 있지만, 전체 급여의 합계가 10억 원을 넘으면 안 된다는 것입니다. 마치 가계부에서 "이번 달 총 지출은 300만 원을 넘기지 말자"라고 정하는 것과 비슷합니다.

```sql
-- ✅ 올바른 예시: 집합 제약 설정
-- EMP 테이블의 급여를 갱신한 후, 전 직원의 평균 급여가 300만원 이하여야 함
AFTER UPDATING EMP.SALARY                    -- EMP 테이블의 SALARY를 갱신한 후에
CHECK (AVERAGE(EMP.SALARY) <= 300)           -- 전 직원 급여의 평균이 300(만원) 이하인지 확인
```

- **`AVERAGE(EMP.SALARY)`** — EMP 테이블에 있는 모든 직원의 급여 **평균**을 계산합니다.
- 누구는 많이 받고 누구는 적게 받을 수 있지만, **평균이 300만 원을 초과하면** 해당 갱신은 거부됩니다.

#### 튜플 제약 (Tuple Constraint)

**튜플 제약**은 집합 제약과 달리, **개별 튜플(레코드) 하나하나에 대해 제약 조건을 거는 것**입니다.

```sql
-- ✅ 올바른 예시: 튜플 제약 설정
-- 모든 직원의 개별 급여는 500만원 이하여야 함
CHECK (EMP.SALARY <= 500)  -- 개별 직원의 급여가 500(만원)을 초과할 수 없음
```

이 제약은 전체 평균이나 합계와 상관없이, **각 직원 한 명 한 명의 급여가 500만 원을 넘을 수 없다**는 것입니다.

| 제약 유형 | 적용 범위 | 예시 |
|-----------|-----------|------|
| **튜플 제약** | 개별 레코드 하나 | 각 직원의 급여 ≤ 500만원 |
| **집합 제약** | 전체 레코드 집합 | 전 직원 평균 급여 ≤ 300만원 |

#### 즉시 제약 vs 지연 제약

무결성 규정에서 아주 중요한 개념이 바로 **즉시 제약**과 **지연 제약**의 구분입니다.

**즉시 제약(Immediate Constraint)**은 삽입, 삭제, 갱신 작업이 수행되고 난 **즉시** 갱신이 바로 반영되도록 하는 것입니다. 예를 들어, 네이버에서 주소를 변경하면 저장 버튼을 누르는 즉시 반영됩니다. 일반적인 데이터들은 대부분 즉시 제약을 따릅니다.

```sql
-- ✅ 올바른 예시: 즉시 제약
-- 성별 값은 'MALE' 또는 'FEMALE'만 가능하며, 업데이트 즉시 반영됨
AFTER UPDATING EMP.GENDER               -- 성별을 갱신한 후에
CHECK (EMP.GENDER IN ('MALE', 'FEMALE'))  -- 남자 또는 여자 값만 가능
```

성별을 입력하면 바로바로 값이 바뀌어서 갱신이 반영됩니다.

**지연 제약(Deferred Constraint)**은 즉시 반영되지 않고, **확인을 한 다음에** 갱신을 해주는 것입니다. 가장 대표적인 예가 바로 **계좌 이체**입니다.

내 통장(A)에서 상대방 통장(B)으로 100만 원을 이체한다고 해봅시다:

1. 내 통장에서 100만 원을 빼냄
2. 상대방 통장으로 100만 원을 보냄
3. 상대방 통장에 100만 원이 정상 입금됨
4. 상대방 은행에서 "잘 받았어!"라는 확인 메시지를 보냄
5. 그때서야 내 통장의 잔액이 갱신됨

:::danger 즉시 제약으로 계좌 이체를 하면?
만약 계좌 이체가 **즉시 제약**으로 동작한다면 큰 문제가 생깁니다:
- 내 통장에서 100만 원이 **즉시 빠져나감**
- 그런데 상대방 은행 서버가 점검 중이라 이체가 안 됨
- 결과: **내 통장에서는 돈이 빠졌는데, 상대방은 받지 못한 상태!**

이런 심각한 문제를 방지하기 위해 계좌 이체 같은 작업은 반드시 **지연 제약**으로 처리해야 합니다.
:::

```sql
-- ✅ 올바른 예시: 지연 제약
-- 트랜잭션이 완전히 커밋(성공)된 후에 잔액을 갱신
WHEN COMMIT                              -- 트랜잭션이 성공적으로 완료되었을 때
  UPDATE ACCOUNT                         -- 계좌 테이블을 갱신
  SET BALANCE = BALANCE - TRANSFER_AMOUNT -- 이체 금액만큼 잔액에서 차감
```

- **`WHEN COMMIT`** — `COMMIT`은 트랜잭션(작업 묶음)이 성공적으로 완료되었다는 의미입니다. 상대방이 돈을 정상적으로 받고, 모든 과정이 문제없이 끝나야 `COMMIT`이 됩니다.
- 모든 과정이 `COMMIT`된 후에야 비로소 내 잔액이 갱신됩니다.

은행에서 수표를 입금하면 바로 찾을 수 없는 것도 같은 원리입니다. 수표가 부도 수표인지, 분실된 수표인지 확인하는 데 시간이 걸리기 때문에, 확인이 끝난 다음 날에야 돈을 찾을 수 있는 것이죠.

---

## ⚡ 트리거(Trigger)의 개념과 활용

### 트리거란 무엇인가?

**트리거(Trigger)**는 무결성 제약 조건과 **반대되는 개념**입니다. 이것만 이해하면 트리거의 핵심을 파악한 것입니다.

| 구분 | 무결성 제약 조건 | 트리거 (Trigger) |
|------|-----------------|-----------------|
| **동작 조건** | 조건을 **위반**했을 때 | 조건을 **만족**했을 때 |
| **동작 방식** | 연산을 **거부** (수동적) | 특정 작업을 **실행** (능동적) |
| **비유** | "그거 하면 안 돼!" | "이 조건이 되면 이거 해줘!" |

**트리거(Trigger)**라는 영어 단어는 원래 **총의 방아쇠**를 뜻합니다. 방아쇠는 평상시에는 가만히 있다가, 손가락으로 당기면(조건을 만족하면) 총알이 발사됩니다(액션이 실행됩니다). 마찬가지로, 트리거를 미리 프로그래밍해 놓으면 평소에는 아무것도 하지 않다가, **조건을 만족하는 순간** 자동으로 동작합니다.

> 🔫 **트리거 = 방아쇠**
> 평상시에는 가만히 있다가 → 조건을 만족하면 → 방아쇠가 당겨지고 → 정해진 액션이 실행된다!

### 트리거의 장점

트리거를 잘 활용하면 다음과 같은 장점이 있습니다:

- **노력 중복 제거**: 복잡한 비즈니스 규칙을 트리거로 한 번만 만들어 놓으면, 매번 같은 코드를 반복 작성할 필요가 없습니다.
- **일관성 제공**: 아무 때나 처리하는 것이 아니라, 규정을 만족할 때만 정해진 대로 처리하므로 항상 **일관된 결과**를 보장합니다.
- **유지보수 용이**: 모듈화 방식으로 규정들을 만들어 놓으면, 조건이 바뀔 때 해당 트리거 프로그램만 수정하면 됩니다.
- **복잡한 비즈니스 규칙 처리**: 계좌 이체, 급여 처리 같은 복잡한 규칙들을 트리거로 깔끔하게 관리할 수 있습니다.

### 트리거의 구성: ECA 규칙

트리거는 **ECA(Event-Condition-Action)** 구조로 이루어져 있습니다:

| 구성 요소 | 영문 | 설명 |
|-----------|------|------|
| **E** - 이벤트 | Event | INSERT, DELETE, UPDATE 작업이 수행될 때 (SELECT은 해당 없음) |
| **C** - 조건 | Condition | 특정 조건이 **참(TRUE)**일 때 |
| **A** - 액션 | Action | 조건이 참이면 실행할 작업 |

:::note SELECT은 왜 트리거와 상관없나요?
트리거는 데이터의 **변경**과 관련됩니다. SELECT(검색)은 데이터를 조회만 할 뿐 변경하지 않으므로 트리거가 동작할 이유가 없습니다. 트리거가 발동되는 이벤트는 **INSERT(삽입), DELETE(삭제), UPDATE(갱신)** 세 가지뿐입니다.
:::

### 트리거 실제 예시

은행 계좌에서 이체할 때, 잔액이 충분한지 확인하고 이체를 처리하는 트리거를 만들어 봅시다:

```sql
-- ✅ 올바른 예시: 계좌 잔고 확인 트리거
CREATE TRIGGER 잔고                    -- '잔고'라는 이름의 트리거 생성
BEFORE UPDATE ON 계좌                  -- 계좌 테이블을 업데이트하기 전에(BEFORE) 실행
FOR EACH ROW                          -- 각 행(레코드)마다 하나씩 처리
WHEN (NEW.잔고 - NEW.이체금액 >= 0)     -- 조건: 잔고에서 이체금액을 뺀 값이 0 이상일 때
BEGIN                                 -- 액션 시작
  UPDATE 계좌                          -- 계좌 테이블을 갱신
  SET 잔고 = 잔고 - 이체금액            -- 잔고에서 이체금액을 차감
  WHERE 계좌번호 = :NEW.계좌번호;       -- 해당 계좌번호에 대해서만 갱신
END;                                  -- 액션 종료
```

이 트리거의 동작 과정을 단계별로 살펴보겠습니다:

1. 누군가 계좌 이체를 시도합니다 → **이벤트(Event)** 발생
2. 잔고가 200만 원이고, 이체하려는 금액이 150만 원이라면: 200 - 150 = 50 ≥ 0 → **조건(Condition) 만족!**
3. 조건을 만족했으므로 → 잔고에서 이체금액을 빼서 잔액을 갱신 → **액션(Action) 실행!**

```sql
-- ❌ 잘못된 상황: 조건 불만족으로 트리거 액션이 실행되지 않음
-- 잔고: 200만원, 이체하려는 금액: 250만원
-- 200 - 250 = -50 < 0 → 조건 불만족! → 이체 거부됨
```

잔고가 200만 원인데 250만 원을 이체하려 하면, 조건이 만족되지 않으므로 트리거 액션이 실행되지 않고 이체가 거부됩니다.

### 트리거의 관리 명령어

```sql
-- 트리거 삭제
DROP TRIGGER 트리거이름;               -- 트리거를 완전히 삭제

-- 트리거 비활성화 (일시적으로 꺼놓기)
ALTER TRIGGER 트리거이름 DISABLE;      -- 트리거를 비활성화 (방아쇠를 잠가놓는 것)

-- 트리거 활성화 (다시 켜기)
ALTER TRIGGER 트리거이름 ENABLE;       -- 트리거를 활성화 (방아쇠를 다시 사용 가능하게)

-- 트리거 내용이 변경되면 재컴파일
ALTER TRIGGER 트리거이름 COMPILE;      -- 변경된 트리거를 다시 컴파일
```

- **`DROP`**: 트리거를 완전히 삭제합니다. 더 이상 필요 없을 때 사용합니다.
- **`DISABLE`**: 트리거를 일시적으로 비활성화합니다. 삭제하지는 않고, 잠시 작동을 멈추게 하는 것입니다.
- **`ENABLE`**: 비활성화된 트리거를 다시 활성화합니다. 언제라도 조건을 만족하면 다시 동작하게 됩니다.
- **`COMPILE`**: 트리거의 규칙이나 조건을 수정한 후, 변경 사항을 반영하기 위해 재컴파일합니다.

### 트리거의 활성화 시점과 실행 범위

트리거는 **언제 활성화되는가(실행 시점)**와 **어떤 범위로 실행되는가(실행 범위)**에 따라 분류됩니다.

**실행 시점**: 작업 **전에(BEFORE)** 할 것인가, 작업 **후에(AFTER)** 할 것인가

**실행 범위**: 전체를 **한꺼번에(STATEMENT)** 처리할 것인가, **한 행씩(ROW)** 처리할 것인가

| 실행 범위 \ 실행 시점 | BEFORE | AFTER |
|----------------------|--------|-------|
| **STATEMENT (문장 트리거)** | BEFORE STATEMENT | AFTER STATEMENT |
| **ROW (행 트리거)** | BEFORE ROW | AFTER ROW |

이렇게 **2 × 2 = 4가지** 조합이 가능합니다.

#### 문장 트리거 (Statement Trigger)

**문장 트리거**는 트리거가 **한 번만 실행**되어 전체 데이터를 **한꺼번에** 처리합니다.

```sql
-- ✅ 올바른 예시: 문장 트리거 (전 직원 급여 10% 인상)
UPDATE EMP SET SALARY = SALARY * 1.1;  -- 전 직원의 급여를 한꺼번에 10% 인상
-- 트리거가 한 번만 실행되어 전체 레코드를 한꺼번에 처리
```

이 경우 트리거는 딱 **한 번** 실행되어 EMP 테이블의 모든 직원 급여를 한꺼번에 10% 올려버립니다.

#### 행 트리거 (Row Trigger)

**행 트리거**는 `FOR EACH ROW`라는 명령을 사용하여 **레코드 하나씩 하나씩 반복적으로** 처리합니다.

```sql
-- ✅ 올바른 예시: 행 트리거 (레코드 하나씩 처리)
CREATE TRIGGER salary_check
BEFORE UPDATE ON EMP
FOR EACH ROW                           -- 각 행(레코드)마다 하나씩 처리
BEGIN
  -- 개별 직원의 급여를 하나씩 확인하고 처리
  IF :NEW.SALARY > 1000 THEN           -- 새 급여가 1000만원 초과이면
    RAISE_APPLICATION_ERROR(-20001, '급여 상한 초과');  -- 오류 발생
  END IF;
END;
```

레코드가 100개 있으면 트리거가 100번 반복 실행됩니다. 첫 번째 레코드 확인, 두 번째 레코드 확인... 이렇게 하나씩 처리하는 것이죠.

| 트리거 유형 | 실행 횟수 | 특징 |
|------------|----------|------|
| **문장 트리거** | 1번 | 전체 데이터를 한꺼번에 처리 |
| **행 트리거** | 레코드 수만큼 | 레코드 하나씩 반복 처리 |

:::warning 트리거의 주의사항
트리거 안에서는 **COMMIT(커밋)**이나 **ROLLBACK(롤백)** 같은 트랜잭션 제어 명령어를 사용할 수 **없습니다**. 이것은 트리거가 갖는 제약 사항 중 하나입니다. 트리거는 잘못된 트랜잭션을 방지하는 역할은 수행하지만, 직접 트랜잭션을 제어하지는 못합니다.
:::

---

## 🛡️ 데이터베이스 보안의 필요성과 위협 요소

### 왜 보안이 필요한가?

컴퓨터가 대량으로 보급되고, 5G 시대와 4차 산업혁명이 진행되면서 데이터의 중요성은 점점 커지고 있습니다. 하지만 그만큼 **해킹, 불법 침입, 데이터 파괴, 정보 노출** 같은 위험도 함께 증가하고 있죠.

데이터베이스는 **데이터와 직접적으로 관련**되어 있기 때문에, 보안을 유지하는 것은 아무리 강조해도 지나치지 않습니다.

데이터베이스 보안이 필요한 핵심 이유:

1. **권한 있는 사용자**: 정당한 권한을 가진 사용자가 자유롭게 데이터에 접근할 수 있어야 합니다.
2. **권한 없는 사용자 차단**: 불법적인 사용자가 데이터에 접근하거나, 수정하거나, 삭제하는 것을 막아야 합니다.
3. **서비스 거부 방지**: DDoS 공격처럼 좀비 PC가 대량으로 자원을 사용하여 서버를 다운시키고, 정상적인 사용자도 서비스를 이용하지 못하게 만드는 것을 방지해야 합니다.
4. **데이터의 기밀성, 무결성, 가용성 보장**: 대량의 데이터를 안전하고 정확하게, 언제든 사용할 수 있도록 보장해야 합니다.

### 데이터베이스의 위협 요소

| 위협 요소 | 설명 | 해치는 속성 |
|-----------|------|------------|
| **데이터 노출 (Disclosure)** | 비공개 데이터가 외부에 노출됨 | 기밀성 |
| **데이터 부정 수정** | 권한 없는 사용자가 데이터를 불법 수정 | 무결성 |
| **서비스 거부 (DoS/DDoS)** | 정상적인 사용자가 서비스를 이용하지 못함 | 가용성 |

### 보안 요구 사항

데이터베이스 보안에서 요구되는 주요 사항들을 정리하면 다음과 같습니다:

- **접근 제어**: 정당한 사용자는 DB에 접근할 수 있어야 하고, 그렇지 않은 사용자는 차단되어야 합니다.
- **추론 방지**: 공개된 데이터를 바탕으로 숨겨진 비밀 정보를 **추측(추론)**하는 것을 막아야 합니다. 보여줄 데이터만 보여주고, 감추고자 하는 데이터는 예측이 불가능하도록 해야 합니다.
- **무결성 유지**: 도메인 무결성, 개체 무결성, 참조 무결성 등 다양한 무결성 규정과 트리거를 통해 데이터의 정확성을 유지합니다.
- **의미 무결성**: 4년제 대학의 학년은 1~4학년, 초등학교는 1~6학년처럼 **의미적으로 당연한** 값의 범위가 지켜져야 합니다.
- **시스템 감사(Audit)**: 사용자가 정상적인 권한으로 데이터에 접근했는지 **로그(기록)**를 통해 확인하고 감사합니다. 은행 직원도 고객의 계좌를 마음대로 볼 수 없고, 정상적인 절차를 거쳐야 합니다.
- **인증(Authentication)**: 아이디와 패스워드가 정상적인 것인지 확인하는 과정입니다.
- **기밀 데이터 보호**: 극비문서(Top Secret), 비밀(Secret), 대외비(Confidential) 등 등급을 부여하여 단계별로 접근을 제어합니다.

:::tip 보안 등급의 예시
군대나 정부 기관에서 자주 사용하는 보안 등급 분류입니다:
- **Top Secret (극비)**: 가장 높은 보안 등급. 극소수만 접근 가능
- **Secret (비밀)**: 높은 보안 등급. 제한된 인원만 접근 가능
- **Confidential (대외비)**: 조직 외부에는 공개되지 않는 정보
- **Unclassified (비밀 아님)**: 공개 가능한 일반 정보
:::

---

## 📌 핵심 정리

- **무결성(Integrity)**은 데이터의 **정확성**을 의미하며, 데이터베이스에서 성능보다 더 중요한 요소이다
- **보안(Security)**은 승인되지 않은 사용자의 접근을 막는 것이고, **무결성**은 승인된 사용자의 작업 과정에서 데이터 정확성을 유지하는 것이다
- 무결성 규정은 **규정 이름, 검사 시기, 제약 조건, 위반 시 조치**의 4가지 요소로 구성된다
- 무결성 규정의 기본 패턴은 **AFTER(또는 BEFORE) → CHECK → ELSE** 구조이다
- **도메인 무결성**은 속성 값이 정해진 범위 안에 있어야 한다는 규정이다
- **릴레이션 무결성**은 테이블에 적용되는 모든 무결성(과도 제약, 집합 제약, 튜플 제약 등)을 포함하는 포괄적 개념이다
- **즉시 제약**은 작업 결과가 바로 반영되는 것이고, **지연 제약**은 트랜잭션이 완전히 성공(COMMIT)한 후에 반영되는 것이다
- **트리거(Trigger)**는 무결성과 반대로, 조건을 **만족했을 때** 특정 액션을 실행하는 능동적 메커니즘이다
- 트리거는 **ECA(Event-Condition-Action)** 구조로 되어 있으며, INSERT/DELETE/UPDATE 이벤트에 반응한다
- 트리거는 실행 시점(BEFORE/AFTER)과 실행 범위(STATEMENT/ROW)에 따라 4가지 조합이 가능하다
- 데이터베이스 보안은 **기밀성, 무결성, 가용성**을 보장하기 위해 접근 제어, 인증, 감사, 추론 방지 등이 필요하다

작성일: 2026-02-21