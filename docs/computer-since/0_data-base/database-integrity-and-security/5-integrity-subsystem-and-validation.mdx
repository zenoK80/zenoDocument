---
title: "무결성 서브시스템과 무결성 검사 과정"
description: "무결성 서브시스템과 무결성 검사 과정에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/database-integrity-and-security/5-integrity-subsystem-and-validation"
sidebar_label: "무결성 검사"
date: "2026-02-21"
---

## 🎯 무결성이란 무엇인가?

데이터베이스를 공부하다 보면 **"무결성(Integrity)"**이라는 용어를 정말 많이 만나게 됩니다. 개체무결성, 참조무결성, 도메인무결성, 키무결성… 여기저기서 "무결성"이라는 단어가 끊임없이 등장하죠. 그런데 이 "무결성"이라는 말 자체가 뭔가 어렵게 느껴지지 않나요?

**무결(無缺)**이라는 한자를 풀어보면 **"결점이 없다"**라는 뜻입니다. 데이터 측면에서 결점이 없다는 것은 곧 **데이터가 가지고 있는 값이 정확하다**는 의미입니다. 그래서 무결성이라는 말을 한마디로 바꾸면 **"정확성"**이라고 표현할 수 있습니다.

> 💡 **무결성 = 정확성**
> 데이터베이스에 저장된 데이터가 항상 정확하고 일관된 상태를 유지하는 것을 무결성이라고 합니다.

마치 은행 통장의 잔액처럼 생각해보세요. 내가 100만 원을 입금했는데 통장에 90만 원만 찍혀 있다면? 또는 50만 원밖에 없는데 갑자기 5억 원이 표시된다면? 이런 상황이 바로 **무결성이 깨진 상태**입니다. 데이터의 값이 정확하지 않은 것이죠.

## 🔍 왜 무결성이 중요한가?

### 성능보다 더 중요한 것

아무리 빠르고 성능이 좋은 시스템이라도, **만 번에 한 번씩 잘못된 결과가 나온다면** 그 시스템은 실제 현업에서 절대 사용할 수 없습니다.

은행 시스템을 예로 들어볼까요? 계좌 이체, 입금, 출금, 조회 등의 작업을 처리하는 은행 시스템이 있다고 합시다. 만약 이 시스템이 만 번에 한 번씩 이상 현상이 생긴다면 어떻게 될까요?

- 이체가 잘못되어 돈이 사라지거나
- 잔액이 1만 원밖에 없었는데 갑자기 10억 원이 되어버리거나
- 10억 원이 있던 통장이 갑자기 잔액 0원이 되어버리거나

이런 일이 만 번에 한 번이라도 발생하면, 아무리 드문 확률이라 해도 **그 시스템은 사용 불가**입니다. 마치 비행기가 만 번에 한 번 추락한다면 아무도 비행기를 타지 않는 것과 같은 이치입니다.

### 성능과 무결성의 트레이드오프(상충 관계)

여기서 중요한 개념이 하나 등장합니다. 바로 **트레이드오프(Trade-off)**입니다. 성능과 무결성은 시소처럼 한쪽이 올라가면 다른 쪽이 내려가는 관계에 있습니다.

| 구분 | 설명 | 비유 |
|------|------|------|
| **성능을 높이면** | 무결성은 떨어질 수밖에 없음 | 속도를 내면 안전벨트가 불편해지는 것처럼 |
| **무결성을 높이면** | 성능은 떨어질 수밖에 없음 | 보안 검색이 철저하면 공항 통과가 느려지는 것처럼 |

무결성을 높인다는 것은 **이것저것 제약이 많다**는 뜻입니다. 뭔가 작업을 하려고 하면 "잠깐만, 검사해야 해!", "이건 안 돼!" 같은 확인 과정을 거쳐야 하니까요. 마치 건물에 들어갈 때 신분증 확인, 소지품 검사, 체온 측정 등을 모두 거쳐야 하는 것처럼, 검사가 많아질수록 처리 속도는 느려질 수밖에 없습니다.

:::warning 핵심 포인트
데이터베이스 시스템에서 **성능 향상보다 더 중요한 것이 무결성 유지**입니다. 두 가지를 동시에 다 올릴 수는 없기 때문에, 무결성을 확보한 뒤에 성능을 최적화하는 것이 올바른 순서입니다.
:::

## 🛡️ 무결성 vs 보안 — 헷갈리면 안 되는 두 개념

무결성을 이야기할 때 항상 함께 등장하는 개념이 **보안(Security)**입니다. 이 둘은 자주 혼동되지만, 완전히 다른 개념입니다.

| 구분 | 무결성(Integrity) | 보안(Security) |
|------|-------------------|----------------|
| **대상** | 승인받은 **정상적인** 사용자 | 승인받지 **못한** 불법적인 사용자 |
| **목적** | 데이터의 **정확성** 유지 | 데이터의 **접근 차단** 및 보호 |
| **동작 시점** | 정상 사용자가 데이터를 조작하는 과정에서 | 사용자가 시스템에 접근하려는 시점에서 |
| **비유** | 요리사가 레시피대로 정확하게 요리하는 것 | 주방에 허가받지 않은 사람이 못 들어오게 하는 것 |

**보안**은 마치 건물의 **정문 경비원** 같은 것입니다. 출입증이 없는 사람이 건물에 들어오지 못하게 막아주는 역할이죠. 승인받지 못한 사용자가 데이터베이스에 접근하는 것을 차단하여 데이터를 안전하게 지켜주는 것이 보안입니다.

**무결성**은 건물 안에 정상적으로 들어온 직원이 **업무를 정확하게 처리하는 것**과 같습니다. 이미 허가받은 사용자가 데이터를 검색, 삽입, 삭제, 갱신하는 과정에서 데이터의 정확성이 흐트러지지 않도록 유지하는 것이죠.

> 🏢 **사용자가 시스템에 접속하는 흐름:**
> 1. 먼저 **보안 서브시스템**을 만남 → 아이디, 패스워드, 권한 확인
> 2. 정상적인 사용자로 확인되면 → **무결성 서브시스템**을 만남 → 데이터 정확성 유지

## ⚙️ 무결성 서브시스템의 핵심 원리

### 사용자가 규정을 정하면, 시스템이 알아서 지킨다

무결성에서 가장 중요한 원리가 바로 이것입니다. **무결성은 사용자나 개발자, DBA(데이터베이스 관리자)가 직접 하나하나 유지하는 것이 아닙니다.**

사용자는 무결성에 대한 **규정(Rule)**만 정해놓으면 됩니다. "이것은 기본키야", "이것은 외래키야", "점수는 0점에서 100점까지만 입력 가능해" — 이런 제약 조건들을 설정해놓으면, **DBMS의 구성 요소인 무결성 서브시스템(Integrity Subsystem)**이 자동으로 무결성을 유지시켜 줍니다.

마치 교통 신호 시스템과 비슷합니다. 교통 법규(규정)를 정해놓으면, 신호등(시스템)이 자동으로 작동해서 교통 질서를 유지하는 것이죠. 경찰관이 모든 교차로에 서서 일일이 차를 통제할 필요가 없는 것처럼, 사용자가 매번 무결성을 직접 확인할 필요가 없습니다.

### 무결성 검사 과정

무결성 서브시스템이 동작하는 과정을 단계별로 살펴보겠습니다.

1. **갱신 작업 발생**: 사용자가 데이터를 삽입, 삭제, 갱신하려고 합니다.
2. **무결성 검사 수행**: 무결성 서브시스템이 미리 정의된 규정을 확인합니다.
3. **규정 위반 여부 판단**: 입력된 값이 규정에 맞는지 검사합니다.
4. **위반 시 조치**: 규정을 위반했다면 갱신을 거부하고, 에러 메시지를 출력합니다.
5. **무결성 유지**: 잘못된 데이터가 들어가지 않으므로 자연스럽게 무결성이 유지됩니다.

:::info 왜 검색(SELECT)은 무결성 검사가 필요 없을까?
검색은 데이터를 **눈으로 보기만 하는 작업**입니다. 데이터가 변경되는 것이 아니기 때문에 무결성이 위반될 일이 없습니다. 무결성 검사는 데이터가 **실제로 변경되는 작업(INSERT, UPDATE, DELETE)**에서만 의미가 있습니다.
:::

### 구체적인 예시로 이해하기

시험 점수를 관리하는 데이터베이스를 생각해봅시다. "점수는 0점에서 100점까지만 입력할 수 있다"라는 무결성 규정이 설정되어 있습니다.

어떤 사용자가 점수를 **120점**으로 입력했다면?

1. 무결성 서브시스템이 규정을 확인합니다.
2. 규정에 따르면 점수는 0~100점인데, 120점이 입력되었습니다.
3. **무결성 위반** 감지!
4. 갱신이 반영되지 않고, "무결성 규정을 위반했습니다. 입력 값을 다시 확인해 보세요"라는 에러 메시지가 출력됩니다.
5. 데이터베이스에는 120점이 저장되지 않으므로 무결성이 유지됩니다.

## 📋 무결성 규정의 구성 요소

무결성 규정(Integrity Rule)은 **네 가지 핵심 요소**로 구성됩니다. 무결성 검사가 수행되는 과정에서 오류가 발생했을 때 그에 대한 조치를 정리해 놓은 것이 바로 무결성 규정입니다.

### 1️⃣ 규정 이름 (Rule Name)

규정을 참조할 때 사용하는 **식별자(고유한 이름)**입니다. R1, R2, R3처럼 일련번호를 부여합니다.

하나의 시스템을 관리하는 무결성 규정은 하나가 아닙니다. 수십, 수백 개의 규정이 존재할 수 있습니다. 마치 법률에 "제1조", "제2조"처럼 번호가 매겨져 있는 것처럼, 수많은 규정들을 유일하게 식별하고 관리하기 위해 규정 이름이 필요합니다. **규정 이름은 유일한 값**을 가져야 합니다.

### 2️⃣ 검사 시기 (When to Check)

**언제 무결성 검사를 수행할 것인가**를 결정합니다. 데이터를 갱신(UPDATE)할 때 할 것인지, 삽입(INSERT)할 때 할 것인지, 삭제(DELETE)할 때 할 것인지를 명시합니다.

또한 해당 작업의 **전(Before)**에 검사할 것인지, **후(After)**에 검사할 것인지도 지정합니다.

### 3️⃣ 제약 조건 (Constraint)

데이터가 **만족해야 하는 조건**입니다. 예를 들면:

- "점수는 0점에서 100점까지만 입력 가능하다"
- "학년은 1학년부터 4학년까지만 입력 가능하다"
- "성별은 '남' 또는 '여'만 입력 가능하다"

이런 조건들을 `CHECK`라는 키워드를 사용하여 설정합니다.

### 4️⃣ 위반 시 조치 (Violation Action)

제약 조건을 **위반했을 때 어떤 조치를 취할 것인지** 정의합니다. 보통은 에러 메시지를 출력하고, 해당 갱신 작업을 거부(REJECT)합니다.

### 무결성 규정 코드 예시

아래는 무결성 규정을 프로그래밍으로 작성한 예시입니다.

```sql
-- ✅ 올바른 무결성 규정 예시
RULE R1                              -- 규정 이름: R1
AFTER UPDATING STUDENT.YEAR          -- 검사 시기: STUDENT 테이블의 YEAR 속성을 업데이트한 후에
CHECK (STUDENT.YEAR > 0)             -- 제약 조건: YEAR 값은 0보다 커야 함
ELSE                                 -- 위반했을 때 조치:
  PRINT 'R1 VIOLATED'                --   'R1 위반' 메시지 출력
  REJECT                             --   업데이트 거부
END                                  -- 규정 끝
```

이 코드를 한 줄씩 자세히 설명하겠습니다.

- **`RULE R1`**: 이 무결성 규정의 이름을 R1으로 지정합니다. 나중에 이 규정을 참조하거나 수정할 때 R1이라는 이름으로 찾을 수 있습니다.
- **`AFTER UPDATING STUDENT.YEAR`**: STUDENT 테이블의 YEAR(학년) 속성을 업데이트**한 후에** 검사를 수행하겠다는 뜻입니다. `AFTER` 대신 `BEFORE`를 쓰면 업데이트 **전에** 검사합니다.
- **`CHECK (STUDENT.YEAR > 0)`**: 제약 조건입니다. STUDENT 테이블의 YEAR 값이 0보다 큰지 확인합니다. 학년이 0이거나 음수가 될 수는 없으니까요.
- **`ELSE`**: 위의 제약 조건을 위반했을 때 실행할 조치를 정의합니다.
- **`PRINT 'R1 VIOLATED'`**: "R1 규정이 위반되었습니다"라는 메시지를 화면에 출력합니다.
- **`REJECT`**: 해당 업데이트 작업을 거부합니다. 잘못된 값이 데이터베이스에 저장되지 않습니다.
- **`END`**: 규정 정의가 끝났음을 나타냅니다.

> 📝 **정리하면**: 무결성 규정은 일반적으로 **AFTER/BEFORE → CHECK → ELSE** 구조로 만들어집니다. 사용자가 이렇게 프로그래밍하면, 시스템이 자동으로 상황이 발생할 때마다 무결성을 유지시켜 줍니다.

```sql
-- ❌ 무결성 규정 없이 0 이하의 학년이 입력되는 경우
UPDATE STUDENT SET YEAR = -1 WHERE ID = '2024001';
-- 규정이 없으면 -1이라는 학년이 그대로 저장되어 무결성이 깨짐!

-- ✅ 무결성 규정이 있으면 시스템이 자동으로 거부
UPDATE STUDENT SET YEAR = -1 WHERE ID = '2024001';
-- 결과: 'R1 VIOLATED' 메시지 출력, 업데이트 거부됨
```

## 📚 무결성의 종류

### 1️⃣ 도메인 무결성 (Domain Integrity)

**도메인(Domain)**이란 속성이 가질 수 있는 **값의 범위**를 의미합니다. 넓게 보면 "이 속성은 정수 타입이다", "이것은 문자 타입이다", "이것은 날짜 타입이다"와 같은 것이 도메인입니다.

좀 더 구체적으로 들어가면:
- 학년은 **1~4**까지만 입력 가능
- 나이는 **0~200**까지만 입력 가능
- 점수는 **0~100**까지만 입력 가능

이런 값의 범위가 도메인이고, **이 범위가 항상 유지되도록 하는 것**이 도메인 무결성입니다.

마치 온도계에 표시할 수 있는 범위가 -40°C ~ 50°C로 정해져 있는 것과 같습니다. 이 범위를 벗어나는 값은 측정 오류이므로 기록하면 안 되는 것이죠.

```sql
-- ✅ 도메인 무결성 설정 예시
CREATE DOMAIN WEIGHT AS DECIMAL(5,1)  -- WEIGHT라는 도메인을 만듦. 전체 5자리, 소수점 이하 1자리
CHECK (VALUE > 0 AND VALUE < 300);    -- 값은 0보다 크고 300보다 작아야 함

-- 이렇게 설정하면:
-- 몸무게에 500을 입력하려고 하면 → 거부됨! (300 이상)
-- 몸무게에 -10을 입력하려고 하면 → 거부됨! (0 이하)
-- 몸무게에 75.5를 입력하면 → 정상 입력!
```

코드를 한 줄씩 설명하면:

- **`CREATE DOMAIN WEIGHT`**: WEIGHT(몸무게)라는 이름의 도메인을 새로 생성합니다. 이것은 테이블이 아니라, 속성이 가질 수 있는 값의 범위를 정의하는 것입니다.
- **`AS DECIMAL(5,1)`**: 데이터 타입을 지정합니다. `DECIMAL(5,1)`은 전체 5자리 숫자이며 소수점 아래 1자리라는 뜻입니다. 예를 들어 `123.4`와 같은 형태입니다.
- **`CHECK (VALUE > 0 AND VALUE < 300)`**: 체크 제약 조건입니다. 입력되는 값(VALUE)이 0보다 크고 300보다 작아야 한다는 조건을 설정합니다.

```sql
-- ❌ 도메인 무결성을 설정하지 않은 경우
INSERT INTO PERSON (NAME, WEIGHT) VALUES ('홍길동', 450);
-- 450이라는 비현실적인 몸무게가 그대로 저장됨!

-- ✅ 도메인 무결성이 설정된 경우
INSERT INTO PERSON (NAME, WEIGHT) VALUES ('홍길동', 450);
-- 결과: 제약 조건 위반! 입력 거부됨
```

### 2️⃣ 릴레이션 무결성 (Relation Integrity)

**릴레이션(Relation)**은 곧 **테이블**입니다. 릴레이션 무결성은 하나의 테이블에 적용할 수 있는 **모든 무결성 규정을 광범위하게 포함**하는 개념입니다.

데이터베이스는 **일관된 상태를 유지하는 것**이 매우 중요합니다. 항상 정확한 상태를 계속 유지해야 하죠. 릴레이션 무결성은 도메인 규정, 기본키 규정, NULL 값 규정, 외래키 참조 무결성 등을 **모두 포함하는 포괄적인 개념**입니다.

릴레이션 무결성에는 여러 가지 세부 제약이 존재합니다.

#### 과도 제약 (Transition Constraint)

상태가 A에서 B로 변화할 때, 그 변화가 논리적으로 타당한지 확인하는 제약입니다.

현실 세계에서 생각해보면 쉽습니다:
- **나이**: 작년 나이보다 올해 나이가 당연히 더 커야 합니다. 나이가 줄어들 수는 없으니까요.
- **주문과 배송**: 주문한 수량보다 배송 수량이 더 많으면 안 됩니다. 10개 주문했는데 15개 배송하면 문제가 되겠죠.

```sql
-- ✅ 과도 제약 예시: 급여는 줄어들 수 없다
WHEN UPDATE EMP.SALARY                      -- EMP 테이블의 SALARY를 업데이트할 때
CHECK (EMP.NEW_SALARY >= EMP.OLD_SALARY)    -- 새 급여가 기존 급여보다 크거나 같아야 함

-- NEW_SALARY: 새로 입력하려는 급여 (예: 2024년 연봉)
-- OLD_SALARY: 기존에 저장되어 있던 급여 (예: 2023년 연봉)
-- 새 연봉이 기존 연봉보다 크거나 같아야 하므로, 연봉이 줄어드는 입력은 거부됨
```

- **`WHEN UPDATE EMP.SALARY`**: EMP(직원) 테이블의 SALARY(급여) 속성이 업데이트될 때 이 제약을 검사합니다.
- **`CHECK (EMP.NEW_SALARY >= EMP.OLD_SALARY)`**: 새로운 급여(NEW_SALARY)가 기존 급여(OLD_SALARY)보다 크거나 같은지 확인합니다. 연봉이 갑자기 줄어드는 잘못된 입력을 방지합니다.

#### 집합 제약 (Aggregate Constraint)

**튜플(행) 집합 전체에 대한 규정**입니다. 개별 데이터가 아니라, 전체 데이터를 종합적으로 봤을 때 만족해야 하는 조건입니다.

예를 들어 "우리 회사의 전 직원 급여 총합은 10억 원을 초과할 수 없다"라는 규정이 있다면, 누구는 급여가 오르고 누구는 줄어들 수 있지만, **전체 합계는 10억 원을 넘을 수 없습니다.**

```sql
-- ✅ 집합 제약 예시: 직원 평균 급여가 300만 원을 초과할 수 없음
AFTER UPDATING EMP.SALARY                      -- EMP 테이블의 SALARY를 업데이트한 후에
CHECK (AVERAGE(EMP.SALARY) <= 300)              -- 전 직원 급여의 평균이 300(만 원) 이하여야 함

-- 개별 직원의 급여는 다를 수 있지만,
-- 전체 직원의 평균 급여는 300만 원을 초과할 수 없다는 제약
```

- **`AFTER UPDATING EMP.SALARY`**: 급여 업데이트가 완료된 후에 검사합니다.
- **`CHECK (AVERAGE(EMP.SALARY) <= 300)`**: `AVERAGE`는 평균을 구하는 함수입니다. 전 직원의 급여 평균이 300만 원 이하인지 확인합니다. 누구는 많이 받고 누구는 적게 받을 수 있지만, 평균이 300만 원을 초과하면 해당 갱신은 거부됩니다.

#### 튜플 제약 (Tuple Constraint)

**개별 튜플(행) 하나하나에 대한 제약 조건**입니다. 집합 제약이 전체를 대상으로 한다면, 튜플 제약은 각각의 레코드 하나에 대해서만 적용됩니다.

```sql
-- ✅ 튜플 제약 예시: 모든 직원의 개별 급여는 500만 원 이하여야 함
CHECK (EMP.SALARY <= 500)

-- 이 조건에 의해 어떤 직원도 500만 원을 초과하는 급여를 받을 수 없음
-- 550만 원으로 급여를 입력하면 거부됨
```

| 제약 종류 | 대상 | 예시 |
|-----------|------|------|
| **튜플 제약** | 개별 레코드 하나 | "모든 직원의 급여는 500만 원 이하" |
| **집합 제약** | 전체 레코드 집합 | "전 직원 급여의 평균은 300만 원 이하" |

#### 즉시 제약 (Immediate Constraint)

삽입, 삭제, 갱신 연산이 수행되고 나서 **즉시 반영되도록 하는 제약**입니다. 일반적인 데이터 변경은 대부분 즉시 제약을 따릅니다.

예를 들어 여러분이 네이버 사이트에 들어가서 주소를 변경하고 저장 버튼을 누르면, **바로 반영**이 됩니다. 연락처 변경, 취미 변경 등도 마찬가지로 즉시 처리되죠.

```sql
-- ✅ 즉시 제약 예시: 성별은 'M' 또는 'F'만 입력 가능
AFTER UPDATING EMP.GENDER                  -- EMP 테이블의 성별을 업데이트한 후에
CHECK (EMP.GENDER IN ('M', 'F'))           -- 성별은 'M'(남자) 또는 'F'(여자)만 가능

-- 성별을 입력하면 바로바로 값이 변경되어 갱신이 반영됨
```

#### 지연 제약 (Deferred Constraint)

즉시 제약과 반대되는 개념으로, **즉시 반영하지 않고 확인을 거친 후에 갱신하는 것**입니다.

가장 대표적인 예가 **계좌 이체**입니다. 내 A 통장에서 B 통장으로 100만 원을 이체한다고 생각해보세요.

만약 **즉시 제약**으로 처리된다면 어떤 문제가 생길까요?

1. 내 통장(A)에서 100만 원이 **즉시** 빠져나감
2. 그런데 B 은행 서버가 업데이트 중이라 이체를 받지 못하는 상황 발생
3. 내 통장에서는 돈이 빠져나갔는데, B 통장에는 돈이 안 들어옴!
4. 💥 **100만 원이 공중에서 사라져 버림!**

이것을 방지하기 위해 **지연 제약**을 사용합니다.

1. 내 통장(A)에서 100만 원 이체 요청
2. **즉시 반영하지 않고 대기**
3. B 통장으로 돈이 정상적으로 입금됨
4. B 은행 서버에서 "돈 잘 받았어!"라는 확인 메시지를 보냄
5. **그제서야** 내 통장에서 100만 원이 차감됨

마치 은행에서 수표를 입금하면 바로 돈을 찾을 수 없는 것과 같습니다. 그 수표가 부도 수표인지, 분실된 수표인지 확인하는 과정이 필요하기 때문에 보통 하루 정도 지난 후에야 현금으로 인출할 수 있죠.

```sql
-- ✅ 지연 제약 예시: 트랜잭션이 완전히 완료된 후에 갱신 반영
WHEN COMMIT                                   -- 트랜잭션이 성공적으로 커밋(완료)되었을 때
UPDATE ACCOUNT SET BALANCE = NEW_BALANCE       -- 그때서야 계좌 잔액을 업데이트

-- COMMIT: 모든 작업이 정상적으로 완료되었다는 신호
-- 상대방이 돈을 정상적으로 받은 후에야 내 잔액이 갱신됨
```

- **`WHEN COMMIT`**: `COMMIT`은 트랜잭션(작업 묶음)이 성공적으로 완료되었다는 신호입니다. 이체를 보내고 상대방이 정상적으로 받아서 전체 작업이 완벽하게 끝났을 때 발생합니다.
- **`UPDATE ACCOUNT SET BALANCE = NEW_BALANCE`**: 커밋이 확인된 후에야 비로소 계좌 잔액을 업데이트합니다.

:::tip 즉시 제약 vs 지연 제약 비유
- **즉시 제약**: 편의점에서 물건을 사면 바로 계산 완료! 🏪
- **지연 제약**: 온라인 쇼핑에서 물건을 주문하면, 배송 완료 확인 후에야 결제 확정! 📦
:::

## 🔫 트리거(Trigger) — 능동적인 무결성 관리

### 트리거란 무엇인가?

**트리거(Trigger)**는 무결성과 **반대되는 개념**입니다. 이 차이점만 이해하면 트리거를 완벽하게 이해할 수 있습니다.

- **무결성 제약 조건**: 조건을 **위반했을 때** 연산을 거부함 → **수동적(소극적)**
- **트리거**: 조건을 **만족했을 때** 특정 액션을 실행함 → **능동적(적극적)**

무결성은 마치 가만히 있다가 규칙을 어기면 "하지 마!"라고 막는 **경비원** 같습니다. 반면 트리거는 특정 조건이 충족되면 자동으로 뭔가를 실행하는 **자동 분사기** 같은 것이죠.

트리거(Trigger)라는 영어 단어 자체가 총의 **방아쇠**를 의미합니다. 평상시에는 가만히 있다가, 조건을 만족하면 방아쇠가 당겨지면서 총알이 발사되는 것처럼, 트리거도 미리 프로그래밍해놓고 있다가 조건이 만족되면 자동으로 동작합니다.

| 구분 | 무결성 제약 조건 | 트리거 |
|------|-----------------|--------|
| **동작 시점** | 조건을 **위반**했을 때 | 조건을 **만족**했을 때 |
| **동작 방식** | 연산을 **거부(차단)** | 특정 액션을 **실행** |
| **성격** | 수동적(소극적) | 능동적(적극적) |
| **비유** | 경비원: "출입 금지!" | 자동문: 사람이 다가오면 열림 |

### 트리거의 구성 요소: ECA

트리거는 **ECA**라는 세 가지 요소로 구성됩니다.

- **E (Event, 이벤트)**: INSERT, DELETE, UPDATE 작업이 수행될 때 (SELECT는 해당 없음!)
- **C (Condition, 조건)**: 특정 조건이 **참(True)**일 때
- **A (Action, 액션)**: 수행할 동작

:::note SELECT가 트리거에 해당하지 않는 이유
트리거는 데이터의 변경과 관련된 개념입니다. SELECT(검색)은 데이터를 읽기만 하고 변경하지 않으므로 트리거와는 무관합니다.
:::

### 트리거의 장점

1. **노력 중복 제거**: 복잡한 비즈니스 규칙을 트리거로 한 번 만들어놓으면, 매번 같은 코드를 반복 작성할 필요가 없습니다.
2. **일관성 제공**: 정해진 규칙에 따라서만 처리되므로, 아무 때나 임의로 처리하는 것이 아니라 항상 같은 방식으로 동작합니다.
3. **유지보수 용이**: 모듈화되어 있으므로, 조건이 바뀌면 해당 트리거 프로그램만 수정하면 됩니다.
4. **복잡한 비즈니스 규칙 처리**: 급여 이체, 입금, 출금 등 복잡한 업무 규칙을 깔끔하게 관리할 수 있습니다.

### 트리거 실행 시점과 범위

트리거는 **실행 시점**과 **실행 범위**에 따라 분류됩니다.

**실행 시점:**
- **BEFORE**: 작업 수행 **전에** 트리거 실행
- **AFTER**: 작업 수행 **후에** 트리거 실행

**실행 범위:**
- **Statement(문장 트리거)**: 전체 데이터를 **한꺼번에** 처리. 트리거가 **한 번만** 실행됨
- **Row(행 트리거)**: 레코드 **하나씩** 처리. 레코드 개수만큼 **반복 실행**됨

이 둘을 조합하면 **4가지 유형**이 됩니다.

| 조합 | 설명 |
|------|------|
| **BEFORE Statement** | 작업 전에, 전체를 한꺼번에 처리 |
| **BEFORE Row** | 작업 전에, 한 행씩 처리 |
| **AFTER Statement** | 작업 후에, 전체를 한꺼번에 처리 |
| **AFTER Row** | 작업 후에, 한 행씩 처리 |

### 문장 트리거 vs 행 트리거

```sql
-- ✅ 문장 트리거(Statement Trigger) 예시: 전 직원 급여를 10% 인상
UPDATE EMP SET SALARY = SALARY * 1.1;
-- 트리거가 한 번 실행되어 전체 직원의 급여를 한꺼번에 10% 인상시킴
-- 직원이 100명이든 1000명이든 트리거는 딱 한 번만 동작
```

```sql
-- ✅ 행 트리거(Row Trigger) 예시: 각 레코드를 하나씩 처리
FOR EACH ROW  -- 각 행마다 반복 실행
-- 레코드가 100개이면 트리거가 100번 실행됨
-- 첫 번째 행 처리 → 두 번째 행 처리 → 세 번째 행 처리 → ... → 100번째 행 처리
```

문장 트리거는 마치 교실 전체에 "전원 10% 성적 상향!"이라고 한 번에 공지하는 것이고, 행 트리거는 학생 한 명 한 명을 불러서 개별적으로 성적을 조정해주는 것과 같습니다.

### 트리거 실습 예시: 계좌 잔액 확인

```sql
-- ✅ 트리거 예시: 계좌 이체 시 잔액 확인
CREATE TRIGGER 잔고                       -- '잔고'라는 이름의 트리거 생성
BEFORE UPDATE ON 계좌                     -- 계좌 테이블을 업데이트하기 전에 실행
FOR EACH ROW                              -- 각 행(레코드)마다 개별적으로 처리
WHEN (NEW.잔고 - NEW.이체금액 >= 0)       -- 잔고에서 이체금액을 뺀 값이 0 이상일 때
BEGIN                                     -- 액션 시작
  UPDATE 계좌                             -- 계좌 테이블을 업데이트
  SET 잔고 = 잔고 - 이체금액              -- 잔고에서 이체금액을 차감
  WHERE 계좌번호 = :NEW.계좌번호;         -- 해당 계좌번호에 대해서
END;                                      -- 액션 끝
```

이 코드의 동작을 실제 상황으로 설명하겠습니다.

**상황 1: 잔액 200만 원, 이체 금액 150만 원**
- 잔고(200) - 이체금액(150) = 50 → 0 이상이므로 **조건 만족!**
- 트리거 동작 → 계좌 잔고가 200 - 150 = 50만 원으로 업데이트됨
- 이체 **성공** ✅

**상황 2: 잔액 200만 원, 이체 금액 250만 원**
- 잔고(200) - 이체금액(250) = -50 → 0 미만이므로 **조건 불만족!**
- 트리거 동작하지 않음 → 이체 **거부** ❌

이처럼 트리거는 조건을 만족할 때만 액션을 수행하여, **잔액이 충분할 때만 이체를 허용**하는 안전한 시스템을 구현합니다.

### 트리거 관리 명령어

```sql
-- 트리거 삭제
DROP TRIGGER 트리거이름;

-- 트리거 비활성화 (잠시 중지)
ALTER TRIGGER 트리거이름 DISABLE;

-- 트리거 활성화 (다시 작동)
ALTER TRIGGER 트리거이름 ENABLE;

-- 트리거 재컴파일 (규칙 변경 후 다시 컴파일)
ALTER TRIGGER 트리거이름 COMPILE;
```

- **DROP**: 트리거를 완전히 삭제합니다.
- **DISABLE**: 트리거를 비활성화합니다. 방아쇠를 잠가놓는 것과 같습니다. 트리거 자체는 남아있지만 동작하지 않습니다.
- **ENABLE**: 비활성화된 트리거를 다시 활성화합니다. 언제라도 조건을 만족하면 트리거가 동작하게 됩니다.
- **COMPILE**: 트리거의 내용(규칙)이 변경되면 다시 컴파일해야 합니다.

:::danger 트리거 사용 시 주의사항
트리거 내부에서는 **COMMIT이나 ROLLBACK 같은 트랜잭션 제어 명령어를 사용할 수 없습니다.** 이것은 트리거의 대표적인 단점 중 하나이므로 반드시 기억해두세요.
:::

## 🔐 데이터베이스 보안의 필요성

### 보안이 필요한 이유

컴퓨터의 대량 보급, 정보화의 급속한 진행, 5G 시대와 4차 산업혁명의 도래로 데이터의 중요성이 그 어느 때보다 높아졌습니다. 그만큼 해킹, 불법 침입, 데이터 파괴, 정보 노출 등의 **보안 위협**도 심각해지고 있습니다.

데이터베이스는 본질적으로 **데이터와 직접 관련**되어 있기 때문에, 데이터베이스 보안을 유지하는 것은 매우 중요한 이슈입니다.

보안이 필요한 핵심 이유를 정리하면:

1. **권한 있는 사용자 보호**: 정당한 사용자가 데이터베이스에 정상적으로 접근하여 정보를 열람할 수 있도록 해야 합니다.
2. **불법 접근 차단**: 권한 없는 사용자가 데이터에 접근하거나, 데이터를 삭제·수정하는 것을 막아야 합니다.
3. **서비스 거부 공격 방지**: DDoS(분산 서비스 거부) 공격처럼, 좀비 PC들이 서버 자원을 대량으로 소모하여 정상 사용자가 시스템을 이용하지 못하게 되는 상황을 방지해야 합니다.
4. **기밀성·무결성·가용성 보장**: 대량의 데이터를 안전하게 관리하면서 데이터의 기밀성, 무결성, 가용성을 보장해야 합니다.

### 데이터베이스 위협 요소

| 위협 요소 | 설명 | 침해되는 속성 |
|-----------|------|---------------|
| **데이터 노출(Disclosure)** | 데이터가 위험하게 외부에 공개됨 | 기밀성 |
| **데이터 불법 수정** | 권한 없는 사용자가 데이터를 임의로 변경함 | 무결성 |
| **서비스 거부(DoS/DDoS)** | 정상 사용자가 시스템을 사용하지 못하게 됨 | 가용성 |

### 데이터베이스 보안 요구사항

데이터베이스 측면에서 요구되는 보안 사항들을 살펴보겠습니다.

- **정당한 접근 보장**: 권한을 가진 사용자는 데이터베이스에 정상적으로 접근할 수 있어야 합니다.
- **추론 방지**: 공개된 데이터를 통해 숨겨진 비밀 정보를 **추론(예측)**하지 못하도록 해야 합니다. 보여줄 데이터만 보여주고, 그 안에 감추고자 하는 데이터는 예측 불가능하도록 차단합니다.
- **무결성 유지**: 도메인 무결성, 릴레이션 무결성, 개체 무결성 등 다양한 무결성 규정을 만들고 트리거를 활용하여 데이터의 정확성을 유지합니다.
- **의미 무결성 유지**: 4년제 대학교는 1~4학년, 초등학교는 1~6학년, 중학교와 고등학교는 1~3학년 — 이처럼 누가 봐도 **의미적으로 당연한** 값의 범위를 유지하는 것입니다.
- **시스템 감사**: 사용자가 정상적인 권한으로 데이터에 접근했는지 **로그(기록)**를 통해 확인합니다. 은행 직원도 고객이 요구하고 서류가 접수될 때만 계좌를 조회할 수 있으며, 이 모든 과정은 로그에 기록됩니다.
- **인증**: 아이디와 패스워드가 정상적인 것인지 확인하는 절차입니다.
- **기밀 데이터 보호**: 극비문서, 대외비, 비밀문서 등 등급을 부여하여 보안을 유지합니다. Top Secret(극비), Secret(비밀), Confidential(대외비) 등으로 등급을 나누어 단계별로 접근 권한을 관리합니다.
- **감금(Confinement)**: 특별히 중요한 데이터는 아예 외부에서 접근하지 못하도록 격리하여 보호합니다.

:::warning 보안과 무결성을 혼동하지 마세요!
- **보안**: 승인받지 않은 사용자의 **접근을 차단**하는 것 (문 앞에서 막기)
- **무결성**: 승인받은 사용자가 사용하는 과정에서 **데이터 정확성을 유지**하는 것 (안에서 규칙 지키기)
:::

## 📌 핵심 정리

- **무결성(Integrity)**은 데이터의 **정확성**을 의미하며, 데이터베이스에서 가장 중요한 요소이다
- **성능과 무결성은 트레이드오프 관계**로, 성능 향상보다 무결성 유지가 더 우선시된다
- **보안은 불법 사용자의 접근 차단**, **무결성은 정상 사용자 사용 시 데이터 정확성 유지**로 구분된다
- **무결성 서브시스템**이 사용자가 설정한 규정에 따라 **자동으로** 무결성을 유지해준다
- 무결성 규정은 **규정 이름 → 검사 시기 → 제약 조건 → 위반 시 조치** 네 가지로 구성된다
- **도메인 무결성**: 속성 값이 정해진 범위(도메인) 내에 있는지 확인한다
- **릴레이션 무결성**: 테이블에 적용되는 모든 제약(과도 제약, 집합 제약, 튜플 제약 등)을 포괄한다
- **즉시 제약**은 변경 사항을 바로 반영하고, **지연 제약**은 트랜잭션 완료 후에 반영한다
- **트리거(Trigger)**는 조건을 **만족했을 때** 액션을 실행하는 **능동적** 메커니즘이다 (무결성은 위반 시 거부하는 **수동적** 메커니즘)
- 트리거는 **ECA(Event-Condition-Action)** 구조로 구성되며, 실행 범위에 따라 **문장 트리거**와 **행 트리거**로 나뉜다
- 데이터베이스 보안은 **기밀성, 무결성, 가용성**을 보장하기 위해 인증, 감사, 기밀 데이터 보호 등이 필요하다

작성일: 2026-02-21