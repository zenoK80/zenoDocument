---
title: "무결성과 보안의 차이"
description: "무결성과 보안의 차이에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/database-integrity-and-security/3-integrity-vs-security"
sidebar_label: "무결성 vs 보안"
date: "2026-02-21"
---

## 🎯 무결성과 보안, 왜 구별해야 할까?

데이터베이스를 공부하다 보면 **무결성(Integrity)**과 **보안(Security)**이라는 두 용어를 끊임없이 만나게 됩니다. 이 둘은 언뜻 비슷해 보이지만, 실제로는 **보호하려는 대상과 상황이 완전히 다릅니다**. 비유를 들어 보겠습니다.

- **보안**은 집 현관에 달린 **도어락**과 같습니다. 열쇠(권한)가 없는 외부인이 집 안에 들어오지 못하도록 막아 주는 역할이죠.
- **무결성**은 집 안에 들어온 가족이 **냉장고 안의 음식을 잘못된 칸에 넣거나, 상한 재료를 집어넣지 않도록** 관리하는 규칙과 같습니다.

즉, 보안은 "**누가 들어올 수 있는가?**"의 문제이고, 무결성은 "**들어온 사람이 데이터를 정확하게 다루고 있는가?**"의 문제입니다. 이 문서에서는 두 개념의 정의, 차이, 그리고 데이터베이스가 이를 어떻게 구현하는지를 **코드 예시**까지 곁들여 아주 자세히 살펴보겠습니다.

> **핵심 한 줄 요약**: 보안 = 불법 사용자를 **차단**, 무결성 = 정상 사용자의 **잘못된 데이터를 방지**

---

## 📖 무결성(Integrity)이란 무엇인가?

### 무결성의 사전적 의미

**무결성(Integrity)**은 한자로 풀면 "결함(缺)이 없다(無)"는 뜻입니다. 영어로는 *Integrity*라고 쓰며, 데이터베이스에서는 **데이터의 정확성(Accuracy)과 일관성(Consistency)**을 의미합니다. 데이터가 삽입·수정·삭제되는 모든 과정에서 "값이 올바른 상태를 유지하고 있는가?"를 보장하는 개념이죠.

예를 들어, 시험 점수는 **0점 이상 100점 이하**여야 합니다. 만약 누군가 120점을 입력한다면, 그 데이터는 *결함이 있는* 상태가 됩니다. 이렇게 결함이 발생하지 않도록 미리 규칙을 정해 놓고, 시스템이 자동으로 검사·거부하는 체계가 바로 **무결성 유지 메커니즘**입니다.

### 왜 무결성이 중요한가?

아무리 성능이 뛰어난 시스템이라도, **만 번에 한 번이라도 잘못된 결과가 나온다면** 실무에서는 사용할 수 없습니다. 은행 시스템을 떠올려 보세요.

- 내 통장 잔액이 **10,000원**인데, 갱신 오류로 갑자기 **10억 원**이 되어 버린다면?
- 반대로 **10억 원**이 있던 통장이 갑자기 **0원**이 되어 버린다면?

이런 일이 단 한 번이라도 발생하면 그 시스템은 **신뢰를 잃고 사용이 불가능**해집니다. 그래서 데이터베이스에서는 **성능(Performance)보다 무결성(Integrity)을 더 우선시**합니다.

:::info 성능과 무결성의 트레이드오프(Trade-off)
성능과 무결성은 **시소 관계**입니다. 무결성을 높이면 "이 값이 맞는지 검사해야 하니까 잠깐 기다려!"라는 과정이 추가되어 성능이 떨어집니다. 반대로 성능을 극대화하면 검사를 줄이게 되어 무결성이 약해질 수 있습니다. 하지만 **데이터베이스 시스템에서는 무결성 유지가 성능 향상보다 더 중요**하다는 것이 기본 원칙입니다.
:::

### 무결성은 누가 유지하는가?

중요한 포인트는, **무결성을 사용자가 직접 매번 확인하는 것이 아니라**, 사용자가 **무결성 규정(Rule)을 미리 정의**해 놓으면 DBMS(데이터베이스 관리 시스템) 내부의 **무결성 서브시스템**이 **자동으로** 검사하고 위반 시 거부한다는 것입니다.

마치 놀이공원 놀이기구에 "키 120cm 이상만 탑승 가능"이라는 규칙을 세워 놓으면, 직원이 매번 자로 재서 확인해 주는 것과 같습니다. 규칙만 잘 세워 놓으면, **시스템이 알아서 지켜 줍니다**.

---

## 🔐 보안(Security)이란 무엇인가?

### 보안의 정의

**보안(Security)**은 **승인받지 못한(불법적인) 사용자**가 데이터베이스에 접근하는 것을 **차단**하고, 데이터를 **안전하게 보호**하는 것을 말합니다. 정상적인 권한을 가진 사용자만 시스템에 접속하고, 자신에게 허락된 범위 내에서만 데이터를 열람·수정할 수 있도록 관리하는 체계입니다.

### 왜 보안이 필요한가?

오늘날은 컴퓨터와 인터넷이 대량으로 보급되고, 5G·4차 산업혁명 시대를 맞아 **데이터의 가치가 폭발적으로 높아졌습니다**. 그만큼 해킹, 불법 침입, DDoS(서비스 거부 공격) 같은 **위협도 함께 커지고 있습니다**.

- **해킹**: 권한 없는 사용자가 시스템에 침입하여 데이터를 탈취·파괴
- **DDoS 공격**: 좀비 PC들이 서버에 대량의 요청을 보내 **정상 사용자도 서비스를 이용하지 못하게** 만듦
- **데이터 노출(Disclosure)**: 기밀 데이터가 외부에 유출되는 것
- **불법 수정(Modification)**: 권한 없는 사용자가 데이터를 임의로 변경하는 것

:::warning 보안 위협의 3대 요소
| 위협 유형 | 설명 | 영향받는 속성 |
|---|---|---|
| **데이터 노출** | 기밀 데이터가 허가 없이 외부에 공개됨 | 기밀성(Confidentiality) |
| **데이터 불법 수정** | 권한 없는 사용자가 데이터를 변경함 | 무결성(Integrity) |
| **서비스 거부(DDoS)** | 정상 사용자가 시스템을 이용하지 못하게 됨 | 가용성(Availability) |
:::

### 보안에서 요구되는 사항들

데이터베이스 보안에서는 다음과 같은 사항들이 요구됩니다.

- **접근 통제**: 정당한 사용자만 DB에 접근할 수 있어야 합니다.
- **추론 방지**: 공개된 데이터를 조합하여 숨겨진 정보를 **추측(추론)**하는 것을 막아야 합니다. 예를 들어, 부서별 평균 급여와 인원수를 공개했을 때, 1인 부서라면 해당 직원의 정확한 급여가 드러나 버리겠죠. 이런 추론을 방지해야 합니다.
- **인증(Authentication)**: 아이디와 패스워드 등을 통해 사용자 본인이 맞는지 확인합니다.
- **기밀 데이터 보호**: 극비(Top Secret), 비밀(Secret), 대외비(Confidential) 등 등급을 부여하여 단계별로 접근을 통제합니다.
- **감사(Audit)**: 누가, 언제, 어떤 데이터에 접근했는지 **로그(기록)**를 남기고 분석합니다. 은행 직원도 고객 계좌를 마음대로 볼 수 없으며, 모든 접근은 로그로 기록됩니다.

---

## ⚖️ 무결성 vs 보안: 핵심 차이 한눈에 보기

이 두 개념의 차이를 명확히 이해하는 것이 이 문서의 핵심입니다. 아래 표로 정리해 보겠습니다.

| 구분 | 🛡️ 무결성(Integrity) | 🔒 보안(Security) |
|---|---|---|
| **대상** | 승인된(정상적인) 사용자 | 승인되지 않은(불법적인) 사용자 |
| **목적** | 데이터의 **정확성·일관성** 유지 | 데이터의 **접근 차단·보호** |
| **비유** | 냉장고 안 음식 정리 규칙 | 집 현관 도어락 |
| **처리 주체** | 무결성 서브시스템(DBMS 내부) | 보안 서브시스템(DBMS 내부) |
| **만나는 순서** | 보안 통과 **후** 만남 (2번째) | 사용자가 **처음** 만남 (1번째) |
| **핵심 질문** | "이 데이터 값이 올바른가?" | "이 사용자가 들어와도 되는가?" |

> 사용자가 시스템에 접속하면 **보안 서브시스템을 먼저 통과**합니다. 아이디·패스워드·권한 등을 확인한 뒤, 정상이면 **그 다음으로 무결성 서브시스템**을 만나게 됩니다. 마치 공항에서 **여권 심사(보안)** → **수화물 규격 검사(무결성)** 순서를 거치는 것과 같습니다.

---

## 📐 무결성 규정(Integrity Rule)의 구조

무결성을 유지하기 위해서는 **무결성 규정**을 미리 정의해야 합니다. 이 규정은 크게 **4가지 요소**로 구성됩니다.

### 1️⃣ 규정 이름 (Rule Name)

각 규정을 **유일하게 식별**하기 위한 이름(식별자)입니다. 하나의 시스템에는 수많은 규정이 존재하기 때문에, R1, R2, R3처럼 고유한 이름을 부여해야 합니다. 마치 법률에 "제1조, 제2조..."처럼 번호를 매기는 것과 같습니다.

### 2️⃣ 검사 시기 (When to Check)

무결성 검사를 **언제 수행할 것인가**를 결정합니다. 데이터가 변경되는 시점, 즉 **삽입(INSERT)·삭제(DELETE)·갱신(UPDATE)** 작업이 수행될 때 검사합니다. 참고로 **검색(SELECT)은 데이터를 변경하지 않으므로** 무결성 검사 대상이 아닙니다. 눈으로 보기만 하는 것은 데이터를 망가뜨리지 않으니까요.

검사 시기는 작업 **이전(BEFORE)** 또는 **이후(AFTER)**로 설정할 수 있습니다.

### 3️⃣ 제약 조건 (Constraint)

데이터가 **만족해야 하는 조건**입니다. 예를 들면:
- 점수는 **0 이상 100 이하**
- 학년은 **1 이상 4 이하**
- 성별은 **'남' 또는 '여'**

이 조건을 `CHECK`라는 키워드로 명시합니다.

### 4️⃣ 위반 시 조치 (Action on Violation)

제약 조건을 **위반했을 때** 어떤 조치를 취할 것인지 정의합니다. 일반적으로 **오류 메시지를 출력하고, 해당 작업(갱신·삽입 등)을 거부(REJECT)**합니다. 규정을 위반한 요청은 실행되지 않으므로, 자연스럽게 무결성이 유지됩니다.

### 무결성 규정 코드 예시

아래는 무결성 규정을 프로그래밍적으로 정의한 의사 코드(Pseudo Code)입니다.

```sql
-- ✅ 올바른 무결성 규정 정의 예시
-- 규정 이름: R1
-- 검사 시기: STUDENT 테이블의 YEAR(학년) 속성이 UPDATE된 직후
-- 제약 조건: YEAR 값이 0보다 커야 함
-- 위반 시 조치: 에러 메시지 출력 + 갱신 거부

R1:                                    -- 규정 이름 (유일한 식별자)
AFTER UPDATING STUDENT.YEAR            -- 검사 시기: 학년 갱신 후
CHECK (STUDENT.YEAR > 0)               -- 제약 조건: 학년은 0보다 커야 함
ELSE                                   -- 위반했을 때 조치
    PRINT 'R1 VIOLATED'                -- 에러 메시지 출력
    REJECT UPDATE                      -- 갱신 작업 거부
END                                    -- 규정 종료
```

**한 줄씩 설명:**

1. `R1:` → 이 규정의 이름은 **R1**입니다. 다른 규정과 구별하기 위한 식별자입니다.
2. `AFTER UPDATING STUDENT.YEAR` → **STUDENT 테이블의 YEAR 속성이 갱신된 직후에** 검사를 수행하겠다는 뜻입니다. `AFTER`이므로 갱신이 먼저 시도되고, 그 결과를 검사합니다.
3. `CHECK (STUDENT.YEAR > 0)` → 제약 조건입니다. **YEAR 값이 0보다 큰지** 확인합니다. 만약 0 이하의 값이 입력되면 위반입니다.
4. `ELSE` → 위의 CHECK 조건을 **위반했을 때** 아래의 조치를 실행합니다.
5. `PRINT 'R1 VIOLATED'` → 화면에 **"R1 규정을 위반했습니다"**라는 에러 메시지를 출력합니다.
6. `REJECT UPDATE` → 시도된 **갱신 작업을 거부**합니다. 데이터는 변경되지 않습니다.
7. `END` → 규정 정의를 마칩니다.

아래는 잘못된 예시입니다.

```sql
-- ❌ 잘못된 예시: 위반 시 조치가 없는 경우
R2:
AFTER UPDATING STUDENT.YEAR
CHECK (STUDENT.YEAR > 0)
-- ELSE 절이 없음! 위반해도 아무 조치가 없으면 무결성 유지 불가
END
```

위 코드처럼 `ELSE` 절(위반 시 조치)이 없으면, 잘못된 값이 입력되어도 **아무런 조치 없이 그대로 반영**되어 버릴 수 있습니다. 반드시 위반 시 조치를 명시해야 합니다.

---

## 🗂️ 무결성의 종류

무결성은 여러 유형으로 나뉘며, 각각이 데이터의 정확성을 서로 다른 관점에서 보장합니다.

### 🔹 도메인 무결성 (Domain Integrity)

**도메인(Domain)**이란 **속성(Attribute)이 가질 수 있는 값의 범위**를 말합니다. 넓게 보면 데이터 타입(정수, 실수, 문자, 날짜 등)이 될 수 있고, 좁게 보면 "학년은 1~4", "나이는 0~200" 같은 구체적인 범위가 됩니다.

**도메인 무결성**은 속성에 입력되는 값이 그 속성의 도메인 범위 안에 있어야 한다는 규칙입니다. 마치 "이 병에는 물만 담을 수 있어요. 기름을 넣으면 안 돼요"라는 규칙과 같습니다.

```sql
-- ✅ 도메인 무결성 설정 예시: 몸무게(WEIGHT) 속성
CREATE DOMAIN WEIGHT AS DECIMAL(5, 1)  -- 전체 5자리, 소수점 이하 1자리
CHECK (WEIGHT > 0 AND WEIGHT < 300);   -- 0보다 크고 300보다 작아야 함
```

**한 줄씩 설명:**

1. `CREATE DOMAIN WEIGHT` → **WEIGHT**라는 이름의 도메인(값의 범위 규칙)을 생성합니다.
2. `AS DECIMAL(5, 1)` → 데이터 타입은 **소수점 포함 전체 5자리, 소수점 이하 1자리**입니다. 예: 123.4, 99.9 등
3. `CHECK (WEIGHT > 0 AND WEIGHT < 300)` → 몸무게는 **0보다 크고 300보다 작은** 값만 허용합니다. 음수(-10)나 300 이상(500)의 값을 입력하면 **거부**됩니다.

```sql
-- ❌ 잘못된 입력 시도 예시
INSERT INTO PERSON (NAME, WEIGHT) VALUES ('홍길동', 450);
-- 결과: 거부됨! 450은 도메인 조건(0 < WEIGHT < 300)을 위반
```

### 🔹 릴레이션 무결성 (Relation Integrity)

**릴레이션(Relation)**은 데이터베이스에서 **테이블**을 의미합니다. 릴레이션 무결성은 **하나의 테이블에 적용할 수 있는 모든 무결성 규정을 포괄적으로 포함**하는 개념입니다. 도메인 무결성, 기본키 무결성, 외래키 참조 무결성, 널(NULL) 값 제약 등을 모두 아우릅니다.

릴레이션 무결성 안에는 세부적인 제약 유형이 있습니다.

#### 과도 제약 (Transition Constraint)

**상태 A에서 상태 B로 변화**할 때, 그 변화가 논리적으로 올바른지 검증하는 제약입니다. 예를 들어:

- **나이**: 작년 나이보다 올해 나이가 더 커야 합니다. 나이가 줄어드는 것은 불가능하죠.
- **주문 수량 vs 배송 수량**: 배송 수량이 주문 수량보다 많아서는 안 됩니다. 10개를 주문했는데 15개를 배송하면 안 되겠죠.
- **연봉**: 일반적으로 새 연봉(new)은 기존 연봉(old)보다 크거나 같아야 합니다.

```sql
-- ✅ 과도 제약 예시: 연봉은 줄어들 수 없다
WHEN UPDATE EMP.SALARY                  -- EMP 테이블의 SALARY를 갱신할 때
CHECK (EMP.NEW.SALARY >= EMP.OLD.SALARY) -- 새 연봉 >= 기존 연봉이어야 함
```

**한 줄씩 설명:**

1. `WHEN UPDATE EMP.SALARY` → EMP 테이블의 SALARY(급여) 속성이 갱신될 때 검사합니다.
2. `CHECK (EMP.NEW.SALARY >= EMP.OLD.SALARY)` → 새로 입력된 급여(`NEW.SALARY`)가 기존 급여(`OLD.SALARY`)보다 **크거나 같아야** 합니다. 급여가 줄어드는 갱신은 거부됩니다.

#### 집합 제약 (Aggregate Constraint)

**전체 튜플(행) 집합**에 대한 제약입니다. 개별 레코드가 아니라 **전체를 합산·평균한 결과**가 조건을 만족해야 합니다.

```sql
-- ✅ 집합 제약 예시: 직원 평균 급여가 300만 원 이하여야 함
AFTER UPDATING EMP.SALARY               -- EMP 테이블의 SALARY 갱신 후
CHECK (AVERAGE(EMP.SALARY) <= 300)       -- 전체 직원 평균 급여 <= 300
```

**한 줄씩 설명:**

1. `AFTER UPDATING EMP.SALARY` → 급여 갱신이 완료된 후 검사합니다.
2. `CHECK (AVERAGE(EMP.SALARY) <= 300)` → 전체 직원의 **평균 급여**가 300(만 원) 이하인지 확인합니다. 누구의 급여를 올리든 내리든, **전체 평균이 300을 초과하면 거부**됩니다.

회사의 총 급여 예산이 정해져 있을 때, 이런 집합 제약이 유용합니다. 한 사람의 급여를 올리면 다른 사람의 급여를 조정해야 할 수도 있겠죠.

#### 튜플 제약 (Tuple Constraint)

**개별 튜플(행) 하나하나**에 대한 제약입니다. 집합 제약과 달리 **각 행이 독립적으로** 조건을 만족해야 합니다.

```sql
-- ✅ 튜플 제약 예시: 개별 직원의 급여가 500만 원 이하여야 함
CHECK (EMP.SALARY <= 500)               -- 모든 직원의 개별 급여 <= 500
```

이 조건은 **모든 직원 각각에게 적용**됩니다. 어떤 직원이든 급여가 500만 원을 초과하면 입력이 거부됩니다.

#### 즉시 제약 (Immediate Constraint)

삽입·삭제·갱신 연산이 수행된 **즉시** 결과가 반영되는 제약입니다. 일반적인 데이터 변경은 대부분 즉시 제약을 따릅니다. 네이버에서 주소를 변경하고 저장 버튼을 누르면 **바로 반영**되는 것처럼요.

```sql
-- ✅ 즉시 제약 예시: 성별은 'M' 또는 'F'만 허용
AFTER UPDATING EMP.GENDER               -- 성별 갱신 후
CHECK (EMP.GENDER IN ('M', 'F'))         -- 'M'(남자) 또는 'F'(여자)만 허용
```

#### 지연 제약 (Deferred Constraint)

즉시 반영이 **아니라**, 관련 작업이 **모두 완료된 후에** 결과를 반영하는 제약입니다. 가장 대표적인 예가 **계좌 이체**입니다.

내 통장(A)에서 상대방 통장(B)으로 100만 원을 이체한다고 가정해 봅시다.

1. A 통장에서 100만 원을 차감 시도
2. B 통장에 100만 원을 입금 시도
3. B 은행에서 "정상 입금 완료"라는 확인(COMMIT) 메시지를 보냄
4. **그제야** A 통장에서 100만 원이 최종 차감됨

만약 이것이 **즉시 제약**이라면 어떤 문제가 생길까요?

```
❌ 즉시 제약으로 계좌 이체를 처리한 경우:
1. A 통장에서 100만 원 차감 → 바로 반영!
2. B 은행 서버가 점검 중이라 입금 실패...
3. 결과: A에서 돈은 빠졌는데, B는 받지 못함 → 100만 원 증발!
```

이런 심각한 문제를 방지하기 위해 **지연 제약**이 필요합니다.

```sql
-- ✅ 지연 제약 예시: 트랜잭션이 완전히 완료(COMMIT)된 후에 갱신 반영
WHEN COMMIT                              -- 모든 작업이 성공적으로 완료된 후
UPDATE ACCOUNT                           -- 계좌 테이블을 갱신
SET BALANCE = BALANCE - TRANSFER_AMOUNT  -- 잔액에서 이체 금액을 차감
```

:::tip 수표 입금도 지연 제약의 예
은행에서 수표를 입금하면 보통 **24시간 후에야** 돈을 인출할 수 있습니다. 이는 수표가 **부도 수표인지, 분실 수표인지** 확인하는 시간이 필요하기 때문입니다. 확인이 완료된 후에야 잔액에 반영되는 것이 바로 지연 제약의 실생활 예시입니다.
:::

---

## ⚡ 트리거(Trigger): 무결성의 능동적 파트너

### 트리거란?

**트리거(Trigger)**는 영어로 "방아쇠"를 뜻합니다. 총을 떠올려 보세요. 평소에는 가만히 있다가, **방아쇠를 당기면 총알이 발사**됩니다. 데이터베이스의 트리거도 마찬가지입니다. 평소에는 가만히 있다가, **특정 조건이 만족되면 자동으로 미리 정의된 동작을 실행**합니다.

### 무결성 제약 vs 트리거: 핵심 차이

이 두 개념의 차이를 이해하는 것이 매우 중요합니다.

| 구분 | 무결성 제약 조건 | 트리거(Trigger) |
|---|---|---|
| **동작 시점** | 조건을 **위반**했을 때 | 조건을 **만족**했을 때 |
| **성격** | **수동적** (가만있다가 위반하면 거부) | **능동적** (조건 맞으면 적극 실행) |
| **비유** | "규칙 어기면 퇴장!" | "조건 충족하면 자동 처리!" |

> **무결성 제약**: "점수가 100점을 초과하면? → **거부!**" (수동적)
> **트리거**: "잔액이 충분하면? → **이체 실행!**" (능동적)

### 트리거의 구성 요소: ECA

트리거는 **ECA** 구조로 이루어져 있습니다.

- **E (Event, 이벤트)**: 언제 트리거가 감지되는가? → **INSERT, DELETE, UPDATE** 작업 시 (SELECT은 해당 없음)
- **C (Condition, 조건)**: 어떤 조건이 참일 때 실행되는가? → 특정 조건식
- **A (Action, 액션)**: 조건이 참이면 무엇을 실행하는가? → 실제 수행할 작업

### 트리거의 장점

- **노력 중복 제거**: 복잡한 비즈니스 규칙을 한 번 정의해 놓으면, 매번 수동으로 처리할 필요가 없습니다.
- **일관성 유지**: 같은 조건이면 항상 같은 처리가 이루어지므로 데이터의 일관성이 보장됩니다.
- **유지보수 용이**: 규칙이 바뀌면 해당 트리거 프로그램만 수정하면 됩니다. 모듈화된 구조이기 때문입니다.
- **복잡한 비즈니스 규칙 처리**: 은행 이체, 급여 계산 등 복잡한 로직을 트리거로 자동화할 수 있습니다.

### 트리거의 실행 시점과 범위

| 실행 시점 | 설명 |
|---|---|
| **BEFORE** | 작업이 수행되기 **전에** 트리거 실행 |
| **AFTER** | 작업이 수행된 **후에** 트리거 실행 |

| 실행 범위 | 설명 |
|---|---|
| **STATEMENT (문장 트리거)** | 트리거가 **한 번** 실행되어 전체 데이터를 한꺼번에 처리 |
| **ROW (행 트리거)** | 영향받는 **각 행(레코드)마다** 트리거가 반복 실행 |

이를 조합하면 **4가지** 실행 유형이 나옵니다:

| 조합 | 의미 |
|---|---|
| BEFORE STATEMENT | 전체 문장 실행 전에, 한 번만 트리거 실행 |
| BEFORE ROW | 각 행 처리 전에, 행마다 트리거 실행 |
| AFTER STATEMENT | 전체 문장 실행 후에, 한 번만 트리거 실행 |
| AFTER ROW | 각 행 처리 후에, 행마다 트리거 실행 |

### 트리거 코드 예시

```sql
-- ✅ 문장 트리거(STATEMENT Trigger) 예시
-- 전 직원의 급여를 한꺼번에 10% 인상
UPDATE EMP SET SALARY = SALARY * 1.1;
-- 트리거가 한 번 실행되어 전체 직원의 급여를 일괄 처리
```

```sql
-- ✅ 행 트리거(ROW Trigger) 예시: 계좌 이체 시 잔액 확인
CREATE TRIGGER 잔고_확인                  -- 트리거 이름: 잔고_확인
BEFORE UPDATE ON 계좌                     -- 계좌 테이블 갱신 전에 실행
FOR EACH ROW                              -- 각 행(레코드)마다 반복 실행
WHEN (NEW.잔고 - NEW.이체금액 >= 0)        -- 조건: 잔고에서 이체금액을 빼도 0 이상인가?
BEGIN
    -- 조건을 만족하면(잔액이 충분하면) 이체 처리 실행
    UPDATE 계좌
    SET 잔고 = 잔고 - :NEW.이체금액        -- 잔액에서 이체 금액을 차감
    WHERE 계좌번호 = :NEW.계좌번호;        -- 해당 계좌에 대해서만 적용
END;
```

**한 줄씩 설명:**

1. `CREATE TRIGGER 잔고_확인` → **"잔고_확인"**이라는 이름의 트리거를 생성합니다.
2. `BEFORE UPDATE ON 계좌` → **계좌 테이블에 UPDATE가 수행되기 전에** 이 트리거가 동작합니다.
3. `FOR EACH ROW` → 영향받는 **각 행마다** 트리거가 반복 실행됩니다. 이것이 **행 트리거(ROW Trigger)**의 핵심입니다.
4. `WHEN (NEW.잔고 - NEW.이체금액 >= 0)` → 조건(Condition)입니다. 잔고에서 이체 금액을 뺀 값이 **0 이상**(즉, 잔액이 충분한 경우)이면 아래 액션을 수행합니다.
5. `BEGIN ... END` → 조건이 만족되면 실행할 액션(Action) 블록입니다.
6. `SET 잔고 = 잔고 - :NEW.이체금액` → 잔액에서 이체 금액만큼 차감합니다.
7. `WHERE 계좌번호 = :NEW.계좌번호` → 해당 계좌번호에 대해서만 적용합니다.

잔액이 200만 원인데 250만 원을 이체하려 하면? `200 - 250 = -50`이므로 조건(`>= 0`)을 만족하지 못해 **트리거가 동작하지 않고, 이체가 거부**됩니다.

```sql
-- ❌ 잘못된 예시: 잔액 확인 없이 바로 이체
-- 조건 검사 없이 무조건 차감하면 잔액이 마이너스가 될 수 있음!
UPDATE 계좌
SET 잔고 = 잔고 - 이체금액;  -- 잔액 부족 여부를 확인하지 않음!
```

### 트리거 관리 명령어

```sql
-- 트리거 삭제
DROP TRIGGER 잔고_확인;

-- 트리거 비활성화 (방아쇠를 내려놓는 것)
ALTER TRIGGER 잔고_확인 DISABLE;

-- 트리거 활성화 (방아쇠를 올려놓는 것)
ALTER TRIGGER 잔고_확인 ENABLE;

-- 트리거 재컴파일 (내용 변경 후 다시 적용)
ALTER TRIGGER 잔고_확인 COMPILE;
```

:::danger 트리거 사용 시 주의사항
트리거 내부에서는 **COMMIT이나 ROLLBACK 같은 트랜잭션(작업 묶음) 제어 명령어를 사용할 수 없습니다**. 트리거는 다른 트랜잭션의 일부로 실행되기 때문에, 자체적으로 트랜잭션을 확정하거나 취소하면 예기치 않은 오류가 발생할 수 있습니다.
:::

---

## 🛡️ 보안의 구체적 구현 방법

데이터베이스 보안은 단순히 "막는다"가 아니라, 여러 계층의 보호 메커니즘으로 이루어집니다.

### 인증 (Authentication)

사용자가 시스템에 접속할 때 **아이디와 패스워드**가 정상적인지 확인합니다. 가장 기본적인 보안 단계입니다. 마치 건물 입구에서 출입증을 확인하는 것과 같습니다.

### 접근 통제 (Access Control)

인증을 통과한 사용자라도 **모든 데이터에 접근할 수 있는 것은 아닙니다**. 각 사용자에게 허용된 권한(읽기, 쓰기, 삭제 등)의 범위 내에서만 데이터에 접근할 수 있도록 제어합니다. 마치 회사에서 일반 직원은 인사 파일에 접근할 수 없고, 인사부 직원만 접근할 수 있는 것과 같습니다.

### 기밀 데이터 등급 분류

중요도에 따라 데이터를 등급별로 분류하여 관리합니다.

| 등급 | 영문 | 설명 |
|---|---|---|
| 극비 | Top Secret | 최고 수준의 보안. 극소수만 접근 가능 |
| 비밀 | Secret | 높은 수준의 보안. 특정 권한자만 접근 가능 |
| 대외비 | Confidential | 내부에서만 공유 가능. 외부 유출 금지 |
| 일반 | Unclassified | 누구나 접근 가능한 공개 데이터 |

### 감사 (Audit)

모든 데이터 접근과 조작 내역을 **로그(Log)**로 기록하여, 나중에 **누가 언제 무엇을 했는지** 추적할 수 있도록 합니다. 은행 직원이 고객 계좌를 임의로 조회할 수 없는 이유도, 모든 접근이 로그로 남기 때문입니다. 감사를 통해 비정상적인 접근 패턴을 탐지할 수 있습니다.

### 추론 방지 (Inference Prevention)

공개된 데이터를 조합하여 **비공개 정보를 추측**하는 것을 막아야 합니다. 예를 들어, 부서별 평균 급여를 공개했는데 어떤 부서에 한 사람만 있다면, 그 사람의 정확한 급여가 바로 드러나 버립니다. 이런 추론 경로를 차단하는 것이 추론 방지입니다.

---

## ⚠️ 자주 헷갈리는 점과 주의사항

### 무결성 ≠ 보안, 절대 혼동하지 마세요

| 상황 | 해당 개념 |
|---|---|
| 해커가 데이터베이스에 침입하여 데이터를 탈취 | 🔒 **보안** 문제 |
| 정상 사용자가 점수에 120을 입력 | 🛡️ **무결성** 문제 |
| DDoS 공격으로 서비스 불가 | 🔒 **보안** 문제 |
| 이체 중 시스템 오류로 잔액이 잘못 계산 | 🛡️ **무결성** 문제 |
| 권한 없는 직원이 인사 파일을 열람 | 🔒 **보안** 문제 |
| 나이 필드에 음수 값이 입력 | 🛡️ **무결성** 문제 |

### 검색(SELECT)은 무결성 검사 대상이 아닙니다

검색은 데이터를 **읽기만** 할 뿐 변경하지 않으므로, 무결성이 위반될 여지가 없습니다. 무결성 검사는 **INSERT, UPDATE, DELETE** 작업에서만 수행됩니다.

### 트리거에서 COMMIT/ROLLBACK 사용 불가

트리거는 다른 트랜잭션 내부에서 실행되므로, **자체적으로 COMMIT이나 ROLLBACK을 수행할 수 없습니다**. 이를 시도하면 오류가 발생합니다.

### 성능과 무결성의 균형

무결성 규정을 너무 많이 설정하면 **매 작업마다 수많은 검사가 수행**되어 성능이 저하될 수 있습니다. 하지만 그렇다고 무결성을 느슨하게 하면 데이터 품질이 떨어집니다. **꼭 필요한 규정을 정확하게 설정**하는 것이 핵심입니다.

:::warning 가장 흔한 실수
"무결성을 잘 설정했으니 보안은 신경 쓰지 않아도 된다"고 생각하는 것은 매우 위험합니다. 무결성은 **이미 들어온 사용자**의 데이터 정확성을 관리할 뿐, **불법 침입을 막아 주지는 않습니다**. 보안과 무결성은 **둘 다 반드시 필요**합니다.
:::

---

## 📌 핵심 정리

- **무결성(Integrity)**: 승인된 사용자가 데이터를 다룰 때 **데이터의 정확성과 일관성이 유지**되도록 보장하는 것
- **보안(Security)**: 승인되지 않은 사용자가 데이터베이스에 **접근·수정·파괴하는 것을 차단**하는 것
- 사용자는 시스템 접속 시 **보안 서브시스템 → 무결성 서브시스템** 순서로 통과한다
- 무결성 규정은 **규정 이름, 검사 시기, 제약 조건, 위반 시 조치** 4가지로 구성된다
- 무결성은 사용자가 규정을 정의하면 **DBMS가 자동으로** 검사·유지한다
- **도메인 무결성**: 속성 값이 정해진 범위(도메인) 안에 있어야 함
- **릴레이션 무결성**: 테이블에 적용되는 모든 제약(과도 제약, 집합 제약, 튜플 제약 등)을 포괄
- **즉시 제약**: 작업 즉시 결과 반영 / **지연 제약**: 관련 작업 전부 완료 후 반영 (예: 계좌 이체)
- **트리거(Trigger)**: 조건을 **만족**하면 자동 실행 (능동적) ↔ 무결성 제약: 조건을 **위반**하면 거부 (수동적)
- 트리거는 **ECA(Event-Condition-Action)** 구조이며, BEFORE/AFTER × STATEMENT/ROW로 4가지 실행 유형이 있다
- 성능과 무결성은 **트레이드오프 관계**이지만, 데이터베이스에서는 **무결성이 성능보다 우선**한다
- 보안의 핵심 요소: **인증, 접근 통제, 기밀 등급 분류, 감사(로그), 추론 방지**

---

작성일: 2026-02-21