---
title: "성능과 무결성의 트레이드오프 관계"
description: "성능과 무결성의 트레이드오프 관계에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/database-integrity-and-security/2-performance-vs-integrity"
sidebar_label: "성능과 무결성"
date: "2026-02-21"
---

## 🎯 무결성이란 무엇인가?

데이터베이스를 공부하다 보면 **무결성(Integrity)**이라는 단어를 정말 자주 만나게 됩니다. 개체 무결성, 참조 무결성, 도메인 무결성, 키 무결성… 온갖 곳에 "무결성"이 붙어 있죠. 그런데 이 단어가 대체 무슨 뜻일까요?

**무결성**이라는 말을 한자로 풀어보면 **"결점이 없다"**라는 뜻입니다. 영어로는 **Integrity**라고 합니다. 데이터 측면에서 결점이 없다는 것은, 곧 **데이터가 갖고 있는 값이 정확하다**는 의미입니다. 그래서 무결성은 곧 **"정확성"**이라는 말로 바꿔서 이해할 수 있습니다.

> **무결성 = 정확성**
> 데이터베이스에 저장된 데이터가 항상 정확하고 일관된 상태를 유지하는 것을 의미합니다.

마치 은행 통장의 잔액이 항상 실제 입출금 내역과 정확히 일치해야 하는 것처럼, 데이터베이스의 모든 데이터도 현실 세계의 값과 정확히 일치해야 합니다. 만약 통장에 100만 원이 있는데 시스템이 50만 원이라고 보여준다면, 그 시스템은 무결성이 깨진 것입니다.

### 📌 무결성이 왜 중요한가?

아무리 성능이 좋은 시스템이라도, **만 번에 한 번씩이라도 잘못된 결과가 나온다면** 그 시스템은 실제 현업에서 사용할 수 없습니다. 이것이 무결성이 중요한 핵심 이유입니다.

예를 들어볼까요? 은행 시스템을 생각해 보세요. 매일 수백만 건의 입금, 출금, 이체, 조회가 이루어지는 은행 시스템에서 만 번에 한 번씩 이상한 일이 벌어진다고 가정해 봅시다.

- 내 통장에 **1만 원**밖에 없었는데, 갱신 오류로 갑자기 **10억 원**이 찍혀버린다면?
- 반대로 **10억 원**이 있던 통장이 갑자기 **잔액 0원**으로 바뀌어 버린다면?

이런 일이 만 번에 한 번, 정말 드물게 발생하더라도 그 시스템은 **절대로 사용할 수 없습니다**. 은행 고객의 재산이 걸린 문제이기 때문입니다.

:::danger 무결성이 깨지면 벌어지는 일
아무리 처리 속도가 빠르고, 아무리 예쁜 UI를 가지고 있어도, 데이터가 한 번이라도 잘못되면 그 시스템은 **신뢰를 완전히 잃게** 됩니다. 성능보다 무결성이 훨씬 더 중요한 이유입니다.
:::

## ⚖️ 성능과 무결성의 트레이드오프 관계

### 트레이드오프(Trade-off)란?

**트레이드오프(Trade-off)**란 **한쪽을 얻으면 다른 한쪽을 잃게 되는 관계**를 말합니다. 마치 시소처럼 한쪽이 올라가면 다른 한쪽은 내려갈 수밖에 없는 것이죠.

데이터베이스에서 **성능(Performance)**과 **무결성(Integrity)**은 바로 이 트레이드오프 관계에 있습니다.

| 방향 | 결과 |
|---|---|
| **성능을 높이면** → | 무결성은 떨어질 수밖에 없음 |
| **무결성을 높이면** → | 성능은 떨어질 수밖에 없음 |
| **둘 다 올리려 하면** → | 현실적으로 불가능 |

### 왜 둘 다 올릴 수 없는가?

무결성을 높인다는 것은 **이것저것 제약이 많아진다**는 뜻입니다. 제약이 많다는 것은 무언가를 하려고 할 때마다 "잠깐만, 검사해야 돼!", "이건 안 돼!" 같은 확인 절차가 추가된다는 의미입니다.

마치 공항 보안검색을 생각해 보세요. 보안검색을 철저히 하면 할수록 안전성(무결성)은 높아지지만, 탑승까지 걸리는 시간(성능)은 길어집니다. 보안검색을 안 하면 빨리 탑승할 수 있지만, 위험한 물건이 반입될 수 있죠.

데이터베이스도 마찬가지입니다:

- **"이 값이 0~100 사이인지 확인해!"** → 검사 시간 소요
- **"기본키가 중복되지 않는지 확인해!"** → 검사 시간 소요
- **"외래키가 참조하는 테이블에 실제로 존재하는지 확인해!"** → 검사 시간 소요

이런 검사를 하나하나 수행할 때마다 시스템은 조금씩 느려질 수밖에 없습니다. 하지만 이 검사들을 생략하면? 빠르긴 하지만 잘못된 데이터가 들어갈 위험이 생깁니다.

> **데이터베이스 시스템에서 가장 중요한 것은 성능을 향상시키는 것보다 무결성을 유지하는 것입니다.** 속도가 느리더라도 정확한 데이터를 보장하는 시스템이, 빠르지만 가끔 틀리는 시스템보다 훨씬 가치 있습니다.

## 🛡️ 무결성과 보안의 차이

무결성을 이야기할 때 항상 **보안(Security)**이라는 개념과 헷갈리기 쉽습니다. 이 둘은 비슷해 보이지만 완전히 다른 개념입니다.

| 구분 | 무결성(Integrity) | 보안(Security) |
|---|---|---|
| **대상** | 승인받은 **정상적인** 사용자 | 승인받지 못한 **불법적인** 사용자 |
| **목적** | 데이터의 **정확성** 유지 | 데이터의 **접근 차단** 및 보호 |
| **언제 동작?** | 정상 사용자가 검색·삽입·삭제·갱신할 때 | 불법 사용자가 접근하려 할 때 |
| **비유** | 요리사가 레시피대로 정확히 요리하는 것 | 주방에 관계자 외 출입금지 하는 것 |

쉽게 비유하자면 이렇습니다. 여러분이 회사 건물에 출입하는 상황을 떠올려 보세요.

- **보안**: 건물 입구에서 출입증을 확인하고, 출입증이 없는 사람은 들어오지 못하게 막는 것
- **무결성**: 건물에 정상적으로 들어온 직원이 업무를 수행할 때, 실수로 잘못된 데이터를 입력하지 않도록 검증하는 것

사용자가 시스템에 접근할 때는 **먼저 보안 서브시스템**을 만나게 됩니다. 아이디와 패스워드가 정상적인지, 권한이 있는지 확인하죠. 이상이 없으면 그 다음에 **무결성 서브시스템**을 만나게 됩니다. 정상적인 사용자가 데이터를 다룰 때 데이터의 정확성이 유지되도록 검사하는 것이죠.

:::info 보안과 무결성의 만남 순서
**사용자 접근** → 🔒 **보안 서브시스템** (권한 확인) → ✅ **무결성 서브시스템** (데이터 정확성 검증) → 📦 **데이터베이스**
:::

## 📋 무결성 규정(Integrity Rule)이란?

### 누가 무결성을 유지하는가?

여기서 중요한 포인트가 있습니다. **무결성은 사용자나 개발자, DBA(데이터베이스 관리자)가 직접 유지하는 것이 아닙니다.** 사람이 매번 "이 데이터 정확한지 확인해볼게~" 하면서 일일이 검사하는 것이 아니라는 거죠.

우리가 해야 할 일은 **무결성에 대한 규정을 미리 정해놓는 것**입니다.

- "학번은 기본키로 설정해!"
- "점수는 0점에서 100점까지만 가능해!"
- "성별은 '남' 또는 '여'만 입력 가능해!"

이런 제약 조건들을 쭉 설정해 놓으면, **DBMS의 무결성 서브시스템**이라는 구성 요소가 **알아서 자동으로** 무결성을 유지시켜 줍니다. 마치 자동 세탁기에 세탁 코스를 설정해 놓으면 기계가 알아서 빨래를 해주는 것과 같은 원리입니다.

### 무결성 검사의 동작 과정

무결성 검사가 어떻게 이루어지는지 단계별로 살펴보겠습니다.

1. **갱신 작업 요청**: 사용자가 데이터를 삽입, 수정, 삭제하려고 합니다
2. **무결성 검사 수행**: DBMS가 미리 설정된 규정에 맞는지 자동으로 검사합니다
3. **규정 위반 여부 판단**: 규정을 위반했는지 확인합니다
4. **조치 수행**: 위반했다면 갱신을 거부하고 에러 메시지를 출력합니다

예를 들어 "점수는 0점에서 100점까지"라는 규정이 있는데, 누군가 **120점**을 입력했다면:

1. 120점 입력 요청 발생
2. 무결성 서브시스템이 "점수는 0~100점" 규정과 비교
3. 120점은 규정 위반!
4. "무결성 규정을 위반했습니다. 입력 값을 다시 확인해 보세요" 에러 메시지 출력 + 갱신 거부

이렇게 자연스럽게 무결성이 유지되는 것입니다.

:::tip 핵심 원리
무결성은 **"규정 설정 → 자동 검사 → 위반 시 거부"**라는 흐름으로 유지됩니다. 사람이 매번 확인하는 것이 아니라, 한 번 규정을 설정해 놓으면 시스템이 알아서 해줍니다!
:::

### 무결성 규정의 4가지 구성 요소

무결성 규정(Integrity Rule)은 다음 4가지 요소로 구성됩니다:

| 구성 요소 | 설명 | 예시 |
|---|---|---|
| **규정 이름** | 규정을 식별하는 유일한 이름 | R1, R2, R3... |
| **검사 시기** | 언제 무결성 검사를 할 것인가 | 삽입 시, 갱신 시, 삭제 시 |
| **제약 조건** | 데이터가 만족해야 하는 조건 | 점수 ≥ 0 AND 점수 ≤ 100 |
| **위반 시 조치** | 조건을 위반했을 때 취할 행동 | 갱신 거부, 에러 메시지 출력 |

**규정 이름**은 규정을 참조할 때 사용하는 식별자(Identifier)입니다. 하나의 시스템에 무결성 규정이 수십, 수백 개 있을 수 있기 때문에, 각 규정을 유일하게 구분하기 위해 이름이 필요합니다. 마치 법률에 번호를 매기듯이 말이죠.

**검사 시기**는 무결성 검사를 **언제** 수행할 것인지를 정합니다. 여기서 중요한 점은, **검색(SELECT) 작업은 데이터를 변경하지 않으므로 무결성 검사가 필요 없다**는 것입니다. 눈으로 보기만 하는 것이니까요. 무결성 검사가 필요한 것은 데이터가 변경되는 **삽입(INSERT), 갱신(UPDATE), 삭제(DELETE)** 작업뿐입니다.

**제약 조건(Constraint)**은 데이터가 만족해야 하는 조건 자체입니다. "점수는 0~100점", "학년은 1~4학년", "성별은 남 또는 여" 같은 것들이죠.

**위반 시 조치**는 제약 조건을 만족하지 못했을 때 어떤 행동을 취할 것인지를 정의합니다. 대부분 갱신을 거부하고 에러 메시지를 보여주는 방식입니다.

### 무결성 규정 프로그래밍 예시

실제로 무결성 규정을 프로그래밍하면 어떤 모습일까요? 아래 예시를 통해 살펴보겠습니다.

✅ **올바른 무결성 규정 작성 예시:**

```sql
-- 무결성 규정 R1: 학생 테이블의 학년(year) 값은 반드시 0보다 커야 한다
R1:                              -- 규정 이름: R1
AFTER UPDATING STUDENT.YEAR      -- 검사 시기: STUDENT 테이블의 YEAR 속성 업데이트 후
CHECK (STUDENT.YEAR > 0)         -- 제약 조건: 학년 값이 0보다 큰지 검사
ELSE                             -- 위반 시 조치:
  PRINT 'R1 VIOLATED'            --   "R1 위반" 메시지 출력
  REJECT UPDATE                  --   업데이트 거부
END                              -- 규정 끝
```

이 코드를 한 줄씩 자세히 뜯어보겠습니다:

- **`R1:`** — 이 무결성 규정의 이름입니다. 나중에 이 규정을 참조하거나 수정할 때 "R1"이라는 이름으로 찾을 수 있습니다.
- **`AFTER UPDATING STUDENT.YEAR`** — 검사 시기를 지정합니다. `AFTER`는 "~한 후에"라는 뜻이므로, STUDENT 테이블의 YEAR 속성을 **업데이트하고 난 직후에** 검사하겠다는 의미입니다. `BEFORE`를 쓰면 업데이트 **이전에** 검사합니다.
- **`CHECK (STUDENT.YEAR > 0)`** — 제약 조건입니다. STUDENT 테이블의 YEAR 값이 0보다 큰지 확인합니다. 1학년, 2학년, 3학년, 4학년은 모두 0보다 크므로 통과하지만, 0이나 음수는 통과하지 못합니다.
- **`ELSE`** — 위의 CHECK 조건을 **위반했을 때** 실행할 내용이 여기에 옵니다.
- **`PRINT 'R1 VIOLATED'`** — 화면에 "R1 규정이 위반되었습니다"라는 메시지를 출력합니다.
- **`REJECT UPDATE`** — 업데이트를 거부합니다. 즉, 잘못된 값으로 데이터가 변경되는 것을 막습니다.
- **`END`** — 이 무결성 규정의 끝을 나타냅니다.

이렇게 프로그래밍을 해놓으면, 사용자가 직접 검사할 필요 없이 **시스템이 자동으로** 무결성을 유지합니다. 문제 상황이 발생하면 자동으로 실행을 거부하고, 정상적인 상황이면 자동으로 통과시켜 줍니다.

:::note AFTER vs BEFORE
- **AFTER**: 작업이 수행된 **후에** 검사합니다. 일단 실행해보고, 문제가 있으면 되돌립니다.
- **BEFORE**: 작업이 수행되기 **전에** 검사합니다. 문제가 있으면 아예 실행하지 않습니다.
:::

## 📊 무결성의 종류

### 1. 도메인 무결성 (Domain Integrity)

**도메인(Domain)**이란 **속성이 가질 수 있는 값의 범위**를 말합니다. 마치 자판기에서 선택할 수 있는 음료 종류가 정해져 있듯이, 각 속성(칼럼)에 들어갈 수 있는 값의 종류와 범위가 정해져 있는 것이죠.

넓은 의미에서의 도메인:
- 정수(Integer) 타입
- 실수(Float) 타입
- 문자(Character) 타입
- 날짜(Date) 타입
- 불린(Boolean) 타입 — True/False

좀 더 구체적인 도메인:
- **학년**: 1, 2, 3, 4만 가능
- **나이**: 0~200까지만 가능
- **성별**: '남' 또는 '여'만 가능
- **점수**: 0~100까지만 가능

**도메인 무결성**이란 주어진 속성의 값이 그 속성에 정해진 **도메인(값의 범위)에 반드시 속해야 한다**는 규정입니다. 삽입이나 갱신 작업이 일어났을 때, 이 범위가 지켜지도록 유지하는 것이 도메인 무결성의 핵심입니다.

✅ **도메인 무결성 설정 예시:**

```sql
-- 도메인 생성: 몸무게(WEIGHT) 속성의 값 범위를 정의
CREATE DOMAIN WEIGHT              -- WEIGHT라는 도메인을 생성한다
  DECIMAL(5, 1)                   -- 전체 5자리, 소수점 이하 1자리 (예: 123.4)
  CHECK (VALUE > 0 AND VALUE < 300)  -- 값은 0보다 크고 300보다 작아야 한다
```

이 코드를 한 줄씩 살펴보겠습니다:

- **`CREATE DOMAIN WEIGHT`** — `CREATE DOMAIN` 명령어로 `WEIGHT`라는 이름의 도메인을 생성합니다. 이 도메인은 몸무게 속성에 적용됩니다.
- **`DECIMAL(5, 1)`** — 데이터 타입을 지정합니다. 전체 5자리 숫자이고 소수점 이하 1자리입니다. 예를 들어 `072.5`(72.5kg)나 `125.3`(125.3kg) 같은 값이 가능합니다.
- **`CHECK (VALUE > 0 AND VALUE < 300)`** — 제약 조건입니다. 값이 0보다 크고 300보다 작아야 합니다.

❌ **도메인 무결성 위반 예시:**

```sql
-- 잘못된 입력: 몸무게에 500을 입력하려고 함
INSERT INTO PERSON (NAME, WEIGHT) VALUES ('홍길동', 500);
-- ❌ 거부됨! CHECK 조건에 의해 WEIGHT는 300 미만이어야 하므로 500은 입력 불가
```

```sql
-- 잘못된 입력: 몸무게에 음수를 입력하려고 함
INSERT INTO PERSON (NAME, WEIGHT) VALUES ('홍길동', -10);
-- ❌ 거부됨! CHECK 조건에 의해 WEIGHT는 0보다 커야 하므로 -10은 입력 불가
```

✅ **도메인 무결성을 만족하는 입력 예시:**

```sql
-- 올바른 입력: 몸무게가 0~300 범위 안에 있음
INSERT INTO PERSON (NAME, WEIGHT) VALUES ('홍길동', 72.5);
-- ✅ 성공! 72.5는 0보다 크고 300보다 작으므로 정상 입력
```

### 2. 릴레이션 무결성 (Relation Integrity)

**릴레이션(Relation)**은 곧 **테이블(Table)**입니다. 릴레이션 무결성이란 **하나의 테이블에 적용할 수 있는 모든 종류의 무결성을 포괄적으로 포함하는 개념**입니다.

릴레이션 무결성은 다음과 같은 것들을 전부 포함합니다:
- **도메인 무결성**: 값의 범위 지키기
- **기본키 무결성**: 기본키는 중복되면 안 됨
- **NULL 제약**: NULL 값이 들어가면 안 되는 속성 관리
- **외래키 참조 무결성**: 외래키가 참조하는 값이 실제로 존재해야 함
- **의미 무결성**: 의미상 맞는 값만 허용

데이터베이스가 **일관된 상태(Consistent State)**를 유지하는 것이 매우 중요하기 때문에, 이 모든 무결성을 한데 묶어서 관리하는 것이 릴레이션 무결성입니다.

릴레이션 무결성 안에는 몇 가지 세부 제약이 있습니다. 하나씩 살펴보겠습니다.

#### 과도 제약 (Transition Constraint)

**과도 제약**이란 **상태가 A에서 B로 변화할 때, 그 변화가 논리적으로 올바른지 검증하는 제약**입니다.

마치 사람의 나이를 생각해 보세요. 작년 나이가 25살이었다면, 올해 나이는 당연히 25살 **이상**이어야 합니다. 올해 나이가 23살이 되는 것은 말이 안 되죠? 이것이 바로 과도 제약입니다.

또 다른 예시로, **주문 수량과 배송 수량**을 생각해 보세요. 고객이 10개를 주문했는데 15개를 배송하면 안 되겠죠? 배송 수량은 반드시 주문 수량 이하여야 합니다.

✅ **과도 제약 예시:**

```sql
-- 과도 제약: 직원의 급여(SALARY)는 반드시 기존보다 같거나 높아야 한다
WHEN UPDATE EMP.SALARY            -- EMP 테이블의 SALARY를 업데이트할 때
CHECK (EMP.NEW.SALARY >= EMP.OLD.SALARY)  -- 새 급여가 기존 급여보다 같거나 커야 함
```

- **`EMP.NEW.SALARY`** — 업데이트 후의 새로운 급여 값 (예: 2025년 연봉)
- **`EMP.OLD.SALARY`** — 업데이트 전의 기존 급여 값 (예: 2024년 연봉)
- 새 급여가 기존 급여보다 같거나 커야 한다는 것은, **급여가 깎이는 것을 방지**하는 규정입니다.

❌ **과도 제약 위반 예시:**

```sql
-- 기존 연봉이 5000만 원인데, 3000만 원으로 업데이트하려고 함
UPDATE EMP SET SALARY = 3000 WHERE EMP_ID = 101;
-- ❌ 거부됨! NEW.SALARY(3000) < OLD.SALARY(5000) 이므로 과도 제약 위반
```

#### 집합 제약 (Aggregate Constraint)

**집합 제약**이란 **튜플(행) 집합 전체에 대한 규정**입니다. 개별 데이터가 아니라 전체 데이터의 합계, 평균 등을 기준으로 제약을 거는 것이죠.

예를 들어, 회사에서 "올해 전 직원의 총 급여 합계는 10억 원을 초과할 수 없다"라는 규정이 있다고 해봅시다. 개별 직원의 급여가 오르거나 내릴 수는 있지만, **전체 합계가 10억 원을 넘어서는 안 됩니다.**

✅ **집합 제약 예시:**

```sql
-- 집합 제약: 직원들의 평균 급여가 300만 원을 초과할 수 없다
AFTER UPDATING EMP.SALARY            -- EMP 테이블의 SALARY를 업데이트한 후
CHECK (AVERAGE(EMP.SALARY) <= 300)   -- 전 직원 급여의 평균이 300 이하인지 확인
```

- **`AVERAGE(EMP.SALARY)`** — 전 직원 급여의 **평균**을 계산합니다.
- 누구는 많이 받고 누구는 적게 받을 수 있지만, **평균이 300만 원을 초과하면 안 된다**는 것이 이 회사의 급여 제약 조건입니다.

#### 튜플 제약 (Tuple Constraint)

**튜플 제약**은 집합 제약과 달리 **개별 튜플(행) 하나하나에 대한 제약 조건**입니다.

```sql
-- 튜플 제약: 모든 직원의 개별 급여는 500만 원 이하여야 한다
CHECK (EMP.SALARY <= 500)            -- 개별 직원의 급여가 500 이하인지 확인
```

이 제약에 따르면, 회사의 **모든 직원** 각각의 급여가 500만 원을 넘을 수 없습니다. 한 명이라도 500만 원 초과 급여를 입력하면 거부됩니다.

| 제약 종류 | 검사 대상 | 예시 |
|---|---|---|
| **튜플 제약** | 개별 행 하나하나 | 각 직원 급여 ≤ 500만 원 |
| **집합 제약** | 전체 행의 합계/평균 등 | 전 직원 급여 평균 ≤ 300만 원 |

#### 즉시 제약 (Immediate Constraint)

**즉시 제약**이란 삽입, 삭제, 갱신 연산이 수행되면 **즉시 결과가 반영되도록** 하는 제약입니다.

여러분이 네이버에서 회원 정보를 수정하는 상황을 떠올려 보세요. 주소를 바꾸거나, 전화번호를 변경하고 저장 버튼을 누르면 **바로바로 반영**됩니다. 이런 일반적인 데이터 변경은 즉시 제약을 따릅니다.

```sql
-- 즉시 제약: 성별은 'MALE' 또는 'FEMALE'만 가능하며, 즉시 반영
AFTER UPDATING EMP.GENDER            -- EMP 테이블의 GENDER를 업데이트한 후
CHECK (EMP.GENDER IN ('MALE', 'FEMALE'))  -- 성별이 MALE 또는 FEMALE인지 확인
```

성별을 입력하면 조건을 확인한 후 바로바로 값이 바뀌어서 갱신이 반영됩니다.

#### 지연 제약 (Deferred Constraint)

**지연 제약**은 즉시 제약과 반대되는 개념으로, **즉시 반영하지 않고 모든 작업이 완료된 후에 반영**하는 제약입니다.

가장 대표적인 예시가 **계좌 이체**입니다. 이 과정을 자세히 살펴보겠습니다.

내 통장(A)에 200만 원이 있고, B 통장으로 100만 원을 이체한다고 가정해 봅시다.

❌ **만약 즉시 제약으로 처리한다면 (잘못된 방식):**

```
1. 내 통장(A)에서 100만 원 출금 → 바로 반영! (잔액: 100만 원)
2. B 통장으로 100만 원 입금 시도... 그런데 B 은행 서버가 점검 중!
3. 결과: 내 통장에서는 100만 원이 빠져나갔는데, B는 돈을 받지 못함!
   → 💀 100만 원이 사라짐! 무결성 완전히 붕괴!
```

✅ **지연 제약으로 처리한다면 (올바른 방식):**

```
1. 내 통장(A)에서 100만 원 출금 요청 → 아직 반영하지 않고 기다림!
2. B 통장으로 100만 원 입금 시도
3. B 은행에서 "돈 잘 받았어!" 확인 메시지(COMMIT) 전달
4. 그제서야 내 통장에서 100만 원 출금 반영 (잔액: 100만 원)
   → ✅ 양쪽 모두 정상 처리!
```

```sql
-- 지연 제약: 트랜잭션이 완전히 완료(COMMIT)된 후에만 갱신 반영
WHEN COMMIT                          -- 트랜잭션이 성공적으로 완료되었을 때
  UPDATE ACCOUNT                     -- 계좌 테이블을 업데이트한다
  SET BALANCE = NEW_BALANCE          -- 잔액을 새로운 잔액으로 변경
```

- **`WHEN COMMIT`** — **COMMIT**은 트랜잭션(작업 묶음)이 **성공적으로 완료**되었다는 의미입니다. 이체 과정에서 보내는 쪽과 받는 쪽 모두 정상적으로 처리가 끝나야 COMMIT이 됩니다.
- COMMIT이 되기 전까지는 어떤 변경도 실제 데이터베이스에 반영되지 않습니다.

은행에서 수표를 입금하면 바로 찾을 수 없고 보통 하루 정도 지나야 하는 것도 같은 원리입니다. 그 수표가 부도 수표인지, 분실된 수표인지, 위조된 수표인지 확인하는 시간이 필요하기 때문입니다.

:::warning 즉시 제약 vs 지연 제약 선택 기준
- **일반 데이터 수정** (주소 변경, 전화번호 변경 등) → **즉시 제약** 사용
- **금융 거래** (계좌 이체, 결제 등 여러 단계가 연결된 작업) → **지연 제약** 사용
:::

## 🔫 트리거(Trigger)란?

### 무결성과 트리거의 차이

**트리거(Trigger)**는 무결성과 **반대되는 개념**입니다. 이 차이를 이해하는 것이 핵심입니다.

| 구분 | 무결성 제약 | 트리거(Trigger) |
|---|---|---|
| **동작 시점** | 조건을 **위반했을 때** | 조건을 **만족했을 때** |
| **동작 방식** | 연산을 **거부** (수동적) | 연산을 **실행** (능동적) |
| **비유** | "안 돼! 하지 마!" | "좋아! 실행해!" |
| **성격** | 방어적, 수동적 | 적극적, 능동적 |

**무결성**은 가만히 있다가 규정을 위반하면 "하지 마!"라고 거부하는 **수동적인** 방식입니다. 반면 **트리거**는 특정 조건을 만족하면 미리 정해놓은 작업을 **능동적으로 실행**해주는 방식입니다.

트리거(Trigger)라는 단어의 원래 뜻은 **총의 방아쇠(격발장치)**입니다. 평상시에는 가만히 있다가, 조건을 만족하면 방아쇠가 당겨지듯이 자동으로 동작하는 것이죠.

> 트리거는 **"조건을 만족하면 자동으로 실행되는 프로그램"**입니다.

### 트리거의 장점

트리거를 사용하면 다음과 같은 장점이 있습니다:

**1. 노력 중복 제거**
복잡한 비즈니스 규칙(예: 급여 이체, 입출금 처리)을 트리거로 한 번 만들어 놓으면, 매번 같은 코드를 반복 작성할 필요가 없습니다. "이 조건을 만족하면 이거 처리해줘"라고 한 번만 프로그래밍하면 됩니다.

**2. 일관성 유지**
트리거는 정해진 규칙대로만 처리하기 때문에, 어떤 때는 처리하고 어떤 때는 안 하는 불일치가 발생하지 않습니다. 조건을 만족하면 **항상 동일한 방식으로** 처리되므로 일관성이 보장됩니다.

**3. 유지보수 용이**
모듈화 방식으로 규정들을 미리 만들어 놓으면, 나중에 조건이 바뀌었을 때 해당 트리거 프로그램만 수정하면 됩니다. 시스템 전체를 뒤집을 필요가 없습니다.

**4. 복잡한 비즈니스 규칙 처리**
은행의 이체, 입금, 출금 같은 복잡한 비즈니스 로직을 트리거로 깔끔하게 관리할 수 있습니다.

### 트리거의 구성: ECA 규칙

트리거는 **ECA**라는 세 가지 요소로 구성됩니다:

| 요소 | 영어 | 설명 |
|---|---|---|
| **E** | Event (이벤트) | INSERT, DELETE, UPDATE 작업이 수행될 때 |
| **C** | Condition (조건) | 특정 조건이 **참(True)**일 때 |
| **A** | Action (액션) | 실행할 동작 |

:::info SELECT는 트리거와 무관합니다
트리거는 데이터가 **변경되는** INSERT, DELETE, UPDATE 작업에서만 동작합니다. **SELECT(검색)**은 데이터를 읽기만 하므로 트리거와 관계가 없습니다.
:::

동작 흐름은 다음과 같습니다:

```
이벤트 발생 (INSERT/DELETE/UPDATE)
    ↓
조건 확인 (Condition이 참인가?)
    ↓ YES
액션 실행 (미리 정의한 작업 수행)
```

### 트리거 실제 예시

은행 계좌에서 이체할 때의 트리거 예시를 살펴보겠습니다:

```sql
-- 트리거 생성: '잔고' 트리거는 계좌 테이블 업데이트 전에 동작
CREATE TRIGGER 잔고                    -- '잔고'라는 이름의 트리거를 생성한다
BEFORE UPDATE ON 계좌                  -- 계좌 테이블을 업데이트하기 전에 동작
FOR EACH ROW                          -- 각 행(레코드)마다 하나씩 검사
WHEN (NEW.잔고 - NEW.이체금액 >= 0)     -- 조건: 잔고에서 이체금액을 뺀 값이 0 이상일 때
BEGIN                                 -- 액션 시작
  UPDATE 계좌                          -- 계좌 테이블을 업데이트한다
  SET 잔액 = 잔고 - 이체금액            -- 잔액 = 기존 잔고 - 이체금액
  WHERE 계좌번호 = :NEW.계좌번호;       -- 해당 계좌번호에 대해
END;                                  -- 액션 끝
```

이 트리거의 동작 과정을 구체적으로 살펴보겠습니다:

**상황 1: 잔고가 충분한 경우**
- 내 잔고: 200만 원
- 이체 금액: 150만 원
- 조건 확인: 200 - 150 = 50 ≥ 0 → **조건 만족! ✅**
- 액션 실행: 잔액을 200 - 150 = 50만 원으로 업데이트

**상황 2: 잔고가 부족한 경우**
- 내 잔고: 200만 원
- 이체 금액: 250만 원
- 조건 확인: 200 - 250 = -50 ≥ 0 → **조건 불만족! ❌**
- 액션 실행되지 않음: 이체 거부

이처럼 트리거는 **조건을 만족할 때만** 미리 정해놓은 작업을 자동으로 수행합니다.

### 트리거의 관리 명령어

```sql
-- 트리거 삭제
DROP TRIGGER 잔고;                     -- '잔고' 트리거를 삭제한다

-- 트리거 비활성화 (잠시 꺼놓기)
ALTER TRIGGER 잔고 DISABLE;            -- '잔고' 트리거를 비활성화한다

-- 트리거 활성화 (다시 켜기)
ALTER TRIGGER 잔고 ENABLE;             -- '잔고' 트리거를 활성화한다

-- 트리거 재컴파일 (내용 변경 후)
ALTER TRIGGER 잔고 COMPILE;            -- '잔고' 트리거를 재컴파일한다
```

- **DROP TRIGGER**: 트리거를 완전히 삭제합니다.
- **DISABLE**: 방아쇠를 잠금 해제하지 않는 것처럼, 트리거를 일시적으로 비활성화합니다. 트리거 자체는 남아있지만 동작하지 않습니다.
- **ENABLE**: 트리거를 다시 활성화합니다. 언제라도 조건을 만족하면 동작합니다.
- **COMPILE**: 트리거의 내용(규칙)을 변경한 후 다시 컴파일합니다.

### 문장 트리거 vs 행 트리거

트리거의 실행 범위에 따라 두 가지로 나뉩니다:

| 구분 | 문장 트리거 (Statement Trigger) | 행 트리거 (Row Trigger) |
|---|---|---|
| **실행 범위** | 전체 데이터를 **한꺼번에** 처리 | 레코드를 **하나씩** 처리 |
| **트리거 발생 횟수** | **한 번만** 발생 | 레코드 **개수만큼** 반복 발생 |
| **키워드** | (기본값) | `FOR EACH ROW` |
| **비유** | 교실 전체에 한 번에 공지하는 것 | 학생 한 명 한 명에게 개별 통보하는 것 |

**문장 트리거 예시:**

```sql
-- 문장 트리거: 전 직원의 급여를 한꺼번에 10% 인상
UPDATE EMP SET SALARY = SALARY * 1.1;  -- 모든 직원의 급여를 1.1배로 변경
-- 트리거가 한 번만 실행되어 전체 데이터를 한꺼번에 처리
```

**행 트리거 예시:**

```sql
-- 행 트리거: 각 레코드마다 개별적으로 처리
CREATE TRIGGER salary_check
BEFORE UPDATE ON EMP
FOR EACH ROW                          -- 각 행마다 하나씩 검사
BEGIN
  -- 각 직원의 급여를 개별적으로 검증하고 처리
  IF :NEW.SALARY < :OLD.SALARY THEN
    RAISE_APPLICATION_ERROR(-20001, '급여는 감소할 수 없습니다');
  END IF;
END;
```

트리거의 **실행 시점(BEFORE/AFTER)**과 **실행 범위(STATEMENT/ROW)**를 조합하면 4가지가 됩니다:

| 조합 | 설명 |
|---|---|
| **BEFORE STATEMENT** | 전체 문장 실행 **전에** 한 번 동작 |
| **BEFORE ROW** | 각 행 처리 **전에** 행마다 동작 |
| **AFTER STATEMENT** | 전체 문장 실행 **후에** 한 번 동작 |
| **AFTER ROW** | 각 행 처리 **후에** 행마다 동작 |

:::warning 트리거 사용 시 주의사항
트리거에서는 **COMMIT이나 ROLLBACK** 같은 트랜잭션 제어 명령어를 사용할 수 없습니다. 트리거는 이미 하나의 트랜잭션 안에서 동작하기 때문에, 트리거 내부에서 트랜잭션을 직접 제어하면 충돌이 발생할 수 있습니다.
:::

## 🔒 데이터베이스 보안의 필요성

### 왜 보안이 필요한가?

현재 우리는 컴퓨터가 대량으로 보급되고, 5G 네트워크와 4차 산업혁명 시대를 살고 있습니다. 이런 환경에서 **데이터는 그 어느 때보다 중요한 자산**이 되었습니다. 하지만 그만큼 **해킹, 불법 침입, 데이터 파괴, 정보 노출** 같은 위험도 함께 커졌습니다.

데이터베이스는 특히 데이터와 직접적으로 관련되어 있기 때문에, **데이터베이스의 보안을 유지하는 것**은 현대 IT 시스템에서 가장 중요한 이슈 중 하나입니다.

데이터베이스 보안이 필요한 핵심 이유:

1. **정당한 사용자의 접근 보장**: 권한이 있는 사용자가 불편 없이 데이터에 접근할 수 있어야 합니다.
2. **불법 사용자의 접근 차단**: 권한이 없는 사용자가 데이터에 접근하거나, 데이터를 삭제·수정하는 것을 막아야 합니다.
3. **서비스 거부 공격 방어**: DDoS(분산 서비스 거부) 공격처럼 좀비 PC들이 대량의 트래픽을 보내서 서버를 다운시키면, 정상적인 사용자도 시스템을 이용하지 못하게 됩니다.
4. **데이터의 기밀성·무결성·가용성 보장**: 대량의 데이터가 안전하게 보호되어야 합니다.

### 데이터베이스 위협 요소

데이터베이스를 위협하는 주요 요소는 다음 세 가지입니다:

| 위협 요소 | 설명 | 침해되는 속성 |
|---|---|---|
| **데이터 노출 (Disclosure)** | 비공개 데이터가 외부에 노출됨 | **기밀성** |
| **데이터 잘못 수정** | 권한 없는 사용자가 데이터를 불법 수정 | **무결성** |
| **서비스 거부 (DoS)** | 정상 사용자가 서비스를 이용하지 못함 | **가용성** |

### 데이터베이스 보안 요구사항

데이터베이스를 안전하게 보호하기 위해 다음과 같은 보안 사항들이 요구됩니다:

**1. 접근 제어**
정당한 사용자는 데이터베이스에 자유롭게 접근할 수 있어야 하고, 비인가 사용자는 접근이 차단되어야 합니다.

**2. 추론 방지**
**추론(Inference)**이란 공개된 데이터를 조합하여 비공개 데이터를 유추해내는 것입니다. 보여줄 데이터만 보여주고, 감추고자 하는 데이터는 예측이 불가능하도록 막아야 합니다.

**3. 무결성 유지**
앞서 배운 도메인 무결성, 릴레이션 무결성, 트리거 등을 통해 데이터의 정확성을 유지합니다.

**4. 의미 무결성**
데이터의 의미상 당연한 범위를 지키는 것입니다. 예를 들어 4년제 대학은 1~4학년, 초등학교는 1~6학년, 중·고등학교는 1~3학년만 존재합니다.

**5. 시스템 감사 (Audit)**
사용자들이 정상적인 권한으로 데이터에 접근했는지 **로그(Log) 분석**을 통해 확인하는 것입니다. 은행 직원이 고객의 계좌를 마음대로 열람할 수 없고, 정당한 서류가 접수되었을 때만 볼 수 있는 것처럼, 모든 접근 기록이 로그로 남아 감사할 수 있어야 합니다.

**6. 인증 (Authentication)**
아이디와 패스워드가 정상적인 것인지 확인하는 과정입니다. 시스템에 접근하는 첫 번째 관문이죠.

**7. 기밀 데이터 관리**
데이터를 등급별로 분류하여 관리합니다:

| 등급 | 영어 | 설명 |
|---|---|---|
| **극비** | Top Secret | 최고 수준의 보안 |
| **비밀** | Secret | 높은 수준의 보안 |
| **대외비** | Confidential | 조직 내부에서만 열람 가능 |

등급에 따라 접근 권한을 다르게 부여하여, 중요한 데이터일수록 더 엄격하게 보호합니다. 특히 중요한 데이터는 아예 접근하지 못하도록 격리(Confinement)하여 처리하기도 합니다.

## 📌 핵심 정리

- **무결성(Integrity)**은 데이터의 정확성을 의미하며, 데이터베이스에서 가장 중요한 가치이다
- **성능과 무결성은 트레이드오프 관계**로, 무결성을 높이면 성능이 떨어지고 성능을 높이면 무결성이 떨어진다
- **무결성은 시스템이 자동으로 유지**하며, 사용자는 무결성 규정만 설정하면 된다
- 무결성 규정은 **규정 이름, 검사 시기, 제약 조건, 위반 시 조치** 4가지로 구성된다
- **보안**은 불법 사용자의 접근을 차단하는 것이고, **무결성**은 정상 사용자의 데이터 정확성을 유지하는 것이다
- **도메인 무결성**은 속성이 가질 수 있는 값의 범위를 지키는 것이다
- **릴레이션 무결성**은 테이블에 적용되는 모든 무결성을 포괄하며, 과도 제약·집합 제약·튜플 제약·즉시 제약·지연 제약을 포함한다
- **지연 제약**은 계좌 이체처럼 모든 작업이 완료(COMMIT)된 후에야 반영하는 방식이다
- **트리거(Trigger)**는 조건을 만족했을 때 능동적으로 실행되며, 무결성은 위반 시 수동적으로 거부한다
- 트리거는 **ECA(Event-Condition-Action)** 구조로 구성된다
- 트리거는 실행 범위에 따라 **문장 트리거(한꺼번에)**와 **행 트리거(하나씩)**로 나뉜다
- 데이터베이스 보안은 **기밀성, 무결성, 가용성**을 보장하기 위해 반드시 필요하다

작성일: 2026-02-21