---
title: "무결성(Integrity)의 개념과 중요성"
description: "무결성(Integrity)의 개념과 중요성에 대해 초보자도 쉽게 이해할 수 있도록 설명합니다."
slug: "/database-integrity-and-security/1-integrity-concept"
sidebar_label: "무결성 개념"
date: "2026-02-21"
---

## 🎯 무결성(Integrity)이란 무엇인가?

데이터베이스를 공부하다 보면 **무결성(Integrity)**이라는 단어를 정말 자주 만나게 됩니다. 개체 무결성, 참조 무결성, 도메인 무결성, 키 무결성 등 "무결성"이라는 말이 여기저기에서 등장하죠. 그런데 이 "무결성"이라는 단어 자체가 일상에서 잘 쓰지 않는 말이다 보니 처음 접하면 어렵게 느껴질 수 있습니다.

**무결성(Integrity)**을 쉽게 풀어보면 이렇습니다:

- **무(無)**: 없다
- **결(缺)**: 결점, 결함
- **성(性)**: 성질

즉, **"결점이 없는 성질"**이라는 뜻입니다. 데이터베이스 측면에서 결점이 없다는 것은 **데이터가 갖고 있는 값이 정확하다**는 의미입니다. 그래서 무결성이라는 말은 바꿔 말하면 **정확성(Accuracy)**이라고 표현할 수 있습니다.

> **무결성 = 정확성**: 데이터베이스에 저장된 데이터의 값이 항상 정확하고 올바른 상태를 유지하는 것

마치 은행 통장의 잔액이 항상 정확해야 하는 것처럼, 데이터베이스에 들어 있는 모든 데이터가 항상 정확한 값을 유지하고 있어야 한다는 것이 바로 무결성의 핵심 개념입니다.

:::info 인테그리티(Integrity)라는 영어 단어
영어로 Integrity는 "온전함", "완전함"이라는 뜻을 가지고 있습니다. 데이터가 온전하고 완전하게 정확한 상태를 유지한다는 의미로 이해하시면 됩니다.
:::

## 🤔 왜 무결성이 중요한가? — 성능보다 중요한 정확성

### 아무리 빠른 시스템이라도 결과가 틀리면 쓸모없다

데이터베이스 시스템에서 무결성을 유지하는 것이 왜 그토록 중요할까요? 이것을 이해하기 위해 은행 시스템을 예로 들어보겠습니다.

여러분이 사용하는 은행 앱을 떠올려 보세요. 이 앱에서 예금을 입금하고, 출금하고, 이체하고, 잔액을 조회합니다. 이 시스템이 아무리 빠르고 성능이 좋다고 해도, **만 번에 한 번씩이라도 잘못된 결과가 나온다면** 어떻게 될까요?

- 내 통장에 잔액이 **1만 원**밖에 없었는데, 갱신이 잘못되어 갑자기 **10억 원**이 들어와 버린다면?
- 반대로 **10억 원**이 들어 있던 통장의 잔액이 갑자기 **0원**이 되어 버린다면?

이런 일이 만 번에 한 번, 정말 극히 드물게 발생한다고 하더라도, **그 시스템은 실제 현업에서는 절대 사용할 수 없습니다.** 은행, 병원, 항공 예약 시스템 등 중요한 데이터를 다루는 곳에서 단 한 번의 오류도 심각한 문제를 초래할 수 있기 때문입니다.

### 성능과 무결성의 트레이드오프(Trade-off) 관계

여기서 중요한 개념이 하나 등장합니다. 바로 **트레이드오프(Trade-off, 상충 관계)**입니다.

| 항목 | 성능을 높이면 | 무결성을 높이면 |
|------|-------------|---------------|
| **장점** | 처리 속도가 빨라짐 | 데이터의 정확성이 보장됨 |
| **단점** | 무결성이 떨어질 수 있음 | 성능이 떨어질 수 있음 |

마치 자동차의 속도와 안전장치의 관계와 비슷합니다. 안전장치를 많이 달면 차가 무거워져서 속도가 느려지지만, 사고가 나도 탑승자를 보호할 수 있죠. 반대로 안전장치를 다 빼면 가볍고 빠르지만 사고가 나면 큰 피해를 입습니다.

**무결성을 높인다는 것은 이것저것 제약이 많다는 뜻입니다.** 무언가를 하려고 할 때마다 "잠깐만, 이 값이 맞는지 검사해야 해!", "이 조건을 만족하는지 확인해야 해!" 이런 검사 과정이 추가되기 때문에, 그만큼 처리 속도가 느려질 수밖에 없습니다.

하지만 데이터베이스 시스템에서는 **성능을 향상시키는 것보다 무결성을 유지하는 것이 훨씬 더 중요합니다.** 아무리 빨라도 결과가 틀리면 아무 의미가 없기 때문입니다.

> 💡 **핵심**: 데이터베이스 시스템에서 가장 중요한 것은 성능이 아니라 **무결성(정확성)**입니다. 빠르지만 부정확한 시스템보다, 느리더라도 정확한 시스템이 훨씬 가치 있습니다.

### 무결성은 누가 유지하는가? — 시스템이 자동으로!

여기서 한 가지 중요한 점이 있습니다. **무결성은 사용자, 개발자, 데이터베이스 관리자(DBA)가 직접 매번 확인하며 유지하는 것이 아닙니다.**

작동 방식은 이렇습니다:

1. 사용자가 **무결성에 대한 규정**을 미리 설정해 둡니다
   - "이 컬럼은 기본키(Primary Key)야"
   - "이 컬럼은 외래키(Foreign Key)야"
   - "학번은 기본키로 설정하고, 점수는 0점에서 100점까지만 가능해"
2. 이렇게 규정을 설정해 놓으면, **DBMS(데이터베이스 관리 시스템)의 무결성 서브시스템**이 **자동으로** 무결성을 유지시켜 줍니다

마치 건물 입구에 자동문과 보안 센서를 설치해 놓으면, 경비원이 매번 일일이 문을 열고 닫지 않아도 시스템이 자동으로 작동하는 것과 같습니다. 우리는 규칙만 정해주면, 시스템이 알아서 그 규칙을 지켜주는 것이죠.

## 🔐 무결성 vs 보안 — 헷갈리기 쉬운 두 개념

무결성을 공부할 때 **보안(Security)**이라는 개념과 자주 헷갈리게 됩니다. 이 두 개념은 비슷해 보이지만 전혀 다른 것입니다.

| 구분 | 무결성(Integrity) | 보안(Security) |
|------|-------------------|----------------|
| **대상** | 승인받은 **정상적인** 사용자 | 승인받지 못한 **불법적인** 사용자 |
| **목적** | 정상적인 사용 과정에서 데이터의 **정확성 유지** | 불법적인 접근으로부터 데이터를 **보호** |
| **비유** | 직원이 장부를 작성할 때 숫자를 틀리지 않게 하는 것 | 외부인이 금고에 접근하지 못하게 잠금장치를 다는 것 |
| **서브시스템** | 무결성 서브시스템 | 보안 서브시스템 |

쉽게 비유하자면:

- **보안**은 우리 집에 도둑이 들어오지 못하게 **현관문을 잠그는 것**입니다
- **무결성**은 집에 정상적으로 들어온 가족이 **냉장고에 음식을 넣을 때 유통기한이 지난 음식을 넣지 못하게** 하는 것입니다

사용자가 데이터베이스를 이용할 때 거치는 순서도 다릅니다:

1. **먼저 보안 서브시스템을 만남** → 아이디, 패스워드, 권한을 확인합니다
2. **그 다음 무결성 서브시스템을 만남** → 정상 사용자가 데이터를 조작할 때 정확성이 유지되도록 검사합니다

:::warning 무결성과 보안을 혼동하지 마세요!
- **보안**: 승인받지 **않은** 사용자로부터 데이터를 보호하는 것
- **무결성**: 승인받은 **정상** 사용자가 데이터를 사용할 때 정확성을 유지하는 것

시험에서 자주 나오는 개념이니 반드시 구분해서 기억하세요!
:::

## 📜 무결성 규정(Integrity Rule)이란?

### 무결성 규정의 개념

무결성을 유지하기 위해서는 **규정(Rule)**이 필요합니다. 무결성 규정이란, **무결성 검사가 수행되는 과정에서 오류가 발생했을 때, 그에 대한 조치를 명세해 놓은 것**입니다.

비유하자면 이렇습니다. 학교에서 시험 점수를 입력하는 시스템이 있다고 합시다. "점수는 0점에서 100점까지만 입력 가능합니다"라는 규정을 미리 정해 놓으면, 누군가 120점을 입력했을 때 시스템이 자동으로 이렇게 반응합니다:

1. **무결성 검사 수행**: "120점이 입력되었는데, 규정에 따르면 점수는 0~100점까지만 가능하네?"
2. **위반 판정**: "규정을 위반했다!"
3. **조치 실행**: "갱신을 거부하고, 에러 메시지를 표시한다: '무결성 규정을 위반했습니다. 입력 값을 다시 확인해 보세요.'"

이렇게 하면 자연스럽게 무결성이 유지됩니다.

### 무결성 규정의 4가지 구성 요소

무결성 규정은 다음 **4가지 요소**로 구성됩니다:

| 구성 요소 | 설명 | 비유 |
|-----------|------|------|
| **규정 이름** | 규정을 식별하는 고유한 이름 (예: R1, R2, R3) | 마치 법률 조항의 번호처럼 |
| **검사 시기** | 언제 무결성 검사를 할 것인가 (삽입/갱신/삭제 시) | 택배 검수를 언제 할지 정하는 것 |
| **제약 조건** | 데이터가 만족해야 하는 조건 (예: 점수 0~100) | 입장 조건, 자격 요건 같은 것 |
| **위반 시 조치** | 제약 조건을 위반했을 때 취하는 행동 | 위반 시 벌금을 내는 것처럼 |

각 요소를 하나씩 자세히 살펴보겠습니다.

**① 규정 이름**: 무결성 규정이 하나만 있을 리 없겠죠? 하나의 시스템을 관리하는 규정은 수십, 수백 개가 될 수 있습니다. 이 엄청 많은 규정들을 유일하게 식별하고 관리하기 위해 **고유한 이름(식별자)**이 필요합니다. R1, R2, R3처럼 일련번호를 붙여서 관리합니다.

**② 검사 시기**: 무결성 검사를 **언제** 할 것인지 정합니다. 여기서 중요한 점은, **검색(SELECT) 작업은 데이터를 변경하지 않으므로 무결성 검사가 필요 없습니다.** 눈으로 보기만 하는 것이니까요. 무결성 검사가 필요한 시점은 데이터가 실제로 변경되는 **갱신(UPDATE)**, **삽입(INSERT)**, **삭제(DELETE)** 작업일 때입니다.

**③ 제약 조건(Constraint)**: 데이터가 만족해야 하는 조건을 정의합니다. 예를 들면:
- 점수는 0점에서 100점까지만 입력 가능
- 학년은 1학년부터 4학년까지만 입력 가능
- 성별은 '남자' 또는 '여자'만 입력 가능

**④ 위반 시 조치**: 제약 조건을 위반했을 때 어떤 조치를 취할지 정합니다. 보통은 해당 작업(갱신/삽입/삭제)을 **거부(REJECT)**하고, 오류 메시지를 표시합니다.

### 무결성 규정 프로그래밍 예시

실제로 무결성 규정을 어떻게 프로그래밍하는지 살펴보겠습니다.

✅ **올바른 무결성 규정 예시**:

```sql
-- 무결성 규정 R1: 학생 테이블의 학년(year) 값은 0보다 커야 한다
R1:
AFTER UPDATING STUDENT.YEAR   -- 검사 시기: STUDENT 테이블의 YEAR를 업데이트한 후에
CHECK (STUDENT.YEAR > 0)       -- 제약 조건: YEAR 값이 0보다 큰지 검사
ELSE                           -- 위반 시 조치:
  PRINT 'R1 VIOLATED'          --   "R1 규정 위반" 메시지 출력
  REJECT UPDATE                --   업데이트를 거부
END                            -- 규정 끝
```

이 코드를 한 줄씩 풀어서 설명하겠습니다:

- **`R1:`** → 이 무결성 규정의 이름은 **R1**입니다. 나중에 이 규정을 참조하거나 관리할 때 사용하는 식별자입니다.
- **`AFTER UPDATING STUDENT.YEAR`** → **검사 시기**를 지정합니다. STUDENT 테이블의 YEAR(학년) 속성이 **업데이트(갱신)된 직후에** 검사하겠다는 뜻입니다. `AFTER`는 "~한 후에"라는 의미이고, `BEFORE`를 쓰면 "~하기 전에" 검사합니다.
- **`CHECK (STUDENT.YEAR > 0)`** → **제약 조건**입니다. STUDENT 테이블의 YEAR 값이 0보다 커야 한다는 조건입니다. 학년이 0이거나 음수이면 안 되니까요.
- **`ELSE`** → 위의 CHECK 조건을 **위반했을 때** 실행될 부분입니다.
- **`PRINT 'R1 VIOLATED'`** → "R1 규정을 위반했습니다"라는 메시지를 화면에 출력합니다.
- **`REJECT UPDATE`** → 해당 업데이트 작업을 **거부**합니다. 즉, 잘못된 값으로의 갱신이 반영되지 않습니다.
- **`END`** → 규정의 끝을 표시합니다.

> 💡 무결성 규정의 핵심 구조: **AFTER(검사 시기)** → **CHECK(제약 조건)** → **ELSE(위반 시 조치)** → **END**

❌ **만약 무결성 규정이 없다면?**:

```sql
-- 무결성 규정 없이 그냥 업데이트를 수행하는 경우
UPDATE STUDENT SET YEAR = -5 WHERE ID = '2024001';
-- YEAR에 -5라는 말도 안 되는 값이 그대로 들어가 버립니다!
-- 학년이 -5라니... 데이터가 오염되어 무결성이 깨집니다.
```

무결성 규정을 설정해 놓으면, 사용자가 프로그래밍을 하고 나서 **시스템이 자동으로** 검사하고 처리합니다. 위반 상황이 발생하면 자동으로 실행을 거부하고, 정상적인 상황에서만 갱신을 반영합니다.

## 📋 무결성의 종류

### 1. 도메인 무결성 (Domain Integrity)

**도메인(Domain)**이란 **속성(컬럼)이 가질 수 있는 값의 범위**를 말합니다. 마치 "이 상자에는 빨간색, 파란색, 초록색 공만 넣을 수 있어"라고 정해 놓는 것과 같습니다.

도메인은 넓게 보면 데이터 타입 자체를 의미하기도 합니다:
- 정수(Integer)
- 실수(Float)
- 문자(Character)
- 불린(Boolean, 참/거짓)
- 날짜(Date)

좀 더 구체적으로 들어가면:
- 학년은 **1 ~ 4** 사이의 값만 가능
- 나이는 **0 ~ 200** 사이의 값만 가능
- 몸무게는 **0 초과, 300 미만**의 값만 가능

이런 값의 범위가 유지되도록 하는 것이 바로 **도메인 무결성**입니다.

✅ **도메인 무결성 설정 예시**:

```sql
-- 도메인 무결성: 몸무게(WEIGHT) 속성의 값 범위를 설정
CREATE DOMAIN WEIGHT AS DECIMAL(5, 1)  -- 전체 5자리, 소수점 아래 1자리
  CHECK (WEIGHT > 0 AND WEIGHT < 300); -- 0보다 크고 300보다 작아야 함
```

코드를 한 줄씩 설명하겠습니다:

- **`CREATE DOMAIN WEIGHT`** → WEIGHT(몸무게)라는 이름의 도메인을 생성합니다.
- **`AS DECIMAL(5, 1)`** → 데이터 타입은 DECIMAL(십진수)이며, 전체 5자리 중 소수점 아래 1자리입니다. 예를 들어 `123.4`나 `85.7` 같은 값이 됩니다.
- **`CHECK (WEIGHT > 0 AND WEIGHT < 300)`** → 제약 조건입니다. 몸무게 값은 0보다 크고 300보다 작아야 합니다.

❌ **도메인 무결성을 위반하는 경우**:

```sql
-- 몸무게에 500을 입력하면? → 도메인 무결성 위반!
INSERT INTO PERSON (NAME, WEIGHT) VALUES ('홍길동', 500);
-- 500은 300보다 크기 때문에 CHECK 제약 조건에 위배됩니다.
-- 시스템이 자동으로 이 삽입을 거부합니다!

-- 몸무게에 -10을 입력하면? → 도메인 무결성 위반!
INSERT INTO PERSON (NAME, WEIGHT) VALUES ('김철수', -10);
-- -10은 0보다 작기 때문에 CHECK 제약 조건에 위배됩니다.
-- 마찬가지로 시스템이 거부합니다!
```

### 2. 릴레이션 무결성 (Relation Integrity)

**릴레이션(Relation)**은 쉽게 말해 **테이블**입니다. 릴레이션 무결성은 하나의 테이블에 적용할 수 있는 **모든 종류의 무결성 규정을 광범위하게 포함**하는 개념입니다. 도메인 무결성, 기본키 무결성, 널(NULL) 값 제약, 외래키 참조 무결성, 의미 무결성 등을 **전부 포괄**합니다.

데이터베이스는 **일관된 상태를 유지하는 것**이 매우 중요합니다. 마치 회계장부가 항상 대차(빌림과 빌려줌)가 맞아야 하는 것처럼, 데이터베이스의 테이블도 항상 정확하고 일관성 있는 상태를 유지해야 합니다.

릴레이션 무결성에는 세부적으로 여러 가지 제약이 포함되는데, 중요한 것들을 살펴보겠습니다.

#### 과도 제약 (Transition Constraint)

**과도 제약**이란 **상태가 A에서 B로 변화했을 때, 그 변화가 논리적으로 타당한지** 확인하는 제약입니다.

실생활 예시를 들어볼게요:
- **나이**: 작년 나이가 25세였다면, 올해 나이는 당연히 25세 이상이어야 합니다. 나이가 줄어들면 안 되죠!
- **주문과 배송**: 주문 수량이 10개인데 배송 수량이 15개이면 안 됩니다. 배송 수량은 주문 수량 이하여야 합니다.
- **연봉**: 특별한 경우가 아니면, 새로운 연봉은 기존 연봉보다 크거나 같아야 합니다.

✅ **과도 제약 설정 예시**:

```sql
-- 과도 제약: EMP 테이블의 급여(SALARY)를 업데이트할 때
-- 새 급여는 기존 급여보다 크거나 같아야 한다
WHEN UPDATE EMP.SALARY                        -- EMP 테이블의 SALARY가 업데이트될 때
CHECK (EMP.NEW.SALARY >= EMP.OLD.SALARY)      -- 새 급여 >= 기존 급여인지 확인
-- NEW.SALARY: 변경 후의 급여 값 (예: 2024년 연봉)
-- OLD.SALARY: 변경 전의 급여 값 (예: 2023년 연봉)
```

- **`EMP.NEW.SALARY`** → 변경 **후**의 급여 값입니다. 앞으로 받게 될 새로운 급여죠.
- **`EMP.OLD.SALARY`** → 변경 **전**의 급여 값입니다. 기존에 받던 급여입니다.
- 새 급여가 기존 급여보다 크거나 같아야 한다는 조건을 설정함으로써, **급여가 줄어드는 잘못된 갱신**을 방지합니다.

#### 집합 제약 (Aggregate Constraint)

**집합 제약**은 **튜플(행) 집합 전체에 대한 규정**입니다. 개별 데이터가 아니라, 데이터 전체를 놓고 봤을 때의 조건을 말합니다.

예를 들어 봅시다:
- "우리 회사의 전 직원 급여 총합은 10억 원을 초과할 수 없다"
- "전 직원의 평균 급여는 300만 원 이하여야 한다"

이런 조건은 개별 직원의 급여를 보는 것이 아니라, **전체 직원의 급여를 합치거나 평균을 내서** 확인하는 것이죠.

✅ **집합 제약 설정 예시**:

```sql
-- 집합 제약: 직원 평균 급여가 300만 원 이하여야 한다
AFTER UPDATING EMP.SALARY                  -- EMP 테이블의 SALARY를 업데이트한 후에
CHECK (AVERAGE(EMP.SALARY) <= 300)         -- 전 직원 급여의 평균이 300 이하인지 확인
-- 누군가의 급여를 올려서 전체 평균이 300을 초과하면
-- 해당 갱신은 거부됩니다!
```

이 규정이 설정되어 있으면, 특정 직원의 급여를 아무리 올리고 싶어도 **전체 직원의 평균 급여가 300만 원을 초과하는 순간** 시스템이 자동으로 갱신을 거부합니다.

#### 튜플 제약 (Tuple Constraint)

**튜플 제약**은 집합 제약과 달리 **개별 튜플(행) 하나하나에 대한 제약 조건**입니다.

```sql
-- 튜플 제약: 모든 직원의 개별 급여는 500만 원 이하여야 한다
CHECK (EMP.SALARY <= 500)
-- 어떤 직원이든 급여가 500만 원을 초과할 수 없습니다
```

집합 제약은 **전체를 대상으로** 하고, 튜플 제약은 **개별을 대상으로** 한다는 차이를 기억하세요.

| 제약 유형 | 대상 | 예시 |
|-----------|------|------|
| 튜플 제약 | 개별 행 하나하나 | 각 직원의 급여 ≤ 500만 원 |
| 집합 제약 | 전체 행의 집합 | 전 직원 평균 급여 ≤ 300만 원 |

#### 즉시 제약 (Immediate Constraint)

**즉시 제약**은 삽입, 삭제, 갱신 작업이 수행되면 **즉시 결과가 반영**되도록 하는 제약입니다.

여러분이 네이버에 로그인해서 주소를 변경하면, 저장 버튼을 누르는 즉시 바로 반영되죠? 이것이 즉시 제약입니다. 일반적인 데이터들은 대부분 즉시 제약을 따릅니다.

```sql
-- 즉시 제약: 성별은 'MALE' 또는 'FEMALE'만 가능
AFTER UPDATING EMP.GENDER                -- EMP 테이블의 성별을 업데이트한 후에
CHECK (EMP.GENDER IN ('MALE', 'FEMALE')) -- 성별이 MALE 또는 FEMALE인지 확인
-- 조건을 만족하면 바로바로 갱신이 반영됩니다
```

#### 지연 제약 (Deferred Constraint)

**지연 제약**은 즉시 제약의 반대입니다. 작업이 **즉시 반영되지 않고, 확인을 거친 후에** 반영되는 제약입니다.

가장 대표적인 예가 바로 **계좌 이체**입니다. 이 과정을 자세히 살펴볼게요:

> **시나리오**: A 통장에서 B 통장으로 100만 원을 이체하려고 합니다.

❌ **만약 즉시 제약으로 처리하면 (위험!)**:

```sql
-- 위험한 즉시 처리 방식
UPDATE ACCOUNT SET BALANCE = BALANCE - 1000000 WHERE ACCOUNT_ID = 'A';
-- A 통장에서 100만 원이 바로 빠져나감

-- 그런데 B 은행 서버가 점검 중이라 이체가 안 됨!
-- A에서는 돈이 빠져나갔는데, B에서는 돈을 못 받음
-- → 100만 원이 공중에서 증발! 심각한 문제 발생!
```

✅ **지연 제약으로 처리하면 (안전!)**:

```sql
-- 안전한 지연 처리 방식
WHEN COMMIT  -- 모든 작업이 성공적으로 완료(커밋)된 후에
-- A 통장에서 돈이 빠져나가고
-- B 통장으로 돈이 정상적으로 입금되었다는 확인을 받은 다음에
-- 그제서야 A 통장의 잔액을 갱신합니다
UPDATE ACCOUNT SET BALANCE = NEW_BALANCE WHERE ACCOUNT_ID = 'A';
```

여기서 **커밋(COMMIT)**이란, 트랜잭션(작업 묶음)이 **성공적으로 완료**되었다는 것을 의미합니다. A에서 돈을 보내고, B에서 정상적으로 돈을 받았다는 확인이 된 후에야 비로소 한 사이클이 완성되는 것이죠.

은행에서 수표를 입금하면 바로 출금할 수 없고 하루 정도 기다려야 하는 것도 같은 원리입니다. 그 수표가 부도 수표인지, 분실된 수표인지 확인하는 시간이 필요하기 때문입니다.

:::tip 즉시 제약 vs 지연 제약 요약
- **즉시 제약**: 주소 변경, 전화번호 변경처럼 **바로바로 반영**해도 되는 작업
- **지연 제약**: 계좌 이체, 수표 입금처럼 **확인을 거친 후에 반영**해야 하는 작업
:::

## ⚡ 트리거(Trigger) — 조건을 만족하면 자동으로 실행!

### 트리거의 개념

**트리거(Trigger)**는 무결성 제약 조건과 **반대되는 개념**입니다. 이것만 이해하면 트리거의 핵심을 파악한 겁니다.

| 구분 | 무결성 제약 조건 | 트리거(Trigger) |
|------|-----------------|----------------|
| **동작 조건** | 조건을 **위반**했을 때 | 조건을 **만족**했을 때 |
| **동작 방식** | 연산을 **거부**함 (수동적) | 특정 작업을 **실행**함 (능동적) |
| **비유** | "안 돼!"라고 막는 경비원 | 조건이 맞으면 문을 열어주는 자동문 |

**트리거(Trigger)**라는 영어 단어는 총의 **방아쇠**를 뜻합니다. 평상시에는 가만히 있다가, 조건을 만족하면 마치 방아쇠가 당겨지듯 **자동으로 특정 작업이 실행**됩니다.

- **무결성 제약 조건**: "위반하면 하지 마!" → **수동적**
- **트리거**: "조건 만족하면 이거 실행해!" → **능동적**

### 트리거의 구성: ECA 규칙

트리거는 **ECA**라는 3가지 요소로 구성됩니다:

| 요소 | 영어 | 한국어 | 설명 |
|------|------|--------|------|
| **E** | Event | 이벤트 | INSERT, DELETE, UPDATE 작업이 수행될 때 |
| **C** | Condition | 조건 | 특정 조건이 참(True)일 때 |
| **A** | Action | 액션 | 수행할 동작 |

중요한 점은, **SELECT(검색)는 트리거와 상관없습니다.** 데이터를 변경하는 INSERT(삽입), DELETE(삭제), UPDATE(갱신) 작업에서만 트리거가 동작합니다.

### 트리거의 장점

트리거를 미리 프로그래밍해 놓으면 다음과 같은 장점이 있습니다:

- **노력 중복 제거**: 같은 검사를 매번 반복하지 않아도 됩니다. 한 번 규칙을 만들어 놓으면 자동으로 처리됩니다.
- **일관성 제공**: 조건을 만족할 때만 정해진 작업을 실행하므로, 항상 동일한 결과를 보장합니다. 아무 때나 처리해주고 안 해주고 하는 것이 아니라, 규정대로만 처리합니다.
- **유지보수 용이**: 모듈화 방식으로 규정을 만들어 놓았기 때문에, 조건이 바뀌면 해당 트리거 프로그램만 수정하면 됩니다.
- **복잡한 비즈니스 규칙 처리**: 급여 이체, 입금, 출금 같은 복잡한 비즈니스 로직도 트리거를 통해 체계적으로 관리할 수 있습니다.

### 트리거 실행 시점과 범위

트리거가 언제, 어떻게 실행되는지를 두 가지 기준으로 나눌 수 있습니다:

**① 실행 시점 (BEFORE / AFTER)**:

| 시점 | 의미 | 예시 |
|------|------|------|
| **BEFORE** | 작업 수행 **전에** 트리거 실행 | 삽입 전에 유효성 검사 |
| **AFTER** | 작업 수행 **후에** 트리거 실행 | 갱신 후에 로그 기록 |

**② 실행 범위 (STATEMENT / ROW)**:

| 범위 | 의미 | 특징 |
|------|------|------|
| **STATEMENT** | 전체 데이터를 **한꺼번에** 처리 | 트리거가 **한 번만** 발생 |
| **ROW** | 레코드를 **하나씩** 처리 | 레코드 개수만큼 **반복** 실행 |

이 두 가지를 조합하면 **4가지 경우**가 나옵니다:

| 조합 | 설명 |
|------|------|
| BEFORE STATEMENT | 전체 작업 수행 전에 한 번 실행 |
| BEFORE ROW | 각 행 처리 전에 행마다 실행 |
| AFTER STATEMENT | 전체 작업 수행 후에 한 번 실행 |
| AFTER ROW | 각 행 처리 후에 행마다 실행 |

### 문장 트리거(Statement Trigger) vs 행 트리거(Row Trigger)

**문장 트리거(Statement Trigger)**는 전체를 한꺼번에 처리합니다:

```sql
-- 문장 트리거: 전 직원의 급여를 10% 인상
UPDATE EMP SET SALARY = SALARY * 1.1;
-- 한 번의 트리거 실행으로 모든 직원의 급여가 한꺼번에 10% 인상됩니다
-- 직원이 100명이든 1000명이든, 트리거는 딱 한 번만 발생합니다
```

**행 트리거(Row Trigger)**는 레코드 하나씩 처리합니다:

```sql
-- 행 트리거: FOR EACH ROW를 사용하여 레코드 하나씩 처리
FOR EACH ROW
-- 레코드가 100개라면 100번 반복하며 하나씩 처리합니다
-- 첫 번째 행 처리 → 두 번째 행 처리 → ... → 100번째 행 처리
```

### 트리거 실전 예시: 계좌 이체

```sql
-- 트리거 생성: 계좌 잔고를 확인하는 트리거
CREATE TRIGGER 잔고                    -- '잔고'라는 이름의 트리거를 생성
BEFORE UPDATE ON 계좌                  -- 계좌 테이블을 업데이트하기 전에 실행
FOR EACH ROW                           -- 각 행마다 하나씩 처리
WHEN (NEW.잔고 - NEW.금액 >= 0)         -- 조건: 잔고에서 이체 금액을 뺀 값이 0 이상일 때
BEGIN                                  -- 액션 시작
  UPDATE 계좌                          -- 계좌 테이블을 업데이트
  SET 잔고 = 잔고 - NEW.금액            -- 잔고에서 이체 금액만큼 차감
  WHERE 계좌번호 = NEW.계좌번호;        -- 해당 계좌번호에 대해서만
END;                                   -- 액션 끝
```

이 트리거가 어떻게 동작하는지 구체적으로 살펴보겠습니다:

**시나리오**: 잔액이 200만 원인 계좌에서 150만 원을 이체하려는 경우

1. `NEW.잔고 - NEW.금액` = 200만 원 - 150만 원 = 50만 원
2. 50만 원 ≥ 0 → **조건 만족!** ✅
3. 트리거가 실행되어 잔고에서 150만 원을 차감
4. 잔액이 200만 원 → 50만 원으로 업데이트

**시나리오**: 잔액이 200만 원인 계좌에서 250만 원을 이체하려는 경우

1. `NEW.잔고 - NEW.금액` = 200만 원 - 250만 원 = -50만 원
2. -50만 원 ≥ 0 → **조건 불만족!** ❌
3. 트리거가 실행되지 않음 → 이체 거부

:::note 트리거의 제한사항
트리거 내에서는 **COMMIT(커밋)**이나 **ROLLBACK(롤백)** 같은 트랜잭션 제어 명령어는 사용할 수 없습니다. 이는 트리거의 단점 중 하나입니다.
:::

### 트리거 관리 명령어

```sql
-- 트리거 삭제
DROP TRIGGER 트리거이름;

-- 트리거 비활성화 (잠시 꺼놓기)
ALTER TRIGGER 트리거이름 DISABLE;

-- 트리거 활성화 (다시 켜기)
ALTER TRIGGER 트리거이름 ENABLE;

-- 트리거 재컴파일 (규칙 변경 후 다시 적용)
ALTER TRIGGER 트리거이름 COMPILE;
```

- **DISABLE**: 트리거를 비활성화합니다. 방아쇠를 잠가놓는 것이죠. 조건을 만족해도 트리거가 동작하지 않습니다.
- **ENABLE**: 트리거를 활성화합니다. 언제라도 조건을 만족하면 트리거가 동작하게 됩니다.
- **COMPILE**: 트리거의 내용(규칙)이 변경되었을 때 다시 컴파일하여 반영합니다.

## 🛡️ 데이터베이스 보안(Security)의 필요성

### 왜 보안이 필요한가?

오늘날 컴퓨터가 대량으로 보급되고, 정보화가 빠르게 진행되며, 5G와 4차 산업혁명 시대를 살고 있는 우리에게 데이터는 그 어느 때보다 중요해졌습니다. 하지만 그만큼 **위험성**도 커졌습니다. 해킹, 불법 침입, 데이터 파괴, 개인정보 노출 등 심각한 보안 위협이 현실로 다가오고 있습니다.

특히 **데이터베이스는 데이터와 직접 관련**되어 있기 때문에, 데이터베이스 보안을 유지하는 것은 매우 중요한 이슈입니다.

데이터베이스 보안의 핵심 목표:
- **권한이 있는 사용자**: 데이터베이스에 자유롭게 접근하여 정보를 열람할 수 있어야 합니다
- **권한이 없는 사용자**: 데이터베이스에 접근하거나, 데이터를 열람·수정·삭제하는 것을 막아야 합니다
- **정당한 사용자 보호**: DDoS(서비스 거부 공격) 같은 공격으로부터 정상적인 사용자가 서비스를 이용하지 못하게 되는 상황을 방지해야 합니다

:::danger DDoS 공격이란?
DDoS(Distributed Denial of Service, 분산 서비스 거부 공격)는 좀비 PC들이 대량으로 서버에 접속하여 자원을 소모시킴으로써, **정상적인 사용자마저도 서비스를 이용하지 못하게** 만드는 공격입니다. 마치 수천 명이 동시에 가게 앞에 줄을 서서 진짜 손님이 들어오지 못하게 막는 것과 같습니다.
:::

### 데이터베이스 위협 요소

데이터베이스 측면에서 위협이 되는 요소는 크게 세 가지입니다:

| 위협 요소 | 설명 | 침해되는 속성 |
|-----------|------|-------------|
| **데이터 노출(Disclosure)** | 데이터가 불법적으로 외부에 노출되는 것 | **기밀성** 침해 |
| **데이터 불법 수정(Modification)** | 권한 없는 사용자에 의해 데이터가 수정되는 것 | **무결성** 침해 |
| **서비스 거부(Denial of Service)** | 정상적인 사용자가 서비스를 이용하지 못하는 것 | **가용성** 침해 |

### 데이터베이스 보안 요구사항

데이터베이스 보안에서 요구되는 주요 사항들을 정리하면 다음과 같습니다:

- **접근 제어**: 정당한 사용자만 데이터베이스에 접근할 수 있어야 합니다
- **추론 방지**: 공개된 데이터를 조합하여 숨겨진 정보를 추론(예측)하는 것을 막아야 합니다. 보여줄 데이터만 보여주고, 감추고자 하는 데이터는 예측이 불가능하도록 해야 합니다.
- **무결성 유지**: 도메인 무결성, 릴레이션 무결성, 의미 무결성 등 다양한 무결성 규정과 트리거를 통해 데이터의 정확성을 유지해야 합니다
- **의미 무결성**: 4년제 대학은 1~4학년, 초등학교는 1~6학년, 중·고등학교는 1~3학년처럼 **의미적으로 당연한** 값의 범위가 지켜져야 합니다
- **시스템 감사**: 사용자가 정상적인 권한으로 데이터에 접근했는지를 **로그(기록)를 통해 감사**합니다. 은행 직원도 고객의 계좌를 임의로 볼 수 없으며, 모든 접근 기록이 로그에 남습니다
- **인증**: 아이디와 패스워드가 정상적인지 확인하는 과정입니다
- **기밀 데이터 보호**: 극비(Top Secret), 비밀(Secret), 대외비(Confidential) 등 **등급별로 보안 레벨**을 부여하여 중요한 데이터를 보호합니다
- **감금(Confinement)**: 아주 중요한 데이터는 아예 외부에서 접근하지 못하도록 격리하여 보호합니다

:::warning 추론 방지가 중요한 이유
직접 기밀 데이터에 접근하지 않더라도, 공개된 여러 데이터를 조합하면 숨겨진 정보를 추측할 수 있습니다. 예를 들어, "부서별 평균 급여"와 "부서별 인원수" 데이터만 있어도 특정 사람의 급여를 추론할 수 있는 경우가 있습니다. 이런 추론을 방지하는 것도 보안의 중요한 요소입니다.
:::

## 📌 핵심 정리

- **무결성(Integrity)**은 데이터베이스에 저장된 데이터의 **정확성**을 유지하는 것이다
- **성능보다 무결성이 더 중요하다** — 아무리 빠른 시스템도 결과가 부정확하면 사용할 수 없다
- 성능과 무결성은 **트레이드오프(Trade-off)** 관계에 있다 — 둘 다 동시에 최대로 올릴 수 없다
- **무결성은 시스템이 자동으로 유지**한다 — 사용자는 규정만 설정하면 DBMS의 무결성 서브시스템이 알아서 처리한다
- **무결성과 보안은 다른 개념이다** — 무결성은 정상 사용자의 정확성 유지, 보안은 불법 사용자의 접근 차단
- **무결성 규정**은 규정 이름, 검사 시기, 제약 조건, 위반 시 조치의 4가지 요소로 구성된다
- **도메인 무결성**은 속성 값이 정해진 범위 안에 있는지 확인하는 것이다
- **릴레이션 무결성**은 과도 제약, 집합 제약, 튜플 제약, 즉시 제약, 지연 제약 등을 포괄하는 넓은 개념이다
- **트리거(Trigger)**는 조건을 **만족**했을 때 자동으로 작업을 실행하는 **능동적** 메커니즘이다
- 트리거는 **ECA(Event-Condition-Action)** 규칙으로 구성된다
- 트리거 실행은 **시점(BEFORE/AFTER)**과 **범위(STATEMENT/ROW)**에 따라 4가지로 나뉜다
- 데이터베이스 **보안**은 기밀성, 무결성, 가용성을 보장하기 위해 접근 제어, 인증, 감사, 추론 방지 등이 필요하다

---

작성일: 2026-02-21