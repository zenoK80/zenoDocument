---
title: "UML과 객체지향 프로그래밍의 기초"
description: "설계 도구 UML이 어떻게 프로그래밍 코드로 변환되는지 학습합니다."
slug: "uml-oop-basics"
sidebar_position: 1
date: "2024-01-17"
---

# UML과 객체지향 프로그래밍의 기초

## UML이란?

### UML의 정의

**UML** = Unified Modeling Language (통합 모델링 언어)

```
설계 도구: 표준화되어 있는 표기법
디자인: 소프트웨어 구조를 시각적으로 표현
목적: 개발자와 설계자가 쉽게 이해할 수 있도록
```

### 왜 UML이 필요한가?

```
설계 → 코딩 과정에서:

설계 문서 (UML)
        ↓
개발자가 이해
        ↓
실제 코드 작성
```

---

## 클래스와 객체

### 클래스의 개념

**클래스** = 속성(데이터) + 메서드(기능)을 하나로 묶은 것

```
클래스 구성:

┌─────────────────────┐
│      Class: User    │
├─────────────────────┤
│  속성 (Attributes)   │
│  - age: int         │
│  - name: string     │
├─────────────────────┤
│  메서드 (Methods)    │
│  - getAge()         │
│  - setName()        │
└─────────────────────┘
```

### UML 표기법

```
UML 다이어그램:

┌─────────────────┐
│      User       │  ← 클래스 이름
├─────────────────┤
│  age: int       │  ← 속성들
│  name: string   │
├─────────────────┤
│  getAge()       │  ← 메서드들
│  setName()      │
└─────────────────┘
```

### 자바 코드로의 변환

```java
// UML을 자바로 구현

public class User {
    // 속성 (Attributes)
    private int age;
    private String name;
    
    // 메서드 (Methods)
    public int getAge() {
        return age;
    }
    
    public void setName(String newName) {
        name = newName;
    }
}
```

**코드 한 줄 한 줄 리뷰:**

```java
public class User {
    // public: 누구나 접근 가능
    // class: 이것이 클래스임을 선언
    // User: 클래스의 이름
    
    private int age;
    // private: 이 클래스 안에서만 사용 가능
    // int: 정수 타입
    // age: 속성 이름
    
    public int getAge() {
        // public: 외부에서도 호출 가능
        // int: 정수를 반환
        // getAge(): 메서드 이름
        return age;
        // age 값을 반환
    }
}
```

---

## 접근 제어자 (Access Modifier)

### public vs private

```
public:
├─ 공용 (공개)
├─ 누구나 접근 가능
└─ 외부에서도 사용 가능

private:
├─ 비공개 (내부용)
├─ 같은 클래스 내에서만 사용
└─ 외부에서 접근 불가
```

### 사용 예시

```java
public class User {
    // ❌ 나쁜 예: public 필드
    public String password;  // 누구나 접근 가능!
    
    // ✅ 좋은 예: private 필드
    private String password;  // 내부에서만 사용
    
    // ✅ 접근하려면 메서드를 통해
    public String getPassword() {
        return password;
    }
}
```

---

## 추상 클래스 (Abstract Class)

### 추상 클래스란?

**추상 클래스** = 일부 메서드만 정의하고 구체적 구현은 없는 클래스

```
일반 클래스:
└─ 모든 메서드가 구현됨

추상 클래스:
├─ 메서드 껍데기만 정의
├─ 실제 구현은 상속받은 클래스에서
└─ 직접 사용할 수 없음
```

### 예시

```java
// 추상 클래스 정의
abstract class User {
    // 구현된 메서드
    public void login() {
        System.out.println("로그인");
    }
    
    // 껍데기만 있는 메서드 (구현 없음)
    abstract void work();
}

// 추상 클래스를 상속받은 실제 클래스
class Developer extends User {
    @Override
    void work() {
        System.out.println("개발 중");
    }
}
```

---

## 일반화 (상속)

### 상속의 개념

```
부모 클래스 (Superclass) User:
├─ 공통 속성: id, password
├─ 공통 메서드: login()
└─ 모든 사용자가 가져야 할 것들

자식 클래스들 (Subclass):
├─ Customer: 고객
├─ Admin: 관리자
└─ 부모의 login() 메서드를 상속받아 사용
```

### 상속 구조

```
        ┌─────────────────┐
        │      User       │  (부모)
        │  - id           │
        │  - password     │
        │  + login()      │
        └────────┬────────┘
                 │
        ┌────────┴────────┐
        │                 │
    ┌───────────┐     ┌─────────────┐
    │ Customer  │     │    Admin    │  (자식)
    └───────────┘     └─────────────┘
```

### 코드로 표현

```java
// 부모 클래스
public class User {
    private String id;
    private String password;
    
    public void login() {
        System.out.println("로그인");
    }
}

// 자식 클래스 1: Customer
public class Customer extends User {
    // User의 id, password, login() 상속받음
    
    public void shopping() {
        System.out.println("쇼핑 중");
    }
}

// 자식 클래스 2: Admin
public class Admin extends User {
    // User의 id, password, login() 상속받음
    
    public void manage() {
        System.out.println("관리 중");
    }
}
```

**extends 키워드의 의미:** "User 클래스를 상속받는다"

---

## 인터페이스 (Interface)

### 인터페이스란?

**인터페이스** = 메서드의 명세만 정의 (구현은 없음)

```
인터페이스:
├─ 메서드 이름만 선언
├─ 실제 기능은 구현하지 않음
└─ "이런 기능을 하는 메서드가 있어야 한다"는 약속

구현 클래스:
└─ 인터페이스의 약속을 지켜 실제 기능 구현
```

### 인터페이스 예시

```java
// 인터페이스 정의 (껍데기만)
public interface CheckLogin {
    boolean checkPassword();  // 구현 없음, 정의만
}

// 인터페이스를 구현하는 클래스
public class DatabaseCheckLogin implements CheckLogin {
    @Override
    public boolean checkPassword() {
        // 실제 구현
        System.out.println("데이터베이스에서 확인");
        return true;
    }
}
```

**implements 키워드의 의미:** "CheckLogin 인터페이스를 구현하겠다"

### 인터페이스 vs 추상 클래스

```
인터페이스:
├─ 모든 메서드가 구현되지 않음 (명세만)
├─ 상속 다중 구현 가능
└─ "이런 기능이 있어야 한다"는 강제

추상 클래스:
├─ 일부는 구현, 일부는 미구현
├─ 단일 상속만 가능
└─ 공통 기능을 부분적으로 제공
```

---

## 의존성 (Dependency)

### 의존성이란?

한 클래스가 다른 클래스를 참조하여 사용하는 관계

```java
public class User {
    private Schedule schedule;  // Schedule을 의존
    
    public void createSchedule() {
        schedule = new Schedule();  // Schedule 객체 생성
    }
}
```

### 객체 생성 (new 키워드)

```java
// 클래스 정의만으로는 사용 불가
Schedule schedule;  // ❌ 아직 사용 불가

// new 키워드로 객체 생성
schedule = new Schedule();  // ✅ 이제 사용 가능

// 생성된 객체를 사용
schedule.addEvent("회의");  // 객체의 메서드 호출
```

---

## 연관성 (Association)

### 연관성의 개념

한 클래스가 다른 클래스를 포함하는 관계

```java
public class User {
    // Address 클래스를 포함
    private List<Address> addresses;  // 여러 주소를 리스트로 관리
    
    public void addAddress(Address address) {
        addresses.add(address);
    }
}

public class Address {
    private String city;
    private String street;
}
```

### 집합 (Aggregation)

```java
// 전체와 부분의 관계
public class User {
    // User는 여러 Address를 가질 수 있음
    private List<Address> addresses;
}

// User를 지우면 addresses도 함께 지워짐
```

---

## UML 다이어그램과 코드의 관계

### 설계 → 구현 과정

```
UML 다이어그램
        ↓
개발자가 읽음
        ↓
클래스 이름, 속성, 메서드 파악
        ↓
자바 코드 작성
        ↓
완성된 프로그램
```

### 중요한 점

```
프로그래밍 경험이 없으면:
└─ 코드가 낯설 수 있음
└─ 하지만 걱정하지 말 것

여기서 알아야 할 것:
├─ UML을 어떻게 코드로 변환하는가
├─ 클래스의 구조
└─ 상속, 인터페이스의 개념
```

---

## 정리

### 핵심 개념

| 개념 | 설명 |
|------|------|
| **클래스** | 속성 + 메서드를 묶은 템플릿 |
| **객체** | 클래스를 new로 생성한 실제 인스턴스 |
| **상속** | extends로 부모 클래스의 기능 이어받음 |
| **인터페이스** | 메서드의 약속만 제공 |
| **public** | 공개 (외부 접근 가능) |
| **private** | 비공개 (내부만 접근 가능) |

### 관계도

```
UML
  ↓
(설계 도구)
  ↓
개발자가 이해
  ↓
자바 코드로 변환
  ↓
프로그램 완성
```