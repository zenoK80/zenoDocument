---
title: "리팩토링과 코드 스멜"
description: "나쁜 코드를 식별하고 리팩토링을 통해 개선하는 기법을 학습합니다."
slug: "refactoring-code-smell"
sidebar_position: 3
date: "2024-01-17"
---

# 리팩토링과 코드 스멜

## 리팩토링이란?

### 리팩토링의 정의

**리팩토링** = 기능을 변경하지 않으면서 코드를 개선하는 작업

```
"Refactoring"의 의미:

Re (다시) + Factoring (공장/만들기)
= 이미 만들어진 것을 다시 만들기
= 더 좋은 코드로 개선하기
```

### 왜 리팩토링이 필요한가?

```
처음 작성한 코드:
└─ 동작은 하지만 복잡함
└─ 가독성이 떨어짐
└─ 유지보수가 어려움

리팩토링 후:
├─ 동일한 기능
├─ 간단하고 명확함
├─ 유지보수가 쉬움
└─ 버그 찾기가 쉬움
```

### 리팩토링의 목표

```
✅ 가독성 향상 (코드를 쉽게 이해)
✅ 유지보수 용이 (수정하기 쉬움)
✅ 버그 감소 (문제점 찾기 쉬움)
✅ 개발 속도 향상 (다음 개발이 빨라짐)
```

---

## 코드 스멜 (Code Smell)

### 코드 스멜이란?

**코드 스멜** = 리팩토링이 필요한 신호를 보내는 나쁜 코드의 징후

```
냄새가 난다 = 뭔가 문제가 있다는 신호
문제점을 찾기 위한 신호탄
```

---

## 코드 스멜의 종류와 해결책

### 1️⃣ 중복된 코드 (Duplicate Code)

#### 문제

```java
// ❌ 나쁜 예: 같은 코드가 반복됨
class Report {
    void printCustomerReport() {
        System.out.println("보고서 시작");
        System.out.println("고객 정보");
        System.out.println("---");
        System.out.println("판매액: 10000");
        System.out.println("보고서 끝");
    }
    
    void printSalesReport() {
        System.out.println("보고서 시작");
        System.out.println("판매 정보");
        System.out.println("---");
        System.out.println("판매액: 10000");
        System.out.println("보고서 끝");
    }
}
```

#### 해결책: 메서드 추출 (Extract Method)

```java
// ✅ 좋은 예: 공통 부분을 메서드로 추출
class Report {
    void printReport(String title, String content) {
        printReportHeader();
        System.out.println(title);
        System.out.println("---");
        System.out.println(content);
        printReportFooter();
    }
    
    void printReportHeader() {
        System.out.println("보고서 시작");
    }
    
    void printReportFooter() {
        System.out.println("보고서 끝");
    }
}
```

### 2️⃣ 긴 메서드 (Long Method)

#### 문제

```java
// ❌ 나쁜 예: 메서드가 너무 길다
public void processOrder(Order order) {
    // 300줄의 코드...
    // - 검증
    // - 결제 처리
    // - 재고 관리
    // - 배송 준비
    // - 메일 발송
    // 모든 것이 한 메서드에...
}
```

#### 해결책: 메서드 분할

```java
// ✅ 좋은 예: 메서드를 작은 단위로 분할
public void processOrder(Order order) {
    validateOrder(order);
    processPayment(order);
    updateInventory(order);
    prepareShipment(order);
    sendConfirmationEmail(order);
}

private void validateOrder(Order order) { }
private void processPayment(Order order) { }
private void updateInventory(Order order) { }
private void prepareShipment(Order order) { }
private void sendConfirmationEmail(Order order) { }
```

### 3️⃣ 큰 클래스 (Large Class)

#### 문제

```java
// ❌ 나쁜 예: 클래스에 너무 많은 책임
class User {
    // 사용자 정보
    String name, email, phone;
    
    // 주문 정보
    Order[] orders;
    
    // 결제 정보
    CreditCard card;
    
    // 배송 정보
    Address deliveryAddress;
    
    // 메서드도 100개 이상...
}
```

#### 해결책: 클래스 분할

```java
// ✅ 좋은 예: 책임에 따라 클래스 분할
class User {
    String name, email, phone;
}

class OrderManagement {
    private Order[] orders;
}

class PaymentInfo {
    private CreditCard card;
}

class DeliveryInfo {
    private Address address;
}
```

### 4️⃣ 긴 파라미터 (Long Parameter List)

#### 문제

```java
// ❌ 나쁜 예: 파라미터가 너무 많다
void createUser(String name, String email, String phone, 
                int age, String address, String city,
                String country, String zipcode,
                String job, String company) {
    // 파라미터가 10개...
}
```

#### 해결책: 객체로 묶기

```java
// ✅ 좋은 예: 관련된 파라미터를 객체로 묶음
class UserInfo {
    String name, email, phone;
    int age;
}

class AddressInfo {
    String address, city, country, zipcode;
}

class JobInfo {
    String job, company;
}

void createUser(UserInfo user, AddressInfo address, JobInfo job) {
    // 파라미터가 3개로 줄어듦
}
```

### 5️⃣ 복잡한 조건문 (Complex Conditional)

#### 문제

```java
// ❌ 나쁜 예: 복잡한 조건문
int rating;
if (age > 18) {
    if (hasLicense) {
        if (hasInsurance) {
            rating = 5;
        } else {
            rating = 3;
        }
    } else {
        rating = 2;
    }
} else {
    rating = 1;
}
```

#### 해결책: 조건 단순화

```java
// ✅ 좋은 예: 조건을 메서드로 분리
int rating = calculateRating(age, hasLicense, hasInsurance);

private int calculateRating(int age, boolean license, boolean insurance) {
    if (age <= 18) return 1;
    if (!license) return 2;
    if (!insurance) return 3;
    return 5;
}
```

### 6️⃣ 중복된 데이터 (Duplicate Data)

#### 문제

```java
// ❌ 나쁜 예: 같은 정보를 여러 곳에서 관리
class Person {
    String firstName, lastName;
    String fullName;  // firstName + lastName과 중복
    
    void setName(String first, String last) {
        firstName = first;
        lastName = last;
        // fullName을 따로 업데이트하지 않으면 불일치 발생!
    }
}
```

#### 해결책: 중복 제거

```java
// ✅ 좋은 예: 필요할 때 계산
class Person {
    String firstName, lastName;
    
    String getFullName() {
        return firstName + " " + lastName;  // 필요할 때만 계산
    }
}
```

### 7️⃣ 여러 클래스를 동시에 수정 (Divergent Change)

#### 문제

```java
// ❌ 나쁜 예: 한 기능 추가 시 여러 클래스 수정
// 결제 방법 추가 → Payment, Order, User 모두 수정해야 함
```

#### 해결책: 클래스 통합

```java
// ✅ 좋은 예: 결제 관련 클래스 통합
class PaymentManager {
    // 결제 관련 모든 기능을 한 곳에
}
```

### 8️⃣ 과다한 클래스 참조 (Feature Envy)

#### 문제

```java
// ❌ 나쁜 예: 다른 클래스의 데이터를 너무 많이 사용
class OrderService {
    void calculateTotal(Order order) {
        // order의 items를 여러 번 접근
        int total = 0;
        for (Item item : order.items) {  // 외부 접근 1
            total += item.price * item.quantity;  // 외부 접근 2, 3
        }
    }
}
```

#### 해결책: 메서드 이동

```java
// ✅ 좋은 예: 계산을 Order 클래스로 이동
class Order {
    int calculateTotal() {
        int total = 0;
        for (Item item : items) {
            total += item.price * item.quantity;
        }
        return total;
    }
}

class OrderService {
    void process(Order order) {
        int total = order.calculateTotal();  // 간단하게 호출
    }
}
```

### 9️⃣ 에러 코드 반환 (Error Codes)

#### 문제

```java
// ❌ 나쁜 예: 에러를 숫자로 반환
int withdraw(int amount) {
    if (amount > balance) {
        return -1;  // 에러 코드
    }
    balance -= amount;
    return 0;  // 성공 코드
}

// 사용할 때 확인 어려움
int result = withdraw(100);
if (result == -1) {
    System.out.println("잔액 부족");
}
```

#### 해결책: 예외 처리

```java
// ✅ 좋은 예: 예외로 처리
void withdraw(int amount) throws InsufficientFundsException {
    if (amount > balance) {
        throw new InsufficientFundsException("잔액이 부족합니다");
    }
    balance -= amount;
}

// 사용할 때 명확함
try {
    withdraw(100);
} catch (InsufficientFundsException e) {
    System.out.println(e.getMessage());
}
```

---

## 리팩토링 프로세스

### 단계별 접근

```
1단계: 작은 변경
    └─ 한 번에 한 가지만 수정

2단계: 테스트
    └─ 변경 후 제대로 작동하는지 확인

3단계: 확인
    └─ 버그가 없는지 검증

4단계: 다음 변경으로 진행
    └─ 또는 실패하면 이전으로 되돌리기

반복...
```

### 리팩토링의 원칙

```
✅ 작은 단위로 변경
✅ 매 변경 후 테스트
✅ 작동하지 않으면 롤백
✅ 한 번에 한 가지만 수정

❌ 한꺼번에 여러 것 수정 (위험!)
❌ 테스트 없이 진행 (버그 위험)
❌ 큰 변경을 한 번에 (문제 발생 시 원인 파악 어려움)
```

---

## 정리

### 코드 스멜의 신호

```
⚠️ 중복된 코드 있음?
⚠️ 메서드가 너무 길다?
⚠️ 클래스가 너무 크다?
⚠️ 조건문이 복잡하다?
⚠️ 파라미터가 많다?
```

### 리팩토링의 목표

```
나쁜 코드 → 좋은 코드
복잡함   → 단순함
읽기 어려움 → 읽기 쉬움
유지보수 어려움 → 유지보수 쉬움
```

**핵심**: 기능은 같되, 코드 품질을 개선하는 것