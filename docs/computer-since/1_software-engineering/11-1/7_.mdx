---
title: "좋은 코드 작성 습관"
description: "전문적인 프로그래머가 되기 위한 코딩 습관과 표준을 배웁니다."
slug: "good-coding-habits"
sidebar_position: 7
date: "2024-01-15"
---

# 좋은 코드 작성 습관

**좋은 코드**는 타고나는 것이 아니라, **습관**으로 만들어집니다. 이번 시간에는 전문 프로그래머가 갖춰야 할 습관들을 배웁니다.

---

## 1️⃣ 변수명 작성 (Naming Convention)

### 변수명의 중요성

변수명은 **코드의 의도를 드러내는 창**입니다.

```cpp
// ❌ 나쁜 예: 무엇을 하는지 모름
int a = 0;
int b = 0;
for (int i = 0; i < 10; i++) {
    a += score[i];
}
b = a / 10;
printf("%d\n", b);
```

**무엇을 하는 코드인가요?** 모릅니다! 😕

```cpp
// ✅ 좋은 예: 무엇을 하는지 명확함
int totalScore = 0;
int averageScore = 0;
for (int i = 0; i < 10; i++) {
    totalScore += score[i];
}
averageScore = totalScore / 10;
printf("평균 점수: %d\n", averageScore);
```

**아, 평균을 구하는 코드군요!** ✅

### 변수명 작성 규칙

```cpp
// 패턴 1: snake_case (C 언어에서 권장)
int total_score = 0;
int average_score = 0;
int max_value = 100;

// 패턴 2: camelCase (Java에서 권장)
int totalScore = 0;
int averageScore = 0;
int maxValue = 100;

// 패턴 3: PascalCase (클래스명에서 주로 사용)
class StudentGrade { }
struct EmployeeInfo { }
```

### 변수명 작성 팁

```cpp
// ✅ 좋은 변수명의 특징
int userAge = 25;           // 용도가 명확
double salary = 3500.50;    // 타입이 드러남
bool isAdmin = true;        // 불린 변수는 is/has 접두어
int count = 0;              // 개수를 나타냄

// ❌ 피해야 할 변수명
int temp = 25;              // temp는 너무 일반적
int x = 0;                  // x는 수학 변수처럼 보임
int data = 100;             // data는 뭔지 불명확
int xxx = 5;                // xxx는 의미 없음
int o = 1;                  // 0과 헷갈림
```

:::tip
**규칙**: 변수명을 읽었을 때, **"아, 이게 뭐구나!"라고 즉시 알아야** 합니다!
:::

---

## 2️⃣ 주석문 작성 (Comments)

### 주석이란?

코드를 **설명하는 텍스트**입니다.

```cpp
#include <stdio.h>

int main() {
    // ✅ 주석 예시
    int score = 85;  // 학생의 점수
    
    // 90점 이상이면 A학점
    if (score >= 90) {
        printf("A\n");
    }
    
    return 0;
}
```

### 좋은 주석 vs 나쁜 주석

```cpp
// ❌ 나쁜 주석: 코드와 중복
int x = 5;  // x는 5다

// ✅ 좋은 주석: 왜 이렇게 했는지 설명
int retryCount = 5;  // 네트워크 재시도 횟수 (경험상 5회가 최적)

// ❌ 나쁜 주석: 너무 많음
int score = 0;  // score 변수
int count = 0;  // 개수
for (int i = 0; i < 10; i++) {  // i는 0부터 9까지
    score += data[i];  // score에 더하기
}
average = score / 10;  // 10으로 나누기

// ✅ 좋은 주석: 필요한 부분만
int score = 0;
int count = 0;
for (int i = 0; i < 10; i++) {
    score += data[i];
}
// 성적이 0점인 학생은 평균 계산에서 제외
if (score > 0) {
    average = score / count;
}
```

### 주석 작성 원칙

```cpp
// ✅ 주석은 다음을 설명해야 함:

// 1. 왜 이렇게 했는가?
if (timeout > 5000) {  // 5초 이상 응답 없으면 종료
    abort();
}

// 2. 주의할 점이 무엇인가?
strcpy(buffer, input);  // 주의: 버퍼 오버플로우 위험!

// 3. 특이한 구현 방법
count = (count + 1) % 10;  // 순환 배열: 0~9 반복

// 4. 복잡한 알고리즘 설명
// 퀵 정렬: 피벗 선택 → 분할 → 재귀
```

:::warning
**피해야 할 주석들:**
- 당연한 것을 반복하는 주석
- 너무 많은 주석 (코드가 보이지 않음)
- 코드와 맞지 않는 주석
:::

---

## 3️⃣ 코드 포맷팅 (Code Formatting)

### 들여쓰기 (Indentation)

```cpp
// ❌ 들여쓰기 안 한 코드 (읽기 어려움)
int main() {
for (int i = 0; i < 10; i++) {
if (i % 2 == 0) {
printf("%d ", i);
}
}
return 0;
}

// ✅ 들여쓰기 한 코드 (읽기 쉬움)
int main() {
    for (int i = 0; i < 10; i++) {
        if (i % 2 == 0) {
            printf("%d ", i);
        }
    }
    return 0;
}
```

### 공백 (Spacing)

```cpp
// ❌ 공백 없음 (답답함)
int a=b+c*d;
for(int i=0;i<10;i++){
    if(x>5&&y<10){
        result=a+b;
    }
}

// ✅ 적절한 공백 (읽기 쉬움)
int a = b + c * d;
for (int i = 0; i < 10; i++) {
    if (x > 5 && y < 10) {
        result = a + b;
    }
}
```

### 한 줄의 길이

```cpp
// ❌ 너무 긴 줄 (화면을 벗어남)
int result = calculateTotalScore(student1, student2, student3) + adjustBonus(department) * calculateGrade(level);

// ✅ 적절히 나눔 (읽기 쉬움)
int totalScore = calculateTotalScore(
    student1, student2, student3
);
int bonus = adjustBonus(department);
int gradeMultiplier = calculateGrade(level);
int result = totalScore + (bonus * gradeMultiplier);
```

### 줄바꿈

```cpp
// ✅ 좋은 포맷
int main() {
    // 변수 선언
    int score = 0;
    int count = 0;
    
    // 입력 받기
    scanf("%d", &score);
    
    // 처리
    if (score >= 90) {
        printf("A\n");
    }
    
    return 0;
}
```

:::tip
**규칙**: 가독성이 좋아야 합니다. 다른 사람이 읽었을 때도 쉽게 이해해야 합니다!
:::

---

## 4️⃣ 함수 작성 (Function Design)

### 함수는 한 가지 일만 해야 한다

```cpp
// ❌ 나쁜 예: 여러 일을 함
void processStudent(int id) {
    // 데이터 읽기
    FILE *fp = fopen("student.txt", "r");
    // ... 읽기 ...
    
    // 데이터 계산
    int total = sum(scores);
    int average = total / count;
    
    // 데이터 정렬
    sort(scores);
    
    // 파일에 쓰기
    fwrite(scores, ...);
    
    // 결과 출력
    printf("완료\n");
}

// ✅ 좋은 예: 각각의 일을 하는 함수들
int calculateAverage(int scores[], int count) {
    int total = 0;
    for (int i = 0; i < count; i++) {
        total += scores[i];
    }
    return total / count;
}

void sortScores(int scores[], int count) {
    // 정렬 코드...
}

void printResult(int average) {
    printf("평균: %d\n", average);
}
```

### 함수 이름 작성

```cpp
// ❌ 나쁜 함수명
void do_it() { }           // 뭐를 하는데?
void calc() { }            // 뭘 계산?
void process() { }         // 뭘 처리?

// ✅ 좋은 함수명
int calculateAverage() { }         // 평균을 계산
bool isValidEmail() { }            // 유효한 이메일인지 확인
void printStudentInfo() { }        // 학생 정보 출력
```

### 함수의 크기

```cpp
// ❌ 너무 큰 함수 (200줄 이상)
void hugeFunction() {
    // 1단계: 데이터 입력
    // ... 50줄 ...
    
    // 2단계: 데이터 처리
    // ... 100줄 ...
    
    // 3단계: 결과 출력
    // ... 50줄 ...
}

// ✅ 작은 함수들로 분할 (각 20~50줄)
void inputData() {
    // 입력 코드...
}

void processData() {
    // 처리 코드...
}

void outputResult() {
    // 출력 코드...
}

int main() {
    inputData();
    processData();
    outputResult();
}
```

:::info
**원칙**: 한 함수는 **한 가지 일만** 하고, **20~50줄 정도**가 이상적입니다!
:::

---

## 5️⃣ 에러 처리 (Error Handling)

### 모든 에러를 처리해야 한다

```cpp
// ❌ 나쁜 예: 에러 체크 안 함
FILE *fp = fopen("data.txt", "r");
int value;
fscanf(fp, "%d", &value);  // fp가 NULL일 수도 있음!
fclose(fp);

// ✅ 좋은 예: 에러 체크
FILE *fp = fopen("data.txt", "r");
if (fp == NULL) {
    printf("파일 열기 실패\n");
    return -1;  // 함수 종료
}

int value;
if (fscanf(fp, "%d", &value) != 1) {
    printf("파일 읽기 실패\n");
    fclose(fp);
    return -1;
}

fclose(fp);
return 0;
```

### 함수의 반환값 확인

```cpp
// ✅ 함수에서 상태를 반환하기
int readScore(const char *filename, int *score) {
    FILE *fp = fopen(filename, "r");
    if (fp == NULL) {
        return -1;  // 파일 열기 실패
    }
    
    if (fscanf(fp, "%d", score) != 1) {
        fclose(fp);
        return -2;  // 파일 읽기 실패
    }
    
    fclose(fp);
    return 0;  // 성공
}

// 사용
int score = 0;
int result = readScore("score.txt", &score);
if (result == 0) {
    printf("점수: %d\n", score);
} else if (result == -1) {
    printf("파일을 열 수 없습니다\n");
} else if (result == -2) {
    printf("점수를 읽을 수 없습니다\n");
}
```

---

## 6️⃣ 문서화 (Documentation)

### 파일 헤더

```cpp
/**
 * @file student.c
 * @brief 학생 정보 관리 프로그램
 * @author John Doe
 * @date 2024-01-15
 * @version 1.0
 */
```

### 함수 문서

```cpp
/**
 * 두 개의 정수를 더하는 함수
 * 
 * @param a 첫 번째 정수
 * @param b 두 번째 정수
 * @return a와 b의 합
 * 
 * @note 오버플로우를 체크하지 않습니다
 * @see subtract() 빼기 함수도 있습니다
 */
int add(int a, int b) {
    return a + b;
}
```

### 모듈 문서

```cpp
/**
 * @module MathLibrary
 * @brief 수학 함수들의 모음
 * @description
 * 기본 산술 연산(덧셈, 뺄셈, 곱셈, 나눗셈)을 제공합니다.
 * 오버플로우 처리는 별도로 필요합니다.
 * 
 * @functions
 * - add(a, b): 덧셈
 * - subtract(a, b): 뺄셈
 * - multiply(a, b): 곱셈
 * - divide(a, b): 나눗셈 (0으로 나누기 체크 필수)
 */
```

---

## 7️⃣ 코드 리뷰 체크리스트

프로그래밍을 마친 후 **자신의 코드를 리뷰**하세요:

```
□ 변수명이 명확한가?
□ 함수명이 기능을 잘 표현하는가?
□ 필요한 곳에 주석이 있는가?
□ 들여쓰기와 공백이 일관적인가?
□ 한 함수는 한 가지 일만 하는가?
□ 에러 처리가 되어있는가?
□ 경계값 테스트를 했는가?
□ 메모리 누수가 없는가?
□ 문자열 오버플로우가 없는가?
□ 코드가 읽기 쉬운가?
□ 문서화가 되어있는가?
```

---

## 정리하며 🎯

### 좋은 코드의 특징

| 특징 | 설명 |
|------|------|
| **명확성** | 읽었을 때 의도가 드러남 |
| **단순성** | 불필요한 복잡성 없음 |
| **일관성** | 스타일이 균일함 |
| **안전성** | 에러 처리가 철저함 |
| **유지보수성** | 수정하기 쉬움 |
| **문서화** | 의도가 명확히 기록됨 |

### 개발자의 성숙도

```
단계 1: "코드가 작동하면 된다" ❌
    ↓
단계 2: "코드가 작동하고 읽기 쉬워야 한다" ✅
    ↓
단계 3: "코드가 작동하고, 읽기 쉽고, 유지보수하기 좋아야 한다" ⭐⭐⭐
```

:::success
이러한 습관들을 지키면, 여러분도 **전문적인 프로그래머**가 될 수 있습니다! 🚀
:::

### 마지막 조언

```
"코드는 컴퓨터를 위해 쓰는 것이 아니라, 
미래의 자신과 다른 개발자를 위해 쓰는 것입니다."

- 프로그래밍 명언 -
```

다음에 코드를 작성할 때마다 이 말을 기억하세요! 💻