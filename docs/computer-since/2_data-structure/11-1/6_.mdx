---
title: "그래프 구현하기 - 인접 행렬 방식"
description: "C 언어로 인접 행렬을 사용해서 그래프를 직접 구현하고 코드를 한 줄씩 분석합니다."
slug: "graph-implementation-adjacency-matrix"
sidebar_position: 5
date: "2024-01-15"
---

## 🎯 학습 목표

이 장에서는 다음을 배웁니다:

- ✅ 그래프 구조체 설계
- ✅ 인접 행렬로 그래프 표현
- ✅ 그래프의 기본 연산 구현
- ✅ 실제 동작하는 코드 작성

---

## 📋 ADT (Abstract Data Type) 정의

먼저 그래프가 가져야 할 연산들을 정의합니다.

### 생성 및 제거

```
Create Graph()
→ 새로운 그래프 생성

Destroy Graph(G)
→ 그래프 G를 제거 (메모리 해제)
```

### 초기화

```
Init(G)
→ 그래프 G를 초기 상태로 설정
→ 모든 정점과 간선 비우기
```

### 정점 연산

```
Insert Vertex(G, v)
→ 그래프 G에 정점 v 추가

Delete Vertex(G, v)
→ 그래프 G에서 정점 v 제거
```

### 간선 연산

```
Insert Edge(G, u, v)
→ 그래프 G에 간선 (u,v) 추가

Delete Edge(G, u, v)
→ 그래프 G에서 간선 (u,v) 제거
```

### 조회 연산

```
Is Empty(G)
→ 그래프 G가 공백인지 확인 (정점이 0개?)

Is Full(G)
→ 그래프 G가 가득 찼는지 확인
→ ADT에서는 명시하지 않음 (구현에서 처리)

Adjacent(G, v)
→ 정점 v와 인접한 정점들의 리스트 반환
→ v의 이웃들을 반환
```

---

## 💾 구조체 설계

### 정점과 간선

```c
// 정점: 단순히 0, 1, 2, ... 숫자로 표현
// 간선: (u, v) 쌍

// 하지만 더 복잡한 데이터 구조라면:
typedef struct {
    int id;           // 정점의 ID
    char name[50];    // 정점의 이름
    int value;        // 정점의 값
} Vertex;
```

### 그래프 구조체

```c
#define MAX_VERTEX 50    // 최대 정점 개수

typedef struct {
    int n;                              // 현재 정점 개수
    int adj_matrix[MAX_VERTEX][MAX_VERTEX];  // 인접 행렬
} Graph;

/**
 * 필드 설명:
 * - n: 현재 그래프에 있는 정점의 개수
 * - adj_matrix: 2D 배열로 정점들 간의 연결을 저장
 *   → adj_matrix[i][j] = 1: i와 j가 연결됨
 *   → adj_matrix[i][j] = 0: i와 j가 연결 안 됨
 */
```

---

## 📝 함수별 코드 작성 및 분석

### 1️⃣ 헤더 파일 포함 및 상수 정의

```c
#include <stdio.h>      // printf, fprintf 등 입출력 함수
#include <stdlib.h>     // malloc, free 등 메모리 함수
#include <string.h>     // 문자열 관련 함수

#define MAX_VERTEX 50   // 최대 정점 개수를 50으로 정의
```

**코드 분석:**
- `#include <stdio.h>`: 화면에 출력하거나 입력받기 위해 필요
- `#include <stdlib.h>`: 동적 메모리 할당(malloc) 및 해제(free) 위해 필요
- `#include <string.h>`: 문자열을 다룰 때 필요
- `#define MAX_VERTEX 50`: 그래프는 최대 50개의 정점을 가질 수 있음

---

### 2️⃣ 그래프 초기화 함수

```c
void init_graph(Graph *g) {
    int r, c;
    
    // ① 정점 개수를 0으로 설정
    g->n = 0;
    
    // ② 모든 행(row)과 열(column)을 0으로 초기화
    for (r = 0; r < MAX_VERTEX; r++) {
        for (c = 0; c < MAX_VERTEX; c++) {
            g->adj_matrix[r][c] = 0;  // 모두 연결 안 됨
        }
    }
}
```

**코드 분석 라인 바이 라인:**

```c
void init_graph(Graph *g)
→ 반환값 없음, Graph 구조체 포인터 g 받음

g->n = 0;
→ 포인터 g의 n 필드를 0으로 설정
→ 의미: 그래프가 비어있음 (정점 0개)

for (r = 0; r < MAX_VERTEX; r++)
→ 행(row)을 0부터 49까지 반복
→ MAX_VERTEX = 50이므로 0~49

for (c = 0; c < MAX_VERTEX; c++)
→ 열(column)을 0부터 49까지 반복

g->adj_matrix[r][c] = 0;
→ 모든 위치를 0으로 초기화
→ 의미: 어떤 정점도 연결되지 않은 상태
```

**시각화:**
```
초기화 후 adj_matrix:
    0  1  2  3 ... 49
0 [ 0  0  0  0 ... 0 ]
1 [ 0  0  0  0 ... 0 ]
2 [ 0  0  0  0 ... 0 ]
...
49[ 0  0  0  0 ... 0 ]

모두 0이므로 아무것도 연결 안 됨!
```

---

### 3️⃣ 정점 삽입 함수

```c
void insert_vertex(Graph *g, int v) {
    // ① 정점 추가 후에 최대 개수를 초과하는지 확인
    if (g->n + 1 > MAX_VERTEX) {
        fprintf(stderr, "Error: 그래프 정점 개수 초과!\n");
        return;
    }
    
    // ② 정점을 추가할 수 없으면 여기서 종료
    // 정점 추가 성공하면 개수 증가
    g->n = g->n + 1;  // 또는 g->n++
}
```

**코드 분석:**

```c
if (g->n + 1 > MAX_VERTEX)
→ 현재 정점 개수 + 1이 최대값을 넘으면?

fprintf(stderr, "Error: 그래프 정점 개수 초과!\n");
→ 표준 에러(stderr)에 에러 메시지 출력
→ stderr: 모니터에 빨간 글씨로 표시되는 출력

return;
→ 함수 종료 (정점 추가 안 함)

g->n = g->n + 1;
→ 정점 개수 1 증가
→ 예: n=3이면 새 정점은 3번 (0,1,2,3)
```

**실행 예시:**

```
초기 상태: g->n = 0 (정점 없음)

insert_vertex(g, 0) 호출
→ 0 + 1 = 1 ≤ 50 ✅
→ g->n = 1 (정점 1개)

insert_vertex(g, 1) 호출
→ 1 + 1 = 2 ≤ 50 ✅
→ g->n = 2 (정점 2개)

... (반복) ...

insert_vertex(g, 49) 호출
→ 49 + 1 = 50 ≤ 50 ✅
→ g->n = 50 (정점 50개)

insert_vertex(g, 50) 호출
→ 50 + 1 = 51 > 50 ❌
→ 에러 메시지 출력, 함수 종료
```

---

### 4️⃣ 간선 삽입 함수

```c
void insert_edge(Graph *g, int start, int end) {
    // ① 시작 정점이 유효한지 확인
    // 정점은 0부터 (n-1)까지만 존재
    if (start < 0 || start >= g->n) {
        fprintf(stderr, "Error: 그래프 정점 번호 오류 (start)\n");
        return;
    }
    
    // ② 끝 정점이 유효한지 확인
    if (end < 0 || end >= g->n) {
        fprintf(stderr, "Error: 그래프 정점 번호 오류 (end)\n");
        return;
    }
    
    // ③ 정점 번호가 모두 유효하면 간선 추가
    // 무방향 그래프이므로 양방향 모두 설정
    g->adj_matrix[start][end] = 1;  // start → end
    g->adj_matrix[end][start] = 1;  // end → start (무방향)
}
```

**코드 분석:**

```c
if (start < 0 || start >= g->n)
→ start가 0미만이거나 n 이상이면 유효하지 않음
→ 왜? 정점은 0부터 (n-1)까지만 존재

예: n=4이면 정점은 0,1,2,3만 유효
    start=4 또는 start=-1은 불가

g->adj_matrix[start][end] = 1;
g->adj_matrix[end][start] = 1;
→ 무방향 그래프이므로 양쪽을 모두 1로 설정
→ (start, end)도 연결, (end, start)도 연결
```

**시각화:**

```
insert_edge(g, 0, 1) 호출 후:

행렬:
  0 1 2
0[0 1 0]  ← (0,1) = 1로 설정
1[1 0 0]  ← (1,0) = 1로 설정
2[0 0 0]

그래프: 0 ─── 1    (양방향)
        2 (혼자)
```

---

### 5️⃣ 인접 행렬 출력 함수

```c
void print_adj_matrix(Graph *g) {
    int i, j;
    
    // ① 행렬 헤더 출력 (정점 번호)
    printf("    ");
    for (j = 0; j < g->n; j++) {
        printf("%3d ", j);
    }
    printf("\n");
    
    // ② 각 행을 출력
    for (i = 0; i < g->n; i++) {
        printf("%3d [", i);  // 행 번호 출력
        
        // ③ 각 열의 값 출력
        for (j = 0; j < g->n; j++) {
            printf("%3d ", g->adj_matrix[i][j]);
        }
        printf("]\n");
    }
}
```

**코드 분석:**

```c
printf("    ");
for (j = 0; j < g->n; j++) {
    printf("%3d ", j);
}
→ 맨 위 헤더 출력: 0 1 2 3 ...

for (i = 0; i < g->n; i++)
→ 각 정점(행)을 반복

printf("%3d [", i);
→ 행 번호를 출력 (예: 0 [, 1 [, ...)

for (j = 0; j < g->n; j++) {
    printf("%3d ", g->adj_matrix[i][j]);
}
→ 각 행의 값들을 출력
```

**출력 예시:**

```
g->n = 3일 때:

      0   1   2
  0 [ 0   1   1 ]
  1 [ 1   0   1 ]
  2 [ 1   1   0 ]

의미: 정점 0,1,2가 모두 연결되어 있음 (완전 그래프)
```

---

## 🎬 메인 함수: 전체 흐름

```c
int main() {
    Graph *g;
    
    // ① 메모리 할당
    // malloc: 동적 메모리 할당 함수
    // sizeof(Graph): Graph 구조체 크기만큼 할당
    g = (Graph *)malloc(sizeof(Graph));
    
    // ② 그래프 초기화
    init_graph(g);
    
    // ③ 정점 추가 (0, 1, 2, 3)
    for (int i = 0; i < 4; i++) {
        insert_vertex(g, i);
    }
    
    // ④ 간선 추가
    insert_edge(g, 0, 1);  // 0-1 연결
    insert_edge(g, 0, 2);  // 0-2 연결
    insert_edge(g, 0, 3);  // 0-3 연결
    insert_edge(g, 1, 2);  // 1-2 연결
    insert_edge(g, 2, 3);  // 2-3 연결
    
    // ⑤ 그래프 출력
    printf("인접 행렬:\n");
    print_adj_matrix(g);
    
    // ⑥ 메모리 해제
    free(g);
    
    return 0;
}
```

**코드 분석:**

```c
Graph *g;
→ Graph 구조체를 가리킬 포인터 선언

g = (Graph *)malloc(sizeof(Graph));
→ Graph 크기만큼 메모리 할당
→ 할당된 주소를 g에 저장

init_graph(g);
→ 그래프를 초기 상태로 설정 (모두 0)

insert_vertex(g, i);
→ 정점 4개 추가 (0, 1, 2, 3)
→ g->n = 4가 됨

insert_edge(g, 0, 1);
→ 정점 0과 1을 연결

free(g);
→ 할당받은 메모리 해제
→ malloc과 free는 쌍을 이루어야 함!
```

---

## 📊 실행 결과

```
정점 4개, 간선 5개를 추가했을 때:

인접 행렬:
      0   1   2   3
  0 [ 0   1   1   1 ]
  1 [ 1   0   1   0 ]
  2 [ 1   1   0   1 ]
  3 [ 1   0   1   0 ]

그래프 그림:
    0 ─── 1
    │ ╲   │
    2 ─── 3

확인:
- matrix[0][1] = 1: 0-1 연결 ✅
- matrix[0][2] = 1: 0-2 연결 ✅
- matrix[0][3] = 1: 0-3 연결 ✅
- matrix[1][2] = 1: 1-2 연결 ✅
- matrix[2][3] = 1: 2-3 연결 ✅
- matrix[1][3] = 0: 1-3 미연결 ✅
```

---

## ⚠️ 중요한 메모리 개념

### malloc과 free의 쌍

```c
// 메모리 할당 (사용 시작)
g = (Graph *)malloc(sizeof(Graph));

... 코드 실행 ...

// 메모리 해제 (사용 종료)
free(g);

// 이 두 개는 반드시 쌍을 이루어야 함!
```

### 메모리 누수 방지

```
❌ 나쁜 예:
malloc 했는데 free 안 함
→ 메모리가 계속 차있음
→ 나중에 컴퓨터 느려짐

✅ 좋은 예:
malloc한 만큼 정확히 free
→ 메모리 효율적
→ 프로그램 안정성 높음
```

---

## 🔑 핵심 정리

| 함수 | 역할 | 시간 |
|------|------|------|
| init_graph | 그래프 초기화 | O(N²) |
| insert_vertex | 정점 추가 | O(1) |
| insert_edge | 간선 추가 | O(1) |
| print_adj_matrix | 행렬 출력 | O(N²) |

---

## ❓ 생각해보기

1. 왜 인접 행렬은 O(N²) 메모리가 필요할까?
   → 정점이 N개면 N×N 크기의 2D 배열 필요

2. 간선 추가할 때 왜 양쪽을 모두 1로 설정할까?
   → 무방향 그래프이므로 양방향 모두 이동 가능

3. malloc 안 하고 그냥 Graph g; 하면 안 될까?
   → 스택 메모리를 사용하므로 함수 끝나면 삭제됨
   → 힙 메모리(malloc)를 써야 더 큰 크기 할당 가능