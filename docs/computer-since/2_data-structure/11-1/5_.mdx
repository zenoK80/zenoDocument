---
title: "그래프를 프로그래밍으로 표현하는 방법"
description: "인접 행렬과 인접 리스트로 그래프를 구현하는 두 가지 방법을 배웁니다."
slug: "graph-representation"
sidebar_position: 5
date: "2024-01-15"
---

## 🤔 그래프를 어떻게 저장할까?

그래프는 눈으로 볼 수 있는 그림이지만, **컴퓨터에 저장**하려면 어떻게 할까요?

지금까지 배운 자료구조처럼 **그래프도 두 가지 방법**으로 표현할 수 있습니다:

1. **인접 행렬 (Adjacency Matrix)** - 배열 사용
2. **인접 리스트 (Adjacency List)** - 연결 리스트 사용

---

## 📊 인접 행렬 (Adjacency Matrix)

### 개념

**2차원 배열을 사용**해서 정점들 간의 연결 관계를 나타냅니다.

### 기본 원리

```
그래프를 그렸을 때:
  0 ─── 1
  │ ╲   │
  2 ─── 3

이걸 행렬로 표현:
    0  1  2  3
0 [ 0  1  1  1 ]
1 [ 1  0  1  1 ]
2 [ 1  1  0  1 ]
3 [ 1  1  1  0 ]

의미: matrix[i][j] = 1 → i와 j 정점이 연결됨
     matrix[i][j] = 0 → i와 j 정점이 연결 안 됨
```

### 상세 읽기 방법 📖

```
matrix[0][1] = 1
→ "정점 0과 정점 1 사이에 간선이 있다"

matrix[0][2] = 1
→ "정점 0과 정점 2 사이에 간선이 있다"

matrix[1][3] = 1
→ "정점 1과 정점 3 사이에 간선이 있다"
```

### 무방향 그래프 vs 방향 그래프

#### 무방향 그래프 (Undirected)
```
A ─── B

행렬:
  A B
A 0 1
B 1 0

특징: 대칭 구조! (A,B) = (B,A)
```

#### 방향 그래프 (Directed)
```
A ──→ B

행렬:
  A B
A 0 1
B 0 0

특징: 비대칭 구조! (A,B) ≠ (B,A)
→ A→B는 있지만 B→A는 없음
```

### 가중치 그래프에서의 인접 행렬

```
가중치를 포함한 그래프:
  10        15
서울 ──── 대전 ──── 부산
          (불연결)

행렬:
      서울 대전 부산
서울 [  0  10   0  ]
대전 [ 10   0  15  ]
부산 [  0  15   0  ]

의미: matrix[i][j] = 가중치 (0이면 연결 안 됨)
```

### 인접 행렬의 장단점 ⚖️

#### ✅ 장점
- **빠른 접근**: O(1) 시간에 연결 여부 확인 가능
- **구현이 간단**: 배열이라서 초기화, 접근 쉬움
- **간선 추가/제거**: O(1) 시간

#### ❌ 단점
- **메모리 낭비**: 정점이 N개면 N² 크기의 배열 필요
  - 정점 1000개 → 100만 크기의 배열 필요
  - 간선이 100개면, 999900개는 0으로 낭비!
- **순회가 느림**: 모든 간선을 찾으려면 O(N²) 필요

### 사용하기 좋은 경우 📌

- 정점 개수가 **적을 때** (수백 개 이하)
- 정점들이 **많이 연결되어 있을 때** (밀집 그래프)
- **빠른 연결 확인**이 필요할 때

---

## 🔗 인접 리스트 (Adjacency List)

### 개념

**각 정점마다 연결된 정점들의 리스트**를 저장합니다.

### 기본 원리

```
그래프:
  0 ─── 1
  │ ╲   │
  2 ─── 3

인접 리스트:
0: [1, 2, 3]        (0과 연결된 정점들)
1: [0, 2, 3]        (1과 연결된 정점들)
2: [0, 1, 3]        (2와 연결된 정점들)
3: [0, 1, 2]        (3과 연결된 정점들)

의미: 정점 0은 1, 2, 3과 연결되어 있다!
```

### 방향 그래프에서의 인접 리스트

```
방향 그래프:
0 ──→ 1
│     │
└──→  2

인접 리스트:
0: [1, 2]           (0에서 출발하는 간선)
1: [2]              (1에서 출발하는 간선)
2: []               (2에서 출발하는 간선 없음)

의미: 0에서 1, 2로 갈 수 있다!
```

### 가중치 포함 인접 리스트

```
가중치 그래프:
  10        15
A ──── B ──── C

인접 리스트 (연결 리스트):
A: [(B, 10)]              (B로 가는데 가중치 10)
B: [(A, 10), (C, 15)]     (A로 가는데 10, C로 가는데 15)
C: [(B, 15)]              (B로 가는데 가중치 15)
```

### 인접 리스트의 장단점 ⚖️

#### ✅ 장점
- **메모리 효율**: 간선 개수만큼만 저장
  - N개 정점, E개 간선 → O(N+E) 메모리
- **순회가 빠름**: 모든 간선 순회는 O(N+E)
- **큰 그래프에서 최적**: 정점은 많지만 간선이 적을 때

#### ❌ 단점
- **연결 확인이 느림**: 리스트를 일일이 확인 (최악 O(N))
- **구현이 복잡**: 연결 리스트 관리 필요
- **간선 삭제가 느림**: 리스트에서 찾아서 삭제 필요

### 사용하기 좋은 경우 📌

- 정점 개수가 **많을 때** (수만 개 이상)
- 간선이 **적을 때** (희소 그래프)
- **모든 간선 순회**가 자주 필요할 때

---

## 🆚 인접 행렬 vs 인접 리스트

### 한눈에 비교

| 특징 | 인접 행렬 | 인접 리스트 |
|------|---------|----------|
| 메모리 | O(N²) | O(N+E) |
| 연결 확인 (i,j) | O(1) ⭐ | O(degree(i)) |
| 모든 간선 순회 | O(N²) | O(N+E) ⭐ |
| 간선 추가 | O(1) | O(1) ⭐ |
| 간선 삭제 | O(1) | O(degree(i)) |
| 구현 난이도 | 쉬움 | 어려움 |
| 정점 차수 구하기 | O(N) | O(1) ⭐ |

### 선택 기준 🎯

```
Q: 정점 1000개, 간선 50개
→ 희소 그래프! 인접 리스트 사용

Q: 정점 100개, 간선 7000개 (거의 완전 그래프)
→ 밀집 그래프! 인접 행렬 사용

Q: 빠른 연결 확인이 중요
→ 인접 행렬 (O(1))

Q: 메모리가 제한적
→ 인접 리스트 (희소 그래프라면)
```

---

## 📝 정리: 어떤 것을 써야 할까?

### 인접 행렬을 선택하세요 🎯

```
✅ 정점이 50개 이하
✅ 대부분의 정점이 서로 연결됨
✅ 특정 두 정점의 연결을 자주 확인
✅ 구현 단순함이 중요
```

**예시**: 작은 네트워크, 보드 게임의 위치 표현

### 인접 리스트를 선택하세요 🎯

```
✅ 정점이 매우 많음 (수만 개)
✅ 간선이 비교적 적음 (희소)
✅ 모든 인접 정점을 자주 순회
✅ 메모리 효율이 중요
```

**예시**: 소셜 네트워크, 웹 크롤링, 대규모 지도
---

## 🔑 핵심 정리

| 개념 | 설명 |
|------|------|
| **인접 행렬** | 2D 배열로 연결 관계 표현 |
| **인접 리스트** | 각 정점의 연결 정점 리스트 |
| **희소 그래프** | 간선이 적은 그래프 → 리스트 추천 |
| **밀집 그래프** | 간선이 많은 그래프 → 행렬 추천 |
| **메모리** | 행렬: O(N²), 리스트: O(N+E) |
| **속도** | 행렬: 조회 O(1), 리스트: 순회 O(N+E) |

---
