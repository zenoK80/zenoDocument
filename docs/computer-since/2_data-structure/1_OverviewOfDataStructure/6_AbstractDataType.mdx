---
title: 추상 자료형
description: 추상 자료형(ADT)의 개념과 왜 중요한지, 어떻게 사용하는지 배웁니다.
slug: abstract-data-type
sidebar_position: 6
---
# 추상 자료형 (Abstract Data Type, ADT)

추상 자료형(ADT)은 **"무엇을 할 수 있는지"만 정의**하고, **"어떻게 구현되는지"는 숨기는** 자료형입니다.

**핵심 한 문장**:
> TV 리모컨처럼, 버튼(기능)만 알면 되고 내부 회로(구현)는 몰라도 되는 것!

<img src={require('../img/abstract-data-type.png').default} 
     alt="추상 데이터 타입" 
     style={{ maxWidth: '500px', width: '100%', display: 'block', margin: '0 auto' }} />
---

## 자료형(Data Type)이란?

먼저 일반적인 자료형을 이해해야 합니다.

### 정의

**자료형 = 데이터의 집합 + 연산의 집합**

### 예시: int (정수형)

```c
int a = 5;
int b = 10;
int result = a + b;
```

**int 자료형의 구성**:
- **데이터**: ..., -2, -1, 0, 1, 2, 3, ...
- **연산**: +, -, *, /, %

---

## 자료형의 종류

### 1. 기초 자료형 (Primitive Type)

C언어에서 기본으로 제공하는 자료형:

| 자료형 | 크기 | 데이터 범위 | 예시 |
|--------|------|------------|------|
| `char` | 1바이트 | -128 ~ 127 | 'A', 'z' |
| `int` | 4바이트 | -2,147,483,648 ~ 2,147,483,647 | 42, -100 |
| `float` | 4바이트 | 소수점 6자리 | 3.14f |
| `double` | 8바이트 | 소수점 15자리 | 3.14159265 |

---

### 2. 파생 자료형 (Derived Type)

기초 자료형을 기반으로 만든 자료형:

```c
// 배열 (Array)
int numbers[5] = {1, 2, 3, 4, 5};

// 포인터 (Pointer)
int* ptr = &numbers[0];
```

**배열**: 같은 타입의 데이터를 연속으로 저장  
**포인터**: 메모리 주소를 저장

---

### 3. 사용자 정의 자료형 (User-Defined Type)

프로그래머가 직접 만든 자료형:

```c
// 구조체 (Structure)
struct Student {
    char name[50];
    int age;
    float gpa;
};

// 공용체 (Union)
union Data {
    int i;
    float f;
    char str[20];
};

// 열거형 (Enumeration)
enum Weekday {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
};
```

---

## 추상 자료형(ADT)이란?

### 정의

**추상 자료형 = "무엇을"만 정의, "어떻게"는 숨김**

- **Abstract (추상적)**: 구체적인 구현을 숨김
- **Data Type (자료형)**: 데이터 + 연산

:::tip 핵심 개념
사용자는 **"기능(연산)"만 알면** 되고, **"내부 구조(구현)"은 몰라도** 됩니다!
:::

---

## 실생활 비유: TV

### TV는 완벽한 추상 자료형입니다!

```
┌─────────────────────┐
│                     │
│      TV 화면        │  ← 결과만 보임
│                     │
├─────────────────────┤
│ [전원] [채널] [음량] │  ← 인터페이스 (버튼)
└─────────────────────┘
         ↓
    내부 회로 🔒       ← 구현 숨김 (몰라도 됨)
```

**사용자 입장**:
- ✅ 전원 버튼 → TV 켜짐
- ✅ 채널 버튼 → 채널 변경
- ✅ 음량 버튼 → 소리 조절
- ❌ 내부 전자회로 → 몰라도 됨!

**ADT도 똑같습니다**:
- ✅ **연산(버튼)**: 사용자가 알아야 함
- ❌ **구현(회로)**: 숨겨져 있음

---

## ADT의 구조

```
┌──────────────────────────────┐
│    응용 프로그램              │
│    (사용자)                   │
└──────────┬───────────────────┘
           │
           ↓
┌──────────────────────────────┐
│    인터페이스 (연산)          │  ← 공개 (사용자가 볼 수 있음)
│    - 생성()                  │
│    - 삽입()                  │
│    - 삭제()                  │
│    - 검색()                  │
└──────────┬───────────────────┘
           │ 🔒 정보 은닉
           ↓
┌──────────────────────────────┐
│    구현 (내부 데이터)         │  ← 비공개 (숨겨짐)
│    - 배열로 구현?            │
│    - 연결 리스트로 구현?     │
│    - 내부 알고리즘           │
└──────────────────────────────┘
```

---

## ADT 예시: 자연수

### ADT 정의

```
ADT NaturalNumber

객체 (Objects):
    0부터 INT_MAX까지의 정수

연산 (Operations):
    - isZero(n): n이 0인지 확인
    - successor(n): n의 다음 수 반환
    - equal(n, m): n과 m이 같은지 확인
    - add(n, m): n + m 반환
    - subtract(n, m): n - m 반환
```

**포인트**:
- ✅ **무엇을 하는지** 정의됨 (isZero, add 등)
- ❌ **어떻게 하는지** 정의 안 됨 (내부 구현 숨김)

---

### 사용 예시

```c
// 사용자는 이렇게 사용합니다
NaturalNumber a = 5;
NaturalNumber b = 3;

if (isZero(a)) {
    printf("a는 0입니다\n");
}

NaturalNumber sum = add(a, b);  // 8
NaturalNumber next = successor(a);  // 6
```

**사용자는 몰라도 됩니다**:
- add()가 내부적으로 어떻게 더하는지
- 데이터가 메모리에 어떻게 저장되는지
- 오버플로우를 어떻게 처리하는지

---

## ADT의 핵심 원리

### 1. 추상화 (Abstraction)

**중요한 정보만 강조**, 구현 세부사항은 숨김

```
사용자가 알아야 할 것:
✅ push(item) → 스택에 추가
✅ pop() → 스택에서 제거

사용자가 몰라도 될 것:
❌ 배열로 구현했는지
❌ 연결 리스트로 구현했는지
❌ 메모리 할당 방식
```

---

### 2. 정보 은닉 (Information Hiding)

**내부 데이터를 직접 접근 못하게** 막음

```c
// ❌ 나쁜 예: 데이터 직접 접근
stack.data[0] = 100;  // 내부 구조 노출

// ✅ 좋은 예: 연산으로만 접근
push(&stack, 100);    // 인터페이스 사용
```

---

### 3. 캡슐화 (Encapsulation)

**데이터 + 연산을 하나로 묶음**

```c
typedef struct {
    int data[100];    // 데이터 (숨김)
    int top;          // 데이터 (숨김)
} Stack;

// 연산 (공개)
void push(Stack* s, int item);
int pop(Stack* s);
int isEmpty(Stack* s);
```

---

## ADT와 일반 자료형 비교

| 구분 | 일반 자료형 (int) | 추상 자료형 (Stack) |
|------|------------------|-------------------|
| **데이터** | 정수 | 스택 내부 배열 (숨김) |
| **연산** | +, -, *, / | push(), pop() |
| **구현** | 하드웨어 수준 | 프로그래머가 구현 |
| **접근** | 직접 접근 가능 | 연산으로만 접근 |

---

## 실전 예제: 스택 ADT

### ADT 정의

```
ADT Stack

객체 (Objects):
    0개 이상의 원소를 가진 순서 있는 리스트

연산 (Operations):
    - create(): 빈 스택 생성
    - push(item): 스택에 원소 추가
    - pop(): 스택에서 원소 제거 및 반환
    - peek(): 맨 위 원소 확인 (제거 안 함)
    - isEmpty(): 스택이 비었는지 확인
    - isFull(): 스택이 가득 찼는지 확인
```

---

### 구현 1: 배열 기반

```c
#define MAX_SIZE 100

typedef struct {
    int data[MAX_SIZE];
    int top;
} Stack;

void create(Stack* s) {
    s->top = -1;
}

void push(Stack* s, int item) {
    if (s->top >= MAX_SIZE - 1) {
        printf("스택이 가득 참!\n");
        return;
    }
    s->data[++(s->top)] = item;
}

int pop(Stack* s) {
    if (s->top < 0) {
        printf("스택이 비어있음!\n");
        return -1;
    }
    return s->data[(s->top)--];
}

int isEmpty(Stack* s) {
    return s->top < 0;
}
```

---

### 구현 2: 연결 리스트 기반

```c
typedef struct Node {
    int data;
    struct Node* next;
} Node;

typedef struct {
    Node* top;
} Stack;

void create(Stack* s) {
    s->top = NULL;
}

void push(Stack* s, int item) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = item;
    newNode->next = s->top;
    s->top = newNode;
}

int pop(Stack* s) {
    if (s->top == NULL) {
        printf("스택이 비어있음!\n");
        return -1;
    }
    Node* temp = s->top;
    int data = temp->data;
    s->top = s->top->next;
    free(temp);
    return data;
}

int isEmpty(Stack* s) {
    return s->top == NULL;
}
```

---

### 사용자 코드 (동일!)

```c
int main() {
    Stack s;
    create(&s);
    
    // 배열 구현이든 연결 리스트 구현이든
    // 사용 방법은 똑같습니다!
    push(&s, 10);
    push(&s, 20);
    push(&s, 30);
    
    printf("%d\n", pop(&s));  // 30
    printf("%d\n", pop(&s));  // 20
    
    return 0;
}
```

**핵심**: 
- 구현을 **배열 → 연결 리스트**로 바꿔도
- 사용자 코드는 **전혀 수정 안 해도 됨**!

:::tip ADT의 장점
구현을 바꿔도 사용자 코드는 그대로! 이게 바로 ADT의 힘입니다.
:::

---

## ADT의 장점

### 1. 모듈화 (Modularity)

각 부분을 독립적으로 개발 가능

```
개발자 A: 스택 구현
개발자 B: 스택 사용 (응용 프로그램)

→ 동시에 작업 가능!
```

---

### 2. 유지보수성 (Maintainability)

구현 변경이 쉬움

```c
// 배열이 느리면 → 연결 리스트로 교체
// 사용자 코드는 수정 불필요!
```

---

### 3. 재사용성 (Reusability)

한 번 만든 ADT를 여러 곳에서 사용

```c
Stack s1;  // 정수 스택
Stack s2;  // 또 다른 정수 스택
// 같은 ADT를 재사용
```

---

### 4. 추상화 수준 향상

**복잡한 내부를 신경 안 써도 됨**

```c
// 사용자는 이것만 알면 됨
push(&stack, 100);
pop(&stack);

// 내부 구현은 몰라도 됨
// - 메모리 할당
// - 포인터 조작
// - 경계 검사
```

---

## ADT 설계 원칙

### 1. 완전성 (Completeness)

필요한 모든 연산 제공

```c
// ✅ 좋은 예
create(), push(), pop(), peek(), isEmpty(), isFull()

// ❌ 나쁜 예
push(), pop()  // peek, isEmpty 없음
```

---

### 2. 단순성 (Simplicity)

연산은 간단하고 명확하게

```c
// ✅ 좋은 예
int pop(Stack* s);

// ❌ 나쁜 예
int popAndPrintAndCheckIfEmptyAndReturnSize(Stack* s);
```

---

### 3. 일관성 (Consistency)

비슷한 연산은 비슷한 이름

```c
// ✅ 좋은 예
push() / pop()
enqueue() / dequeue()

// ❌ 나쁜 예
push() / remove()
add() / pop()
```

---

## 실전 연습: 큐 ADT 설계

### 문제

다음 조건을 만족하는 큐(Queue) ADT를 설계하세요:
- 선입선출(FIFO) 구조
- 원소 추가/삭제 가능
- 큐의 상태 확인 가능

<details>
<summary>정답 보기</summary>

```
ADT Queue

객체 (Objects):
    0개 이상의 원소를 가진 선입선출 리스트

연산 (Operations):
    - create(): 빈 큐 생성
    - enqueue(item): 큐의 뒤에 원소 추가
    - dequeue(): 큐의 앞에서 원소 제거 및 반환
    - peek(): 맨 앞 원소 확인 (제거 안 함)
    - isEmpty(): 큐가 비었는지 확인
    - isFull(): 큐가 가득 찼는지 확인
    - size(): 큐의 원소 개수 반환
```

**포인트**:
- 어떻게 구현할지는 정의 안 함
- 무엇을 할 수 있는지만 명시
- 사용자는 이 연산만 알면 됨

</details>

---

## ADT vs 자료구조

| 구분 | ADT (추상 자료형) | 자료구조 (Data Structure) |
|------|------------------|-------------------------|
| **정의** | 논리적 명세 | 구체적 구현 |
| **초점** | 무엇을 하는가 | 어떻게 하는가 |
| **예시** | 스택 ADT | 배열 스택, 연결 리스트 스택 |
| **수준** | 추상적 | 구체적 |

**관계**:
```
ADT (스택)
    ↓ 구현
자료구조 (배열 스택 or 연결 리스트 스택)
```

:::info 정리
- **ADT**: "스택은 push/pop을 할 수 있다"
- **자료구조**: "배열로 구현한 스택은 이렇게 동작한다"
:::

---

## 마무리

### 핵심 정리

1. **추상 자료형(ADT)**:
   - "무엇을"만 정의
   - "어떻게"는 숨김
   - TV 리모컨처럼 버튼만 알면 됨

2. **ADT의 구성**:
   - **객체**: 데이터 (숨김)
   - **연산**: 기능 (공개)

3. **ADT의 장점**:
   - 모듈화, 유지보수성, 재사용성
   - 구현 변경이 쉬움
   - 복잡도 숨김

4. **ADT vs 자료구조**:
   - ADT: 논리적 명세 (What)
   - 자료구조: 구체적 구현 (How)

---

### 실무에서

**좋은 프로그래머는**:
- ADT를 잘 설계하고
- 인터페이스를 명확히 하며
- 구현 세부사항을 숨깁니다

**나쁜 프로그래머는**:
- 모든 걸 공개하고
- 내부 구조를 노출하며
- 변경할 때마다 모든 코드 수정

:::tip 명심하세요
"추상화는 복잡함을 관리하는 가장 강력한 도구입니다!" 🚀
:::

---