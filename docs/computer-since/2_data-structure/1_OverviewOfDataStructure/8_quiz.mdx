---
title: 학습 퀴즈
description: 자료구조의 개요부터 빅오 표기법까지 배운 내용을 확인하는 퀴즈입니다.
slug: data-structure-quiz
sidebar_position: 8
---

# 1단원 학습 총정리 퀴즈 📝

1단원에서 배운 내용을 **퀴즈로 점검**해봅시다!

:::tip 퀴즈 활용법
- 각 문제를 풀어보세요
- `정답 보기`를 클릭하면 해설이 나옵니다
- 70% 이상 맞으면 다음 단원으로 GO! 🚀
:::
<img src={require('../img/data-structure-quiz.png').default} 
     alt="데이터 구조 퀴즈" 
     style={{ maxWidth: '500px', width: '100%', display: 'block', margin: '0 auto' }} />
---

## 📚 Part 1: 자료구조와 알고리즘 기초

### 문제 1. 프로그램의 구성 요소

다음 중 프로그램을 구성하는 두 가지 핵심 요소는?

**A)** 변수와 함수  
**B)** 자료구조와 알고리즘  
**C)** 입력과 출력  
**D)** 하드웨어와 소프트웨어

<details>
<summary>정답 보기</summary>

**정답: B) 자료구조와 알고리즘**

**해설**:
```
프로그램 = 자료구조 + 알고리즘
```

- **자료구조**: 데이터를 어떻게 저장할 것인가
- **알고리즘**: 데이터를 어떻게 처리할 것인가

**예시**:
```c
int scores[5] = {90, 85, 95, 80, 88};  // 자료구조: 배열
int max = find_max(scores, 5);         // 알고리즘: 최댓값 찾기
```

</details>

---

### 문제 2. 일상 속 자료구조 매칭

다음 일상생활 상황과 가장 적합한 자료구조를 연결하세요:

1. 그릇 쌓기
2. 마트 줄서기
3. 컴퓨터 폴더 구조
4. 지도/네비게이션

**A)** 큐 (Queue)  
**B)** 그래프 (Graph)  
**C)** 스택 (Stack)  
**D)** 트리 (Tree)

<details>
<summary>정답 보기</summary>

**정답**:
1. 그릇 쌓기 → **C) 스택** (마지막에 올린 것 먼저 꺼냄, LIFO)
2. 마트 줄서기 → **A) 큐** (먼저 온 사람 먼저 나감, FIFO)
3. 컴퓨터 폴더 구조 → **D) 트리** (상위-하위 계층 구조)
4. 지도/네비게이션 → **B) 그래프** (지점과 경로의 연결)

**해설**:
자료구조는 일상생활의 문제를 해결하기 위해 만들어졌습니다!

</details>

---

### 문제 3. 알고리즘의 조건

다음 중 올바른 알고리즘이 가져야 할 조건이 **아닌** 것은?

**A)** 명확성 (모호하지 않아야 함)  
**B)** 유한성 (반드시 종료되어야 함)  
**C)** 최적성 (항상 가장 빠른 방법이어야 함)  
**D)** 유효성 (실행 가능해야 함)

<details>
<summary>정답 보기</summary>

**정답: C) 최적성**

**해설**:

**알고리즘의 필수 조건**:
1. **명확성**: 명령어가 모호하지 않아야 함
2. **유한성**: 한정된 시간 내에 반드시 종료
3. **유효성**: 각 명령어가 실행 가능해야 함

**최적성은 필수가 아닙니다**:
- 동작하는 알고리즘이면 OK
- 나중에 최적화는 별도의 과제

</details>

---

## 📊 Part 2: 알고리즘 표현 방법

### 문제 4. 알고리즘 표현 방법

다음 중 설계 단계에서 가장 권장되는 알고리즘 표현 방법은?

**A)** 자연어  
**B)** 흐름도  
**C)** 의사코드 (Pseudocode)  
**D)** C 언어

<details>
<summary>정답 보기</summary>

**정답: C) 의사코드**

**해설**:

| 방법 | 장점 | 단점 |
|------|------|------|
| 자연어 | 읽기 쉬움 | 모호할 수 있음 |
| 흐름도 | 시각적 | 복잡하면 폭발 |
| **의사코드** ⭐ | 핵심만 표현 | 표준 없음 |
| 프로그래밍 언어 | 정확함 | 잡음 많음 |

**의사코드 예시**:
```
algorithm find_max(list, n)
    largest ← list[0]
    for i ← 1 to n-1
        if list[i] > largest
            largest ← list[i]
    return largest
```

**장점**: 핵심 로직만 깔끔하게!

</details>

---

## 🎯 Part 3: 추상 자료형 (ADT)

### 문제 5. ADT의 핵심 개념

추상 자료형(ADT)에 대한 설명으로 **옳지 않은** 것은?

**A)** "무엇을(What)" 할 수 있는지만 정의한다  
**B)** "어떻게(How)" 구현되는지는 숨긴다  
**C)** 내부 데이터를 직접 접근할 수 있다  
**D)** 정보 은닉(Information Hiding)을 지원한다

<details>
<summary>정답 보기</summary>

**정답: C) 내부 데이터를 직접 접근할 수 있다**

**해설**:

**ADT의 핵심**:
```
사용자
  ↓
인터페이스 (공개) ← What (무엇을)
  ↓ 🔒
구현 (숨김) ← How (어떻게)
```

**올바른 사용**:
```c
// ❌ 나쁜 예: 직접 접근
stack.data[0] = 100;

// ✅ 좋은 예: 인터페이스 사용
push(&stack, 100);
```

**ADT의 장점**:
- 모듈화, 유지보수성, 재사용성
- 구현 변경 쉬움

</details>

---

### 문제 6. TV 비유

TV를 ADT로 비유할 때, 다음 중 "인터페이스"에 해당하는 것은?

**A)** 내부 회로  
**B)** 전원/채널/음량 버튼  
**C)** 화면  
**D)** 전자 부품

<details>
<summary>정답 보기</summary>

**정답: B) 전원/채널/음량 버튼**

**해설**:

```
┌─────────────────┐
│   TV 화면       │  ← 결과
├─────────────────┤
│ [전원][채널][음량]│  ← 인터페이스 (정답!)
└─────────────────┘
    내부 회로 🔒   ← 구현 (숨김)
```

**ADT와 매칭**:
- **버튼** = 연산 (push, pop 등)
- **내부 회로** = 구현 (배열, 연결 리스트 등)
- **사용자는 버튼만 알면 됨**!

</details>

---

## ⏱️ Part 4: 알고리즘 성능 분석

### 문제 7. 시간 복잡도와 공간 복잡도

다음 코드의 시간 복잡도와 공간 복잡도를 구하세요:

```c
int sum_array(int arr[], int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += arr[i];
    }
    return sum;
}
```

**A)** 시간: O(1), 공간: O(1)  
**B)** 시간: O(n), 공간: O(1)  
**C)** 시간: O(n), 공간: O(n)  
**D)** 시간: O(n²), 공간: O(1)

<details>
<summary>정답 보기</summary>

**정답: B) 시간: O(n), 공간: O(1)**

**해설**:

**시간 복잡도 분석**:
```c
int sum = 0;           // 1회
for (int i = 0; i < n; i++) {  // n번 반복
    sum += arr[i];     // n번 실행
}
return sum;            // 1회
```
→ **O(n)** (반복문 n번)

**공간 복잡도 분석**:
- `sum`: 정수 변수 1개
- `i`: 정수 변수 1개
- **총**: 변수 2개 → **O(1)** (상수)

**핵심**:
- 시간: 반복 횟수에 비례
- 공간: 변수/배열 개수에 비례

</details>

---

### 문제 8. 입력 크기에 따른 성능

n=100일 때, 다음 중 가장 빠른 알고리즘은?

**A)** O(n²) → 10,000번  
**B)** O(2ⁿ) → 1.27×10³⁰번  
**C)** O(n log n) → 664번  
**D)** O(n) → 100번

<details>
<summary>정답 보기</summary>

**정답: D) O(n) → 100번**

**해설**:

**성능 비교 (n=100)**:

| 복잡도 | 연산 횟수 | 평가 |
|--------|----------|------|
| O(1) | 1 | ⭐⭐⭐ 최고 |
| O(log n) | 7 | ⭐⭐⭐ 매우 좋음 |
| **O(n)** | **100** | ⭐⭐ 좋음 (정답!) |
| O(n log n) | 664 | ⭐⭐ 괜찮음 |
| O(n²) | 10,000 | ⭐ 느림 |
| O(2ⁿ) | 1.27×10³⁰ | 💀 불가능 |

**핵심**:
- n이 커지면 최고차항이 성능을 지배
- O(2ⁿ), O(n!)는 현실적으로 불가능

</details>

---

## 🔢 Part 5: 빅오 표기법

### 문제 9. 빅오 계산

다음 중 빅오 표기법으로 올바르게 표현한 것은?

```
T(n) = 5n² + 3n + 10
```

**A)** O(5n²)  
**B)** O(n² + n)  
**C)** O(n²)  
**D)** O(n)

<details>
<summary>정답 보기</summary>

**정답: C) O(n²)**

**해설**:

**빅오 계산 규칙**:
1. **최고차항만 남김**: 5n² ← 이것만!
2. **계수 제거**: 5n² → n²
3. **하위항 제거**: +3n +10 버림

**단계별 계산**:
```
T(n) = 5n² + 3n + 10
     ≈ 5n²  (하위항 제거)
     = O(n²) (계수 제거)
```

**왜?**
- n이 커지면 5n²가 99% 차지
- 3n, 10은 무시 가능한 수준

</details>

---

### 문제 10. 빅오 순서

다음 복잡도를 빠른 순서대로 나열하세요:

① O(2ⁿ)  
② O(n)  
③ O(log n)  
④ O(n²)  
⑤ O(1)

**A)** ⑤ → ③ → ② → ④ → ①  
**B)** ① → ④ → ② → ③ → ⑤  
**C)** ② → ③ → ⑤ → ④ → ①  
**D)** ⑤ → ② → ③ → ④ → ①

<details>
<summary>정답 보기</summary>

**정답: A) ⑤ → ③ → ② → ④ → ①**

**해설**:

**복잡도 순서 (빠름 → 느림)**:
```
O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ) < O(n!)
  ⑤       ③        ②                    ④       ①
```

**성능 비교 (n=10)**:

| 복잡도 | 연산 횟수 | 등급 |
|--------|----------|------|
| O(1) | 1 | 🥇 |
| O(log n) | 3 | 🥈 |
| O(n) | 10 | 🥉 |
| O(n²) | 100 | ⭐ |
| O(2ⁿ) | 1,024 | 💀 |

</details>

---

### 문제 11. 코드 복잡도 분석

다음 코드의 시간 복잡도는?

```javascript
function example(n) {
    for (let i = 0; i < n; i++) {
        console.log(i);
    }
    
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            console.log(i, j);
        }
    }
}
```

**A)** O(n)  
**B)** O(n²)  
**C)** O(2n²)  
**D)** O(n³)

<details>
<summary>정답 보기</summary>

**정답: B) O(n²)**

**해설**:

**단계별 분석**:

```javascript
// 첫 번째 반복문
for (let i = 0; i < n; i++) {    // n번
    console.log(i);              // n번
}
// → O(n)

// 두 번째 중첩 반복문
for (let i = 0; i < n; i++) {    // n번
    for (let j = 0; j < n; j++) { // n번
        console.log(i, j);        // n×n번
    }
}
// → O(n²)
```

**총합**:
```
O(n) + O(n²)
```

**빅오 규칙**: 큰 것만 남김
```
O(n) + O(n²) = O(n²)
```

</details>

---

## 📉 Part 6: 성능 케이스 분석

### 문제 12. 최선/평균/최악

다음 선형 탐색 코드에서, 배열 [5, 9, 10, 17, 20]에서 **17**을 찾을 때의 케이스는?

```c
int search(int arr[], int n, int key) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == key) return i;
    }
    return -1;
}
```

**A)** 최선의 경우  
**B)** 평균의 경우  
**C)** 최악의 경우  
**D)** 불가능한 경우

<details>
<summary>정답 보기</summary>

**정답: B) 평균의 경우**

**해설**:

**배열**: [5, 9, 10, 17, 20]

**17 찾기 과정**:
```
i=0: arr[0]=5 ≠ 17 ✗
i=1: arr[1]=9 ≠ 17 ✗
i=2: arr[2]=10 ≠ 17 ✗
i=3: arr[3]=17 == 17 ✓
```

**케이스별 분석**:

| 케이스 | 상황 | 위치 | 비교 횟수 |
|--------|------|------|----------|
| 최선 | 첫 번째 (5) | 0 | 1 |
| **평균** | **중간 (17)** | **3** | **4** ← 정답! |
| 최악 | 마지막 (20) | 4 | 5 |

</details>

---

### 문제 13. 왜 최악의 경우?

실무에서 최악의 경우(Worst Case)를 기준으로 하는 이유로 **가장 적절한** 것은?

**A)** 계산이 쉬워서  
**B)** 안전을 보장하기 위해  
**C)** 최선의 경우는 존재하지 않아서  
**D)** 평균은 정확하지 않아서

<details>
<summary>정답 보기</summary>

**정답: B) 안전을 보장하기 위해**

**해설**:

**비행기 관제 시스템 예시**:

```c
int detect_collision(Plane planes[], int n) {
    for (int i = 0; i < n; i++) {
        for (int j = i+1; j < n; j++) {
            if (too_close(planes[i], planes[j])) {
                return 1;  // 충돌 위험!
            }
        }
    }
    return 0;
}
```

**최선 기준 (사기)**:
- "보통은 빠르니까 괜찮아요" ❌
- 최악 상황 → 💥 충돌

**최악 기준 (안전)**:
- "최악에도 1초 안에 끝나요" ✅
- 안전 보장 → ✈️ OK

**왜 최악이 중요한가?**:
1. **안전 보장** (생명과 직결)
2. **계산 쉬움** (명확한 기준)
3. **응용 가능** (실무 표준)

:::danger 핵심
최선의 경우를 말하는 건 사기입니다!
:::

</details>

---

## 🎓 Part 7: 종합 문제

### 문제 14. 복잡도 비교

다음 중 같은 복잡도를 가진 것은?

**A)** O(2n) 과 O(n²)  
**B)** O(n + 100) 과 O(n)  
**C)** O(log n) 과 O(n log n)  
**D)** O(n²) 과 O(2ⁿ)

<details>
<summary>정답 보기</summary>

**정답: B) O(n + 100) 과 O(n)**

**해설**:

**빅오 규칙 적용**:

**A) O(2n) vs O(n²)**:
```
O(2n) = O(n)  (상수 2 제거)
O(n) ≠ O(n²)  (차수가 다름) ✗
```

**B) O(n + 100) vs O(n)**:
```
O(n + 100) = O(n)  (상수 100 제거)
O(n) = O(n)  (같음!) ✓
```

**C) O(log n) vs O(n log n)**:
```
O(log n) ≠ O(n log n)  (n배 차이) ✗
```

**D) O(n²) vs O(2ⁿ)**:
```
O(n²) ≠ O(2ⁿ)  (차수가 다름) ✗
```

**핵심**: 상수는 버리고, 차수만 봅니다!

</details>

---

### 문제 15. 알고리즘 개선

다음 두 알고리즘 중 더 효율적인 것은?

**알고리즘 A (이중 반복문)**:
```javascript
for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
        // 작업
    }
}
```

**알고리즘 B (단일 반복문)**:
```javascript
for (let i = 0; i < n; i++) {
    // 작업 (2배)
}
```

**A)** 알고리즘 A  
**B)** 알고리즘 B  
**C)** 둘 다 같음  
**D)** 입력에 따라 다름

<details>
<summary>정답 보기</summary>

**정답: B) 알고리즘 B**

**해설**:

**복잡도 비교**:

**알고리즘 A**:
```
for (i) for (j) → n × n = n²
T(n) = O(n²)
```

**알고리즘 B**:
```
for (i) → n번 (작업이 2배여도 상수)
T(n) = O(2n) = O(n)
```

**성능 차이 (n=100)**:

| 알고리즘 | 복잡도 | 연산 횟수 |
|---------|--------|----------|
| A | O(n²) | 10,000 |
| B | O(n) | 100 (2배=200) |

**결론**:
- B가 **50~100배** 빠름!
- n이 커질수록 차이 폭발

</details>

---

## 📊 점수 확인하기

### 채점표

| 맞힌 개수 | 등급 | 평가 |
|----------|------|------|
| 14~15개 | 🥇 완벽 | 다음 단원 GO! |
| 11~13개 | 🥈 우수 | 조금만 더! |
| 8~10개 | 🥉 양호 | 복습 필요 |
| 8개 미만 | 📚 재학습 | 문서 다시 읽기 |

---

## 🔄 복습이 필요한 주제

틀린 문제가 많았던 파트를 중점적으로 복습하세요:

### Part 1-2: 기초 개념
- 자료구조와 알고리즘 관계
- 일상 속 자료구조
- 알고리즘 표현 방법

👉 [자료구조 소개 문서](../1_OverviewOfDataStructure/1_IntroductionToDataStructure)
---

### Part 3: ADT
- 추상 자료형 개념
- 정보 은닉
- 인터페이스 vs 구현

👉 [추상 자료형 문서](../1_OverviewOfDataStructure/6_AbstractDataType)

---

### Part 4: 성능 분석
- 시간/공간 복잡도
- 연산 횟수 계산

👉 [알고리즘 성능 분석 문서](../1_OverviewOfDataStructure/3_AlgorithmPerformanceAnalysis)

---

### Part 5: 빅오 표기법
- 빅오 정의와 계산
- 복잡도 순서
- 코드 분석

👉 [빅오 표기법 문서](../1_OverviewOfDataStructure/4_Big-ONotation)

---

### Part 6: 케이스 분석
- 최선/평균/최악
- 실무 기준

👉 [성능 케이스 분석 문서](../1_OverviewOfDataStructure/5_AlgorithmPerformanceCase)

---

## ✅ 자가 진단 체크리스트

다음 질문에 모두 "예"라고 답할 수 있나요?

- [ ] 프로그램 = 자료구조 + 알고리즘을 설명할 수 있다
- [ ] 일상생활 예시로 자료구조를 설명할 수 있다
- [ ] 의사코드를 읽고 쓸 수 있다
- [ ] ADT의 개념과 장점을 이해했다
- [ ] 시간/공간 복잡도를 구분할 수 있다
- [ ] 코드를 보고 빅오를 계산할 수 있다
- [ ] 빅오 계산 규칙 5개를 안다
- [ ] 최선/평균/최악을 구분할 수 있다
- [ ] 왜 최악의 경우가 중요한지 안다
- [ ] 복잡도 순서를 외웠다

**모두 체크했나요?** 🎉 축하합니다! 

---

## 🌟 마무리

**퀴즈를 완료하신 여러분, 수고하셨습니다!** 🎉

:::tip 학습 격려
- 틀린 것은 부끄러운 게 아닙니다
- 지금 배우는 과정입니다
- 꾸준히 하면 반드시 늡니다! 💪
:::

**다음 퀴즈에서 만나요!** 🚀

---