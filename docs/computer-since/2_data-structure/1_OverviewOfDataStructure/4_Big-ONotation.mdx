---
title: 빅오 표기법
description: 알고리즘의 시간 복잡도를 표현하는 가장 중요한 방법을 배웁니다.
slug: big-o-notation
sidebar_position: 4
---

# 빅오 표기법 (Big-O Notation)

빅오 표기법은 알고리즘의 성능을 표현하는 **가장 중요한 도구**입니다.

**핵심 한 문장**:
> 입력 크기 `n`이 커질 때, 알고리즘이 **최악의 경우** 얼마나 느려지는지를 나타내는 **상한(upper bound)** 표기법

<img src={require('../img/big-o-notation.png').default} 
     alt="빅오표기법" 
     style={{ maxWidth: '500px', width: '100%', display: 'block', margin: '0 auto' }} />
---

## 왜 빅오 표기법이 필요한가?

### 문제 상황

두 알고리즘이 있습니다:
- 알고리즘 A: `T(n) = 2n + 1`
- 알고리즘 B: `T(n) = n² + 5`

**질문**: 어느 알고리즘이 더 빠를까요?

### n이 작을 때 (n=5)

- 알고리즘 A: 2(5) + 1 = **11회**
- 알고리즘 B: 5² + 5 = **30회**

→ A가 빠름!

### n이 클 때 (n=1000)

- 알고리즘 A: 2(1000) + 1 = **2,001회**
- 알고리즘 B: 1000² + 5 = **1,000,005회**

→ A가 **압도적으로** 빠름!

:::tip 핵심 인사이트
n이 커질수록 **최고차항**이 성능을 지배합니다!
:::

---

## 빅오 표기법이란?

### 쉬운 비유: 속도 제한 표지판

도로에서 "최고 속도 100km/h" 표지판을 본 적 있나요?

- 실제로는 80km/h로 갈 수도, 100km/h로 갈 수도 있습니다
- 하지만 **"100km/h를 넘지는 않는다"**는 **상한**을 보장합니다

빅오도 똑같습니다:
- 알고리즘이 실제로는 더 빠를 수도 있습니다
- 하지만 **"이 속도보다 느려지지는 않는다"**는 **최악의 상한**을 표현합니다

---

## 수학적 정의 (초보자용 해석)

### 원문

함수 `f(n)`과 `g(n)`에 대해,  
상수 `c > 0`와 `n₀`가 존재하여  
모든 `n ≥ n₀`에 대해

```
f(n) ≤ c · g(n)
```

이면 **f(n) = O(g(n))** 이라고 합니다.

---

### 한국어로 풀어쓰기

이 수식이 말하는 것:

1. **n₀ (엔 제로)**: "n이 이 정도 이상 커지면"
2. **c (씨)**: "상수 배수까지는 괜찮아"
3. **f(n) ≤ c·g(n)**: "f는 g의 상수배를 넘지 않아"

**결론**: 
> n이 충분히 커지면(n ≥ n₀), f(n)은 g(n)에 어떤 상수를 곱한 것보다 크지 않다

그래서 **g(n)이 f(n)의 상한(upper bound)** 역할을 합니다!

---

## 왜 "상수 c"를 붙이나?

### 예시로 이해하기

```
f(n) = 2n + 1
g(n) = n
```

**질문**: f(n)이 g(n)보다 크잖아요? 그런데 같은 O(n)이라고요?

**답변**: 네! 왜냐하면...

```
n이 충분히 크면:
f(n) = 2n + 1
     ≤ 2n + n    (n≥1일 때, 1≤n)
     = 3n
     = 3·g(n)
```

c=3, n₀=1일 때 조건을 만족합니다!

### 핵심 원리

빅오는 **"2배 빠르냐/느리냐" 같은 상수 차이는 무시**하고,  
**"증가율(차수)"만 봅니다**.

- `2n`, `5n`, `100n` → 모두 **O(n)**
- `n²`, `3n²`, `n²+100` → 모두 **O(n²)**

:::warning 중요
상수는 무시하고 성장률(차수)만 봅니다!
:::

---

## 왜 "최고차항만 남기나"?

### 예시: T(n) = 3n² + 10n + 5

n이 커질수록:

| n | 3n² | 10n | 5 | 비율 |
|---|-----|-----|---|------|
| 10 | 300 | 100 | 5 | 3n²가 74% |
| 100 | 30,000 | 1,000 | 5 | 3n²가 97% |
| 1,000 | 3,000,000 | 10,000 | 5 | 3n²가 99.7% |

**결론**: n이 커지면 **최고차항(3n²)이 거의 100%를 차지**합니다!

그래서:
```
T(n) = 3n² + 10n + 5
     ≈ 3n²  (하위 항 무시)
     = O(n²)  (상수 계수 무시)
```

:::tip 빅오의 핵심
**최고차항**만 남기고, **상수 계수**는 버립니다!
:::

---

## 대표적인 시간 복잡도

### 복잡도 순서 (빠름 → 느림)

```
O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ) < O(n!)
```

### 복잡도 비교표

| 표기 | 이름 | 의미 | n=10 | n=100 | 대표 예시 |
|------|------|------|------|-------|----------|
| **O(1)** | 상수 | 항상 똑같음 | 1 | 1 | 배열 인덱스 접근 |
| **O(log n)** | 로그 | 절반씩 줄임 | 3 | 7 | 이진 탐색 |
| **O(n)** | 선형 | 1번씩 다 봄 | 10 | 100 | 선형 탐색 |
| **O(n log n)** | 선형로그 | n번 작업 × log n | 30 | 664 | 병합 정렬 |
| **O(n²)** | 이차 | 이중 반복문 | 100 | 10,000 | 버블 정렬 |
| **O(2ⁿ)** | 지수 | 2배씩 폭증 | 1,024 | 1.27×10³⁰ | 재귀 피보나치 |
| **O(n!)** | 팩토리얼 | 경우의 수 폭발 | 3,628,800 | - | 모든 순열 |

:::warning 위험
O(2ⁿ), O(n!)는 입력이 조금만 커져도 **현실적으로 계산 불가능**합니다!
:::

---

## 성능 비교 그래프

```
연산 횟수
    ↑
    │
10⁶ │                                            ╱ O(2ⁿ)
    │                                        ╱╱╱
    │                                    ╱╱╱
10⁴ │                              ╱╱╱╱
    │                          ╱╱╱╱ O(n²)
    │                      ╱╱╱╱
10² │              ╱╱╱╱╱╱ O(n log n)
    │        ╱╱╱╱╱╱ O(n)
    │  ╱╱╱╱╱ O(log n)
  1 │─────────────────── O(1)
    └────────────────────────────→ 입력 크기 (n)
```

**해석**:
- **O(1)**: 수평선 - 항상 일정 ⭐⭐⭐
- **O(log n)**: 완만한 증가 ⭐⭐⭐
- **O(n)**: 직선 증가 ⭐⭐
- **O(n²)**: 급격한 증가 ⭐
- **O(2ⁿ)**: 폭발적 증가 💀

---

## 코드 예제: 각 복잡도별 실습

### 1. O(1) - 상수 시간

**전체 코드**:

```c
#include <stdio.h>

int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    
    int x = arr[2];  // O(1)
    
    printf("%d\n", x);
    return 0;
}
```

**한 줄씩 설명**:

```c
#include <stdio.h>
```
- 표준 입출력 라이브러리 포함 (`printf` 사용)

```c
int main() {
```
- 프로그램 시작점

```c
int arr[5] = {10, 20, 30, 40, 50};
```
- 길이 5인 정수 배열 생성

```c
int x = arr[2];
```
- **핵심**: 배열의 인덱스 2번(3번째 값)에 **바로 접근**
- 배열은 메모리에서 연속된 공간에 저장되므로
- 시작 주소 + (인덱스 × 자료형 크기)로 **즉시 계산 가능**
- **입력 크기 n과 무관하게 항상 1번 연산** → **O(1)**

```c
printf("%d\n", x);
```
- 값 출력 (30)

```c
return 0;
```
- 정상 종료

**시간 복잡도**: **O(1)** - 상수 시간

---

### 2. O(n) - 선형 시간

**전체 코드**:

```c
#include <stdio.h>

int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    int n = 5;
    
    int sum = 0;
    
    for (int i = 0; i < n; i++) {
        sum += arr[i];
    }
    
    printf("%d\n", sum);
    return 0;
}
```

**한 줄씩 설명**:

```c
int arr[5] = {10, 20, 30, 40, 50};
int n = 5;
```
- 배열과 크기 선언

```c
int sum = 0;
```
- 합을 저장할 변수 초기화

```c
for (int i = 0; i < n; i++) {
```
- **핵심**: i가 0부터 n-1까지 **총 n번 반복**
- n=5이면 5번, n=100이면 100번
- 입력 크기에 **비례**합니다

```c
sum += arr[i];
```
- 각 반복마다 1번 실행
- 총 n번 실행됩니다

```c
printf("%d\n", sum);
```
- 결과 출력 (150)

**시간 복잡도**: **O(n)** - 선형 시간

**왜 O(n)인가?**
- 반복문이 n번 실행됩니다
- n이 2배가 되면 → 시간도 2배가 됩니다
- n이 10배가 되면 → 시간도 10배가 됩니다

---

### 3. O(n²) - 이차 시간

**전체 코드**:

```c
#include <stdio.h>

int main() {
    int n = 3;
    
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            printf("(%d, %d) ", i, j);
        }
        printf("\n");
    }
    
    return 0;
}
```

**한 줄씩 설명**:

```c
int n = 3;
```
- 반복 횟수 설정

```c
for (int i = 0; i < n; i++) {
```
- **외부 반복문**: i가 0부터 n-1까지 **n번 반복**

```c
for (int j = 0; j < n; j++) {
```
- **내부 반복문**: j가 0부터 n-1까지 **n번 반복**
- **핵심**: i가 한 번 고정될 때마다 j가 n번 돕니다
- i가 총 n번이므로 → **n × n = n²번 실행**

```c
printf("(%d, %d) ", i, j);
```
- 총 n² 번 실행됩니다
- n=3이면 9번, n=10이면 100번, n=100이면 10,000번!

**출력 결과**:
```
(0, 0) (0, 1) (0, 2) 
(1, 0) (1, 1) (1, 2) 
(2, 0) (2, 1) (2, 2)
```

**시간 복잡도**: **O(n²)** - 이차 시간

**왜 O(n²)인가?**
- 중첩 반복문: 외부 n번 × 내부 n번 = n²번
- n이 2배가 되면 → 시간은 4배가 됩니다
- n이 10배가 되면 → 시간은 100배가 됩니다

---

### 4. O(log n) - 로그 시간

**이진 탐색**(Binary Search)은 "한 번 비교할 때마다 탐색 범위를 절반으로" 줄입니다.

**전체 코드**:

```c
#include <stdio.h>

int binary_search(int arr[], int n, int key) {
    int low = 0;
    int high = n - 1;
    
    while (low <= high) {
        int mid = (low + high) / 2;
        
        if (arr[mid] == key) {
            return mid;  // 찾음
        } else if (arr[mid] < key) {
            low = mid + 1;   // 오른쪽 절반만 탐색
        } else {
            high = mid - 1;  // 왼쪽 절반만 탐색
        }
    }
    
    return -1; // 못 찾음
}

int main() {
    int arr[] = {10, 20, 30, 40, 50, 60, 70};
    int n = 7;
    int key = 50;
    
    int idx = binary_search(arr, n, key);
    
    if (idx != -1) {
        printf("인덱스 %d에서 발견\n", idx);
    } else {
        printf("찾을 수 없음\n");
    }
    
    return 0;
}
```

**한 줄씩 설명**:

```c
int binary_search(int arr[], int n, int key) {
```
- 이진 탐색 함수
- `arr`: 정렬된 배열
- `n`: 배열 크기
- `key`: 찾을 값

```c
int low = 0;
int high = n - 1;
```
- 탐색 구간의 양 끝 인덱스
- **예시**: arr = [10, 20, 30, 40, 50, 60, 70]
- low = 0 (첫 번째), high = 6 (마지막)

```c
while (low <= high) {
```
- 탐색 구간이 남아있는 동안 반복
- low > high가 되면 더 이상 찾을 곳이 없음

```c
int mid = (low + high) / 2;
```
- **가운데 인덱스** 계산
- **예시**: (0 + 6) / 2 = 3

```c
if (arr[mid] == key) {
    return mid;
```
- 가운데 값이 찾는 값이면 끝!
- **예시**: arr[3] = 40 ≠ 50이므로 계속

```c
} else if (arr[mid] < key) {
    low = mid + 1;
```
- 가운데 값이 더 작으면 → **오른쪽 절반만 탐색**
- **예시**: 40 < 50이므로 low = 4
- 이제 탐색 범위: [50, 60, 70]

```c
} else {
    high = mid - 1;
```
- 가운데 값이 더 크면 → **왼쪽 절반만 탐색**

**핵심**: 한 번 비교할 때마다 **절반을 버림**!

**실행 과정 (key=50 찾기)**:

```
1회: [10, 20, 30, 40, 50, 60, 70] → mid=3 (40)
     40 < 50 → 오른쪽으로
     
2회: [50, 60, 70] → mid=4 (50)
     50 == 50 → 찾음!
```

**시간 복잡도**: **O(log n)** - 로그 시간

**왜 O(log n)인가?**
- 매번 절반씩 줄어듭니다
- n=8 → 3번, n=16 → 4번, n=1024 → 10번
- n이 2배가 되면 → 연산은 1번만 증가합니다!

---

## 빅오 계산 실전 규칙

### 규칙 1: for문 1개 → O(n)

```javascript
for (let i = 0; i < n; i++) {
    console.log(i);
}
```
→ **O(n)**

### 규칙 2: for문 2중 → O(n²)

```javascript
for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
        console.log(i, j);
    }
}
```
→ **O(n²)**

### 규칙 3: 반씩 줄어듦 → O(log n)

```javascript
while (n > 1) {
    n = n / 2;
}
```
→ **O(log n)**

### 규칙 4: 연속 실행이면 큰 것만 남김

```javascript
for (let i = 0; i < n; i++) {     // O(n)
    console.log(i);
}

for (let i = 0; i < n; i++) {     // O(n²)
    for (let j = 0; j < n; j++) {
        console.log(i, j);
    }
}
```

- O(n) + O(n²) = **O(n²)** (큰 것만 남김)

### 규칙 5: 계수/상수는 버림

```javascript
for (let i = 0; i < n; i++) {
    console.log(i);
    console.log(i);
    console.log(i);
}
```

- 실제로는 3n번이지만
- **O(3n) = O(n)** (계수 3은 버림)

---

## 빅오 치트키 5개

:::tip 빅오 계산 꿀팁

1. **for문 1개** → O(n)
2. **for문 2중** → O(n²)
3. **반씩 줄어듦** → O(log n)
4. **연속 실행** → 큰 것만: O(n) + O(n²) = O(n²)
5. **계수/상수** 버림: O(5n) = O(n), O(n+100) = O(n)

:::

---

## 실전 예제: 복잡도 구하기

### 예제 1
```javascript
function example1(n) {
    let sum = 0;
    for (let i = 0; i < n; i++) {
        sum += i;
    }
    return sum;
}
```

**답**: **O(n)** - 반복문 1개

---

### 예제 2
```javascript
function example2(n) {
    let sum = 0;
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            sum += i * j;
        }
    }
    return sum;
}
```

**답**: **O(n²)** - 중첩 반복문

---

### 예제 3
```javascript
function example3(arr) {
    return arr[0] + arr[arr.length - 1];
}
```

**답**: **O(1)** - 인덱스 접근 2번 (상수)

---

### 예제 4
```javascript
function example4(n) {
    for (let i = 0; i < n; i++) {
        console.log(i);
    }
    
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            console.log(i, j);
        }
    }
}
```

**답**: O(n) + O(n²) = **O(n²)** - 큰 것만 남김

---

## 복잡도별 성능 비교

### n=1,000일 때

| 복잡도 | 연산 횟수 | 시간(가정) | 평가 |
|--------|----------|----------|------|
| O(1) | 1 | 0.001ms | ⭐⭐⭐ 최고 |
| O(log n) | 10 | 0.01ms | ⭐⭐⭐ 매우 좋음 |
| O(n) | 1,000 | 1ms | ⭐⭐ 좋음 |
| O(n log n) | 10,000 | 10ms | ⭐⭐ 괜찮음 |
| O(n²) | 1,000,000 | 1초 | ⭐ 느림 |
| O(2ⁿ) | 10³⁰⁰ | 우주 나이 초과 | 💀 불가능 |

:::warning 실무에서
- O(n²) 이하: 대부분 괜찮음
- O(2ⁿ), O(n!): 입력이 조금만 커지면 실행 불가능
:::

---

## 마무리

### 빅오 표기법 핵심 정리

1. **상한(Upper Bound)**: "최악의 경우에도 이것보다 느려지진 않는다"
2. **점근적(Asymptotic)**: "n이 충분히 클 때의 성장률"
3. **최고차항**: 가장 빠르게 증가하는 항만 남김
4. **상수 무시**: 2n, 5n, 100n → 모두 O(n)

### 복잡도 순서 (외우세요!)

```
O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ) < O(n!)
좋음 ←──────────────────────────────────────────────→ 나쁨
```

### 실무 꿀팁

- **O(1), O(log n), O(n)**: 거의 항상 괜찮음 ⭐
- **O(n log n)**: 정렬 알고리즘의 표준 ⭐
- **O(n²)**: 조심해서 사용 (n이 크면 느림)
- **O(2ⁿ), O(n!)**: 가능하면 피하기 💀

---