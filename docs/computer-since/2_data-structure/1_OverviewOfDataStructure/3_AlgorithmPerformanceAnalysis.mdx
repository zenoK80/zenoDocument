---
title: 알고리즘 성능 분석
description: 알고리즘의 효율성을 측정하고 분석하는 방법을 배웁니다.
slug: algorithm-performance-analysis
sidebar_position: 3
---
# 알고리즘 성능 분석 (Algorithm Performance Analysis)

프로그램의 효율성을 평가하기 위해서는 알고리즘의 성능을 정확하게 측정하고 분석할 수 있어야 합니다.

알고리즘 성능을 분석하는 방법에는 크게 두 가지가 있습니다:
1. **수행 시간 측정** (실제 실행 시간 측정)
2. **복잡도 분석** (연산 횟수 계산)

<img src={require('../img/algorithm-performance-analysis.png').default} 
     alt="알고리즘 성능 분석" 
     style={{ maxWidth: '500px', width: '100%', display: 'block', margin: '0 auto' }} />

---

## 왜 성능 분석이 중요한가?

### 입력 크기에 따른 성능 차이

같은 문제를 해결하는 두 알고리즘이 있다고 가정해봅시다:
- 알고리즘 A: 연산 횟수가 `n²`에 비례
- 알고리즘 B: 연산 횟수가 `2ⁿ`에 비례

| 입력 크기 (n) | n² | 2ⁿ |
|--------------|-----|-----|
| 6 | 36초 | 64초 |
| 100 | 10,000초 (약 3시간) | 4 × 10²² 년 |

:::warning 핵심 포인트
n이 **작을 때**는 차이가 별로 없어 보입니다. 하지만 n이 **클 때**는 엄청난 차이가 발생합니다!
:::

### 실무에서의 중요성

- 사용자 경험: 빠른 응답 속도
- 비용 절감: 서버 자원 효율적 사용
- 확장성: 데이터가 증가해도 안정적 동작

---

## 방법 1: 수행 시간 측정

실제로 프로그램을 실행해서 걸리는 시간을 측정하는 방법입니다.

### 특징

**장점**:
- 직관적이고 이해하기 쉬움
- 실제 실행 환경에서의 성능 파악 가능

**단점**:
- 하드웨어에 따라 결과가 달라짐
- A 컴퓨터와 B 컴퓨터의 클럭 주파수가 다르면 시간도 다름
- 실제로 구현해야 측정 가능
- 범용적이지 않음

---

### C언어에서 시간 측정하기

#### 방법 1: clock() 함수 사용

**전체 코드**:

```c
#include <stdio.h>
#include <time.h>

int main() {
    clock_t start, stop;
    double duration;
    
    // 시작 시간 기록
    start = clock();
    
    // 측정할 코드 (예: 반복문)
    for (int i = 0; i < 1000000; i++) {
        // 의미 없는 연산
    }
    
    // 종료 시간 기록
    stop = clock();
    
    // 실행 시간 계산
    duration = (double)(stop - start) / CLOCKS_PER_SEC;
    
    printf("실행 시간: %.6f초\n", duration);
    
    return 0;
}
```

**코드 한 줄씩 설명**:

```c
#include <stdio.h>
```
- 표준 입출력 라이브러리를 포함합니다
- `printf()` 함수를 사용하기 위해 필요합니다

```c
#include <time.h>
```
- 시간 관련 함수를 사용하기 위한 라이브러리입니다
- `clock()` 함수와 `CLOCKS_PER_SEC` 상수를 사용하기 위해 필요합니다

```c
int main() {
```
- 프로그램의 시작점입니다
- 모든 C 프로그램은 main 함수에서 시작합니다

```c
clock_t start, stop;
```
- 시작 시간과 종료 시간을 저장할 변수를 선언합니다
- `clock_t`는 클럭 수를 저장하는 데이터 타입입니다

```c
double duration;
```
- 실행 시간(초 단위)을 저장할 변수입니다
- 소수점 계산을 위해 `double` 타입을 사용합니다

```c
start = clock();
```
- 프로그램 시작부터 지금까지의 클럭 수를 `start`에 저장합니다
- 이 순간부터 시간 측정이 시작됩니다

```c
for (int i = 0; i < 1000000; i++) {
    // 의미 없는 연산
}
```
- 시간을 측정하고 싶은 코드 부분입니다
- 여기서는 예시로 100만 번 반복하는 빈 반복문을 사용했습니다
- 실제로는 이 자리에 측정하고 싶은 알고리즘 코드를 넣으면 됩니다

```c
stop = clock();
```
- 코드 실행이 끝난 시점의 클럭 수를 `stop`에 저장합니다
- 이 순간 시간 측정이 종료됩니다

```c
duration = (double)(stop - start) / CLOCKS_PER_SEC;
```
- 실행 시간을 초 단위로 계산합니다
- `stop - start`: 시작부터 종료까지 경과한 클럭 수
- `CLOCKS_PER_SEC`: 1초당 클럭 개수 (예: 1,000,000)
- `(double)`: 정수 나눗셈이 아닌 실수 나눗셈을 하기 위한 타입 변환
- **계산 예시**: 만약 경과 클럭이 500,000이고 `CLOCKS_PER_SEC`가 1,000,000이면 → 500,000 / 1,000,000 = 0.5초

```c
printf("실행 시간: %.6f초\n", duration);
```
- 계산된 실행 시간을 화면에 출력합니다
- `%.6f`: 소수점 6자리까지 표시합니다

```c
return 0;
```
- 프로그램을 정상 종료합니다
- `0`은 정상 종료를 의미합니다

:::info 클럭(Clock)이란?
CPU가 작동하는 기본 단위 시간입니다. 예를 들어 3GHz CPU는 1초에 30억 번의 클럭이 발생합니다.

**쉬운 비유**: 
- 시계의 초침이 1초에 한 번 움직이는 것처럼
- CPU의 클럭은 1초에 수억~수십억 번 "똑딱" 합니다
- `clock()` 함수는 이 "똑딱"을 세어줍니다
:::

---

#### 방법 2: time() 함수 사용

**전체 코드**:

```c
#include <stdio.h>
#include <time.h>

int main() {
    time_t start, stop;
    double duration;
    
    // 시작 시간 기록
    time(&start);
    
    // 측정할 코드
    for (int i = 0; i < 1000000; i++) {
        // 연산
    }
    
    // 종료 시간 기록
    time(&stop);
    
    // 실행 시간 계산
    duration = difftime(stop, start);
    
    printf("실행 시간: %.2f초\n", duration);
    
    return 0;
}
```

**코드 한 줄씩 설명**:

```c
#include <stdio.h>
#include <time.h>
```
- `stdio.h`: 출력을 위한 `printf()` 사용
- `time.h`: `time()`과 `difftime()` 함수 사용

```c
time_t start, stop;
```
- 시작 시간과 종료 시간을 저장할 변수입니다
- `time_t`는 시간을 저장하는 데이터 타입입니다 (초 단위)

```c
double duration;
```
- 실행 시간(초 단위)을 저장할 변수입니다

```c
time(&start);
```
- 현재 시각을 초 단위로 `start`에 저장합니다
- `&start`: start 변수의 메모리 주소를 전달합니다 (포인터)
- **참고**: 1970년 1월 1일 00:00:00부터 지금까지의 초를 반환합니다

```c
for (int i = 0; i < 1000000; i++) {
    // 연산
}
```
- 시간을 측정하고 싶은 코드를 이 자리에 넣습니다

```c
time(&stop);
```
- 코드 실행 후의 시각을 `stop`에 저장합니다

```c
duration = difftime(stop, start);
```
- 두 시간의 차이를 초 단위로 계산합니다
- `difftime(종료시간, 시작시간)`: 종료 - 시작 = 경과 시간
- **예시**: stop이 100, start가 95이면 → 100 - 95 = 5초

```c
printf("실행 시간: %.2f초\n", duration);
```
- 실행 시간을 소수점 2자리까지 출력합니다

```c
return 0;
```
- 프로그램 정상 종료

**차이점 정리**:

| 함수 | 측정 단위 | 정밀도 | 용도 |
|------|----------|--------|------|
| `clock()` | 클럭 수 | 높음 (밀리초 단위) | 짧은 시간 측정 |
| `time()` | 초 | 낮음 (1초 단위) | 긴 시간 측정 |

:::tip 어떤 걸 써야 할까?
- **짧은 코드** (1초 이내): `clock()` 사용 ⭐
- **긴 코드** (여러 초 이상): `time()` 사용
:::

---

### JavaScript에서 시간 측정하기

**전체 코드**:

```javascript
// 시작 시간 기록
const start = performance.now();

// 측정할 코드
for (let i = 0; i < 1000000; i++) {
    // 연산
}

// 종료 시간 기록
const end = performance.now();

// 실행 시간 계산 (밀리초)
const duration = end - start;
console.log(`실행 시간: ${duration.toFixed(2)}ms`);
```

**코드 한 줄씩 설명**:

```javascript
const start = performance.now();
```
- 현재 시각을 밀리초(ms) 단위로 저장합니다
- `performance.now()`: 페이지 로드 시점부터의 경과 시간을 반환
- `const`: 변하지 않는 상수 변수 선언
- **예시**: 3250.5 (페이지 로드 후 3.2505초가 지남)

```javascript
for (let i = 0; i < 1000000; i++) {
    // 연산
}
```
- 시간을 측정하고 싶은 코드를 이 자리에 넣습니다
- 여기서는 예시로 100만 번 반복합니다

```javascript
const end = performance.now();
```
- 코드 실행 후의 시각을 밀리초 단위로 저장합니다
- **예시**: 3258.7

```javascript
const duration = end - start;
```
- 시작 시간과 종료 시간의 차이를 계산합니다
- **계산 예시**: 3258.7 - 3250.5 = 8.2ms (밀리초)

```javascript
console.log(`실행 시간: ${duration.toFixed(2)}ms`);
```
- 실행 시간을 콘솔에 출력합니다
- `toFixed(2)`: 소수점 2자리까지만 표시
- 백틱(`` ` ``)과 `${}`: 변수를 문자열에 넣는 템플릿 리터럴
- **출력 예시**: `실행 시간: 8.20ms`

:::info 밀리초(ms)란?
- 1초 = 1,000밀리초(ms)
- 0.001초 = 1밀리초
- JavaScript는 밀리초 단위로 시간을 측정합니다
:::

**브라우저 콘솔에서 실행하기**:

1. 웹 브라우저를 엽니다 (Chrome, Firefox 등)
2. `F12` 키를 눌러 개발자 도구를 엽니다
3. `Console` 탭을 클릭합니다
4. 위 코드를 복사해서 붙여넣고 `Enter`를 누릅니다
5. 실행 시간이 출력됩니다!

---

## 방법 2: 복잡도 분석 ⭐

**연산의 횟수**를 계산하여 알고리즘의 성능을 분석하는 방법입니다.

하드웨어에 독립적이며, 일반화된 성능 평가가 가능합니다.

### 시간 복잡도 (Time Complexity)

알고리즘이 수행하는 **연산의 횟수**를 입력 크기 `n`의 함수로 표현합니다.

#### 계산 방법

연산의 종류:
- **대입 연산**: `=`
- **비교 연산**: `>`, `<`, `==`
- **산술 연산**: `+`, `-`, `*`, `/`

**예시 코드: 배열에서 최댓값 찾기**

```c
int find_max(int score[], int n) {
    int largest = score[0];  // 대입 연산 1회
    
    for (int i = 1; i < n; i++) {  // i 대입 1회, 비교 (n-1)회, 증가 (n-1)회
        if (score[i] > largest) {  // 비교 연산 (n-1)회
            largest = score[i];    // 대입 연산 (최악의 경우 n-1회)
        }
    }
    
    return largest;
}
```

**코드 한 줄씩 연산 횟수 분석**:

```c
int find_max(int score[], int n) {
```
- 함수 선언: 연산 없음
- `score[]`: 정수 배열
- `n`: 배열의 크기

```c
int largest = score[0];  // 대입 연산 1회
```
- **연산**: 대입 1회
- 배열의 첫 번째 값을 `largest`에 저장합니다
- **예시**: score = [85, 92, 78]이면 → largest = 85

```c
for (int i = 1; i < n; i++) {
```
- `int i = 1`: **대입 1회** (i 초기화)
- `i < n`: **비교 (n-1)회** (반복할 때마다 비교)
- `i++`: **증가 (n-1)회** (반복할 때마다 1 증가)
- **예시**: n=5이면 i는 1,2,3,4로 4번 반복 → 비교 4회, 증가 4회

```c
if (score[i] > largest) {
```
- **연산**: 비교 (n-1)회
- 현재 값이 지금까지의 최댓값보다 큰지 비교합니다
- **예시**: score[1]=92 > largest=85? → True

```c
largest = score[i];
```
- **연산**: 대입 (최악의 경우 n-1회)
- 더 큰 값을 발견하면 `largest`를 업데이트합니다
- **최악의 경우**: 배열이 오름차순으로 정렬되어 있을 때 (매번 업데이트)
- **최선의 경우**: 배열이 내림차순으로 정렬되어 있을 때 (업데이트 0회)

```c
return largest;
```
- **연산**: 반환 (연산 횟수에 포함 안 함)

**연산 횟수 총정리**:

| 연산 종류 | 횟수 | 설명 |
|----------|------|------|
| 대입 | 1회 | `largest = score[0]` |
| 대입 | 1회 | `i = 1` |
| 비교 | (n-1)회 | `i < n` 반복 체크 |
| 증가 | (n-1)회 | `i++` 증가 |
| 비교 | (n-1)회 | `score[i] > largest` |
| 대입 | 최악 (n-1)회 | `largest = score[i]` |

**총 연산 횟수**: `1 + 1 + (n-1) + (n-1) + (n-1) + (n-1) = 4n - 2 ≈ 4n`

**구체적인 예시 (n=5)**:
- 초기 대입: 2회
- 반복문 비교: 4회
- 반복문 증가: 4회
- if 비교: 4회
- 최악의 경우 대입: 4회
- **총합**: 2 + 4 + 4 + 4 + 4 = 18회

시간 복잡도를 **입력 크기 n의 함수**로 표현할 수 있습니다!

---

### 공간 복잡도 (Space Complexity)

알고리즘이 사용하는 **메모리 공간**을 측정합니다.

```c
// 예시 1: O(1) 공간 복잡도
int sum = a + b;  // 변수 1개만 사용

// 예시 2: O(n) 공간 복잡도
int arr[n];  // 크기 n인 배열 사용
```

**메모리 계산**:
- `int` (32비트 시스템): 4바이트
- `double`: 8바이트
- 배열 `int[n]`: 4n 바이트

---

## 복잡도 비교 예시

### 알고리즘 1: `T(n) = 3n + 2`

```c
// 의사코드
algorithm1(n) {
    int result = 0;     // 대입 1회
    int temp = 1;       // 대입 1회
    
    for i = 1 to n {    // 대입 1회, 비교 n회, 증가 n회
        result += i;    // 덧셈 n회, 대입 n회
    }
    
    return result;
}
```

**연산 횟수**:
- 대입: 1 + 1 + 1 + n = n + 3
- 비교: n
- 증가: n
- 덧셈: n
- **총합**: 3n + 2

**n = 6일 때**: 3(6) + 2 = **20회**

---

### 알고리즘 2: `T(n) = 5n² + 6`

```c
// 의사코드
algorithm2(n) {
    for i = 1 to n {          // 외부 반복
        for j = 1 to n {      // 내부 반복
            operation();      // 어떤 연산
        }
    }
}
```

**연산 횟수**:
- 중첩 반복문: n × n = n²
- 각 반복마다 여러 연산 발생
- **총합**: 5n² + 6

**n = 6일 때**: 5(36) + 6 = **186회**

---

## 복잡도 함수 비교

| 입력 크기 (n) | 3n + 2 | 5n² + 6 | 2ⁿ |
|--------------|--------|---------|-----|
| 10 | 32 | 506 | 1,024 |
| 100 | 302 | 50,006 | 1.27 × 10³⁰ |
| 1,000 | 3,002 | 5,000,006 | - |

:::tip 성능 차이
입력 크기가 커질수록 함수의 **최고 차항**이 성능을 결정합니다!
:::

---

## 알고리즘 비교 예시: m × n 계산

세 가지 다른 방법으로 양의 정수 m을 n번 더하는 알고리즘을 구현해봅시다.

### 알고리즘 A: 곱셈 사용

```c
result = m * n;
```

**연산 횟수**:
- 대입 연산: 1회
- 곱셈 연산: 1회
- **총 연산**: 2회 (상수)

**시간 복잡도**: O(1)

---

### 알고리즘 B: n번 더하기

```c
result = 0;
for (int i = 0; i < n; i++) {
    result += m;
}
```

**연산 횟수**:
- 대입 연산: n회
- 덧셈 연산: n회
- **총 연산**: 2n회

**시간 복잡도**: O(n)

---

### 알고리즘 C: 1씩 m×n번 더하기

```c
result = 0;
for (int i = 0; i < m; i++) {
    for (int j = 0; j < n; j++) {
        result += 1;
    }
}
```

**연산 횟수**:
- 대입 연산: m×n회
- 덧셈 연산: m×n회
- **총 연산**: 2mn회

**시간 복잡도**: O(mn) ≈ O(n²)

---

### 알고리즘 성능 비교

| 알고리즘 | 연산 횟수 | 시간 복잡도 | 평가 |
|---------|----------|------------|------|
| A (곱셈) | 2 | O(1) | ⭐⭐⭐ 최고 |
| B (n번 덧셈) | 2n | O(n) | ⭐⭐ 보통 |
| C (mn번 덧셈) | 2mn | O(n²) | ⭐ 나쁨 |

:::info 정설과 사설
**정설**: 알고리즘 A가 가장 효율적입니다.

**사설**: 곱셈 연산의 구현 비용이 덧셈보다 훨씬 높다면, 실제로는 알고리즘 B나 C가 더 나을 수도 있습니다. 하지만 일반적으로는 알고리즘 A가 가장 좋습니다.
:::

---

## 입력 크기에 따른 성능 변화

```
연산 횟수
    ↑
    │                                    ╱ n²
    │                                 ╱
    │                              ╱
    │                           ╱
    │                        ╱
    │                    ╱╱╱
    │              ╱╱╱╱
    │        ╱╱╱╱          n
    │  ╱╱╱╱ _______________
    │_____________________  상수(1)
    └─────────────────────────────→ 입력 크기 (n)
```

**해석**:
- **상수(1)**: 입력 크기와 무관하게 일정 - 가장 좋음 ⭐⭐⭐
- **선형(n)**: 입력 크기에 비례 - 일반적 ⭐⭐
- **이차(n²)**: 입력 크기의 제곱에 비례 - 나쁨 ⭐

:::warning 중요
입력이 작을 때는 차이가 없어 보이지만, 입력이 조금만 커져도 엄청난 차이가 발생합니다!
:::

---

## 실습: 연산 횟수 계산하기

### 문제: 배열의 합 구하기

```javascript
function arraySum(arr) {
    let sum = 0;           // 1. 대입 연산
    
    for (let i = 0; i < arr.length; i++) {  // 2. 반복문
        sum += arr[i];     // 3. 덧셈 및 대입
    }
    
    return sum;
}
```

**연산 횟수 분석**:
1. 초기 대입: 1회
2. 반복문:
   - 초기화 (`i = 0`): 1회
   - 비교 (`i < arr.length`): (n+1)회
   - 증가 (`i++`): n회
3. 배열 접근 및 덧셈: n회
4. 대입: n회

**총 연산 횟수**: `1 + 1 + (n+1) + n + n + n = 4n + 3`

**시간 복잡도**: `T(n) = 4n + 3`

---

### 문제: 중첩 반복문

```javascript
function printPairs(n) {
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            console.log(i, j);  // n² 번 실행
        }
    }
}
```

**연산 횟수**:
- 외부 반복문: n번 실행
- 내부 반복문: 각각 n번 실행
- 총 출력: n × n = n²번

**시간 복잡도**: `T(n) = n²`

---

## 시간 복잡도 vs 공간 복잡도

| 복잡도 종류 | 측정 대상 | 예시 |
|------------|----------|------|
| **시간 복잡도** | 연산 횟수 | 대입, 비교, 산술 연산 |
| **공간 복잡도** | 메모리 사용량 | 변수, 배열, 객체 |

### 예시: 피보나치 수열

```javascript
// 방법 1: 재귀 (높은 시간 복잡도, 낮은 공간 복잡도)
function fib(n) {
    if (n <= 1) return n;
    return fib(n-1) + fib(n-2);
}
// 시간: O(2ⁿ), 공간: O(n)

// 방법 2: 반복 (낮은 시간 복잡도, 낮은 공간 복잡도)
function fib(n) {
    if (n <= 1) return n;
    let a = 0, b = 1;
    for (let i = 2; i <= n; i++) {
        let temp = a + b;
        a = b;
        b = temp;
    }
    return b;
}
// 시간: O(n), 공간: O(1)
```

---

## 측정 방법 비교

| 방법 | 장점 | 단점 | 사용 시기 |
|------|------|------|----------|
| **수행 시간 측정** | 직관적, 실제 성능 파악 | 하드웨어 의존적 | 실제 환경 테스트 |
| **복잡도 분석** | 범용적, 이론적 분석 | 추상적 | 알고리즘 설계 단계 |

---

## 마무리

알고리즘 성능 분석의 핵심:

1. **수행 시간 측정**: 실제 실행 시간 측정 (하드웨어 의존적)
2. **복잡도 분석**: 연산 횟수 계산 (일반화 가능) ⭐

복잡도 분석이 더 중요한 이유:
- 하드웨어에 독립적
- 입력 크기에 따른 성능 예측 가능
- 알고리즘 비교가 용이
- **최고 차항**이 성능을 결정

---