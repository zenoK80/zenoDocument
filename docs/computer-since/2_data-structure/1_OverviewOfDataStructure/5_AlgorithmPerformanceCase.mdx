---
title: 알고리즘 성능 케이스 분석
description: 최선, 평균, 최악의 경우를 이해하고 왜 최악의 경우가 중요한지 배웁니다.
slug: algorithm-performance-cases
sidebar_position: 5
---
# 알고리즘 성능 케이스 분석

같은 알고리즘이라도 **어떤 입력 데이터**가 들어오느냐에 따라 성능이 달라질 수 있습니다.

이 글에서는 알고리즘 성능을 분석하는 **세 가지 케이스**를 배웁니다:
1. **최선의 경우 (Best Case)**
2. **평균의 경우 (Average Case)**
3. **최악의 경우 (Worst Case)**
<img src={require('../img/algorithm-performance-cases.png').default} 
     alt="알고리즘 성능 케이스 분석" 
     style={{ maxWidth: '500px', width: '100%', display: 'block', margin: '0 auto' }} />
---

## 왜 케이스를 나누나?

### 실생활 비유: 출근 시간

집에서 회사까지 가는데 걸리는 시간은?

- **최선의 경우**: 신호등이 모두 초록불, 차가 없음 → 20분
- **평균의 경우**: 보통 상황 → 30분
- **최악의 경우**: 모든 신호 빨간불, 차 막힘 → 50분

**질문**: 회의가 10시에 있다면 몇 시에 출발해야 할까요?

**답**: 9시 10분! (최악의 경우 50분 기준)

알고리즘도 똑같습니다. **최악의 경우**를 기준으로 설계해야 안전합니다!

---

## 세 가지 케이스 정의

| 케이스 | 의미 | 표기법 | 사용 빈도 |
|--------|------|--------|----------|
| **최선 (Best)** | 가장 빠른 경우 | Ω (오메가) | ⭐ 거의 안 씀 |
| **평균 (Average)** | 평균적인 경우 | Θ (세타) | ⭐⭐ 가끔 씀 |
| **최악 (Worst)** | 가장 느린 경우 | O (빅오) | ⭐⭐⭐ 가장 많이 씀 |

:::warning 중요
실무에서는 거의 항상 **최악의 경우**(Big-O)만 사용합니다!
:::

---

## Big-Ω (빅 오메가) - 하한 (Lower Bound)

### 정의

"**아무리 운이 좋아도 최소 이 정도는 걸린다**"는 **하한**(lower bound)

수학적 정의:
```
f(n) ≥ c · g(n)  (n ≥ n₀일 때)
```

### 예시

```
f(n) = 2n + 1
```

**증명**:
- c = 1, n₀ = 1일 때
- 2n + 1 ≥ 1 · n (모든 n ≥ 1에 대해 성립)
- 따라서 **f(n) = Ω(n)**

**의미**: "아무리 빨라도 최소 n에 비례한다"

---

## Big-Θ (빅 세타) - 상한과 하한의 중간

### 정의

"**정확히 이 정도 걸린다**"는 **타이트한 범위(tight bound)**

수학적 정의:
```
c₁ · g(n) ≤ f(n) ≤ c₂ · g(n)  (n ≥ n₀일 때)
```

### 예시

```
f(n) = 2n + 1
```

**증명**:
- c₁ = 1, c₂ = 3, n₀ = 1일 때
- 1 · n ≤ 2n + 1 ≤ 3 · n (모든 n ≥ 1에 대해 성립)
- 따라서 **f(n) = Θ(n)**

**의미**: "정확히 n에 비례한다" (상한과 하한이 같음)

---

## Big-O (빅 오) - 상한 (Upper Bound) ⭐

### 정의

"**아무리 운이 나빠도 이것보다 느려지진 않는다**"는 **상한(upper bound)**

수학적 정의:
```
f(n) ≤ c · g(n)  (n ≥ n₀일 때)
```

### 예시

```
f(n) = 2n + 1
```

**증명**:
- c = 3, n₀ = 1일 때
- 2n + 1 ≤ 3 · n (모든 n ≥ 1에 대해 성립)
- 따라서 **f(n) = O(n)**

**의미**: "아무리 느려도 최대 n에 비례한다"

---

## 표기법 비교 그래프

```
연산 횟수
    ↑
    │
    │        ─────────── O(g(n)) = c₂·g(n)  [상한]
    │       ╱
    │      ╱  f(n)  [실제 성능]
    │     ╱
    │    ╱───────────── Θ(g(n))  [타이트]
    │   ╱
    │  ╱
    │ ╱
    │───────────────── Ω(g(n)) = c₁·g(n)  [하한]
    └─────────────────────────────→ 입력 크기 (n)
```

**해석**:
- **Ω**: "최소 이만큼은 걸려"
- **Θ**: "정확히 이 정도야"
- **O**: "최대 이것까지 걸릴 수 있어"

---

## 실전 예제: 선형 탐색 (Linear Search)

배열에서 특정 값을 찾는 알고리즘입니다.

### 전체 코드

```c
#include <stdio.h>

int linear_search(int arr[], int n, int key) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == key) {
            return i;  // 찾음!
        }
    }
    return -1;  // 못 찾음
}

int main() {
    int arr[] = {5, 9, 10, 17, 20};
    int n = 5;
    
    // 케이스 1: 최선 - 첫 번째에 있음
    int result1 = linear_search(arr, n, 5);
    printf("첫 번째 찾기: %d\n", result1);  // 0
    
    // 케이스 2: 최악 - 마지막에 있음
    int result2 = linear_search(arr, n, 20);
    printf("마지막 찾기: %d\n", result2);  // 4
    
    // 케이스 3: 평균 - 중간에 있음
    int result3 = linear_search(arr, n, 10);
    printf("중간 찾기: %d\n", result3);  // 2
    
    return 0;
}
```

---

### 코드 한 줄씩 분석

```c
int linear_search(int arr[], int n, int key) {
```
- 선형 탐색 함수
- `arr`: 탐색할 배열
- `n`: 배열 크기
- `key`: 찾을 값

```c
for (int i = 0; i < n; i++) {
```
- 배열을 **처음부터 끝까지** 하나씩 확인합니다
- 최악의 경우 n번 반복

```c
if (arr[i] == key) {
    return i;
```
- 찾는 값을 발견하면 **즉시 종료**하고 인덱스 반환
- 이 부분이 **케이스를 결정**합니다!

```c
return -1;
```
- 끝까지 찾지 못하면 -1 반환

---

### 케이스별 성능 분석

#### 배열: [5, 9, 10, 17, 20]

---

### 1. 최선의 경우 (Best Case)

**상황**: 찾는 값이 **첫 번째**에 있음

```c
linear_search(arr, 5, 5);  // key = 5
```

**실행 과정**:
```
i=0: arr[0]=5 == key=5 ✓ 찾음! 종료
```

**연산 횟수**: **1회**

**시간 복잡도**: **Ω(1)** - 상수 시간

:::tip 최선의 경우
첫 번째 비교에서 바로 찾는 경우입니다.
:::

---

### 2. 최악의 경우 (Worst Case)

**상황**: 찾는 값이 **마지막**에 있거나 **없음**

```c
linear_search(arr, 5, 20);  // key = 20 (마지막)
```

**실행 과정**:
```
i=0: arr[0]=5 != 20 ✗
i=1: arr[1]=9 != 20 ✗
i=2: arr[2]=10 != 20 ✗
i=3: arr[3]=17 != 20 ✗
i=4: arr[4]=20 == 20 ✓ 찾음!
```

**연산 횟수**: **5회** (n번)

**시간 복잡도**: **O(n)** - 선형 시간

:::warning 최악의 경우
끝까지 다 확인해야 하는 경우입니다. 실무에서는 이 경우를 기준으로 합니다!
:::

---

### 3. 평균의 경우 (Average Case)

**상황**: 찾는 값이 **중간쯤**에 있음 (평균적으로)

```c
linear_search(arr, 5, 10);  // key = 10 (중간)
```

**실행 과정**:
```
i=0: arr[0]=5 != 10 ✗
i=1: arr[1]=9 != 10 ✗
i=2: arr[2]=10 == 10 ✓ 찾음!
```

**연산 횟수**: **3회** (평균 n/2번)

**수학적 계산**:
```
평균 = (1 + 2 + 3 + ... + n) / n
     = (n(n+1)/2) / n
     = (n+1) / 2
     ≈ n/2
```

**시간 복잡도**: **Θ(n)** - 선형 시간

- 상수 1/2는 빅오에서 무시되므로 여전히 **O(n)**

:::info 평균의 경우
계산이 복잡하고 입력 데이터에 따라 달라져서 실무에서는 잘 안 씁니다.
:::

---

## 케이스별 비교 정리

### 선형 탐색 케이스 요약

| 케이스 | 상황 | 비교 횟수 | 시간 복잡도 | 표기법 |
|--------|------|----------|------------|--------|
| **최선** | 첫 번째에 있음 | 1 | O(1) | Ω(1) |
| **평균** | 중간쯤에 있음 | n/2 | O(n) | Θ(n) |
| **최악** | 마지막/없음 | n | O(n) | O(n) |

---

## 왜 최악의 경우가 중요한가?

### 1. 계산하기 쉽다

- **최선**: 운이 좋은 경우 (드묾)
- **평균**: 계산 복잡, 입력 데이터에 따라 변함
- **최악**: 명확하고 계산 쉬움 ⭐

---

### 2. 안전을 보장한다

**시나리오**: 비행기 관제 시스템

```c
// 충돌 위험 감지 알고리즘
int detect_collision(Plane planes[], int n) {
    // 최악의 경우: O(n²)
    for (int i = 0; i < n; i++) {
        for (int j = i+1; j < n; j++) {
            if (too_close(planes[i], planes[j])) {
                return 1;  // 위험!
            }
        }
    }
    return 0;
}
```

**만약 최선의 경우만 고려했다면?**
- "보통은 빠르니까 괜찮아요" ❌
- 최악의 상황에서 느려짐 → **비행기 충돌** 💥

**최악의 경우를 고려하면?**
- "최악의 경우에도 1초 안에 끝나요" ✅
- 안전 보장! ✈️

:::danger 왜 최악의 경우를 써야 하나?
**최선의 경우를 말하는 건 사기입니다!**

크리티컬한 시스템(의료, 금융, 항공)에서는 **최악의 경우가 생명**입니다.
:::

---

### 3. 실무 적용 사례

#### 시나리오 1: 웹 서버

```javascript
// 사용자 검색 기능
function searchUser(users, username) {
    for (let user of users) {
        if (user.name === username) {
            return user;
        }
    }
    return null;
}
```

- **최선**: 첫 번째 사용자 (거의 없음)
- **최악**: 마지막 또는 없음 (자주 발생)
- **SLA 약속**: "검색은 최대 1초 안에 완료됩니다"
  - 최악의 경우 기준으로 약속해야 함!

---

#### 시나리오 2: 게임 렌더링

```c
// 프레임 렌더링
void render_frame(GameObject objects[], int n) {
    for (int i = 0; i < n; i++) {
        draw(objects[i]);  // O(1)
    }
}
// 전체: O(n)
```

- 60FPS 유지 = 16ms 안에 렌더링 완료 필요
- **최악의 경우** 기준으로 최적화해야 끊김 없음

---

## 케이스별 그래프

```
수행 시간 (ms)
    ↑
 50 │                           ● 최악
    │                        ●
 40 │                     ●
    │                  ●
 30 │            ● ● ●  ← 평균
    │        ●
 20 │    ●
    │ ●
 10 │● ← 최선
    └──────────────────────────→ 입력 데이터
```

**해석**:
- 최선의 경우: 거의 발생 안 함 (의미 없음)
- 평균의 경우: 계산 어려움
- 최악의 경우: 설계 기준 ⭐

---

## 다른 알고리즘 케이스 비교

### 1. 삽입 정렬 (Insertion Sort)

| 케이스 | 상황 | 시간 복잡도 |
|--------|------|------------|
| 최선 | 이미 정렬됨 | O(n) |
| 평균 | 무작위 | O(n²) |
| 최악 | 역순 정렬됨 | O(n²) |

---

### 2. 퀵 정렬 (Quick Sort)

| 케이스 | 상황 | 시간 복잡도 |
|--------|------|------------|
| 최선 | 피벗이 중간값 | O(n log n) |
| 평균 | 보통 | O(n log n) |
| 최악 | 피벗이 최소/최대 | O(n²) |

:::tip 실무 팁
퀵 정렬은 평균적으로 빠르지만, 최악의 경우 O(n²)이므로  
중요한 시스템에서는 병합 정렬(O(n log n) 보장)을 씁니다.
:::

---

### 3. 이진 탐색 (Binary Search)

| 케이스 | 상황 | 시간 복잡도 |
|--------|------|------------|
| 최선 | 중간에 있음 | O(1) |
| 평균 | 보통 | O(log n) |
| 최악 | 끝까지 탐색 | O(log n) |

:::info 참고
이진 탐색은 최악의 경우에도 O(log n)으로 매우 효율적입니다!
:::

---

## 실전 연습 문제

### 문제 1: 배열 최댓값 찾기

```javascript
function findMax(arr) {
    let max = arr[0];
    for (let i = 1; i < arr.length; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    return max;
}
```

**질문**: 최선, 평균, 최악의 경우는?

<details>
<summary>정답 보기</summary>

- **최선**: O(n) - 첫 번째가 최댓값이어도 끝까지 확인 필요
- **평균**: O(n)
- **최악**: O(n) - 마지막이 최댓값

**결론**: 모든 경우 **O(n)** - 항상 배열 전체를 확인해야 함!

</details>

---

### 문제 2: 정렬된 배열 검색

```javascript
function searchSorted(arr, target) {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === target) return i;
        if (arr[i] > target) break;  // 더 이상 볼 필요 없음
    }
    return -1;
}
```

**질문**: 최선, 평균, 최악의 경우는?

<details>
<summary>정답 보기</summary>

- **최선**: O(1) - 첫 번째에 있음
- **평균**: O(n/2) ≈ O(n)
- **최악**: O(n) - 마지막 또는 없음

**개선**: 이진 탐색을 쓰면 최악의 경우도 **O(log n)**!

</details>

---

## 마무리

### 핵심 정리

1. **세 가지 케이스**:
   - 최선 (Best): Ω - 거의 안 씀
   - 평균 (Average): Θ - 가끔 씀
   - 최악 (Worst): O - 가장 많이 씀 ⭐

2. **왜 최악의 경우를 쓰나?**:
   - 계산하기 쉬움
   - 안전 보장
   - 명확한 성능 약속

3. **실무 원칙**:
   - 항상 최악의 경우 기준으로 설계
   - 최선의 경우는 사기!
   - 크리티컬한 시스템일수록 최악 기준 중요

---

### 복잡도 표기법 순서

```
Ω (오메가) ≤ Θ (세타) ≤ O (빅오)
하한         타이트      상한
(최선)       (평균)      (최악)
```

:::warning 실무 팁
- 면접/설계: **O (빅오)** 사용
- 논문/연구: Θ, Ω도 사용
- 99%의 경우: **O만 알아도 충분**
:::

---