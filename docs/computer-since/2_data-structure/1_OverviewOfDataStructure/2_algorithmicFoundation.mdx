---
title: 알고리즘의 기초
description: 알고리즘의 정의, 조건, 표현 방법을 이해합니다.
slug: algorithmic-foundation
sidebar_position: 2
---

# 알고리즘의 기초 (Algorithmic Foundation)

## 알고리즘이란?

**알고리즘**(Algorithm)은 컴퓨터로 문제를 풀기 위한 **단계적인 절차**입니다.

:::info 핵심 개념
- 알고리즘은 인간이 푸는 것이 아니라 **컴퓨터가 실행**하기 위한 절차
- 한 번에 해결되지 않고 **10단계, 20단계**를 거쳐서 문제를 해결
- 명확하고 실행 가능한 **단계별 명령어의 집합**
:::
<img src={require('../img/algorithmic-foundation.png').default} 
     alt="알고리즘이란?" 
     style={{ maxWidth: '500px', width: '100%', display: 'block', margin: '0 auto' }} />
---

## 알고리즘의 조건

좋은 알고리즘이 되기 위해서는 다음 조건들을 반드시 만족해야 합니다:

### 1. 입력 (Input)
- **0개 이상**의 입력이 존재해야 함
- 외부에서 제공되는 데이터

### 2. 출력 (Output)
- **1개 이상**의 출력이 존재해야 함
- 동작만 하는 경우 0개 이상도 가능

### 3. 명백성 (Definiteness) ⭐

**가장 중요한 조건**입니다!

- 각 명령어의 의미가 **모호하면 안 됨**
- 명령어가 모호하다 = 구현할 수 없다
- 누가 봐도 정확하게 이해할 수 있어야 함
```javascript
// ❌ 나쁜 예: 모호한 명령
"적당히 큰 값을 찾아라"

// ✅ 좋은 예: 명확한 명령
"배열에서 가장 큰 값을 찾아라"
```

### 4. 유한성 (Finiteness) ⭐

- **한정된 시간 내**에 반드시 종료되어야 함
- 현실적인 시간 내에 끝나야 함
- 무한 루프는 알고리즘이 아님
```javascript
// ❌ 나쁜 예: 무한 루프
while (true) {
  console.log("멈추지 않음");
}

// ✅ 좋은 예: 유한한 반복
for (let i = 0; i < n; i++) {
  console.log(i);
}
```

### 5. 유효성 (Effectiveness) ⭐

- 각 명령어가 **실행 가능**해야 함
- 현실적으로 수행할 수 있는 연산이어야 함

---

## 알고리즘 표현 방법

알고리즘을 기술하는 방법에는 크게 4가지가 있습니다:

### 1. 자연어 (Natural Language)

일상적인 언어로 알고리즘을 설명하는 방법입니다.

**장점**:
- 인간이 읽기 쉬움
- 이해하기 편함

**단점**:
- 명백성을 해칠 수 있음
- 의미 전달이 모호할 수 있음
- 복잡한 알고리즘은 표현하기 어려움

**예시: 배열에서 최댓값 찾기**
```
1. 배열 리스트의 첫 번째 요소를 변수 TMP에 복사하자
2. 배열 리스트의 다음 요소들을 차례대로 TMP와 비교하면서
   더 크면 TMP로 복사하자
3. 배열 리스트의 모든 요소를 비교했으면 TMP를 반환하자
```

:::warning 주의사항
간단한 알고리즘은 괜찮지만, 100줄, 200줄의 복잡한 알고리즘을 자연어로 표현하면 명백성이 떨어집니다!
:::

---

### 2. 흐름도 (Flowchart)

그림으로 알고리즘의 흐름을 표현하는 방법입니다.

**장점**:
- 시각적이고 직관적
- 흐름을 한눈에 파악 가능

**단점**:
- 그림의 한계가 있음
- 복잡한 알고리즘은 표현하기 어려움
- 100줄짜리 알고리즘을 그림으로 그리면 이해 불가능

**흐름도 기호**:
```
┌─────────┐
│  시작   │  ← 타원: 시작/종료
└─────────┘

┌─────────┐
│ 처리/연산│  ← 사각형: 처리 과정
└─────────┘

    ◇
   / \
  /   \     ← 마름모: 판단/조건
 /     \
└───────┘

  ↓ → ←     ← 화살표: 흐름 방향
```

**예시: 최댓값 찾기 흐름도**
```
     시작
      ↓
  largest = score[0]
      ↓
    i = 1
      ↓
  i < n? ─No→ largest 반환 → 종료
    ↓Yes
 score[i] > largest?
    ↓Yes        ↓No
largest = score[i]  (skip)
    ↓              ↓
   i++  ←──────────┘
    ↓
  (반복)
```

---

### 3. 의사코드 (Pseudocode) ⭐⭐⭐

**가장 많이 사용하는 방법**입니다!

알고리즘의 **핵심적인 내용만** 프로그래밍 언어처럼 표현하는 방법입니다.

**장점**:
- 군더더기 없이 핵심만 표현
- `#include`, `#define` 같은 자잘한 것 불필요
- 알고리즘의 로직에만 집중 가능
- 언어에 독립적

**단점**:
- 특정 표준 포맷이 없음
- 사람마다 작성 방식이 조금씩 다름

**예시: 최댓값 찾기**
```
findMax(list, n)
  largest ← list[0]
  for i ← 1 to n-1 do
    if list[i] > largest then
      largest ← list[i]
  return largest
```

:::tip 왜 의사코드를 많이 쓸까?
프로그래밍 언어는 `#include`, `main()`, 세미콜론 등 자잘한 문법이 많지만,  
의사코드는 **알고리즘의 핵심 로직**만 표현하므로 이해하기 쉽습니다!
:::

---

### 4. 프로그래밍 언어 (Programming Language)

실제 프로그래밍 언어로 알고리즘을 구현하는 방법입니다.

**장점**:
- 알고리즘을 가장 정확하게 기술 가능
- 실제로 실행 가능

**단점**:
- 자잘한 문법에 신경 써야 함
- `#include` 누락, 대소문자 오류 등으로 컴파일 에러 발생
- 언어별로 문법이 다름

**예시: C언어로 구현**
```c
#include <stdio.h>
#define MAX_ELEMENT 100

int score[MAX_ELEMENT];

int find_max(int n) {
    int largest = score[0];
    
    for (int i = 1; i < n; i++) {
        if (score[i] > largest) {
            largest = score[i];
        }
    }
    
    return largest;
}

int main() {
    // 사용 예시
    int n = 5;
    score[0] = 85;
    score[1] = 92;
    score[2] = 78;
    score[3] = 95;
    score[4] = 88;
    
    int max = find_max(n);
    printf("최댓값: %d\n", max);
    
    return 0;
}
```
- **stdio.h** : printf 같은 입출력 함수를 사용하기 위한 표준 라이브러리
- **MAX_ELEMENT** : 배열의 최대 크기를 100으로 제한하는 상수
```c
int score[MAX_ELEMENT];
```
- 학생 점수들을 저장하는 정수형 배열
- 최대 100개의 데이터를 저장할 수 있다.

```c
int find_max(int n) {
    int largest = score[0];
    
    for (int i = 1; i < n; i++) {
        if (score[i] > largest) {
            largest = score[i];
        }
    }
    
    return largest;
}
```
동작 원리

1. largest에 첫 번째 값 score[0]을 저장  
→ 비교 기준이 필요하므로 초기 최댓값으로 설정  
2. 두 번째 원소부터 마지막 원소까지 반복  
3. 현재 값이 largest보다 크면 largest를 갱신  
4. 반복이 끝나면 largest에 전체 중 최댓값이 남음  
5. 그 값을 반환  
이 알고리즘은 모든 원소를 한 번씩 비교하므로 시간 복잡도는 O(n) 이다.
```c
int main() {
    int n = 5;
    score[0] = 85;
    score[1] = 92;
    score[2] = 78;
    score[3] = 95;
    score[4] = 88;
    
    int max = find_max(n);
    printf("최댓값: %d\n", max);
    
    return 0;
}
```
- 배열에 5개의 점수를 저장
- find_max(n)을 호출하여 최댓값 계산
- 결과를 화면에 출력


**예시: JavaScript로 구현**
```javascript
function findMax(scoreArray) {
    let largest = scoreArray[0];
    
    for (let i = 1; i < scoreArray.length; i++) {
        if (scoreArray[i] > largest) {
            largest = scoreArray[i];
        }
    }
    
    return largest;
}

const scores = [85, 92, 78, 95, 88];
console.log(`최댓값: ${findMax(scores)}`); // 95
```

```js
function findMax(scoreArray) {
```
- scoreArray : 최댓값을 찾을 대상이 되는 숫자 배열
- 배열 전체를 순회하며 가장 큰 값을 찾아 반환하는 함수

```js
let largest = scoreArray[0];
```
- 첫 번째 원소를 임시 최댓값으로 저장
- 비교 기준이 필요하므로 배열의 첫 값을 기준점으로 설정
```js
for (let i = 1; i < scoreArray.length; i++) {
    if (scoreArray[i] > largest) {
        largest = scoreArray[i];
    }
}
```
동작 원리
1. largest에 첫 번째 값 scoreArray[0] 저장  
2. 두 번째 원소부터 마지막 원소까지 반복  
3. 현재 값이 largest보다 크면 largest를 갱신  
4. 모든 원소를 한 번씩 비교  
이 과정은 배열을 처음부터 끝까지 한 번 훑는 선형 탐색(Linear Search) 이다.  
시간 복잡도는 O(n) 이다.  
```js
return largest;
```
- 반복이 끝나면 largest에는 배열 전체 중 최댓값이 저장됨
- 그 값을 함수의 반환값으로 돌려줌
```js
const scores = [85, 92, 78, 95, 88];
console.log(`최댓값: ${findMax(scores)}`);
```
- scores 배열에 5개의 점수를 저장
- findMax(scores)를 호출하여 최댓값 계산
- 계산된 최댓값 95를 콘솔에 출력

## 알고리즘 표현 방법 비교

| 방법 | 읽기 쉬움 | 정확성 | 실행 가능 | 복잡도 표현 | 추천도 |
|------|----------|--------|----------|------------|--------|
| 자연어 | ⭐⭐⭐ | ⭐ | ❌ | ⭐ | ⭐ |
| 흐름도 | ⭐⭐⭐ | ⭐⭐ | ❌ | ⭐ | ⭐⭐ |
| 의사코드 | ⭐⭐⭐ | ⭐⭐⭐ | ❌ | ⭐⭐⭐ | ⭐⭐⭐ |
| 프로그래밍 언어 | ⭐⭐ | ⭐⭐⭐ | ✅ | ⭐⭐⭐ | ⭐⭐⭐ |

---

## 실습: 다양한 방법으로 표현해보기

**문제**: 1부터 n까지의 합을 구하는 알고리즘

### 자연어
```
1. 합계를 저장할 변수 sum을 0으로 초기화한다
2. 1부터 n까지 반복하면서 각 숫자를 sum에 더한다
3. 최종 sum 값을 반환한다
```

### 흐름도
```
   시작
    ↓
  sum = 0
    ↓
  i = 1
    ↓
 i ≤ n? ─No→ sum 반환 → 종료
   ↓Yes
 sum = sum + i
   ↓
  i++
   ↓
 (반복)
```

### 의사코드
```
sumToN(n)
  sum ← 0
  for i ← 1 to n do
    sum ← sum + i
  return sum
```

### 프로그래밍 언어 (JavaScript)
```javascript
function sumToN(n) {
    let sum = 0;
    for (let i = 1; i <= n; i++) {
        sum += i;
    }
    return sum;
}

console.log(sumToN(10)); // 55
```

---

## 마무리

알고리즘의 기초를 정리하면:

1. **알고리즘**은 컴퓨터가 문제를 푸는 **단계적 절차**
2. **명백성, 유한성, 유효성**을 반드시 만족해야 함
3. 표현 방법은 **자연어, 흐름도, 의사코드, 프로그래밍 언어** 4가지
4. 실무에서는 **의사코드**를 가장 많이 사용

---