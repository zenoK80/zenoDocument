---
title: 총정리
description: 자료구조의 개요부터 빅오 표기법까지 핵심 내용을 한눈에 정리합니다.
slug: data-structure-summary
sidebar_position: 7
---
# 총정리: 자료구조의 개요

이 문서는 자료구조의 개요 내용을 **한눈에 정리**합니다.

:::tip 학습 목표
프로그램의 기본 구조부터 성능 분석까지, 자료구조 학습의 **탄탄한 기초**를 다집니다!
:::
<img src={require('../img/data-structure-summary.png').default} 
     alt="자료구조 요약" 
     style={{ maxWidth: '500px', width: '100%', display: 'block', margin: '0 auto' }} />
---

## 📚 자료구조의 개요에서 배운 내용

1. **자료구조와 알고리즘**
2. **알고리즘 표현 방법**
3. **추상 자료형 (ADT)**
4. **알고리즘 성능 분석**
5. **빅오 표기법**
6. **성능 케이스 분석**

---

## 1️⃣ 프로그램의 핵심 공식

### 프로그램 = 자료구조 + 알고리즘

```
┌─────────────────┐     ┌─────────────────┐
│  자료구조       │  +  │  알고리즘       │
│  (데이터 저장)  │     │  (문제 해결)    │
└─────────────────┘     └─────────────────┘
         ↓                       ↓
    어떻게 담을까?          어떻게 처리할까?
```

---

### 일상 속 자료구조

| 일상생활 | 자료구조 | 특징 |
|----------|---------|------|
| 🍽️ 그릇 쌓기 | **스택 (Stack)** | 나중에 올린 것 먼저 꺼냄 (LIFO) |
| 🏪 마트 줄서기 | **큐 (Queue)** | 먼저 온 사람 먼저 나감 (FIFO) |
| 📝 버킷리스트 | **리스트 (List)** | 순서대로 나열 |
| 🗺️ 지도/네비 | **그래프 (Graph)** | 지점과 경로의 연결 |
| 📁 컴퓨터 폴더 | **트리 (Tree)** | 계층 구조 |

---

### 예제: 최댓값 찾기

**문제**: 배열에서 가장 큰 값을 찾아라

```c
int find_max(int score[], int n) {
    int largest = score[0];  // 1. 첫 번째 값을 기준으로
    
    for (int i = 1; i < n; i++) {  // 2. 나머지와 비교
        if (score[i] > largest) {
            largest = score[i];  // 3. 더 크면 갱신
        }
    }
    
    return largest;  // 4. 최댓값 반환
}
```

**자료구조**: `int score[]` - 배열  
**알고리즘**: 순차 비교 & 갱신

---

## 2️⃣ 알고리즘 표현 4가지 방법

| 방법 | 장점 | 단점 | 사용도 |
|------|------|------|--------|
| **자연어** | 읽기 쉬움 | 모호할 수 있음 | ⭐ |
| **흐름도** | 시각적 직관 | 복잡하면 그림 폭발 | ⭐ |
| **의사코드** | 핵심만 표현 | 표준 없음 | ⭐⭐⭐ |
| **프로그래밍 언어** | 가장 정확 | 잡음 많음 | ⭐⭐ |

:::tip 추천
설계 단계에서는 **의사코드**가 최고!
:::

---

### 의사코드 예시

```
algorithm find_max(list, n)
    largest ← list[0]
    
    for i ← 1 to n-1
        if list[i] > largest
            largest ← list[i]
    
    return largest
```

**특징**:
- ✅ 핵심만 표현
- ✅ 군더더기 없음
- ✅ 프로그래밍 언어 독립적

---

## 3️⃣ 추상 자료형 (ADT)

### 핵심 개념

**ADT = "무엇을"만 정의, "어떻게"는 숨김**

```
┌──────────────────────┐
│   사용자             │
└──────┬───────────────┘
       │
       ↓
┌──────────────────────┐
│   인터페이스 (공개)   │  ← "무엇을" (What)
│   - push()          │
│   - pop()           │
│   - isEmpty()       │
└──────┬───────────────┘
       │ 🔒
       ↓
┌──────────────────────┐
│   구현 (숨김)        │  ← "어떻게" (How)
│   - 배열?           │
│   - 연결 리스트?     │
└──────────────────────┘
```

---

### TV 비유

```
┌─────────────────┐
│   TV 화면       │  ← 결과
├─────────────────┤
│ [전원][채널][음량]│  ← 인터페이스 (버튼)
└─────────────────┘
      내부 회로 🔒   ← 구현 (숨김)
```

**사용자는**:
- ✅ 버튼만 알면 됨
- ❌ 회로는 몰라도 됨

---

### ADT의 장점

1. **모듈화**: 독립적 개발 가능
2. **유지보수성**: 구현 변경 쉬움
3. **재사용성**: 한 번 만들면 여러 곳에서 사용
4. **추상화**: 복잡도 숨김

---

## 4️⃣ 알고리즘 성능 분석

### 두 가지 방법

| 방법 | 측정 대상 | 장점 | 단점 |
|------|----------|------|------|
| **수행 시간 측정** | 실제 시간 | 직관적 | 하드웨어 의존적 |
| **복잡도 분석** ⭐ | 연산 횟수 | 범용적 | 추상적 |

---

### 시간 복잡도

**알고리즘이 수행하는 연산 횟수**를 입력 크기 `n`의 함수로 표현

```c
int sum = 0;
for (int i = 0; i < n; i++) {  // n번 반복
    sum += arr[i];              // n번 실행
}
```

**시간 복잡도**: `T(n) = n` → **O(n)**

---

### 공간 복잡도

**알고리즘이 사용하는 메모리 공간**을 측정

```c
int arr[n];  // n개의 정수 배열
```

**공간 복잡도**: **O(n)**

---

### 입력 크기에 따른 성능 차이

| n | O(1) | O(log n) | O(n) | O(n²) | O(2ⁿ) |
|---|------|----------|------|-------|-------|
| 10 | 1 | 3 | 10 | 100 | 1,024 |
| 100 | 1 | 7 | 100 | 10,000 | 1.27×10³⁰ |
| 1,000 | 1 | 10 | 1,000 | 1,000,000 | - |

:::warning 핵심
n이 커지면 **최고차항**이 성능을 지배합니다!
:::

---

## 5️⃣ 빅오 표기법 (Big-O Notation)

### 정의

> 입력 크기 `n`이 커질 때, 알고리즘이 **최악의 경우** 얼마나 느려지는지 나타내는 **상한(upper bound)** 표기법

---

### 수학적 정의

```
f(n) ≤ c · g(n)  (n ≥ n₀일 때)
```

**의미**:
- `n₀`: n이 충분히 커지는 시점
- `c`: 상수 배수 여유
- **결론**: n이 커지면 f(n)은 g(n)의 상수배를 넘지 않음

---

### 핵심 원리

#### 1. 최고차항만 남김

```
T(n) = 3n² + 10n + 5
     ≈ 3n²
     = O(n²)
```

#### 2. 상수 계수 무시

```
T(n) = 5n
     = O(n)
```

#### 3. 최악의 경우 기준

- 최선: 운 좋을 때 (무의미)
- 평균: 계산 복잡 (어려움)
- **최악**: 안전 보장 (실무 기준) ⭐

---

### 복잡도 순서

```
O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ) < O(n!)
좋음 ←────────────────────────────────────────────→ 나쁨
```

---

### 복잡도별 성능

| 복잡도 | 이름 | 특징 | 예시 |
|--------|------|------|------|
| **O(1)** | 상수 | 항상 일정 ⭐⭐⭐ | 배열 접근 |
| **O(log n)** | 로그 | 절반씩 줄임 ⭐⭐⭐ | 이진 탐색 |
| **O(n)** | 선형 | 1번씩 다 봄 ⭐⭐ | 선형 탐색 |
| **O(n log n)** | 선형로그 | 정렬 표준 ⭐⭐ | 병합 정렬 |
| **O(n²)** | 이차 | 중첩 반복 ⭐ | 버블 정렬 |
| **O(2ⁿ)** | 지수 | 폭발적 증가 💀 | 재귀 피보나치 |
| **O(n!)** | 팩토리얼 | 계산 불가 💀 | 모든 순열 |

---

## 6️⃣ 성능 케이스 분석

### 세 가지 케이스

| 케이스 | 의미 | 표기법 | 실무 사용 |
|--------|------|--------|----------|
| **최선** | 가장 빠름 | Ω (오메가) | ⭐ 거의 안 씀 |
| **평균** | 평균적 | Θ (세타) | ⭐⭐ 가끔 씀 |
| **최악** | 가장 느림 | O (빅오) | ⭐⭐⭐ 항상 씀 |

---

### 선형 탐색 예시

```c
int search(int arr[], int n, int key) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == key) return i;
    }
    return -1;
}
```

**배열**: [5, 9, 10, 17, 20]

| 케이스 | 상황 | 비교 횟수 | 복잡도 |
|--------|------|----------|--------|
| 최선 | 첫 번째 (5) | 1 | O(1) |
| 평균 | 중간 (10) | n/2 | O(n) |
| 최악 | 마지막/없음 (20) | n | O(n) |

---

### 왜 최악이 중요한가?

#### 비행기 관제 시스템 예시

```c
int detect_collision(Plane planes[], int n) {
    for (int i = 0; i < n; i++) {
        for (int j = i+1; j < n; j++) {
            if (too_close(planes[i], planes[j])) {
                return 1;  // 충돌 위험!
            }
        }
    }
    return 0;
}
```

**최선 기준**: "보통은 빠르니까 괜찮아요" ❌ → 💥 충돌  
**최악 기준**: "최악에도 1초 안에 끝나요" ✅ → ✈️ 안전

:::danger 실무 원칙
**최선의 경우를 말하는 건 사기입니다!**

크리티컬한 시스템에서는 최악의 경우가 생명입니다.
:::

---

## 📊 핵심 정리표

### 알고리즘 표현 방법

| 순위 | 방법 | 사용 시기 |
|------|------|----------|
| 🥇 | 의사코드 | 설계 단계 |
| 🥈 | 프로그래밍 언어 | 구현 단계 |
| 🥉 | 흐름도 | 간단한 알고리즘 |

---

### 성능 분석 방법

| 방법 | 언제 사용 |
|------|----------|
| 수행 시간 측정 | 실제 환경 테스트 |
| 복잡도 분석 ⭐ | 알고리즘 설계/비교 |

---

### 빅오 계산 규칙

| 규칙 | 예시 | 결과 |
|------|------|------|
| 반복문 1개 | `for(i=0; i<n; i++)` | O(n) |
| 중첩 반복문 | `for(i) for(j)` | O(n²) |
| 절반씩 줄임 | `n = n/2` | O(log n) |
| 큰 것만 남김 | O(n) + O(n²) | O(n²) |
| 상수 무시 | O(5n + 100) | O(n) |

---

## 🎯 실전 연습 문제

### 문제 1: 복잡도 구하기

```javascript
function example(n) {
    for (let i = 0; i < n; i++) {
        console.log(i);
    }
    
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            console.log(i, j);
        }
    }
}
```

<details>
<summary>정답 보기</summary>

- 첫 번째 반복문: O(n)
- 두 번째 중첩 반복문: O(n²)
- **총합**: O(n) + O(n²) = **O(n²)** (큰 것만 남김)

</details>

---

### 문제 2: 최선/평균/최악

```c
int find_first_even(int arr[], int n) {
    for (int i = 0; i < n; i++) {
        if (arr[i] % 2 == 0) {
            return i;
        }
    }
    return -1;
}
```

<details>
<summary>정답 보기</summary>

| 케이스 | 상황 | 복잡도 |
|--------|------|--------|
| 최선 | 첫 번째가 짝수 | O(1) |
| 평균 | 중간쯤 | O(n) |
| 최악 | 마지막/없음 | O(n) |

**실무 기준**: O(n)

</details>

---

### 문제 3: ADT 설계

큐(Queue) ADT를 설계하세요.

<details>
<summary>정답 보기</summary>

```
ADT Queue

객체:
    0개 이상의 원소를 가진 선입선출 리스트

연산:
    - create(): 빈 큐 생성
    - enqueue(item): 큐의 뒤에 추가
    - dequeue(): 큐의 앞에서 제거
    - peek(): 맨 앞 원소 확인
    - isEmpty(): 비었는지 확인
    - isFull(): 가득 찼는지 확인
```

</details>

---

## 🚀 다음 단계

1단원을 마스터했다면, 이제 구체적인 자료구조를 배울 준비가 되었습니다!

### 2단원 미리보기

- **배열 (Array)**
- **연결 리스트 (Linked List)**
- **스택 (Stack)**
- **큐 (Queue)**

각 자료구조의:
- 구조와 원리
- 연산별 빅오
- 실전 활용

---

## 💡 핵심 요약 (암기 필수)

### 1. 프로그램의 공식
```
프로그램 = 자료구조 + 알고리즘
```

### 2. ADT의 핵심
```
"무엇을(What)"만 정의, "어떻게(How)"는 숨김
```

### 3. 빅오의 핵심
```
최고차항만 남기고, 상수는 버림, 최악 기준
```

### 4. 복잡도 순서
```
O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ) < O(n!)
```

### 5. 성능 분석 기준
```
항상 최악의 경우(Worst Case)로!
```

---

## ✅ 체크리스트

- [ ] 자료구조와 알고리즘의 차이를 설명할 수 있다
- [ ] 의사코드를 읽고 쓸 수 있다
- [ ] ADT의 개념과 장점을 설명할 수 있다
- [ ] 시간/공간 복잡도를 구분할 수 있다
- [ ] 코드를 보고 빅오를 계산할 수 있다
- [ ] 최선/평균/최악을 구분할 수 있다
- [ ] O(1), O(n), O(n²), O(log n)의 차이를 안다

---

## 🎓 마무리

**축하합니다! 1단원을 완료했습니다!** 🎉

이제 여러분은:
- ✅ 프로그램의 기본 구조를 이해했습니다
- ✅ 알고리즘을 표현하고 분석할 수 있습니다
- ✅ 성능을 객관적으로 평가할 수 있습니다

:::tip 다음 단계
이 기초 위에 **구체적인 자료구조**를 하나씩 쌓아가면,  
어떤 복잡한 문제도 효율적으로 해결할 수 있습니다! 🚀
:::

---