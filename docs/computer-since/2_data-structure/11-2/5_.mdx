---
title: "그래프 탐색의 시간 복잡도"
description: "DFS와 BFS의 시간 복잡도를 인접 행렬과 인접 리스트로 분석합니다."
slug: "graph-traversal-complexity"
sidebar_position: 5
date: "2024-01-15"
---

## 🎯 시간 복잡도란?

**시간 복잡도**는 알고리즘이 입력 크기에 따라 **얼마나 오래 걸리는가**를 나타냅니다.

### 표기법

| 표기 | 의미 | 예시 |
|------|------|------|
| O(1) | 상수 시간 | 배열 원소 접근 |
| O(log n) | 로그 시간 | 이진 탐색 |
| O(n) | 선형 시간 | 배열 순회 |
| O(n²) | 이차 시간 | 중첩 반복문 |
| O(n³) | 삼차 시간 | 3중 중첩 반복문 |

---

## 🔍 DFS의 시간 복잡도

### 인접 행렬 사용

```c
void dfs_recursive(Graph *g, int v) {
    int w;
    visited[v] = TRUE;
    printf("%d ", v);
    
    // 모든 정점을 확인
    for (w = 0; w < g->n; w++) {
        if (g->adj_matrix[v][w] == 1) {
            if (visited[w] == FALSE) {
                dfs_recursive(g, w);
            }
        }
    }
}
```

#### 분석

```
각 정점마다 반복을 g->n번 수행:
  - 정점 0: n번 확인
  - 정점 1: n번 확인
  - 정점 2: n번 확인
  - ...
  - 정점 n-1: n번 확인

총: n × n = n² 번

시간 복잡도: O(n²)
```

#### 상세 분석

```c
for (w = 0; w < g->n; w++)  // n번 반복
    if (g->adj_matrix[v][w] == 1)  // O(1)
        if (visited[w] == FALSE)  // O(1)
            dfs_recursive(g, w);  // 재귀 호출

총 시간 = 모든 정점에 대해 n번 반복
        = n × n
        = O(n²)
```

---

### 인접 리스트 사용

```c
void dfs_adjacency_list(Graph *g, int v) {
    Node *current;
    
    visited[v] = TRUE;
    printf("%d ", v);
    
    // v의 인접 정점들만 확인
    current = g->adj_list[v];
    while (current != NULL) {
        int w = current->vertex;
        if (visited[w] == FALSE) {
            dfs_adjacency_list(g, w);
        }
        current = current->next;
    }
}
```

#### 분석

```
인접 리스트에서 각 정점마다:
  - 그 정점의 인접 정점들만 확인
  - 간선만큼만 반복

예:
  - 정점 0의 인접: 2개 (2번 확인)
  - 정점 1의 인접: 1개 (1번 확인)
  - 정점 2의 인접: 3개 (3번 확인)
  - ...

총: 간선 수 = E

모든 정점 처리: O(V)
모든 간선 확인: O(E)

총 시간: O(V + E)
```

#### 상세 분석

```
각 정점: 1번씩만 방문
  → O(V)

각 간선: 1번씩만 확인
  → O(E)

총: O(V + E)
```

---

## 🔍 BFS의 시간 복잡도

### 인접 행렬 사용

```c
void bfs(Graph *g, int start) {
    Queue q;
    queue_init(&q);
    visited[start] = TRUE;
    printf("%d ", start);
    enqueue(&q, start);
    
    while (!is_empty(&q)) {
        int v = dequeue(&q);
        
        // 모든 정점을 확인
        for (int w = 0; w < g->n; w++) {
            if (g->adj_matrix[v][w] == 1) {
                if (visited[w] == FALSE) {
                    visited[w] = TRUE;
                    printf("%d ", w);
                    enqueue(&q, w);
                }
            }
        }
    }
}
```

#### 분석

```
인접 행렬 사용:

외부 while 루프:
  - 각 정점이 정확히 1번 dequeue됨
  - 최대 n번 반복

내부 for 루프:
  - 각 반복마다 n개 정점 확인
  - n번 반복

총: n × n = n² 번

시간 복잡도: O(n²)
```

---

### 인접 리스트 사용

```c
void bfs_adjacency_list(Graph *g, int start) {
    Queue q;
    Node *current;
    
    queue_init(&q);
    visited[start] = TRUE;
    printf("%d ", start);
    enqueue(&q, start);
    
    while (!is_empty(&q)) {
        int v = dequeue(&q);
        
        // v의 인접 정점들만 확인
        current = g->adj_list[v];
        while (current != NULL) {
            int w = current->vertex;
            if (visited[w] == FALSE) {
                visited[w] = TRUE;
                printf("%d ", w);
                enqueue(&q, w);
            }
            current = current->next;
        }
    }
}
```

#### 분석

```
인접 리스트 사용:

외부 while (dequeue):
  - 각 정점 1번 처리
  - O(V)

내부 while (인접 정점):
  - 각 간선 1번 확인
  - 모든 간선을 합치면 O(E)

총: O(V + E)
```

---

## 📊 시간 복잡도 비교표

### 인접 행렬 vs 인접 리스트

| 작업 | 인접 행렬 | 인접 리스트 |
|------|---------|----------|
| **간선 확인** | O(1) | O(degree) |
| **모든 인접 정점 조회** | O(V) | O(degree) |
| **DFS** | O(V²) | O(V+E) |
| **BFS** | O(V²) | O(V+E) |

---

## 🎯 상황별 시간 복잡도

### 경우 1: 희소 그래프 (간선이 적을 때)

```
예: 정점 100개, 간선 150개

인접 행렬:
  - DFS: O(100²) = O(10,000)
  - BFS: O(100²) = O(10,000)
  
인접 리스트:
  - DFS: O(100 + 150) = O(250) ✅ 훨씬 빠름!
  - BFS: O(100 + 150) = O(250) ✅ 훨씬 빠름!
```

### 경우 2: 밀집 그래프 (간선이 많을 때)

```
예: 정점 100개, 간선 9,900개 (거의 완전 그래프)

인접 행렬:
  - DFS: O(100²) = O(10,000)
  - BFS: O(100²) = O(10,000)
  
인접 리스트:
  - DFS: O(100 + 9,900) = O(10,000)
  - BFS: O(100 + 9,900) = O(10,000)

두 방식이 비슷함 (간선이 많으므로)
```

---

## 💡 선택 기준

### 인접 행렬을 사용할 때

```
✓ 정점이 적을 때 (< 100개)
✓ 간선이 많을 때 (밀집)
✓ 특정 간선의 존재 확인이 중요
→ O(V²)이 좋은 성능
```

### 인접 리스트를 사용할 때

```
✓ 정점이 많을 때 (> 1000개)
✓ 간선이 적을 때 (희소)
✓ 메모리가 중요
→ O(V+E)로 효율적
```

---

## 📋 알고리즘별 시간 복잡도

| 알고리즘 | 인접 행렬 | 인접 리스트 | 비고 |
|---------|---------|----------|------|
| DFS | O(V²) | O(V+E) | 깊이 우선 |
| BFS | O(V²) | O(V+E) | 너비 우선 |
| 위상 정렬 | O(V²) | O(V+E) | DAG만 |
| 최단 경로 (Dijkstra) | O(V²) | O((V+E)logV) | 양수 가중치 |
| 플로이드-워셜 | O(V³) | X | 모든 쌍 |

---

## 🔑 핵심 정리

### DFS 복잡도

```
인접 행렬: O(V²)
  - 모든 정점마다 모든 정점 확인

인접 리스트: O(V+E)
  - 각 정점 1번, 각 간선 2번
```

### BFS 복잡도

```
인접 행렬: O(V²)
  - 모든 정점을 큐에서 처리
  - 각 정점마다 모든 정점 확인

인접 리스트: O(V+E)
  - 각 정점 1번, 각 간선 1번
```

---

## 📊 그래프 크기별 선택

```
N: 정점 개수, E: 간선 개수

N ≤ 100:
  → 인접 행렬 (구현 간단, O(N²) 수용 가능)

N > 1000, E << N²:
  → 인접 리스트 (O(N+E) 효율적)

N > 1000, E ≈ N²:
  → 상황에 따라 선택 (둘 다 O(N²))
```

---

## 🎓 실제 성능 예시

### 시나리오: 소셜 네트워크

```
사용자: 10,000,000명 (N = 10M)
친구 관계: 1,000,000,000건 (E = 1B)

인접 행렬:
  - 메모리: (10M)² = 불가능!
  - 시간: O((10M)²) = 불가능!

인접 리스트:
  - 메모리: O(10M + 1B) = 가능
  - 시간: O(10M + 1B) = 약 1초 내 완료
```

---

## 🎯 결론

| 표현 방식 | 장점 | 단점 | 추천 상황 |
|---------|------|------|---------|
| 인접 행렬 | O(1) 간선 확인 | O(V²) 공간 | 작은 밀집 그래프 |
| 인접 리스트 | O(V+E) 시간 | 구현 복잡 | 큰 희소 그래프 |