---
title: "깊이 우선 탐색 - 반복 방식"
description: "명시적 스택을 사용하여 DFS를 반복 방식으로 구현합니다."
slug: "dfs-iterative"
sidebar_position: 3
date: "2024-01-15"
---

## 🎯 반복 방식 DFS의 필요성

재귀 방식은 간단하지만 **깊은 재귀로 스택 오버플로우 위험**이 있습니다. 

**반복 방식은 스택을 명시적으로 관리**하므로 더 안전합니다.

---

## 📝 헤더 파일 및 상수 정의

```c
#include <stdio.h>      // printf, fprintf
#include <stdlib.h>     // malloc, free, exit

#define TRUE 1          // 참
#define FALSE 0         // 거짓
#define MAX_VERTEX 50   // 최대 정점
```

---

## 🏗️ 스택 구조체 정의

```c
typedef int Element;    // 스택에 저장할 자료형 (정점 번호)

typedef struct {
    Element data[MAX_VERTEX];  // 스택 데이터 저장 배열
    int top;                   // 스택의 맨 위 위치
} Stack;
```

**코드 분석:**
```c
Element data[MAX_VERTEX];
→ 최대 50개의 정점을 저장할 수 있는 배열

int top;
→ 스택의 맨 위치를 나타내는 인덱스
→ 초기값: -1 (비어있음)
→ push 후: top 증가
→ pop 후: top 감소
```

---

## ⚙️ 스택 연산 함수

### 1️⃣ 스택 초기화

```c
void stack_init(Stack *s) {
    s->top = -1;  // 스택 비워두기
}
```

**코드 분석:**
```c
s->top = -1;
→ -1은 스택이 비어있다는 신호
→ top이 0이면 1개 원소 있음
→ top이 1이면 2개 원소 있음
```

---

### 2️⃣ 스택 공백 검사

```c
int is_empty(Stack *s) {
    // top이 -1이면 비어있음
    return (s->top == -1) ? TRUE : FALSE;
}
```

**코드 분석:**
```c
s->top == -1
→ 스택에 아무것도 없음
→ TRUE 반환

s->top >= 0
→ 스택에 데이터 있음
→ FALSE 반환
```

---

### 3️⃣ 스택 포화 검사

```c
int is_full(Stack *s) {
    // top이 MAX_VERTEX-1이면 꽉 찼음
    return (s->top == MAX_VERTEX - 1) ? TRUE : FALSE;
}
```

**코드 분석:**
```c
s->top == MAX_VERTEX - 1
→ 스택이 가득 참 (배열의 마지막)
→ 예: MAX_VERTEX=50이면 top=49 일 때

배열 인덱스: 0 ~ 49 (총 50개)
마지막 위치: 49 = MAX_VERTEX - 1
```

---

### 4️⃣ PUSH (스택에 삽입)

```c
void push(Stack *s, Element item) {
    // 먼저 포화 상태 확인
    if (is_full(s)) {
        fprintf(stderr, "Error: 스택 오버플로우!\n");
        return;
    }
    
    // top을 하나 증가
    s->top++;
    
    // 증가된 위치에 데이터 저장
    s->data[s->top] = item;
}
```

**코드 분석:**
```c
s->top++;
→ 먼저 top 증가 (선 증가)
→ 예: top=-1 → top=0

s->data[s->top] = item;
→ 증가된 위치에 데이터 저장
→ 예: data[0] = 5

** 중요: 선 증가 후 저장!
```

---

### 5️⃣ POP (스택에서 제거)

```c
Element pop(Stack *s) {
    Element item;
    
    // 먼저 공백 상태 확인
    if (is_empty(s)) {
        fprintf(stderr, "Error: 스택 언더플로우!\n");
        exit(1);
    }
    
    // 현재 위치의 데이터를 임시 변수에 저장
    item = s->data[s->top];
    
    // top을 하나 감소
    s->top--;
    
    // 저장된 데이터 반환
    return item;
}
```

**코드 분석:**
```c
item = s->data[s->top];
→ 현재 위치의 데이터 저장
→ 예: top=2일 때 data[2] 값 저장

s->top--;
→ top 감소 (후 감소)
→ 예: top=2 → top=1

return item;
→ 꺼낸 데이터 반환
```

---

## 🔍 DFS 반복 방식 구현

```c
// 그래프 구조체 (이전과 동일)
typedef struct {
    int n;
    int adj_matrix[MAX_VERTEX][MAX_VERTEX];
} Graph;

// visited 배열
int visited[MAX_VERTEX];

void dfs_iterative(Graph *g, int start) {
    Stack s;
    int v, w;
    
    // ① 스택 초기화
    stack_init(&s);
    
    // ② 시작 정점을 스택에 push
    push(&s, start);
    
    // ③ 스택이 비워질 때까지 반복
    while (!is_empty(&s)) {
        // 스택에서 정점 하나를 pop
        v = pop(&s);
        
        // ④ 그 정점이 아직 방문되지 않았다면
        if (visited[v] == FALSE) {
            // 방문 표시
            visited[v] = TRUE;
            
            // 정점 출력 (방문 기록)
            printf("%d ", v);
            
            // ⑤ v의 모든 인접 정점을 찾음
            for (w = 0; w < g->n; w++) {
                // v와 w 사이에 간선이 있고
                if (g->adj_matrix[v][w] == 1) {
                    // w가 아직 방문되지 않았다면
                    if (visited[w] == FALSE) {
                        // w를 스택에 push
                        push(&s, w);
                    }
                }
            }
        }
    }
}
```

**코드 분석:**

```c
stack_init(&s);
→ 스택을 비운 상태로 초기화
→ s->top = -1

push(&s, start);
→ 시작 정점을 스택에 넣음
→ 반복문의 첫 번째 반복에서 꺼냄

while (!is_empty(&s))
→ 스택이 비워질 때까지 반복
→ 모든 정점을 처리할 때까지

v = pop(&s);
→ 스택에서 정점 하나를 꺼냄
→ LIFO: 마지막에 들어온 것이 먼저 나옴

if (visited[v] == FALSE)
→ 이미 방문한 정점은 스킵
→ 중복 처리 방지

for (w = 0; w < g->n; w++)
→ 모든 정점을 확인

if (g->adj_matrix[v][w] == 1)
→ v와 w 사이에 간선이 있는가?

push(&s, w);
→ 미방문 인접 정점을 스택에 추가
→ 다음 반복에서 처리
```

---

## 📊 실행 흐름 예시

```
그래프:   0 ─── 1
          │ ╲   │
          2 ─── 3

초기 상태: Stack: [0]

반복 1: Pop 0
   0 미방문 → 방문 표시, 출력: 0
   0의 인접: 1, 2, 3
   모두 미방문 → Push 3, 2, 1
   Stack: [1, 2, 3]

반복 2: Pop 3
   3 미방문 → 방문 표시, 출력: 3
   3의 인접: 0, 2
   0 방문됨, 2 미방문 → Push 2
   Stack: [1, 2, 2]

반복 3: Pop 2
   2 미방문 → 방문 표시, 출력: 2
   2의 인접: 0, 1, 3
   모두 방문됨
   Stack: [1, 2]

반복 4: Pop 2
   2 방문됨 → 스킵
   Stack: [1]

반복 5: Pop 1
   1 미방문 → 방문 표시, 출력: 1
   1의 인접: 0, 2, 3
   모두 방문됨
   Stack: []

스택 비움 → 종료

최종 출력: 0 3 2 1
```

---

## 💡 중요한 차이점

### 재귀 vs 반복

| 특성 | 재귀 | 반복 |
|------|------|------|
| 스택 | 묵시적 | 명시적 |
| 구현 | 간단 | 복잡 |
| 안전성 | 낮음 (깊은 재귀) | 높음 |
| 스택 관리 | 자동 | 수동 |

### 스택에 넣는 순서의 중요성

```c
// 예: 0의 인접이 1, 2, 3일 때

// 방법 1: 순서대로 push
push(&s, 1);  // 먼저 들어감
push(&s, 2);  // 그 다음
push(&s, 3);  // 마지막 들어감

// 꺼내는 순서: 3 → 2 → 1 (역순!)

---

// 방법 2: 역순으로 push
push(&s, 3);  // 먼저 들어감
push(&s, 2);  // 그 다음
push(&s, 1);  // 마지막 들어감

// 꺼내는 순서: 1 → 2 → 3 (정순!)
```

**주의**: 오름차순 탐색이 필요하면 **역순으로 push**해야 합니다!

---

## 💻 메인 함수

```c
int main() {
    Graph *g;
    int i;
    
    g = (Graph *)malloc(sizeof(Graph));
    init_graph(g);
    
    // visited 배열 초기화
    for (i = 0; i < MAX_VERTEX; i++) {
        visited[i] = FALSE;
    }
    
    // 정점 추가
    for (i = 0; i < 4; i++) {
        insert_vertex(g, i);
    }
    
    // 간선 추가
    insert_edge(g, 0, 1);
    insert_edge(g, 0, 2);
    insert_edge(g, 0, 3);
    insert_edge(g, 1, 2);
    insert_edge(g, 2, 3);
    
    // DFS 실행
    printf("DFS (반복) 탐색 순서: ");
    dfs_iterative(g, 0);
    printf("\n");
    
    free(g);
    return 0;
}
```

---

## 🔑 핵심 정리

| 개념 | 설명 |
|------|------|
| **명시적 스택** | 직접 선언하고 관리하는 스택 |
| **PUSH/POP** | 스택의 기본 연산 |
| **선 증가** | ++top 후 저장 |
| **후 감소** | 사용 후 --top |
| **LIFO** | 마지막 들어온 것이 먼저 나옴 |

---

## 🎓 반복 방식의 장점

✅ 깊은 재귀로 인한 스택 오버플로우 방지  
✅ 스택 크기를 직접 제어 가능  
✅ 대규모 그래프에서도 안전  
✅ 스택 메모리 예측 가능

## 반복 방식의 단점

❌ 코드가 다소 복잡  
❌ 스택 연산을 직접 구현해야 함  
❌ 스택에 정점을 넣는 순서에 주의 필요