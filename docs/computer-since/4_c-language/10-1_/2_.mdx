---
title: "배열로 스택 구현하기 - 주차장 예제"
description: "배열을 이용하여 스택을 구현하고, 주차장 시뮬레이션을 통해 스택의 동작을 이해합니다."
slug: "stack-implementation-parking"
sidebar_position: 2
---

# 배열로 스택 구현하기 - 주차장 예제

## 주차장으로 스택 이해하기

### 주차장 상황 설정

한쪽이 막힌 좁은 주차장이 있습니다:
- 차가 **3대**만 주차 가능
- **한쪽이 막혀있어서** 일렬로만 주차 가능
- 차를 빼려면 **뒤에 있는 차부터** 빼야 합니다

```
막혀있음 ←  [차1] [차2] [차3]  ← 입구
    ↑         ↑     ↑     ↑
   벽       0번째 1번째 2번째
```

이것이 바로 **스택 구조**입니다!

---

## 배열로 주차장 스택 만들기

### 1단계: 배열 선언과 초기화

```c
#include <stdio.h>

int main() {
    // 자동차 3대를 주차할 수 있는 배열 생성
    char car_parking[3];  // 크기가 3인 문자 배열
    
    // top: 다음에 차가 들어갈 위치를 가리킴
    int top = 0;  // 처음에는 0번째 위치를 가리킴
    
    return 0;
}
```

**코드 설명:**
- `char car_parking[3];` 
  - 문자를 저장하는 배열 (자동차 이름 저장용)
  - 크기는 3 (3대의 차만 주차 가능)
- `int top = 0;`
  - top은 다음에 차가 들어갈 위치
  - 처음에는 아무 차도 없으므로 0

```
주차장 상태: (비어있음)
   [  ] [  ] [  ]
    ↑
   top=0
```

---

### 2단계: 첫 번째 차 주차하기 (PUSH)

```c
// A 자동차를 주차장에 넣기
car_parking[top] = 'A';  // 현재 top 위치(0)에 'A' 저장
printf("A 자동차 주차장 들어감\n");
```

**동작 과정:**
1. `car_parking[0] = 'A';` → 0번째 위치에 'A' 저장
2. 아직 top은 증가하지 않음 (다음 차를 위해 증가시킬 예정)

```
주차장 상태:
   [A] [  ] [  ]
    ↑
   top=0
```

---

### 3단계: 두 번째 차 주차하기

```c
top++;  // top을 1로 증가 (다음 위치로 이동)
car_parking[top] = 'B';  // 1번째 위치에 'B' 저장
printf("B 자동차 주차장 들어감\n");
```

**동작 과정:**
1. `top++;` → top이 0에서 1로 증가
2. `car_parking[1] = 'B';` → 1번째 위치에 'B' 저장

```
주차장 상태:
   [A] [B] [  ]
        ↑
       top=1
```

**왜 top을 먼저 증가시킬까요?**
- A를 넣었으니, 다음 차(B)가 들어갈 위치를 준비해야 합니다
- top을 증가시켜야 다음 빈 공간을 가리킵니다

---

### 4단계: 차 빼기 (POP)

```c
top--;  // top을 0으로 감소 (이전 위치로 이동)
printf("%c 자동차 주차장 빠져나감\n", car_parking[top]);
```

**동작 과정:**
1. `top--;` → top이 1에서 0으로 감소
2. `car_parking[0]` → 0번째 위치의 값('B')을 출력

```
주차장 상태 (POP 후):
   [A] [  ] [  ]
    ↑
   top=0
```

**주의:** 
- top을 **먼저 감소**시킵니다
- 그래야 가장 위(마지막)에 있던 차를 가리킵니다
- B가 먼저 나가고, A는 나중에 나갑니다 (후입선출!)

---

## 완성된 간단한 예제

```c
#include <stdio.h>

int main() {
    char car_parking[3];  // 주차장 배열 (크기 3)
    int top = 0;          // top 초기화
    
    // === A 자동차 주차 ===
    car_parking[top] = 'A';
    printf("A 자동차 주차장 들어감\n");
    
    // === B 자동차 주차 ===
    top++;  // top을 1로 증가
    car_parking[top] = 'B';
    printf("B 자동차 주차장 들어감\n");
    
    printf("\n");  // 줄 바꿈
    
    // === B 자동차 빼기 ===
    top--;  // top을 0으로 감소
    printf("%c 자동차 주차장 빠져나감\n", car_parking[top + 1]);
    
    // === A 자동차 빼기 ===
    printf("%c 자동차 주차장 빠져나감\n", car_parking[top]);
    
    return 0;
}
```

**실행 결과:**
```
A 자동차 주차장 들어감
B 자동차 주차장 들어감

B 자동차 주차장 빠져나감
A 자동차 주차장 빠져나감
```

**결과 분석:**
- B가 **먼저** 나갑니다 (나중에 들어갔으므로)
- A가 **나중에** 나갑니다 (먼저 들어갔으므로)
- 이것이 **후입선출(LIFO)**입니다!

---

## 스택이 꽉 찼을 때와 비었을 때 처리하기

### 문제 상황

1. **주차장이 꽉 찬 경우**: 더 이상 차를 넣을 수 없습니다
2. **주차장이 비어있는 경우**: 뺄 차가 없습니다

이런 경우를 처리해야 합니다!

### 개선된 코드

```c
#include <stdio.h>

int main() {
    char car_parking[3];  // 주차장 배열
    int top = 0;          // top 초기화
    char name = 'A';      // 자동차 이름 (A부터 시작)
    int select = 9;       // 메뉴 선택 변수 (초기값 9)
    
    // select가 3이 아닐 때까지 반복
    while(select != 3) {
        // 메뉴 출력
        printf("1. 자동차 넣기\n");
        printf("2. 자동차 빼기\n");
        printf("3. 끝\n");
        scanf("%d", &select);  // 사용자 입력 받기
        
        // 선택에 따라 동작 수행
        switch(select) {
            case 1:  // 자동차 넣기
                // ===== 꽉 찼는지 확인 =====
                if(top == 3) {
                    printf("주차장 꽉 차서 차가 못 들어갑니다\n");
                    break;
                }
                
                // ===== 차 넣기 =====
                name++;  // 자동차 이름 증가 (A→B→C...)
                car_parking[top] = name;
                printf("%c 자동차 주차장 들어감\n", name);
                top++;  // top 증가
                break;
                
            case 2:  // 자동차 빼기
                // ===== 비어있는지 확인 =====
                if(top == 0) {
                    printf("빠져나갈 자동차가 없습니다\n");
                    break;
                }
                
                // ===== 차 빼기 =====
                top--;  // top 감소
                printf("%c 자동차 주차장 빠져나감\n", car_parking[top]);
                car_parking[top] = ' ';  // 빈 공간으로 만들기
                break;
                
            case 3:  // 종료
                printf("현재 주차 대수: %d대\n", top);
                break;
                
            default:  // 잘못된 입력
                printf("잘못 입력하셨습니다. 다시 입력하세요\n");
                break;
        }
    }
    
    return 0;
}
```

---

## 코드 한 줄씩 자세히 분석

### 1. 변수 선언 부분

```c
char car_parking[3];  // 주차장 배열
int top = 0;          // top 초기화
char name = 'A';      // 자동차 이름
int select = 9;       // 메뉴 선택 변수
```

**각 변수의 역할:**
- `car_parking[3]`: 자동차 이름을 저장하는 배열
- `top`: 다음 차가 들어갈 위치 (0부터 시작)
- `name`: 다음 차의 이름 ('A'부터 시작해서 증가)
- `select`: 사용자가 선택한 메뉴 번호 (초기값 9)

### 2. While 반복문

```c
while(select != 3) {
    // ...메뉴 출력 및 처리...
}
```

**동작 원리:**
- `select`가 3이 아닐 때까지 계속 반복
- 사용자가 3을 입력하면 프로그램 종료

### 3. Case 1: 자동차 넣기

```c
case 1:
    if(top == 3) {  // top이 3이면 꽉 찬 상태
        printf("주차장 꽉 차서 차가 못 들어갑니다\n");
        break;
    }
```

**왜 top == 3일까요?**
- 배열 크기가 3이므로 인덱스는 0, 1, 2
- top이 3이면 0, 1, 2가 모두 찼다는 뜻
- 더 이상 넣을 공간이 없음

```c
    name++;  // 'A'에서 'B'로, 'B'에서 'C'로...
    car_parking[top] = name;
    printf("%c 자동차 주차장 들어감\n", name);
    top++;  // 다음 위치로 이동
    break;
```

**동작 순서:**
1. `name++`: 문자 증가 (A → B → C → ...)
2. `car_parking[top] = name`: 현재 top 위치에 차 저장
3. `printf(...)`: 메시지 출력
4. `top++`: top을 다음 위치로 이동
5. `break`: switch문 빠져나가기

### 4. Case 2: 자동차 빼기

```c
case 2:
    if(top == 0) {  // top이 0이면 비어있는 상태
        printf("빠져나갈 자동차가 없습니다\n");
        break;
    }
```

**왜 top == 0일까요?**
- top이 0이면 주차된 차가 없다는 뜻
- 0번째 위치도 비어있음

```c
    top--;  // 이전 위치로 이동
    printf("%c 자동차 주차장 빠져나감\n", car_parking[top]);
    car_parking[top] = ' ';  // 빈 공간으로 만들기
    break;
```

**동작 순서:**
1. `top--`: top을 감소 (마지막 차 위치로 이동)
2. `printf(...)`: 그 위치의 차 출력
3. `car_parking[top] = ' '`: 빈 공간으로 초기화
4. `break`: switch문 빠져나가기

### 5. Case 3: 종료

```c
case 3:
    printf("현재 주차 대수: %d대\n", top);
    break;
```

**왜 top이 주차 대수일까요?**
- top은 다음 차가 들어갈 위치
- 차가 0대면 top=0, 1대면 top=1, 2대면 top=2
- 따라서 top 값이 곧 주차된 차의 개수!

---

## 실행 예시

```
1. 자동차 넣기
2. 자동차 빼기
3. 끝
> 2
빠져나갈 자동차가 없습니다

1. 자동차 넣기
2. 자동차 빼기
3. 끝
> 1
B 자동차 주차장 들어감

1. 자동차 넣기
2. 자동차 빼기
3. 끝
> 1
C 자동차 주차장 들어감

1. 자동차 넣기
2. 자동차 빼기
3. 끝
> 1
D 자동차 주차장 들어감

1. 자동차 넣기
2. 자동차 빼기
3. 끝
> 1
주차장 꽉 차서 차가 못 들어갑니다

1. 자동차 넣기
2. 자동차 빼기
3. 끝
> 2
D 자동차 주차장 빠져나감

1. 자동차 넣기
2. 자동차 빼기
3. 끝
> 2
C 자동차 주차장 빠져나감

1. 자동차 넣기
2. 자동차 빼기
3. 끝
> 2
B 자동차 주차장 빠져나감

1. 자동차 넣기
2. 자동차 빼기
3. 끝
> 3
현재 주차 대수: 0대
```

---

## 핵심 요약

### 배열로 스택 만드는 방법

```c
// 1. 배열과 top 선언
char stack[크기];
int top = 0;

// 2. PUSH (넣기)
if(top < 크기) {  // 꽉 찼는지 확인
    stack[top] = 데이터;
    top++;
}

// 3. POP (빼기)
if(top > 0) {  // 비었는지 확인
    top--;
    데이터 = stack[top];
}
```

### 주의사항

✅ **PUSH 할 때:**
- top이 배열 크기와 같은지 확인 (꽉 찼는지)
- 데이터를 넣은 후 top을 증가

✅ **POP 할 때:**
- top이 0인지 확인 (비었는지)
- top을 먼저 감소한 후 데이터를 꺼냄

✅ **top의 의미:**
- 다음에 데이터가 **들어갈 위치**
- 현재 스택에 들어있는 **데이터 개수**와 같음

---

## 다음 단계

스택과 비슷하지만 반대로 동작하는 **큐(Queue)**에 대해 알아보겠습니다. 큐는 선입선출(FIFO) 구조로, 먼저 들어간 것이 먼저 나오는 자료구조입니다!