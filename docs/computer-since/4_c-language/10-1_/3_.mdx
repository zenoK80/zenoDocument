---
title: "큐(Queue) 개념과 구현"
description: "큐의 기본 개념과 선입선출(FIFO) 자료구조를 배열로 구현하는 방법을 학습합니다."
slug: "queue-concept-implementation"
sidebar_position: 3
---

# 큐(Queue) 개념과 구현

## 큐란 무엇인가요?

큐(Queue)는 **줄을 서는 것**을 의미하는 자료구조입니다.

### 일상 생활 속 큐의 예시

#### 1. 은행 번호표 시스템
```
입구 →  [1번] [2번] [3번] [4번]  → 창구
                                    ↓
                              먼저 온 사람이
                              먼저 처리됨
```

- 먼저 온 사람이 먼저 번호표를 받습니다
- 먼저 받은 사람이 먼저 업무를 처리합니다

#### 2. 놀이공원 줄서기
```
뒤쪽 ←  [사람4] [사람3] [사람2] [사람1]  → 입구
                                          ↓
                                    먼저 탄다!
```

- 먼저 줄을 선 사람이 먼저 놀이기구를 탑니다
- 나중에 온 사람은 뒤에서 기다립니다

---

## 큐의 핵심 개념: 선입선출 (FIFO)

### FIFO란?
**F**irst **I**n **F**irst **O**ut (선입선출)
- **먼저 들어간 것이 먼저 나온다**
- **나중에 들어간 것은 나중에 나온다**

### 스택(Stack)과의 차이점

| 구분 | 스택(Stack) | 큐(Queue) |
|------|------------|-----------|
| 원리 | 후입선출(LIFO) | 선입선출(FIFO) |
| 비유 | 식판 쌓기 | 은행 줄서기 |
| 삽입 위치 | 맨 위(top) | 맨 뒤(rear/tail) |
| 삭제 위치 | 맨 위(top) | 맨 앞(front/head) |
| 사용 예 | 뒤로가기, 실행취소 | 대기열, 순서 처리 |

---

## 큐의 동작 방식

### 큐의 구조

```
front(head)                    rear(tail)
    ↓                              ↓
   [1] [2] [3] [4] [  ] [  ] [  ]
    ↑                  ↑
  나가는 곳         들어오는 곳
```

### 동작 과정

```
1. 처음 상태 (비어있음)
   front, rear
        ↓
   [  ] [  ] [  ] [  ]

2. 데이터 1 삽입 (enQueue)
   front    rear
     ↓        ↓
   [1] [  ] [  ] [  ]
   
3. 데이터 2 삽입 (enQueue)
   front         rear
     ↓             ↓
   [1] [2] [  ] [  ]

4. 데이터 3 삽입 (enQueue)
   front              rear
     ↓                  ↓
   [1] [2] [3] [  ] [  ]

5. 데이터 꺼내기 (deQueue) - 1이 나감
        front         rear
          ↓             ↓
   [  ] [2] [3] [  ] [  ]
   
6. 데이터 꺼내기 (deQueue) - 2가 나감
             front    rear
               ↓        ↓
   [  ] [  ] [3] [  ] [  ]
```

**핵심 포인트:**
- `enQueue`: 뒤쪽(rear)에서 **삽입**
- `deQueue`: 앞쪽(front)에서 **삭제**
- 먼저 들어간 1이 먼저 나옴 → **선입선출!**

---

## 큐의 주요 용어

### 1. enQueue (인큐)
**데이터를 큐의 뒤쪽에 넣는 작업**

```c
// enQueue 작업의 개념
queue[rear] = data;  // rear 위치에 데이터 저장
rear = rear + 1;     // rear를 하나 증가 (다음 위치로)
```

### 2. deQueue (디큐)
**데이터를 큐의 앞쪽에서 꺼내는 작업**

```c
// deQueue 작업의 개념
data = queue[front];  // front 위치의 데이터 꺼냄
front = front + 1;    // front를 하나 증가 (다음 위치로)
```

### 3. front (프론트) / head (헤드)
**큐의 맨 앞을 가리키는 위치**
- 다음에 **데이터가 나갈 위치**
- deQueue 시 front가 증가

### 4. rear (리어) / tail (테일)
**큐의 맨 뒤를 가리키는 위치**
- 다음에 **데이터가 들어갈 위치**
- enQueue 시 rear가 증가

---

## 배열로 큐 구현하기

### 기본 코드 구조

```c
#include <stdio.h>

int main() {
    // 큐에 넣을 값들을 미리 준비
    int values[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // 큐 배열 생성 (크기 100)
    int queue[100];
    
    // front와 rear 초기화 (둘 다 0부터 시작)
    int front = 0;
    int rear = 0;
    
    return 0;
}
```

**변수 설명:**
- `values[]`: 큐에 넣을 데이터들
- `queue[100]`: 실제 큐로 사용할 배열
- `front`: 데이터가 나갈 위치 (처음에는 0)
- `rear`: 데이터가 들어갈 위치 (처음에는 0)

---

### enQueue 구현 (데이터 삽입)

```c
// enQueue: 큐에 데이터 삽입하기
printf("enQueue (삽입):\n");

// values 배열의 모든 값을 큐에 삽입
for(int i = 0; i < sizeof(values) / sizeof(int); i++) {
    queue[rear] = values[i];  // rear 위치에 데이터 저장
    printf("%d ", values[i]);  // 저장한 값 출력
    rear++;  // rear를 다음 위치로 이동
}

printf("\n");
```

**코드 한 줄씩 분석:**

```c
for(int i = 0; i < sizeof(values) / sizeof(int); i++)
```
- `sizeof(values)`: values 배열의 전체 크기 (바이트)
- `sizeof(int)`: int 하나의 크기 (4바이트)
- `sizeof(values) / sizeof(int)`: 배열의 원소 개수
- 예: values가 10개면 → 40바이트 / 4바이트 = 10개

**왜 이렇게 계산할까요?**
- 배열의 크기를 직접 세지 않아도 됩니다
- int가 4바이트이므로, 전체 크기를 4로 나누면 개수가 나옵니다

```c
queue[rear] = values[i];  // rear 위치에 값 저장
rear++;                   // rear를 증가
```

**동작 과정:**
1. 처음: rear = 0, queue[0]에 1 저장, rear → 1
2. 다음: rear = 1, queue[1]에 2 저장, rear → 2
3. 다음: rear = 2, queue[2]에 3 저장, rear → 3
4. ... 반복

```
삽입 후 상태:
front              rear
  ↓                 ↓
 [1][2][3]...[10] [ ][ ]...
```

---

### deQueue 구현 (데이터 삭제)

```c
// deQueue: 큐에서 데이터 꺼내기
printf("deQueue (삭제):\n");

// front가 rear에 도달할 때까지 (큐가 빌 때까지)
for(int i = 0; front < rear; i++) {
    printf("%d ", queue[front]);  // front 위치의 값 출력
    front++;  // front를 다음 위치로 이동
}

printf("\n");
```

**코드 한 줄씩 분석:**

```c
for(int i = 0; front < rear; i++)
```
- `front < rear`: front가 rear보다 작을 때만 반복
- front와 rear가 같아지면 큐가 비었다는 의미

**왜 front < rear일까요?**
```
예시:
front=5, rear=8 → 아직 3개 남음 (5, 6, 7번 위치)
front=8, rear=8 → 비어있음 (더 이상 꺼낼 게 없음)
```

```c
printf("%d ", queue[front]);  // 현재 front의 값 출력
front++;                      // front를 증가
```

**동작 과정:**
1. 처음: front = 0, queue[0] 출력 (1), front → 1
2. 다음: front = 1, queue[1] 출력 (2), front → 2
3. 다음: front = 2, queue[2] 출력 (3), front → 3
4. ... 반복

```
삭제 후 상태:
                  front, rear
                      ↓
 [ ][ ][ ]...[ ] [10] [ ][ ]...
 (비워짐)
```

---

## 완성된 큐 예제

```c
#include <stdio.h>

int main() {
    // 큐에 넣을 데이터
    int values[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // 큐 생성
    int queue[100];
    int front = 0;  // 앞쪽 위치
    int rear = 0;   // 뒤쪽 위치
    
    // ===== enQueue: 데이터 삽입 =====
    printf("enQueue (들어가는 순서):\n");
    for(int i = 0; i < sizeof(values) / sizeof(int); i++) {
        queue[rear] = values[i];
        printf("%d ", values[i]);
        rear++;
    }
    printf("\n\n");
    
    // ===== deQueue: 데이터 삭제 =====
    printf("deQueue (나가는 순서):\n");
    for(int i = 0; front < rear; i++) {
        printf("%d ", queue[front]);
        front++;
    }
    printf("\n");
    
    return 0;
}
```

**실행 결과:**
```
enQueue (들어가는 순서):
1 2 3 4 5 6 7 8 9 10

deQueue (나가는 순서):
1 2 3 4 5 6 7 8 9 10
```

**결과 분석:**
- 들어가는 순서: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
- 나가는 순서: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
- **순서가 똑같습니다!** → 선입선출(FIFO) 확인!

---

## 큐와 스택 비교

### 같은 데이터로 비교해보기

**데이터 삽입 순서:** 1, 2, 3, 4, 5

#### 스택 (LIFO)
```
삽입: 1 → 2 → 3 → 4 → 5
      [5]
      [4]
      [3]
      [2]
      [1]

삭제: 5 → 4 → 3 → 2 → 1
      (역순으로 나옴!)
```

#### 큐 (FIFO)
```
삽입: 1 → 2 → 3 → 4 → 5
      [1][2][3][4][5]

삭제: 1 → 2 → 3 → 4 → 5
      (같은 순서로 나옴!)
```

---

## 실전 예제: 프린터 대기열

```c
#include <stdio.h>
#include <string.h>

int main() {
    // 인쇄 대기 문서들
    char* documents[] = {
        "보고서.pdf",
        "이력서.docx", 
        "사진.jpg",
        "계약서.pdf"
    };
    
    // 문서 큐 (문자열 포인터 배열)
    char* print_queue[100];
    int front = 0;
    int rear = 0;
    
    // ===== 문서를 프린터 대기열에 추가 =====
    printf("=== 프린터 대기열에 문서 추가 ===\n");
    for(int i = 0; i < 4; i++) {
        print_queue[rear] = documents[i];
        printf("%s 추가됨\n", documents[i]);
        rear++;
    }
    printf("\n");
    
    // ===== 문서를 순서대로 인쇄 =====
    printf("=== 인쇄 시작 ===\n");
    while(front < rear) {
        printf("%s 인쇄 중...\n", print_queue[front]);
        front++;
    }
    printf("모든 문서 인쇄 완료!\n");
    
    return 0;
}
```

**실행 결과:**
```
=== 프린터 대기열에 문서 추가 ===
보고서.pdf 추가됨
이력서.docx 추가됨
사진.jpg 추가됨
계약서.pdf 추가됨

=== 인쇄 시작 ===
보고서.pdf 인쇄 중...
이력서.docx 인쇄 중...
사진.jpg 인쇄 중...
계약서.pdf 인쇄 중...
모든 문서 인쇄 완료!
```

**분석:**
- 먼저 추가한 문서가 먼저 인쇄됩니다
- 공정한 순서대로 처리됩니다
- 실제 프린터도 이런 방식으로 동작합니다!

---

## 큐가 사용되는 곳

### 1. 운영체제의 작업 스케줄링
```
프로세스 A → 프로세스 B → 프로세스 C
            (순서대로 CPU 할당)
```

### 2. 네트워크 데이터 전송
```
패킷1 → 패킷2 → 패킷3
       (순서대로 전송)
```

### 3. 콜센터 대기 시스템
```
고객1 → 고객2 → 고객3
       (먼저 건 사람이 먼저 연결)
```

### 4. 게임의 턴제 시스템
```
플레이어1 → 플레이어2 → 플레이어3
          (순서대로 턴 진행)
```

---

## 핵심 요약

### 큐의 기본 구조

```c
// 큐 생성
int queue[크기];
int front = 0;  // 앞쪽 (나가는 곳)
int rear = 0;   // 뒤쪽 (들어오는 곳)

// enQueue (삽입)
queue[rear] = 데이터;
rear++;

// deQueue (삭제)
데이터 = queue[front];
front++;

// 큐가 비었는지 확인
if(front == rear) {
    // 비어있음
}
```

### 스택 vs 큐

| 항목 | 스택 | 큐 |
|------|------|-----|
| 원리 | LIFO (후입선출) | FIFO (선입선출) |
| 삽입 | top 위치 | rear 위치 |
| 삭제 | top 위치 | front 위치 |
| 포인터 | top 1개 | front, rear 2개 |
| 순서 | 역순 | 순서 유지 |

### 주의사항

✅ **enQueue 할 때:**
- rear 위치에 데이터 저장
- rear를 증가시킴

✅ **deQueue 할 때:**
- front 위치의 데이터 꺼냄
- front를 증가시킴

✅ **비었는지 확인:**
- `front == rear`이면 큐가 비어있음

✅ **찼는지 확인:**
- `rear == 배열크기`이면 큐가 가득 참

---

## 다음 단계

이제 스택과 큐의 개념을 이해했으니, **메모리 할당**에 대해 배워보겠습니다. 변수와 배열이 실제로 컴퓨터 메모리에 어떻게 저장되는지, 주소는 무엇인지 알아보겠습니다!