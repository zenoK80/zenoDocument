---
title: "메모리 할당과 주소 개념"
description: "변수와 배열이 메모리에 어떻게 저장되는지, 주소란 무엇인지 이해합니다."
slug: "memory-allocation-address"
sidebar_position: 4
---

# 메모리 할당과 주소 개념

## 메모리란 무엇인가요?

메모리는 **데이터를 저장하는 공간**입니다. 변수와 배열의 값들이 실제로 저장되는 곳이죠.

### 메모리의 구조

```
메모리는 바이트 단위로 나뉩니다:

주소      내용
1000  [        ]  ← 1바이트
1001  [        ]  ← 1바이트
1002  [        ]  ← 1바이트
1003  [        ]  ← 1바이트
1004  [        ]  ← 1바이트
...
```

**핵심 개념:**
- 메모리는 **1바이트씩** 나누어져 있습니다
- 각 바이트마다 고유한 **주소**가 있습니다
- 주소는 숫자로 표현됩니다 (예: 1000, 1001, 1002...)

---

## 변수는 메모리에 어떻게 저장될까요?

### 정수형 변수의 크기

```c
int a;  // 정수형 변수 선언
```

**중요한 사실:**
- `int` 타입은 **4바이트** 크기입니다
- 따라서 변수 a는 메모리에서 4바이트를 차지합니다

### 메모리 할당 예시

```c
int a = 100;
int b = 200;
```

```
메모리 상태:

주소      변수    값
1036  [        ]
1037  [        ]  a = 100
1038  [        ]  (4바이트)
1039  [        ]
-----------------------
1040  [        ]
1041  [        ]  b = 200
1042  [        ]  (4바이트)
1043  [        ]
```

**설명:**
- `a`는 1036번지부터 시작
- 4바이트를 차지하므로 1036~1039까지 사용
- `b`는 1040번지부터 시작
- 마찬가지로 1040~1043까지 사용

---

## 주소란 무엇인가요?

### 주소의 개념

**주소(Address)**: 메모리에서 변수가 **시작하는 위치의 번호**

```
변수 a가 1036번지에서 시작한다면:
→ "a의 주소는 1036입니다"
```

### 주소를 확인하는 방법: & 연산자

```c
int a = 100;
printf("a의 주소: %p\n", &a);  // & 기호 사용!
```

**& 연산자:**
- **주소 연산자** (Address Operator)
- 변수 앞에 `&`를 붙이면 그 변수의 주소를 얻습니다
- `&a` → "a의 주소"를 의미

**출력 형식:**
- `%p`: 주소를 출력하는 형식 지정자
- "pointer"의 p를 의미합니다

---

## 정수형 변수의 메모리 할당 실습

### 코드 예제

```c
#include <stdio.h>

int main() {
    // 정수형 변수 두 개 선언 및 초기화
    int a = 100;
    int b = 200;
    
    // 변수의 값 출력
    printf("a의 값: %d\n", a);
    printf("b의 값: %d\n", b);
    
    // 변수의 주소 출력
    printf("a의 주소: %p\n", &a);  // & 연산자 사용
    printf("b의 주소: %p\n", &b);
    
    return 0;
}
```

**코드 한 줄씩 분석:**

```c
int a = 100;
```
- 정수형 변수 a를 선언
- 메모리에 4바이트 공간 할당
- 그 공간에 100을 저장

```c
printf("a의 값: %d\n", a);
```
- `a`: 변수 a의 **값**을 의미 (100)
- `%d`: 정수를 출력하는 형식

```c
printf("a의 주소: %p\n", &a);
```
- `&a`: 변수 a의 **주소**를 의미
- `%p`: 주소를 출력하는 형식
- 실행할 때마다 주소는 **달라질 수 있습니다**

### 실행 결과 예시

```
a의 값: 100
b의 값: 200
a의 주소: 0x7994010
b의 주소: 0x7994004
```

**결과 분석:**
- 값은 항상 같습니다 (100, 200)
- 주소는 실행할 때마다 다를 수 있습니다
- `0x`는 16진수를 의미합니다

**왜 주소가 달라질까요?**
- 프로그램을 실행할 때마다 메모리의 빈 공간에 변수를 만듭니다
- 매번 다른 위치가 비어있을 수 있습니다
- 따라서 주소는 실행마다 달라질 수 있습니다

---

## 배열은 메모리에 어떻게 저장될까요?

### 배열의 특징

```c
int arr[3] = {10, 20, 30};
```

**핵심 특징:**
- 배열은 **연속된 메모리 공간**을 사용합니다
- 각 요소는 **순서대로 나란히** 저장됩니다

### 메모리 할당 예시

```c
int aa[3] = {10, 20, 30};
```

```
메모리 상태:

주소      요소     값
1031  [        ]
1032  [        ]  aa[0] = 10
1033  [        ]  (4바이트)
1034  [        ]
-----------------------
1035  [        ]
1036  [        ]  aa[1] = 20
1037  [        ]  (4바이트)
1038  [        ]
-----------------------
1039  [        ]
1040  [        ]  aa[2] = 30
1041  [        ]  (4바이트)
1042  [        ]
```

**설명:**
- `aa[0]`: 1031번지부터 시작 (1031~1034)
- `aa[1]`: 1035번지부터 시작 (1035~1038)
- `aa[2]`: 1039번지부터 시작 (1039~1042)
- **연속된 공간**에 저장됨!

---

## 배열의 주소

### 배열 이름 = 배열의 시작 주소

```c
int aa[3] = {10, 20, 30};

// 다음 두 줄은 같은 의미입니다!
printf("%p\n", aa);      // 배열 이름만 사용
printf("%p\n", &aa[0]);  // 첫 번째 요소의 주소
```

**중요한 개념:**
- 배열 이름(`aa`)은 배열의 **시작 주소**를 나타냅니다
- `aa` = `&aa[0]` (똑같습니다!)
- 따라서 `&` 연산자를 붙이지 않아도 됩니다

### 각 요소의 주소 확인하기

```c
int aa[3] = {10, 20, 30};

// 각 요소의 주소 출력
printf("aa[0]의 주소: %p\n", &aa[0]);  // & 필요
printf("aa[1]의 주소: %p\n", &aa[1]);  // & 필요
printf("aa[2]의 주소: %p\n", &aa[2]);  // & 필요

// 배열 전체의 시작 주소
printf("aa의 주소: %p\n", aa);  // & 불필요
```

**차이점 정리:**
- `aa[0]`, `aa[1]`, `aa[2]`: 각 요소의 **값**
- `&aa[0]`, `&aa[1]`, `&aa[2]`: 각 요소의 **주소** (& 필요)
- `aa`: 배열 전체의 **시작 주소** (& 불필요)

---

## 정수형 배열의 메모리 할당 실습

### 완전한 코드 예제

```c
#include <stdio.h>

int main() {
    // 정수형 배열 선언 및 초기화
    int aa[3] = {10, 20, 30};
    
    // ===== 각 요소의 값과 주소 출력 =====
    printf("=== 배열 요소들 ===\n");
    printf("aa[0]의 값: %d, 주소: %p\n", aa[0], &aa[0]);
    printf("aa[1]의 값: %d, 주소: %p\n", aa[1], &aa[1]);
    printf("aa[2]의 값: %d, 주소: %p\n", aa[2], &aa[2]);
    
    printf("\n");
    
    // ===== 배열 전체의 주소 출력 =====
    printf("=== 배열 전체 ===\n");
    printf("aa의 주소: %p\n", aa);        // 배열 이름
    printf("&aa[0]의 주소: %p\n", &aa[0]);  // 첫 요소 주소
    
    // 두 주소가 같은지 확인
    if(aa == &aa[0]) {
        printf("→ aa와 &aa[0]는 같은 주소입니다!\n");
    }
    
    return 0;
}
```

**코드 한 줄씩 분석:**

```c
int aa[3] = {10, 20, 30};
```
- 크기 3인 정수 배열 선언
- 메모리에 12바이트(4×3) 할당
- 10, 20, 30을 순서대로 저장

```c
printf("aa[0]의 값: %d, 주소: %p\n", aa[0], &aa[0]);
```
- `aa[0]`: 첫 번째 요소의 값 (10)
- `&aa[0]`: 첫 번째 요소의 주소
- 한 줄에 값과 주소를 같이 출력

```c
printf("aa의 주소: %p\n", aa);
```
- `aa`: 배열 이름만 사용
- 배열의 시작 주소를 출력
- `&` 연산자 불필요!

```c
if(aa == &aa[0]) {
```
- `aa`와 `&aa[0]`를 비교
- 두 값이 같은지 확인

### 실행 결과 예시

```
=== 배열 요소들 ===
aa[0]의 값: 10, 주소: 0x1467780
aa[1]의 값: 20, 주소: 0x1467784
aa[2]의 값: 30, 주소: 0x1467788

=== 배열 전체 ===
aa의 주소: 0x1467780
&aa[0]의 주소: 0x1467780
→ aa와 &aa[0]는 같은 주소입니다!
```

**결과 분석:**

```
주소 차이를 보세요:
0x1467780 (aa[0])
0x1467784 (aa[1]) ← 80 + 4 = 84
0x1467788 (aa[2]) ← 84 + 4 = 88
```

- 주소가 **4씩 증가**합니다 (정수형은 4바이트이므로)
- `aa`와 `&aa[0]`의 주소가 **똑같습니다**
- 배열은 **연속된 공간**에 저장됩니다

---

## sizeof 연산자로 크기 확인하기

### sizeof란?

**sizeof**: 데이터 타입이나 변수의 **크기(바이트)**를 알려주는 연산자

```c
#include <stdio.h>

int main() {
    int a;
    int arr[10];
    
    // 타입의 크기
    printf("int의 크기: %lu 바이트\n", sizeof(int));
    printf("char의 크기: %lu 바이트\n", sizeof(char));
    
    // 변수의 크기
    printf("변수 a의 크기: %lu 바이트\n", sizeof(a));
    
    // 배열의 크기
    printf("배열 arr의 크기: %lu 바이트\n", sizeof(arr));
    printf("배열의 요소 개수: %lu\n", sizeof(arr) / sizeof(int));
    
    return 0;
}
```

**실행 결과:**
```
int의 크기: 4 바이트
char의 크기: 1 바이트
변수 a의 크기: 4 바이트
배열 arr의 크기: 40 바이트
배열의 요소 개수: 10
```

**계산 설명:**
- `sizeof(arr)`: 배열 전체 크기 = 40바이트 (4 × 10)
- `sizeof(int)`: int 하나의 크기 = 4바이트
- `40 / 4 = 10`: 배열의 요소 개수

### sizeof를 이용한 배열 순회

```c
int values[] = {1, 2, 3, 4, 5};

// 배열 크기를 자동으로 계산
int count = sizeof(values) / sizeof(int);

for(int i = 0; i < count; i++) {
    printf("%d ", values[i]);
}
```

**장점:**
- 배열 크기를 직접 세지 않아도 됩니다
- 배열 크기가 바뀌어도 코드 수정이 필요 없습니다

---

## 메모리와 포인터의 관계 (미리보기)

### 왜 메모리 주소를 배울까요?

다음 강의에서 배울 **포인터(Pointer)**는 주소를 다루는 개념입니다:

```c
int a = 100;
int *p = &a;  // p는 a의 주소를 저장 (포인터)

printf("a의 값: %d\n", a);      // 100
printf("a의 주소: %p\n", &a);   // 0x7ffe...
printf("p가 가리키는 주소: %p\n", p);  // 0x7ffe... (a의 주소)
printf("p가 가리키는 값: %d\n", *p);   // 100 (a의 값)
```

**포인터를 이해하려면:**
- 변수가 메모리에 어떻게 저장되는지 알아야 합니다
- 주소가 무엇인지 알아야 합니다
- 주소를 어떻게 확인하는지 알아야 합니다

→ 그래서 이번 강의가 중요합니다!

---

## 핵심 요약

### 메모리 구조

```
메모리 = 바이트 단위로 나뉜 저장 공간
각 바이트는 고유한 주소를 가짐

주소    내용
1000  [1바이트]
1001  [1바이트]
1002  [1바이트]
...
```

### 변수와 주소

```c
// 정수형 변수 (4바이트)
int a = 100;

// 값 vs 주소
a     → 변수의 값 (100)
&a    → 변수의 주소 (예: 0x7ffe1234)

// 출력
printf("%d", a);   // 값 출력 (%d)
printf("%p", &a);  // 주소 출력 (%p)
```

### 배열과 주소

```c
// 배열 선언
int arr[3] = {10, 20, 30};

// 배열 이름 = 시작 주소
arr == &arr[0]  // 같음!

// 각 요소의 주소
&arr[0]  // 첫 번째 요소 주소
&arr[1]  // 두 번째 요소 주소
&arr[2]  // 세 번째 요소 주소
```

### 중요 연산자

```c
&  → 주소 연산자 (Address Operator)
     변수의 주소를 얻음

sizeof → 크기 연산자
         데이터 타입/변수의 크기(바이트)를 얻음

%p → 주소 출력 형식 지정자
     printf에서 주소를 출력할 때 사용
```

---

## 실전 연습 문제

### 문제 1: 주소 차이 계산하기

```c
#include <stdio.h>

int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    
    // TODO: 각 요소의 주소를 출력하고,
    // 주소 간의 차이가 4바이트인지 확인하세요
    
    return 0;
}
```

### 문제 2: sizeof 활용하기

```c
#include <stdio.h>

int main() {
    char str[] = "Hello";
    int numbers[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // TODO: sizeof를 사용하여
    // 1. str 배열의 크기 출력
    // 2. numbers 배열의 요소 개수 출력
    
    return 0;
}
```

### 정답 예시

**문제 1 정답:**
```c
for(int i = 0; i < 5; i++) {
    printf("arr[%d]의 주소: %p\n", i, &arr[i]);
}
// 주소 간 차이는 4바이트씩 증가합니다
```

**문제 2 정답:**
```c
printf("str 크기: %lu 바이트\n", sizeof(str));
printf("numbers 요소 개수: %lu\n", sizeof(numbers) / sizeof(int));
```

---

## 다음 단계

메모리와 주소의 개념을 이해했으니, 다음 강의에서는 **포인터(Pointer)**에 대해 배워보겠습니다. 포인터는 주소를 저장하는 변수로, C언어의 가장 강력한 기능 중 하나입니다!

**미리 알아두면 좋은 것:**
- 주소는 메모리 위치를 나타내는 숫자입니다
- `&` 연산자로 변수의 주소를 얻을 수 있습니다
- 포인터는 이 주소를 저장하고 활용합니다
- 메모리 구조를 이해하면 포인터가 쉬워집니다!