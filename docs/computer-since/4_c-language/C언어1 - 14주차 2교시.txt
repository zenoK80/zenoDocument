 안녕하십니까. 학생 여러분 시어너 1 14주차 2교시 표준 라이브러리 함수에 대해서 살펴보도록 하겠습니다
 이제 학기 막바지에 이제 다 와서요 우리가 기본적인 시어너의 내용들을 쭉 살펴봤구요
 마무리를 하면서 우리가 지금까지 사용했던 함수들을 모아놓은 표준 라이브러리
 함수에 대해서 좀 더 살펴보도록 하겠습니다 먼저 표준 라이브러리 함수의 개념은요
 C 표준 라이브러리 라고 얘기를 하는데 시어너를 위한 표준 라이브러리에요 그리고 ANSI C 표준에 의해서
 명시되어 있습니다 자 여기서 이제 표준 이라는 단어 표준은 뭔가 기준점이 있다는 거에요
 전 세계적으로 공통된 기준으로 사용되는 라이브러리 라이브러리는 예전에 제가 한번 설명한 적이 있는데
 뜻이 원래는 도서관 이라는 뜻이잖아요 우리가 도서관에 가면 많은 책들이 있습니다
 그리고 여러분들이 그 책을 참조해서 무언가를 작성을 뭐 레포트를 작성을 하던 뭐를 작성하는 거잖아요 그쵸
 마찬가지로 우리가 프로그램 라이브러리라고 하면 그 라이브러리를 참조해서 프로그램을 작성할 때
 기준이 되는 참조문서라는 얘기입니다 이런 참조문서를 우리가 가지고 와서
 가장 많이 지금까지 사용했던 게 프린트f 에요 그리고 이 프린트f 는 어디에 들어가 있었어요
 네 바로 std io.h 라는 헤더 안에 들어가 있었습니다 이 헤더 머리말 이라고 하잖아요 머리말에는
 이 프린트f가 동작할 수 있는 기능에 문서가 이렇게 코딩이 되어 있는 문서가 이렇게 있어요
 문서라기보다 이제 코딩 자체겠죠 그럼 여러분들이 요거를 이게 함수 잖아요
 요 함수를 호출을 하면 여기에 적혀 있는 곳으로 가서요 어떻게 요 헤더 파일을 참조해서 아 std io.h 가
 어딘가에 있겠구나 그리고 찾아서 프린트f 함수가 있는 곳으로 가서 읽고 처리하고 다시 호출한 곳으로
 되돌아와서 화면에 출력하게 되는 겁니다 이게 전체적인 라이브러리가 하는 역할이에요
 그래서 이런 라이브러리가 없다면 우리는 프린트f를 매번 이제 사용할 수가 없구요
 여러분들이 화면에 출력하기 위해서 여러분들의 어떤 코드를 직접 만들어서 화면에 출력을 해야 됩니다
 그리고 다른 프로그램을 만들 때는 또 똑같은 코드를 갖고 와서 또 붙여줘야 되고 엄청나게 번거로운 작업들을 해줘야 될 수도 있어요
 하지만 자 그러한 노력을 우리가 충분히 줄여줄 수 있는 고급 언어를 사용하기 때문에 시어너에서는 이런 라이브러리를 제공해서
 편리하게 코딩 할 수 있게 많은 함수들을 제공하고 있다는 얘기입니다
 자 c 표준 라이브러리는 iso c 라이브러리라고도 불려요 같은 말입니다 근데 이제 보통 다 줄여서
 c라는 언어를 사용하니까 그냥 표준 라이브러리 아니면 또는 그냥 라이브러리라고도 불립니다
 자 여기 라이브러리는 매크로 타입의 정의 그리고 문자의 처리나 수학적인 연산 입출력 프로세스 메모리 할단과 다른 운영체제 서비스 같은 작업을 위한 함수들을 제공한다
 그리고 시어너 표준 규약에 의해서 모든 컴파일러가 기본적으로 제공하도록 약속되어 있는 함수들입니다
 그래서 제가 일전에 이런 얘기를 했어요 리눅스라는 운영체제에서 c 를 작성하는 것하고 윈도우에서
 c 를 작성하는 것하고는 조금 다를 수 있습니다 이거는 우리가 비주 스튜디오 c 를 썼느냐 아니면 또 볼랜드 c 를 썼느냐
 이게 조금 차이점은 있어요 그래서 scanf나 scan_s 이런 차이점은 조금씩 있지만 그래도 전체적으로 봤을 때는
 이 라이브러리 표준에 따라서 우리가 작성할 수 있습니다
 요즘에 볼랜드 c나 리눅스에 있는 gcc 같은 경우에도 다 scanf_s 를 지향하는 형태로 바뀌어 오고 있어요
 그래서 왜 교제에서 이렇게 보면 비주 스튜디오 코드를 이용하는데도 scanf 이렇게 사용을 하느냐
 바로 scanf가 공통적으로 우리가 사용하는 라이브러리 표준이라는 얘기입니다
 그래서 제가 처음 교실 때 scanf_s 를 사용하지 않고 활용하는 방법을 한번 설명한 적이 있습니다
 근데 그게 매번 세팅을 해야 되고 좀 번거로운 일 때문에 저는 그냥 c습에서 scan_s를 사용하지만
 표준은 scan_s예요 scanf입니다
 자 그래서 이렇게 표준을 제공하는 게 바로 라이브러리다 표준 라이브러리다
 자 표준 함수들의 선언 표준 헤더 파일이 있으므로 사용하기 위해서는 함수가 선언된 표준 헤더 파일
 이 sharp include를 해줘야 됩니다 그리고 항상 이름이 있고요 그 라이브러리 이름이 있고 .h라는 확장자를 사용하는 거예요 헤더의 약자입니다
 그리고 sharp include를 꼭 해줘야 돼요 자 이 파일에는 함수의 프로트 타입이 선언되어 있고 구조체 등의 데이터 구조가 정해져 있습니다
 이미 우리 지난 교시에서 구조체 배웠죠 그런 구조체하고 함수의 프로트 타입 즉 함수의 원형
 하고 그 다음에 실제 실행하는 동작 코드 이런 것들이 다 설계가 되어 있습니다
 그래서 예를 들어서 printf 함수는 프로그램의 맨 첫 줄에 sharp include 스탠다드 io.h를 썼기 때문에
 printf 함수를 사용 가능하게 된다는 겁니다
 그래서 C 표준 라이브러리 API에는 많은 헤더 파일들이 정의되어 있고요 각 헤더 파일은 하나 이상의 함수 정의와 데이터 타입 정의 그리고
 여러 가지 매크로들을 포함하고 있습니다 그래서 이런 어떤 그 표준 함수들을 사용하기 위해서는 헤더 파일을 꼭 include 해서
 우리가 그대로 가지고 와서 사용이 가능하다
 자 그래서 좀 자주 사용하는 주요한 표준 헤더들의 파일을 좀 살펴보면요
 가장 보편적으로 가장 그리고 보편적으로 많이 사용하는 헤더 파일이 바로 스탠다드 io.h입니다
 표준 입출력과 관련된 거예요 standard input output 표준 입출력 그래서 여기에는 printf, scanf, get char, foff
 자 이거는 파일을 열어줄 때 f식은 파일을 찾을 때 시크는 찾다 라는 거죠 이런 기능들 하는 함수들을 포함하고 있구요
 string.h 같은 경우에는 메모리와 문자열의 처리에 사용이 됩니다 그래서 여기에 보면 strcat, strcmp, strcpy
 요것도 배웠고 몇 가지 strlen 해서 문자열의 길이를 알아내고 문자열을 복사하고 문자열을 연결시켜주고
 자 이런 다양한 기능들의 함수들이 또 제공이 되고 있구요 자 그리고 ctype.h에 가면 문자 검사 검사 및 변환 이라는 기능을 하는 함수들이 있습니다
 그래서 isalnum 하면 is a number 뭐 알파벳이냐 넘버냐 뭐 이런 검사들 그래서 문자를 검사했을 때 이게 숫자냐 아니면
 문자냐 이런 것들이 또 체크가 가능한 함수들이 있구요 자 그리고 mes.h mes 딱 보면 아 수학과 관련된 거구나
 그래서 여기에 생각함수 지수 절대값 함수 수학함수 다양한 수학함수들이 이렇게 포함이 되어 있고
 그래서 sine, cosine, tangent, log, exponential 자 그 다음에 이거 fmode, square root, abs 절대값 이런 것들을 구해주는 함수들을 사용할 수가 있습니다
 자 그리고 stdlib.h 이거 많이 봤었죠 우리 메모리 동적할당할 때 murloc 같은 거 여기 나오네요 free and std to do a to f
 칼로 이런 것들이 다 stdlib.h에 들어가 있구요 그 다음에 가상난수를 발생하는 것도 있습니다
 문자열을 변환하는 것도 여기에 포함이 되어 있어요 a to f 자 이런 거 그 다음에 동적 메모리 할당할 때 또 따로 헤드파일을 요즘 만들어서 사용하는 게 바로 murloc.h 였습니다
 메모리 할당에 가능함수 caloc이나 murloc free 해서 여기에 포함될 때 내용을 따로 동적 메모리에만 할당하게 사용하게 헤드파일을 따로 분리해서 사용하구요
 자 이것도 굉장히 또 많이 사용합니다 time.h time 시간과 관련된 거겠죠
 자 우리가 프로그램을 하면서 시간과 관련된 내용들을 많이 만들어 낼 수가 있는데 뭐 예약을 한다든지 이런 것들
 자 오늘 날짜와 시간 이런 것들을 알아서 우리가 또 계산을 해서 예약을 하고 이런 것들을 다 만들어줘야 되죠
 그래서 컴퓨터에 있는 내부적인 시간 그리고 cpu의 클럭 속도 이런 것들을 이용해서 다양한 결과물들을 만들어줄 수 있는 함수들을 제공합니다
 클럭 c타임 s c타임 get 데이터 타임 f타임 이런 것들이 전부 함수들로 time.h에 포함되어 있습니다
 자 우리가 standard io.h에서 printf, scanf 내용들은 이미 많이 학습을 했어요
 앞에서 제가 얘기했던 그 함수들 중에서 이제 몇 가지를 조금 설명을 하면서
 자 우리 또 standard 표준 라이브러리를 한번 학습해 보죠 fopen, f는 뭐를 지칭하냐면 file 입니다
 그리고 open은 열어라 그럼 file을 열어주는 거죠 즉 어떤 파일 이름이 있다면 그 파일 이름을 가진 지정한 파일을 열어줍니다
 아주 간단한 기능을 하는 거죠 자 우리가 이제 시어너 기초에서는 다루지는 않았지만
 파일 전체를 읽어서 파일 안에 있는 내용들을 가지고 무언가를 해줄 수 있는 프로그램을 만든다면
 기본적으로 우리가 파일을 오픈을 해줘야 안에 있는 내용들을 읽어 볼 수가 있을 거 아니에요
 자 그럴 때 사용하는 함수 그리고 여기도 f가 붙었네요 뭐 지칭한다 그랬어요?
 뭐 지칭한다 그랬어요? file 그리고 seek는 찾는다 그랬습니다
 그래서 위에서 언급한 fopen 함수를 이용해서 호칠된 파일에서
 현재 위치를 이동시킬 수 있는 함수가 바로 fseq 입니다
 간단하게만 얘기하면 우리가 파일을 열었어요 그래서 여기 안에 뭔가가 이렇게 막 적혀 있을 거 아니에요
 근데 파일을 열었을 때 시작하는 점 이거를 fseq로 찾아주는 겁니다
 현재 위치 그래서 가끔 여러분들 어떤 문서를 저장하고 닫았다가 다시 열 때 처음에서 시작하는 게 아니라 가끔
 내가 끝낸 시점부터 시작하는 경우를 종종 막다뜨리게 됩니다
 이거는 fseq 함수에서 이 현재 위치를 기억하기 때문에 다음 번에 열었을 때 내가 마지막 편집 포인트에
 그 커서가 위치하고 저장이 되고 끝나게 되면 거기서부터 시작이 가능하다 라는 겁니다
 이럴 때 우리는 fseq 함수를 이용해서 이런 기능들을 만들어 줄 수 있어요
 자 mes.h 같은 경우에는 다양한 함수들이 있는데요 fmode 함수는 x/y의 부동소수점의 나머지를 연산해 주는 그러한 역할을 합니다
 mode 함수는 연산자에서 제가 배웠는데 mode는 % 나머지 연산이죠
 이게 mode 영어로 mode라고 하는데 이거를 fmode라고 해서 x와 y의 부동소수점의 나머지를 연산하는 그런 함수
 exp, exponential 함수는 이런 형태 지수를 구하는 그런 함수입니다 square root는 이거죠 제곱근 이거를 구하는 함수
 그 다음에 abs 함수는 절대값을 구하는 겁니다 그래서 mes.h를 include 하고 그 다음에 내가 어떤 값에 절대값을 이용해서 무언가를 해야 된다 그러면
 abs 함수에다가 그대로 넣어주면 돼요 이렇게 활용하는 게 바로 표준 라이브러리입니다
 printf나 scanf를 활용하는 것처럼 그대로 인자에다가 무언가를 넣어주면 값이 만들어지게 됩니다
 그래서 이런 라이브러리 함수에서 중요한 부분은 함수의 원형을 찾는 방법들을 나중에 고급 시어너에서 조금 더 배우게 되는 겁니다
 함수의 원형을 가지고 내가 무엇을 어떻게 만들어내는지 이거를 활용하는 방법들
 자 그 다음에 std-lib.h에는 우리 merlok 이런 함수들이 있다고 그랬는데요 특히 이런 함수가 굉장히 많이 쓰입니다
 랜드 함수 랜드 랜덤의 약자예요 자 랜덤은 무작위수입니다 난수 라고도 하죠
 그래서 0부터 랜드 맥스 범위 내에서 정수형 난수를 반환하게 됩니다
 그래서 0부터 제가 지정한 범위 내에서 정수형 난수를 반환하게 됩니다 랜드 언더맥 맥스는 std-lib.h
 패더 파일에 정의되어 있는 랜드 함수가 반환하는 체대 값을 나타내는 상수예요
 내가 만약에 45라고 정해줬으면 우리 로또가 1부터 45잖아요 그쵸? 이렇게 하면
 요거를 45까지 번호를 줘서 체대 값을 나타내는 상수로 표현해주면 0 1부터 45 사이의 번호를 랜덤 넘버를 생성 하겠죠
 자 이럴 때 즉 무작위수를 우리가 만들어주고 싶을 때는 이 랜드 함수를 사용해 주면 됩니다
 자 그 다음에 살펴볼 함수는 str-tod 함수입니다 수로 구성한 문자열을 계산 이 str이 들어가면 다 문자와 관련된다고 생각하면 되구요
 그리고 tod니까 뭔가를 이제 변환해 주는데 2a-double 이렇게 해주면 됩니다 str-2-double
 이거의 약자에요 그래서 수로 구성된 문자열을 계산하는 데 사용하는 겁니다
 문자열은 계산할 때 사용할 수 없어요 무슨 얘기냐면 이거는 문자열 입니다
 근데 계산에 사용하려면 str-2-d 함수를 이용해서
 이거를 정수형이 아니라 실수형으로 바꿔서 6개를 이용해서 실수형으로 바꾸고
 더블 형식 값으로 바꿔서 계산한 다음에 마찬가지 더블 형식 값으로 반환을 하게 됩니다
 이게 str-2-d 함수에요
 자 그 다음에 str-lib.h에 또 많이 사용하는 게 바로 a2i 함수입니다
 a2i 함수를 살펴보면 a2i 이렇게 나누고 읽어줍니다
 자 예제를 보면서 보면 a는 캐릭터의 ASCII, i는 intro 보면 캐릭터 ASCII to interger
 2라는 게 뭐모로 라는 뜻이잖아요
 a로부터 i로, i까지 부터까지 이런 뜻의 내용을 살펴본다면
 ASCII 코드를 interger 형태로 바꿔 주라는 얘기입니다
 즉 우리 ASCII 코드표 예전에 제가 한번 설명한 적이 있는데
 우리가 문자는 컴퓨터가 알아드릴 수가 없어요
 컴퓨터는 오로지 0과 1밖에 모른다 그랬잖아요
 그래서 이 문자를 정수형으로 바꿔주고 정수형을 다시 이진수 형태로 표현을 해주면
 컴퓨터가 아 이거는 대문자 a구나 소문자 a구나 이렇게 알아드릴 수 있다는 얘기입니다
 이게 ASCII 코드표라 그랬어요
 이거를 interger, 즉 정수형으로 바꿔 준다는 겁니다
 자 몇 가지가 있는데요
 a2i 함수, 일반적인 a2i 함수는 문자를 정수 타입으로 변환하는 거고요
 a2f는, f가 뭘까요? 네 바로 실수겠죠, 플롯 문자를 실수 타입으로 변환해 주는 거고
 a2l 같은 경우에는 문자를 long 정수 타입, 긴 정수형 타입으로 변환 가능합니다
 자 이게 a2i의 핵심적인 내용이고요
 자 앞에서 우리가 살펴봤던 stdlib.h에 관련된 몇 가지 함수들을 사용하는 예제예요
 자 그래서 몇 가지 변수들을 이렇게 선언을 했고
 여기에 보면 a2i, 캐릭터형을 interger로 바꿔 주는 거고요
 자 그리고 인트에서도, 여기 str, 문자열이죠
 이거 숫자인데 정수형 그러면 2000이 나오겠죠
 이제 문자열이 아니라
 그리고 a2f는 실수형으로 바꿔 줄 거고요
 그 다음에 long str은 조금 더 긴 정수형으로 바꿔 주게 될 겁니다
 자 그래서 각각을 이렇게 출력해 보면요
 결과값이 아까 문자열 2001, 정수형 2000으로 바꿨고요
 이건 실수형, 긴 정수형인데
 어차피 2000보다 더 길게 표현을 안 하고 그냥 2000이 나오겠죠
 자 이런 함수들을 우리가 stdlib.h에서 찾아서 활용을 해 줄 수가 있습니다
 자 그리고 time.h에는 다양한 시간과 관련된 함수들이 있는데요
 자 clock 함수가 있는데
 프로그램에 의해 프로세스가 소비된 시간을 반환하는 함수입니다
 자 프로세스 CPU가 측정한 프로그램 실행 시간이라 정확하지는 않습니다
 우리가 일반적으로 시간을 보는 게 아니라
 프로세스 CPU가 측정한 프로그램 실행 시간이에요
 그래서 아주 정확한 값은 반환하지는 않습니다
 물론 이거를 측정 값을 높이기 위해서
 다양한 소프트웨어나 아니면 실제 하드웨어를 높여가면서 측정하면
 정확한 값을 얻어낼 수 있지만
 우리가 단순히 이 프로그램이 실행 속도가 얼마나 될까
 하고 어떤 지표를 얻기 위해서는
 이 clock 함수를 이용해서 측정을 해 보면 되고요
 자 여기에서 이런 구조체가 있어요
 자 clock_t, clock ticks의 자료를 담고 있는 자료용으로
 clock의 반환 형용입니다
 약간 구조체 형식으로 반환을 해 줘요
 왜냐면 시간과 관련된 거는 시,분,초
 이런 내용들이 포함이 돼야 되잖아요 그렇죠
 자 그래서 구조체 형식
 그리고 clocks per second는 초당 clock ticks의 수를 나타낸 매크로입니다
 여기에서 이제 매크로를 잠깐 설명을 하면요
 매크로는 어떤 자동화된 형식이라는 거예요
 시원해서는 매크로를 이렇게 대문자로 다 표시를 합니다
 그래서 이 clocks per second를 쓰면
 모든 시스템에서 지금 초당 걸리는 시간을 측정을 해 줄 수가 있습니다
 근데 이거는 시스템마다 조금씩 기본 값이 다르고요
 시간을 표시하기 위해 다음 예제처럼
 우리가 다양한 방식으로 사용이 가능합니다
 먼저 이렇게 time.h를 사용해서
 우리가 시간과 관련된 내용을 사용할 거고요
 그리고 define이 하나 되어 있네요
 정의가 되어 있는데 iteration_time은 만입니다
 만 번 iteration은 반복한다는 거예요
 만 번 반복을 한다는 거예요
 그래서 만 번 반복하는데 얼마나 걸리는지를
 한번 우리가 얻어 보는 겁니다
 이 시간이 얼마나 걸리는지
 자 그래서 clock_t 구조체 형식에
 거기에 멤버 변수가 start라는 게 있어요
 start 에서 clock_t의 start라는 변수를 하나 만들어 준 겁니다
 그리고 clock_t를 이렇게 사용하게 되면
 거기에서 시작 시간을 얻을 수 있어요
 그리고 iteration_time 만 번을 돌면서
 이 구문을 다시 또 만 번 돕니다
 j 그리고 do_something 해서 함수를 하나 후출해 줍니다
 아 여기 do_something은 여기는 뭔가를 하라는 얘기고요
 자 그리고 clock_t에서 end는 clock 해서
 코드 시간을 저장해 줍니다
 그리고 여기에서 걸린 시간을 이렇게 출력을 해줘야 되는데
 자 clock_per_second라는 아까 매크롤을 이용해서
 시스템마다 다르잖아요
 그래서 그걸로 나눠줘야 됩니다
 그래서 end 빼기 start 해서
 그걸 나눈 거를 계산을 해서 얼마나 걸렸는지
 그것들을 이제 해보는 거예요
 자 실행했더니 13.949900 이런 결과값이 나오면
 13초가 걸렸다는 얘기입니다
 시스템마다 조금씩 다르겠죠
 자 이렇게 보통 자기의 프로그램이 얼마나 걸리는지
 이런 것들을 계산할 때 주로 사용을 하게 됩니다
 자 그 다음에 time.h의 또 다른 가장 많이 사용하는 함수일 거예요
 time 함수 현재 캘린더 시간을 리턴하게 됩니다
 반환한다는 얘기예요
 리턴 값도 time_ptr에서 지정한 위치에 저장이 됩니다
 포인터 형식으로 반환이 된다는 거죠
 time.ptr이 널인 경우 리턴 값은 저장되지 않고요
 자 신기하게 1970년 1월 1일 0시부터
 현재까지 흐른 시간을 time_ttype으로 초단이 정수로 반환하게 되어 있습니다
 내용이 조금 어렵지만
 1970년 1월 1일 0시를 기준으로 해서 지금까지 흐른 시간이죠
 이거를 계산해서 반환해준다는 얘기입니다
 자 time 함수를 사용하는 두 가지 방법이 있는데요
 매개 변수에 너를 집어 넣어서 반환용으로 시간을 받는 방법이 있고요
 매개 변수에 time_t, 포인터 형량의 변수
 time_t를 참조해서 값을 얻어 오는 방법입니다
 자 그래서 우리가 시간을 얻는 두 가지 방법을 코드를 보면
 자 여기처럼 time_t type에 first_t
 그 다음에 time 함수에다가 이렇게 주소 형식으로 넣어주면
 출력을 하면 지금 이제 시간이 출력이 될 거고요
 날짜 이런 것들이
 그 다음에 time_t에 second_t에서 널의 인자로 이렇게 주는 방식으로 사용해도
 같은 결과 값을 얻어 줄 수가 있습니다
 그래서 이렇게 형식으로 나오죠
 자 이상하죠
 결과가 알아볼 수 없는 형태로 나옵니다
 두 가지 방법을 써서 우리가 시간을 얻어냈는데
 사람이 알아볼 수 없는 형태가 나온다는 거예요
 이 결과를 알아보기 위해서는 또 가공을 해줘야 돼요
 어떻게?
 local time 함수를 이용해서 구조체로 변경을 해야 되는 겁니다
 자 신기하게 이 값을 local time에다 딱 넣어주면
 구조체 형식으로 우리가 알아볼 수 있는 형태가 된다는 얘기예요
 둘 다 같은 형식으로 나오죠
 자 local time 함수는 이렇게 함수 원형이 되어 있어요
 제가 아까 이런 얘기를 했어요
 모든 표준 라이브로에서 함수를 이용할 때는 함수의 원형을 파악을 해줘야 된다
 그리고 우리가 이제 구조체를 배웠잖아요
 struct의 tm 포인터형 구조체가 이렇게 만들어져 있고
 local time 이라는 구조체 이름이 되겠죠
 const time and p time입니다
 즉 이 p time에다가 제가 아까 얻은 시간을 딱 넣어주면
 local time에서 구조체 형식으로 딱 아름답게 변해서 출력이 된다는 겁니다
 우리가 알아볼 수 있게
 const time t type의 변수를 매개 변수로 받고
 그 시간을 변환해서 구조체 tm에 넣어서 반환해 주는 함수입니다
 time 함수에서 얻은 결과값을 struct tm의 연,월,일,분,초 등에
 값으로 변환해서 출력하게 됩니다
 그리고 이걸 또 구조체 내용들을 이용해서 우리가 어떤 결과값을 활용해 줄 수가 있겠죠
 자 그래서 여기처럼 우리 time과 관련된 변수를 하나 선언했고요
 struct로 tm에 tinfo에서
 인자값에 넣을 값을 줘서 시간을 얻었습니다
 그리고 그 얻은 시간을 rtime에다가 저장을 했는데
 rtime을 local time에다가 딱 해서 구조체 형식으로 받아와야 되기 때문에
 우리가 구조체를 하나 만든 거예요
 tinfo에서 구조체 안에 넣어주고
 다음에 실제 time을 한번 찍어 보고
 구조체 형식으로 이제 출력을 하는데
 이거 기억나죠? 멤버 변수에 접근하는 방법
 자 year는 tinfo 우리가 만든 구조체 이미 시간과 관련된
 local time에서 구조체 형식이 들어가 있을 겁니다
 거기에 tm_years 라는 구조체 멤버에 접근을 해서
 거기에다가 1900을 더해 줍니다
 그러면 오늘 날짜가 나와요
 자 그리고 month는 tmmonth에 더하기 1
 월에는 1을 더해주면 오늘 날짜가 나오고요
 그다음에 tm_mday
 그 다음에 hour, min, second는 각각 1
 그 다음에 시간, 분, 초 이렇게 해서
 구조체 내용을 이렇게 printf로 각각 출력해 주면 됩니다
 경수형으로 다 받아오죠 그쵸?
 자 그 다음에 보면 우리가 알아볼 수 없는 형태가
 2021년 이렇게 시간으로 나오게 됩니다
 자 그리고 ctime 함수라는 것도 있어요
 시간을 미리 문자열로 만들어 놓은 함수입니다
 우리 앞에서 타임 함수를 이용해서 시간을 받았는데
 결과값이 이상하게 나오고
 그걸 구조체로 넣어서 또 변환해서 해줘야 되는데
 ctime 함수를 이용하면
 시간들이 미리 문자열로 만들어 놓은 함수가 있기 때문에
 그대로 요일, 월, 일, 시간, 분, 초, 연도를 사용할 수가 있습니다
 자 그래서 ctime 함수가 훨씬 더 효율적이겠죠
 매개변수로 받은 시간값을 넘기고
 요일, 월, 시간, 분, 초, 연도 문자열로 반환하게 됩니다
 그래서 여기 time t에서 하나 만들어주고
 그래서 받아줬죠
 자 그래서 시간은 얻어야 됩니다
 일단 그리고 구조체를 선언하는 게 아니라
 그냥 이렇게 ctime에다가 시간을 넘겨 주면
 알아서 문자열 형태로 출력한다는 얘기입니다
 그쵸? 이렇게 이런 형식으로
 우리가 따로 local time 에다 넣을 필요도 없고
 구조체를 만들어서 멤버 변수에 접근할 필요 없이
 그대로 이 형식대로 출력하게 된다는 얘기입니다
 자 그다음에 살펴볼 표준 라이브러리 함수는 string.h 입니다
 C 프로그래밍 언어는 표준 라이브러리에
 문자열에 관련 명령을 구현하는 여러 함수들이 존재하고요
 자 복사, 병합, 비교, 검색과 같은
 다양한 명령을 사용할 수 있습니다
 그리고 string.h는 C 언어의 표준 라이브러리이고요
 메모리 블록이나 문자열로 다룰 수 있는 함수들을
 다량으로 포함하고 있어요
 자 우리가 문자열로 복사하는 함수는
 이미 strcpy 라는 것을 살펴봤어요
 또 다른 문자열복사 함수가 있는데
 memcpy 입니다
 자 1바이트로 나는 메모리의 각 명령은
 메모리 주소로 구분하는데
 보통 0번지부터 시작을 합니다
 그래서 딱 이름에서 봤듯이 메모리 통체를 카피하는 거예요
 즉 문자열로 들어가 있는 메모리 주소로 가서
 그걸 카피해서 사용하겠다라는 겁니다
 자 함수의 원형은 이렇게 되어 있는데
 source의, 이 source 있죠
 source가 type이 constant void이에요
 void는 우리가 반환을 안 하겠다는 거고
 constant는 상수입니다
 반환 안 하는 상수
 자 어렵지만 여기를 읽어보면
 source 인자가 가리키는 곳부터 num byte만큼은
 num byte만큼은 destination이 가리키는 곳에 복사한다는 겁니다
 즉 내가 source는 뭐예요?
 원천지잖아요
 복사하고 싶은 것을 얼마만큼 num만큼 가지고 와서
 destination 이라는 곳에 복사해준다는 뜻입니다
 그래서 destination과 source의 type은 모두 위 함수와 무관하고
 그 이유는 함수는 easy data를 복사하는 것이기 때문에
 그 결과 값의 type은 별로 상관이 없습니다
 메모리 전체를 카피하는 거기 때문에
 그래서 이 함수는 source의 null 종료 문자
 null terminating 캐릭터를 검사하지 않고
 정확히 num byte만큼만을 복사합니다
 그래서 메모리가 이렇게 있으면
 null 포인트가 있는지 없는지 상관없이
 딱 제가 원하는 만큼은 복사해서 넣어 줄 수 있다는 거예요
 근데 메모리에 제가 얘기했을 때
 stack overflow나 heap overflow라는 문제가 발생한다고 했는데
 이걸 방지하기 위해서
 destination과 source가 가리키는 배열의 크기는
 반드시 num byte 이상이어야 되고
 서로 겹치면 안 됩니다
 자 만약에 두 메모리 블록이 겹쳐 있다면
 mem move 함수를 이용하는 것이 좋습니다
 그래서 mem move는 조금 이따가 살펴보기도 하고요
 이 두 메모리 블록이 겹쳐져 있다면
 mem move로 함수를 이용하는 것이 좋고
 겹쳐 있으면 안 됩니다 mem copy는
 자 이렇게 설명을 드리니까 조금 어려운 부분이 있죠
 그래서 우리 코드를 한번 보면서 다시 한번 살펴볼까요
 자 str의 캐릭터형 배열이에요
 I love c라는 문자율을 저장하는데
 이렇게 값이 없이 저장을 했고요
 그리고 str2는 40의 크기를 이렇게 만들어줬습니다
 그리고 mem copy
 자 이게 destination이고요
 즉 str2에 str1의 내용을 복사해 주겠다는 겁니다
 그리고 st 크기 이게 n이에요
 strlen은 길이를 구하는 거잖아요
 str1의 길이에다가 더하기 1만큼 해서
 자 요 전체 길이가 되겠죠
 그리고 str1에 있는 내용을 str2에다가 복사해 주겠다는 뜻입니다
 자 그래서 str1하고 str2를 각각 printf로 출력하게 되면
 정확하게 일치하는 문자율을 얻어 줄 수가 있습니다
 자 그래서 앞에서 함수 원형을 설명하니까
 굉장히 어려운 부분이지만 단순하게 생각하면요
 우리가 어떤 문자율을 가지고 있고
 이 문자율을 그대로 제가 원하는 만큼만 넣어 줄 수 있다는 얘기입니다
 지금은 앞에 코드를 다시 보면
 전체 크기를 다 가지고 와서 str2에다가 복사해 준다는 거예요
 그래서 I love c를 하면 이렇게 입력이 되어 있으면
 똑같이 이거를 카피해서 I love c가 만들어지게 되는 겁니다
 자 우리가 앞에서 memcpy 같은 경우에
 카피 같은 경우에는 뭔가가 겹치면 안 된다고 그랬어요
 근데 이거는 겹쳐도 사용이 가능하다
 자 먼저 이 mem 부분은 메모리 블록을 옮기는 함수입니다
 아까는 복사하는 거고 이거는 아예 자체를 옮기는 거예요
 그래서 원형은 아까랑 비슷하죠
 destination 있고 source가 있고 num이 있어요
 소스가 가리키는 곳부터 numbyte만큼을 destination에 가리키는 곳으로 옮기는 겁니다
 자 여기에서 주의의 점은 카피와 move 또는 우리가 cut이라는 개념을 같이 생각하면 돼요
 카피는 기존에 있던 걸 그대로 두고 복사를 하는 거고요
 move나 cut 같은 경우에는 잘라내서 원본을 삭제해 주고
 원하는 곳에 붙여 넣어주는 겁니다
 그게 다른 거죠
 그쵸
 그래서 메모리 복사 수행시 중간에 버퍼를 이용하게 되면
 destination과 source에 해당하는 범위가 겹쳐져도 문제가 없다는 얘기입니다
 즉 앞에 memcpy의 문제점은
 제가 이렇게 복사할 공간을 만들어 놨는데요
 여기에 제가 복사할 문자가 있다면 이거를 이동할 수 없다는 얘기입니다
 이게 겹쳐지면 안 된다는 거예요
 새로운 전혀 새로운 공간에다가 복사를 해 줄 수 있지만
 제가 여기 위에다가 덮어 쓰기는 해 줄 수 없다는 얘기가 되는데
 이거는 덮어 쓰기가 가능합니다
 왜냐하면 그대로 잘라내서 그 위에다가 붙여 나오면 새로운 게 생기기 때문이에요
 그런 차이점이 있는데 똑같이 한쪽에서 한쪽으로 옮기는 역할을 하는 거고요
 destination과 source의 타입은 모두 위에 함수와 무관한데
 그 이유는 이진데이터를 복사하는 것이기 때문입니다
 이거는 아까 mcopy와 똑같고요
 이 함수는 이것도 비슷합니다
 null 문자의 종류, 종류 문자를 검사하지 않고
 정확히 none byte만큼은 복사하는 건 똑같아요
 오버플러를 방지하기 위해서 destination과 source가 가르치는 배열 모두
 none byte 이상은 되어야 된다
 그래서 내용은 복잡하지만 우리가 가지고 있는 크기가 넉넉하고
 복사하고 붙여놓고 이런 내용들을 수행하게 되는 겁니다
 이렇게 man move can be very useful 해서 배열을 하나 만들어 놨고요
 그리고 man move를 해서 str 더하기 20, str 더하기 15 해주면
 그리고 12를 만큼만 복사해 주는 겁니다
 그래서 m, e, m, m, o, v, e, can 해서 11 글자를 잘라내고요
 거기에 다시 15 글자를 더해서
 그러면 아마 useful까지 딱 잘라질 겁니다
 그거를 str 이라는 곳에 20을 더해서 복사해 주는데
 str이 다 같은 str이잖아요
 그래서 이게 겹쳐진다 그래도 상관없다는 얘기입니다
 길이만 더 길게 해줘서 그대로 가져다가 넣어 줄 수 있다는 얘기입니다
 5개를 더해서 점 하나까지, 아마 useful 더해서 만들어주고요
 이렇게 해서 man move를 이용해서 우리가 복사하고 넣어 줄 수 있습니다
 이제 실습해서 한번 또 다뤄볼게요
 그 다음에 문자열을 연결하는 한수가 있는데 str cash and cash은 concatenate의 약자입니다
 그래서 문자열을 붙이는 역할을 하는데 concatenate는 뭔가를 연결하다는 뜻이에요
 그래서 붙여준다
 destination 끝에 소스를 더하게 되는 겁니다
 그래서 여기 destination에 소스를 더해서 연결시켜 주는 거예요
 이때 destination 맨 마지막 넣을 문자는 소스의 첫 번째 문자가 덮어지게 되고
 그리고 소스의 마지막 넣은 문자가 destination 끝에 붙어서 새로운 문자열을 형성하게 된다
 다시 말해서 destination에 ab가 있고요
 소스의 c가 있다면 str cat 이후에는 abc가 이렇게 새로운 문자열이 하나 만들어진다
 그리고 어디에? destination에
 자, 드시고 이 코드를 보면 strcpy strcat 이용해서 붙여주는 거
 그 내용들을 실습해서 다시 한번 살펴보도록 할게요
 그래서 전체적으로 실행 결과가 I love c가 나오게 됩니다
 자, 그 다음 또 맴이 들어가는데 이번에는 cmp예요
 이거는 두 개의 메모리 블록을 비교하는 겁니다
 이게 뭐의 약자일 것 같아요?
 compare 메모리 즉 어떤 문자열 같은 배열 이런 게 있는데
 이걸 두 개를 비교하는 겁니다
 자, 여기에 원형을 보면 ptr1 이라고 ptr2가 있는데요
 ptr1이 가리키는 처음 넣은 바이트의 데이터와 ptr2가 가리키는 처음 넣은 바이트의 데이터를 비교해서
 이들이 같다면 0을 리턴하고 이게 중요합니다
 결과가 같으면 0을 다르면 0이 아닌 값을 리턴하게 됩니다
 그래서 0이 아닌 값이 나오면 이건 다르구나 라고 해석해서 어떤 다른 결과를 처리해주면 돼요
 자, 두 개의 메모리 블록의 관계에 따라 아래와 같이 정수값을 리턴하는데
 만일 두 메모리 블록이 정확하게 갔다면 0을 두 메모리 블록이 다를 경우에는
 ptr1과 ptr2가 가리키는 메모리 블록에서
 앞에서부터 처음으로 다른 바이트를 살펴보게 됩니다
 그리고 그 바이트를 unsigned 캐릭터로 해석했을 때
 그 값이 ptr1이 더 크면 0보다 큰 값을 아니면 0보다 작은 값을 리턴하게 됩니다
 자, 설명이 어려운데 우리 a와 b를 놓고 보면
 이거를 딱 했는데 a, a가 같지 않기 때문에 다른 값이 나오는 거예요
 근데 ptr1이 더 커요 작아요
 우리 알파벳순으로 하면 a가 더 작잖아요 그쵸?
 그럴 때는 ptr1이 더 크면 0보다 큰 값이 나오고 양수의 값이 나오고
 이거는 이게 작으니까 음수의 값이 나온다는 얘기입니다
 이해가 됐나요?
 자, 이것도 실습을 이렇게 한번 만들어봤어요
 스트럭트를 이렇게 만들어 봤고
 그다음에 이런 멤버들의 내용들이 있고 이거 두 개를, 세 개를 비교해 보는 겁니다
 그래서 같으면 0, 다르면 어떤 숫자가 나오게 되겠죠
 서로 같고, 다르고 이런 내용들이 이렇게 출력이 돼서
 m1과 m2는 서로 다르고 m1과 m3는 서로 같습니다
 그래서 m1에는 뭐가 들어가 있냐면
 앞에 좀 볼게요
 홍기동하고 20이고 m3는 홍기동하고 20, 그대로 들어가 있죠
 근데 이거와 이거를 비교했을 때
 얘는 얘와 다르고 얘는 얘와 같다 라는 결과 값이 나옵니다
 물론 여기에서는 이제 같은지 안 같은지 이거를 비교 판단해서 출력하는 거고요
 실제로는 어떤 0보다 큰 값, 작은 값 이런 것들이 나오면
 이게 피규어 판단이 된다는 얘기입니다
 그리고 0과 같다면 이게 서로 같다가 된다는 얘기죠
 그리고 strlen 함수는 이미 제가 좀 설명을 했는데
 문자열의 길이를 구하는 함수입니다
 c 문자열의 길이는 마지막 널 문자에 의해서 결정이 된다
 따라서 strlen은 문자열의 시작부터 널 문자의 직전까지의 문자의 개수를 세워줍니다
 그래서 이거 개인 문자, 널 문자까지만 세워주고
 그래서 널 문자까지 포함을 해주려면 더하기 1을 해주면 됩니다
 우리 이미 어떤 실습에서 많이 해봤던 형태죠
 자 그래서 hello의 문자열의 길이
 그다음에 greeting gkr이라는 배열의 문자열의 길이를 각각 strlen으로 출력해 보면
 54의 결과 값이 나오게 될 겁니다
 자 그래서 우리 정리해 보자면 다양한 표준 라이브러리 함수에 대해서 살펴봤고요
 이 내용들을 우리 실습으로 다시 한번 살펴보도록 하겠습니다
 14주차 2교시 실습을 시작해 보도록 하겠습니다
 자 먼저 우리가 살펴볼 표준 라이브러리는 std-lib.h의 표준 라이브러리구요
 여기는 다양한 표준 함수들이 포함이 되어 있는데 우리가 학습했던 것은
 workload 함수도 여기 std-lib.h에 포함이 되어 있죠
 workload은 뭐였어요? 동쪽으로 메모리를 할당하는
 자 그러한 내용의 동쪽 메모리 할당 함수였습니다
 그래서 std-lib.h에는 뜻이 standard library header라는 얘기에요
 표준 라이브러리가 전부 여기에 적용이 되어 있다
 그래서 굉장히 유용한 함수들이 많이 있고요
 자 여기처럼 우리 a2i, a2f, a2l 형태로 스탠더드 라이브러리에 있는 것을 이용해 보도록 할게요
 각각 다른 함수입니다
 a2까지는 다 같지만 i, f, l이 다르죠
 그래서 먼저 변수를 하나 이렇게 정수형 변수를 만들고 초기값 0을 줬어요
 그리고 float str 이라는 float 형 변수 초기값 0.0을 줬구요
 long 형의 정수형 변수 그래서 long str 0을 줬습니다
 그리고 character 배열을 하나 만들었어요
 그리고 2000이라는 이 숫자 형 문자를 하나 만들었습니다
 큰 따윈표가 있으니까 이건 문자열 이에요
 숫자가 아닙니다
 이거는 문자열
 자 그래서 이제 a2i, a는 ascii to integer 입니다
 그래서 str 안에 있는 내용 문자열을 우리가 interger로 바꿔 준다는 거에요
 그러면 숫자 2000이 나오게 될 겁니다
 그리고 float str 하면 아까 우리가 float 형으로 변수를 선언한 거구요
 여기에 a2f면 i는 interger고 f는 float 입니다
 실수용으로 되어있으니까 2000에다가 0, 0 이렇게 실수용으로 출력이 될 거구요
 그리고 a2l은 ascii to long 에서 역시 마찬가지로 2000이라는 숫자가 입력 될 겁니다
 숫자가 길지 않기 때문에 이렇게 되는 거에요
 자 각각을 이제 출력해 볼까요
 그러면 2000 여기 0이 6개가 붙죠
 비주얼 스튜디오니까 6개가 붙고 실수용으로 표시되구요
 long, 긴, 정수용 숫자가 그렇게 길지가 않기 때문에
 2000까지 이렇게 출력이 되게 될 겁니다
 자 그래서 std.lib.h에 다양한 at 함수를 살펴봤구요
 뒤에 있는 거에 따라서 출력되는 내용들이 달라지게 됩니다
 자 이번에 살펴볼 예정은 time.h 라이브러리 함수들입니다
 time.h 헤더 파일을 인클로드 해 주면
 우리가 타임과 관련된 내용들을 사용할 수 있을 수 있고요
 자 여기처럼 클럭 언더바 T라고 해서
 구조체 형태 클럭 함수를 이용해서 시간을 얻을 수 있고요
 그리고 어떤 코드를 실행하면
 보통 이제 이 time.h를 해서
 우리가 프로그램 실행 시간을 구해 볼 수가 있습니다
 여기다 이제 실제 어떤 코드를 넣어주게 되면
 만번의 반복을 통해서 이게 얼마나 걸렸는지
 이런 시간들이 출력되게 될 거고요
 자 시간을 구하는 방법은 이렇게
 end start 해서 넣어 주면 됩니다
 이거는 이제 실행을 해도 아무 결과가 나타나지는 않을 거예요
 왜냐하면 여기에는 적당한 코드를 넣어줘야 되는데
 잘못 넣어주면 만번을 하다가
 이렇게 시스템에 무리가 많이 가기 때문에
 자 이거는 이제 이렇게 time.h 함수를 이용할 수 있다는 거고요
 자 이번에 살펴볼 표준 라이브러리 함수도 time.h 함수인데요
 자 여기 time_t라는 내용을 받아서 우리가 처음 시간 이렇게 출력을 해 볼 겁니다
 그리고 두 번째 시간을 또 입력 받아서
 자 time null 그 다음에 time 함수에다가
 이렇게 주소 값을 연결해서 넣어주면
 현재 시간을 입력을 받을 수 있고요
 각각 출력을 해 보는 거예요
 그래서 두 가지 형태로 우리가 시간을 활용해 줄 수 있는데
 첫 번째가 이렇게 time_t 라는 구조체 형식의 변수에
 주소 값을 넘겨주거나 아니면 null 값을 넘겨주면
 시간이 생성이 되게 됩니다
 자 그래서 한번 시간을 생성해 볼까요
 근데 전혀 알아볼 수 없는 형태가 출력이 됐어요
 그래서 제가 본 학습에서 이 두 개의 시간을
 우리가 구조체 형식으로 받아서
 또 이쁘게 만들어줄 수 있다고 얘기했습니다
 자 그러면 이 두 개의 시간을 구조체로 바꾸는 실습을 한번 해 보도록 할까요
 앞에서 이제 시간을 얻었잖아요
 그리고 그 시간을 결과 값을 확인했을 때
 그 시간 결과 값이 우리가 알아볼 수 없는 형태로 되어 있었습니다
 그거를 이제 구조체 형식으로 바꿔보는 겁니다
 자 그래서 시간을 받을 수 있는 time_t 변수를 하나 만들어주고요
 type에 자 그리고 구조체를 하나 이렇게 만들어줍니다
 이 구조체는 우리가 시간 형식을 이렇게 받아 줄 수 있게
 만들어주는 구조체고요
 자 그다음에 time null을 이용해서 우리가 시간을 받아줬어요
 rtime에 그리고 local time이라는 함수를 이용해서
 rtime에 주소 값을 넘기게 되면
 local time에서 구조체가 만들어집니다
 그리고 그 만들어진 구조체를 그대로
 tinfo라는 구조체에다가 넣어준 거예요
 그래서 우리가 멤버 변수를 접근하기 위한 구조체를
 tinfo라는 거를 하나 만들었고요
 local time이라는 함수를 이용해서 구조체가 형성이 되는데
 그걸 그대로 tinfo에다가 넣어준 겁니다
 자 그래서 rtime을 하면 우리가 알아볼 수 없는 형태의 시간이 나오겠죠
 시간 알 수 없는 형태
 알 수 없는 형태
 이거를 좀 뒤로 바꿀게요
 자 그래서 이거를 이제 구조체로 바꿔준 겁니다
 tinfo에 local time에서 넘어온 구조체 멤버 변수 중에서
 tm_e호 하면 연도가 나오는데
 거기에 1900을 더해주면 우리가 현재 연도를 구해줄 수 있고요
 그다음에 tm_mon 하면 month를 구해줄 수 있고
 이거는 day, month, 1, 그다음에 시간, 분, 초까지
 다양한 들어 구해서 각각의 year, month, day, hour, min, second에다가
 이렇게 변수에다 넣어주고
 그거를 출력해 본 겁니다
 자 이제 잘 출력이 되는지 한번 실행해 볼까요
 그러면 원래의 시간 값은 이렇게 알 수 없는 형태가 되지만
 자 local time에 의해서 만들어진 구조체에 의해서
 멤버 변수들의 각각 접근을 해서 값을 얻어와서
 여기다가 넣어주면 2021년 10월 7일
 여기 이런 시간이 출력이 됩니다
 시간, 분, 초까지 그쵸
 그래서 우리가 time 함수에 대해서
 실제 local time을 받아서 활용하는 방법들에 대해서 실습해 보았고요
 이번 실습도 우리 time h에 포함된 내용인
 c time 함수를 한번 실습해 볼 건데요
 c time 함수는 우리 앞에서 시간을 얻어 오잖아요
 그리고 local time이라는 함수에 넣어서 구조체를 얻어서
 구조체의 멤버 변수에 접근해서
 자 그거를 다시 정수형 변수에 넣고 출력해 줬습니다
 그거를 문자열 형태로 미리 만들어 놓고요
 포인터 배열 형식으로 사용을 해 줄 수가 있다는 겁니다
 그게 바로 c time 함수가 하는 역할이에요
 자 그래서 한 줄씩 살펴볼까요
 자 time_t 타입에 변수를 하나 만들었어요
 그리고 time 이라는 곳에 변수 주소값, 여기 너 를 넣어줘도 되겠죠
 자 그러면 시간이 만들어집니다
 우리가 알 수 없는 시간 형태로 만들어지죠
 그 다음에 캐릭터형 포인터 문자로 출력이 되기 때문에
 캐릭터형 포인터로 만들어주고
 그 다음에 이거는 변수 이름이고요
 c time 함수에다가 받은 시간을 그대로 주소값을 넘겨 주게 되면
 여기 안에서 문자열 형태로 그대로 출력이 됩니다
 그래서 여기 %s로 c time str를 출력해 주면 되겠죠
 자 그러면 출력 상태는 이렇게 나와요
 요일, 달, 외국에서는 이렇게 주로 표시를 하게 돼요
 그 다음에 1, 그 다음에 시간, 분, 초, 그리고 마지막에 연도
 자 좀 형태가 우리가 일반적으로 보는 형태는 아니지만
 요거를 이용해서 아주 간단하게 c time을 이용해서 시간을 출력해 줄 수가 있습니다
 자 이번에 살펴볼 실습 내용은
 str.h에 포함되어 있는 memcpy 입니다
 str.cpy 에 대해서 제가 설명한 적이 있는데요
 자 그것과 비슷하게 문자열을 복사해 주는데요
 자 문자열 배열을 이렇게 하나 만들어주고
 I love C라는 문자를 이렇게 넣어 줬습니다
 그리고 두번째로 배열을 하나 크기를 정해서 설정을 해 준 다음에
 str.1 에 있는 문자열을 str.2 에다가 복사해 주는데
 자 문자열의 크기만큼 그리고 더하게 1을 하는 것은
 갱 문자를 하나 더해서 그 크기만큼 str.2 에다가 넣어 준다는 얘기입니다
 똑같이 I love C가 생기지만 여기는 str.2 에는 40개의 문자열이 아니라
 이제 I love C만큼만 배열이 복사가 돼서 만들어진다 라는 거예요
 자 실행해 볼까요? 똑같이 I love C가 나오지만
 여기 아래쪽에 이제 40개의 배열이 아니라 여기 크기만큼만 문자열이 복사가 된다 라는 겁니다
 그리고 여기 memcpy를 하게 되면 우리가
 Visual Studio에서도 warning 구문을 빼도 보안상의 문제가 없이 그대로 복사가 가능합니다
 그리고 실제로 이 크기만큼 복사가 되서요 만약에 str.1이 아니라
 다른 걸로 바꿔 준다면 어떻게 될까요?
 이거를 3으로 해볼까요?
 자 그러면 이런 이상한 값이 나옵니다
 이거는 정수를 못 알아 듣기 때문에 복사가 잘 안되는 거예요
 그래서 보통은 이렇게 아까처럼 문자열의 길이를 알아낸 다음에
 그 길이만큼 복사해서 사용을 해주게 됩니다
 자 그리고 더하기 1을 또 한 번 빼볼까요 어떻게 됐는지
 자 그래도 이상한 문자열이 나오게 됩니다
 즉 memcpy는 계획문자까지를 전부 다 복사해서 넣어 줄 수 있다는 겁니다
 자 이번에 살펴볼 예제도
 메모리를 복사하는 문자열을 복사하고 메모리를 복사하는 형태인데
 복사보다는 이동 즉 cut 입니다
 그래서 아까 memcpy 같은 경우에는 복사하는 영역과 복사할 영역이 겹치면 안됩니다
 하지만 여기는 겹쳐도 상관없어요
 그냥 이동을 하는 거기 때문에 전체가 덮어지게 되어집니다
 그래서 이거를 실행하게 되면
 아까 본학수도 설명했듯이
 실제 11개를 복사를 하는데요
 str 문자열 있죠
 여기에서 15개를 끊어서 복사해주고
 복사해주는 크기는 20개의 공간을 더 만들어서
 이 내용들을 받아주게 됩니다
 이렇게 memmove를 이용해서도 복사가 가능하구요
 이번에 살펴볼 예제는 string.h 에서
 우리가 strcat concatenate 즉 문자를 연결해주는 겁니다
 그래서 i love c 가 각각 strcat 을 이용해서
 하나의 문자열로 출력되게 됩니다
 부츠를 이용해서 보면 i love c에서 출력이 되고
 공백도 마찬가지로 하나의 문자열로 추급되서 연결이 되게 됩니다
 즉 개인 문자 다음으로 각각 연결이 된다는 얘기에요
 자 이번에 살펴볼 학습 내용도 string.h의 함수들을 살펴볼건데요
 자 이 내용 즉 문자를 각각 비교해주는 그런 함수입니다
 memcmp 컴페어의 약자구요
 그래서 m1과 m2를 비교해서
 같으면 0이 결과 값으로 나오게 되고
 다르면 0 이상의 값이 나오게 됩니다
 근데 비교했을 때 이게 더 크거나 하면 양수익 값이
 만약에 m2가 더 크다 그러면 음수익 값이 나오게 됩니다
 자 그래서 우리 구조체를 하나 만들었구요
 구조체의 멤버 변수에다가 이렇게 초기약 값으로
 홍기통 20, 강강차 27, 홍기통 20
 자 요거 두 개는 같은 내용이죠
 이제 memcmp를 이용해서 두 개를 비교해 보는 겁니다
 m1하고 m2가 비교했을 때 만약에 이게 0이면
 즉 m1과 m2의 주소의 데이터가 같을 때
 즉 이게 두 개가 같을 때는 0이 나오면 서로 같습니다가 됩니다
 그렇지 않으면 자 printf에서 m1과 m2는 서로 다릅니다
 m1과 m2는 서로 다릅니다를 출력 시켜 줄 수 있습니다
 자 그리고 m1과 m3을 비교해 보는 거에요
 만약에 같다면 서로 같다 아니면 서로 다르다를 출력하게 됩니다
 자 그래서 우리가 요거를 실행을 해 보게 되면 m1과 m3은 서로 같죠
 왜냐면 똑같은 데이터 내용을 갖고 있기 때문에
 자 결과 값이 0이 나오는 거구요
 요거는 0이 아닌 값이 나오기 때문에
 서로 다릅니다가 출력되게 됩니다
 자 이번에 살펴볼 함수는
 우리 이미 사용을 해 본 적이 있는 함수입니다
 strlen 입니다
 len은 length에요 우리 길이를 알아내는 거구요
 각각의 여기 문자열 배열에서
 이 문자열의 크기를 알아보는 그런 함수입니다
 굉장히 많이 사용되는 함수 중에 하나에요
 문자에 대해 길이가 얼마나 되는지
 자 그래서 실행해 보면 hello는 다섯 글자
 안녕은 네 글자입니다
 오 근데 좀 신기하게 나오죠
 어 안녕은 왜 네 글자지
 분명히 두 글자인데
 자 한글은 각각의 글자가 2바이트입니다
 그래서 총 4가 출력되게 되는 거에요
 즉 length를 넣었을 때 이렇게 넣었을 때
 실제 글자의 크기가 아니라
 바이트의 크기가 출력되게 되는 겁니다
 요거는 영어 문자는 한 바이트씩이 때문에
 다섯 바이트가 나오는 거고
 요거는 한글은 한 문자가 2바이트기 때문에
 4바이트가 이렇게 출력이 되는 겁니다
 그래서 이번 교시에서는 우리 다양한
 표준 라이브러리 함수에 대해서 실습해 보았습니다
