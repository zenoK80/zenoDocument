---
title: "값에 의한 전달"
description: "함수 매개변수로 값을 전달할 때 메모리에서 어떻게 동작하는지 배워보세요"
slug: "c-function-call-by-value"
sidebar_position: 3
date: "2024-01-16"
---

# 값에 의한 전달 (Call by Value)

## 🎯 값에 의한 전달이란?

**값에 의한 전달(Call by Value)**은 함수를 호출할 때 **인수의 값을 복사해서** 매개변수에 전달하는 방식입니다.

```
원본 변수 → 값 복사 → 매개변수에 전달
(영향 없음)
```

## 📋 값에 의한 전달의 특징

### 핵심 특징

| 특징 | 설명 |
|------|------|
| **메모리** | 매개변수와 인수가 다른 메모리 공간을 가짐 |
| **값 변경** | 함수 내부에서 매개변수 변경 → 원본에 영향 없음 |
| **독립성** | 각 변수가 독립적으로 작동 |
| **기본 방식** | C 언어의 기본 전달 방식 |

### 메모리 구조

```c
int main() {
    int a = 10;        // 메모리 위치 1000번에 값 10 저장
    
    function(a);       // 값 10을 복사해서 전달
    
    return 0;
}

void function(int num) {
    // 메모리 위치 2000번에 값 10이 저장됨 (복사본)
    // a와 num은 다른 메모리 위치!
}
```

## 🔄 예제 1: 값을 증가시키기

### 코드

```c
#include <stdio.h>

// 함수 원형
void increment(int num);

// main 함수
int main() {
    int a = 0;
    
    printf("함수 호출 전: a = %d\n", a);
    increment(a);  // a의 값(0)을 전달
    printf("함수 호출 후: a = %d\n", a);
    
    return 0;
}

// 함수 정의
void increment(int num) {
    printf("함수 내부 (호출 직후): num = %d\n", num);
    
    num = num + 1;  // num을 증가
    
    printf("함수 내부 (수정 후): num = %d\n", num);
}
```

### 코드 분석 (한 줄씩)

```c
void increment(int num) {
    // ↑ num: a의 값(0)이 복사되어 들어옴
    
    num = num + 1;
    // ↑ num을 증가 (0 + 1 = 1)
    // 하지만 이것은 복사본일 뿐이므로 a에는 영향 없음
}
```

```c
increment(a);
// ↑ a의 값(0)을 복사해서 전달
// a 자체가 전달되는 게 아니라 값만 전달됨
```

### 메모리 상태 변화

```
[함수 호출 전]
메모리 주소 1000: a = 0

[함수 호출]
메모리 주소 1000: a = 0
메모리 주소 2000: num = 0 (a의 값 복사)

[함수 내부에서 num 증가]
메모리 주소 1000: a = 0     (변화 없음)
메모리 주소 2000: num = 1   (변화)

[함수 종료]
메모리 주소 1000: a = 0     (그대로)
메모리 주소 2000: num 메모리 해제
```

### 실행 결과

```
함수 호출 전: a = 0
함수 내부 (호출 직후): num = 0
함수 내부 (수정 후): num = 1
함수 호출 후: a = 0
```

**결론:** 함수 내부에서 num을 1로 증가시켰지만, a는 여전히 0입니다!

## 🔄 예제 2: 두 수 교환하기

### 코드

```c
#include <stdio.h>

// 함수 원형
void swap(int a, int b);

// main 함수
int main() {
    int i = 2;
    int j = 3;
    
    printf("교환 전: i = %d, j = %d\n", i, j);
    swap(i, j);  // i와 j의 값을 전달
    printf("교환 후: i = %d, j = %d\n", i, j);
    
    return 0;
}

// 함수 정의
void swap(int a, int b) {
    printf("  함수 내부 교환 전: a = %d, b = %d\n", a, b);
    
    int temp = a;
    a = b;
    b = temp;
    
    printf("  함수 내부 교환 후: a = %d, b = %d\n", a, b);
}
```

### 코드 분석 (swap 함수)

```c
void swap(int a, int b) {
    // i와 j의 값이 복사되어 들어옴
    // a = 2, b = 3
    
    int temp = a;    // temp = 2
    a = b;           // a = 3
    b = temp;        // b = 2
    
    // 함수 내부에서는 교환되었지만
    // i와 j는 별개의 메모리이므로 영향 없음
}
```

### 메모리 상태 변화

```
[교환 전]
main: i = 2 (주소 1000), j = 3 (주소 1004)

[함수 호출]
main: i = 2, j = 3
swap: a = 2 (주소 2000), b = 3 (주소 2004)

[교환 수행]
main: i = 2, j = 3 (변화 없음)
swap: a = 3, b = 2 (변화)

[함수 종료]
main: i = 2, j = 3 (그대로)
```

### 실행 결과

```
교환 전: i = 2, j = 3
  함수 내부 교환 전: a = 2, b = 3
  함수 내부 교환 후: a = 3, b = 2
교환 후: i = 2, j = 3
```

**결론:** 함수 내부에서 값을 교환했지만, main의 i와 j는 변하지 않았습니다!

## 💡 값에 의한 전달의 장점과 단점

### 장점

```c
✅ 원본 데이터 보호
   함수 내부에서 변수를 수정해도 원본에 영향 없음

✅ 안전성
   실수로 인한 데이터 손상 방지

✅ 독립성
   각 함수가 독립적으로 동작
```

### 단점

```c
❌ 메모리 낭비
   값을 복사해야 하므로 메모리 사용량 증가

❌ 함수에서 원본 변경 불가
   함수에서 main의 변수를 수정할 수 없음

❌ 큰 배열 전달 시 비효율적
   배열 전체를 복사해야 함
```

## 🎬 실제 예제: 여러 값의 합

### 코드

```c
#include <stdio.h>

// 함수 원형
int sum_three(int a, int b, int c);

// main 함수
int main() {
    int num1 = 10;
    int num2 = 20;
    int num3 = 30;
    
    int total = sum_three(num1, num2, num3);
    
    printf("합: %d\n", total);
    printf("num1: %d (변화 없음)\n", num1);
    printf("num2: %d (변화 없음)\n", num2);
    printf("num3: %d (변화 없음)\n", num3);
    
    return 0;
}

// 함수 정의
int sum_three(int a, int b, int c) {
    // a = 10, b = 20, c = 30 (복사본)
    
    int result = a + b + c;
    return result;  // 60 반환
}
```

### 코드 분석

```c
int total = sum_three(num1, num2, num3);
// ↑ num1, num2, num3의 값들이 복사되어 전달됨
// ↑ sum_three 함수에서 반환된 60이 total에 저장됨

int result = a + b + c;
// ↑ 복사된 값들을 사용해서 계산
// ↑ 원본 num1, num2, num3는 변하지 않음
```

### 실행 결과

```
합: 60
num1: 10 (변화 없음)
num2: 20 (변화 없음)
num3: 30 (변화 없음)
```

## 📊 값에 의한 전달 vs 반환값

### 방식 1: 값 변경이 필요 없으면 반환값 사용

```c
// 값에 의한 전달로 계산하고 결과 반환
int double_value(int num) {
    return num * 2;  // 계산 결과를 반환
}

int main() {
    int a = 5;
    int result = double_value(a);  // a는 변하지 않음
    printf("원본: %d, 결과: %d\n", a, result);  // 5, 10
    return 0;
}
```

### 방식 2: 여러 값을 반환할 수는 없음

```c
// ❌ 값에 의한 전달로는 여러 값을 반환할 수 없음
void swap(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
    // 이렇게 해도 main의 i, j는 변하지 않음
}
```

## ✅ 정리: 값에 의한 전달의 작동 원리

### 흐름도

```
[main]
a = 10

    ↓
[함수 호출: function(a)]
a의 값(10)을 복사
    ↓
[함수 내부]
num = 10 (복사본)
num을 수정해도
    ↓
[함수 내부]
main의 a에는 영향 없음
    ↓
[함수 종료]
메모리 해제
    ↓
[main]
a = 10 (변화 없음)
```

## 📝 언제 값에 의한 전달이 적합한가?

### 적합한 경우

```c
// 1. 원본을 보호해야 할 때
void process_age(int age) {
    age = age + 1;
    // 원본 나이는 유지됨
}

// 2. 계산하고 결과만 필요할 때
int get_percentage(int total, int part) {
    return (part * 100) / total;
}

// 3. 간단한 값을 처리할 때
void print_value(int num) {
    printf("값: %d\n", num);
}
```

## 📌 핵심 정리

:::note 꼭 기억하세요!
1. **값에 의한 전달** = 인수의 값을 복사해서 전달
2. **메모리** = 매개변수와 인수가 다른 메모리 공간
3. **원본 보호** = 함수 내부 변경이 원본에 영향 없음
4. **독립성** = 각 변수가 독립적으로 작동
5. **기본 방식** = C 언어에서 기본으로 사용되는 방식
:::

---

**작성일:** 2024.01.16  
**난이도:** ⭐⭐⭐ 중급