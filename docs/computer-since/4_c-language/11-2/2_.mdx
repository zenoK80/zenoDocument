---
title: "함수 호출 원리와 메모리"
description: "함수가 호출될 때 메모리에서 어떤 일이 일어나는지 상세히 이해해보세요"
slug: "c-function-call-memory-stack"
sidebar_position: 2
date: "2024-01-16"
---

# 함수 호출 원리와 메모리

## 🎯 함수 호출 시 메모리에서의 변화

함수가 호출될 때 컴퓨터의 메모리(특히 **스택 영역**)에서 어떤 일이 발생하는지 상세히 알아보겠습니다.

## 📚 스택(Stack)이란?

### 개념

**스택**은 함수가 호출될 때 필요한 변수들과 반환 정보를 저장하는 메모리 영역입니다.

```
함수 호출 → 스택에 메모리 할당 → 함수 실행 → 스택에서 메모리 해제
```

### 특징

- LIFO (Last In First Out) - 나중에 들어온 것이 먼저 나감
- 함수 호출 시 자동으로 메모리가 할당됨
- 함수 종료 시 자동으로 메모리가 해제됨
- 수동으로 해제할 필요 없음 (포인터와 다름!)

## 🔄 함수 호출의 단계별 과정

### 예제 코드

```c
#include <stdio.h>

// 함수 원형
int add(int a, int b);

// main 함수
int main() {
    int i = 2;      // [1단계]
    int j = 3;      // [1단계]
    int result;     // [1단계]
    
    result = add(i, j);  // [2단계] 함수 호출
    
    printf("%d\n", result);  // [4단계]
    
    return 0;
}

// 함수 정의
int add(int a, int b) {
    return a + b;   // [3단계] 값 반환
}
```

## 📊 단계별 메모리 상태

### [1단계] main 함수 시작

```
메모리 스택:
┌─────────────────┐
│  i = 2          │  ← main 함수의 변수
│  j = 3          │
│  result = 0     │  (초기값 0으로 시작)
└─────────────────┘
```

**이 시점:**
- main 함수가 실행되면서 필요한 변수들(i, j, result)이 스택에 할당됨

### [2단계] 함수 호출 (add(i, j))

```
메모리 스택:
┌─────────────────┐
│  i = 2          │
│  j = 3          │
│  result = 0     │  ← main 함수 영역
├─────────────────┤
│  a = 2          │  ← add 함수 영역
│  b = 3          │    (i와 j의 값이 복사됨)
└─────────────────┘
```

**이 시점:**
- add 함수가 호출되면서 새로운 스택 영역이 생성됨
- i의 값(2)이 a로 복사됨
- j의 값(3)이 b로 복사됨
- **중요:** a와 b는 i와 j와 다른 메모리 주소!

### [3단계] 함수에서 계산 및 반환

```
add 함수 실행:
    return a + b;
    → 2 + 3 = 5 계산
    → 5를 반환

메모리 스택:
┌─────────────────┐
│  i = 2          │
│  j = 3          │
│  result = 5     │  ← 반환값(5)이 여기에 저장됨
├─────────────────┤
│  a = 2          │
│  b = 3          │
└─────────────────┘
```

**이 시점:**
- add 함수가 계산을 완료함 (2 + 3 = 5)
- 반환값(5)이 main의 스택 위에 놓여짐
- a, b의 메모리는 이제 불필요함

### [4단계] 함수 종료 및 메모리 정리

```
메모리 스택:
┌─────────────────┐
│  i = 2          │
│  j = 3          │
│  result = 5     │  ← 반환값이 result에 저장됨
└─────────────────┘

(add 함수의 메모리는 자동으로 삭제됨)
```

**이 시점:**
- add 함수의 스택 영역(a, b)이 자동으로 해제됨
- 반환값(5)이 result에 최종 저장됨
- printf로 result 출력

## 📈 시각적 흐름도

```
[main 함수 시작]
    i = 2, j = 3, result = 0
    
    ↓
[add(2, 3) 호출]
    a = 2, b = 3이 새로 생성됨
    
    ↓
[add 함수 실행]
    return 2 + 3 = 5
    
    ↓
[add 함수 종료, 메모리 해제]
    a, b는 사라짐
    5가 result에 저장됨
    
    ↓
[printf로 5 출력]
    
    ↓
[프로그램 종료]
    모든 메모리 해제
```

## 🔑 핵심 개념: 매개변수 값의 복사

### 매개변수와 인수의 관계

```c
int add(int a, int b) {      // a, b: 매개변수
    return a + b;
}

int main() {
    int i = 2, j = 3;
    add(i, j);               // i, j: 인수
    return 0;
}
```

**중요한 점:**
```
i의 값(2) ──복사──> a의 메모리 위치에 저장
j의 값(3) ──복사──> b의 메모리 위치에 저장

즉, a와 b는 i와 j의 값을 복사한 것일 뿐,
i와 b가 같은 메모리를 가리키는 게 아님!
```

## 💡 실제 메모리 주소로 보기

```c
#include <stdio.h>

void show_addresses(int a, int b) {
    printf("함수 내부:\n");
    printf("a의 주소: %p\n", &a);
    printf("b의 주소: %p\n", &b);
}

int main() {
    int i = 2, j = 3;
    
    printf("main 함수:\n");
    printf("i의 주소: %p\n", &i);
    printf("j의 주소: %p\n", &j);
    printf("\n");
    
    show_addresses(i, j);
    
    return 0;
}
```

**실행 결과:**
```
main 함수:
i의 주소: 0x7ffc1234
j의 주소: 0x7ffc1238

함수 내부:
a의 주소: 0x7ffc1220      ← i의 주소와 다름!
b의 주소: 0x7ffc1224      ← j의 주소와 다름!
```

**결론:** a, b, i, j는 모두 다른 메모리 위치!

## 🎬 실제 예제: 단계별 추적

### 코드

```c
#include <stdio.h>

int multiply(int x, int y) {
    printf("multiply 함수 내부\n");
    printf("x = %d, y = %d\n", x, y);
    
    int result = x * y;
    printf("계산 결과: %d\n", result);
    
    return result;
}

int main() {
    printf("main 함수 시작\n");
    
    int num1 = 4;
    int num2 = 5;
    printf("num1 = %d, num2 = %d\n\n", num1, num2);
    
    int product = multiply(num1, num2);
    
    printf("\nmultiply 함수 반환\n");
    printf("product = %d\n", product);
    
    return 0;
}
```

### 실행 흐름

```
[1] main 함수 시작
    메모리: num1=4, num2=5, product=0

[2] multiply(4, 5) 호출
    메모리: 
    - main: num1=4, num2=5, product=0
    - multiply: x=4, y=5

[3] multiply 함수 실행
    x=4, y=5 출력
    result = 4 * 5 = 20
    20 출력
    return 20

[4] multiply 함수 종료
    multiply의 메모리 삭제
    20이 product에 저장됨

[5] main 함수 계속 실행
    product = 20 출력

[6] 프로그램 종료
    모든 메모리 해제
```

**실행 결과:**
```
main 함수 시작
num1 = 4, num2 = 5

multiply 함수 내부
x = 4, y = 5
계산 결과: 20

multiply 함수 반환
product = 20
```

## ⚠️ 매개변수와 인수의 독립성

### 예제: 값은 같지만 메모리는 다름

```c
#include <stdio.h>

void test(int num) {
    printf("함수 내부 - num: %d\n", num);
    // num을 변경해도 main의 a에는 영향 없음
}

int main() {
    int a = 10;
    printf("main - a: %d\n", a);
    
    test(a);  // a의 값(10)을 복사해서 전달
    
    printf("main - a: %d (변경 안 됨)\n", a);
    
    return 0;
}
```

**실행 결과:**
```
main - a: 10
함수 내부 - num: 10
main - a: 10 (변경 안 됨)
```

**이유:** num과 a는 다른 메모리 공간이므로 num의 값을 변경해도 a는 영향을 받지 않음

## 🔄 main 함수의 return 0

### main 함수도 함수다!

```c
int main() {
    // ...
    return 0;  // main 함수가 반환형 int를 선언했으므로 return 0 필요
}
```

**특이점:**
- main 함수는 **생략 가능**
- C99 표준에서는 마지막 return 0이 자동으로 삽입됨
- 하지만 좋은 습관은 명시적으로 쓰기!

```c
// ✅ 좋은 코드
int main() {
    // ...
    return 0;
}

// ⚠️ 동작하지만 권장하지 않음
int main() {
    // ... (return 생략)
}
```

## 📌 핵심 정리

:::note 꼭 기억하세요!
1. **함수 호출 = 스택에 메모리 생성**
2. **매개변수 = 인수 값의 복사본**
3. **함수 종료 = 스택의 메모리 자동 삭제**
4. **메모리는 독립적** = 함수 내부 변수는 함수 내부에서만 유효
5. **반환값 = 메인 함수의 스택에 잠시 저장 후 변수에 저장**
:::

## 🎯 다음 단계

이제 메모리 구조를 이해했습니다. 다음에는 **값에 의한 전달과 주소에 의한 전달의 차이**를 배우겠습니다!

---

**작성일:** 2024.01.16  
**난이도:** ⭐⭐⭐ 중급