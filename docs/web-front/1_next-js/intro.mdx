---
title: "Next.js란?"
description: "React 기반의 풀스택 웹 애플리케이션 프레임워크 Next.js에 대해 처음부터 차근차근 알아봅니다."
slug: "nextjs-introduction"
sidebar_position: 1
---

# Next.js란?

Next.js는 **React 기반의 오픈소스 웹 애플리케이션 프레임워크**입니다. 

## 용어 설명

먼저 위 문장에 나온 용어들을 하나씩 풀어보겠습니다.

**React**(리액트)는 페이스북(현 Meta)에서 만든 JavaScript 라이브러리로, 웹 페이지의 사용자 인터페이스(UI)를 만드는 도구입니다. 쉽게 말해 웹사이트에서 보이는 버튼, 입력창, 목록 등을 만드는 데 사용합니다.

**프레임워크**(Framework)는 애플리케이션을 만들기 위한 틀이나 뼈대를 제공하는 도구입니다. 집을 지을 때 기둥과 골조가 있으면 더 쉽게 지을 수 있는 것처럼, 프레임워크는 개발에 필요한 기본 구조와 규칙을 제공합니다.

**오픈소스**(Open Source)는 소스 코드가 공개되어 있어 누구나 무료로 사용하고, 수정하고, 배포할 수 있는 소프트웨어를 의미합니다.

정리하면, Next.js는 React를 기반으로 하되, 웹 애플리케이션 개발에 필요한 여러 기능들을 미리 갖춰놓은 도구입니다. Vercel이라는 회사에서 개발하고 유지보수하고 있습니다.

## React만으로는 부족한가요?

React는 훌륭한 도구지만, 실제로 웹사이트를 만들려면 React 외에도 많은 것들을 직접 설정해야 합니다.

예를 들어 React만 사용하면 다음과 같은 것들을 직접 해결해야 합니다.

라우팅****(Routing): 사용자가 `/about` 페이지로 이동하거나 `/contact` 페이지로 이동할 때 어떤 화면을 보여줄지 설정하는 것입니다. React만으로는 이 기능이 없어서 react-router 같은 추가 라이브러리를 설치하고 설정해야 합니다.

**SEO 문제**: 일반적인 React 앱은 빈 HTML 파일에 JavaScript로 내용을 채워 넣는 방식입니다. 이렇게 하면 검색엔진(구글, 네이버 등)이 페이지 내용을 제대로 읽지 못해서 검색 결과에 잘 나오지 않을 수 있습니다.

**성능 최적화**: 이미지 최적화, 코드 분할, 빌드 설정 등을 모두 직접 해야 합니다.

Next.js는 이런 문제들을 해결한 "React + 추가 기능들"이라고 생각하시면 됩니다.

## Next.js의 핵심 기능들

### 1. 서버 사이드 렌더링 (SSR - Server Side Rendering)

이 용어가 처음이시라면 조금 어려울 수 있으니 천천히 설명드리겠습니다.

**렌더링**(Rendering)이란 코드를 실제 사용자가 볼 수 있는 화면으로 변환하는 과정입니다. 쉽게 말해 HTML, CSS, JavaScript 코드를 브라우저가 이해해서 우리가 보는 웹페이지로 만드는 것입니다.

일반적인 React 앱은 **클라이언트 사이드 렌더링**(CSR - Client Side Rendering)을 합니다. 이 방식은 다음과 같이 동작합니다.

1. 서버가 거의 빈 HTML 파일을 보냅니다.
2. 브라우저가 JavaScript 파일을 다운로드합니다.
3. JavaScript가 실행되면서 화면을 그립니다.

이 방식의 문제점은 JavaScript가 다운로드되고 실행될 때까지 사용자는 빈 화면을 보게 됩니다. 또한 검색엔진 봇들이 내용을 제대로 읽지 못할 수 있습니다.

**서버 사이드 렌더링**(SSR)은 이렇게 동작합니다.

1. 서버에서 미리 페이지를 완성된 HTML로 만듭니다.
2. 완성된 HTML을 브라우저에 보냅니다.
3. 사용자는 즉시 내용을 볼 수 있습니다.
4. 그 후에 JavaScript가 로드되어 페이지를 인터랙티브하게 만듭니다.

이렇게 하면 사용자는 더 빨리 내용을 볼 수 있고, 검색엔진도 내용을 잘 읽을 수 있습니다.

Next.js에서 서버 사이드 렌더링을 사용하는 예시를 보겠습니다.

```javascript
// pages/products/[id].js 파일

// 이 함수는 서버에서 실행됩니다
export async function getServerSideProps(context) {
  // context.params.id는 URL의 id 값입니다
  // 예: /products/123 이면 id는 '123'
  const { id } = context.params;
  
  // 서버에서 데이터베이스나 API에서 데이터를 가져옵니다
  const response = await fetch(`https://api.example.com/products/${id}`);
  const product = await response.json();
  
  // 가져온 데이터를 페이지 컴포넌트에 props로 전달합니다
  return {
    props: {
      product, // 이 데이터가 아래 ProductPage 컴포넌트로 전달됩니다
    },
  };
}

// 실제 페이지 컴포넌트
export default function ProductPage({ product }) {
  // 서버에서 가져온 product 데이터를 바로 사용할 수 있습니다
  return (
    <div>
      <h1>{product.name}</h1>
      <p>가격: {product.price}원</p>
      <p>{product.description}</p>
    </div>
  );
}
```

위 코드를 줄별로 설명하면 다음과 같습니다.

`export async function getServerSideProps(context)`: 이것은 Next.js의 특별한 함수입니다. 이 함수가 있으면 Next.js는 "아, 이 페이지는 서버에서 렌더링해야 하는구나"라고 인식합니다. `async`는 이 함수가 비동기 함수라는 의미이고, `context`는 Next.js가 자동으로 제공하는 객체로 요청에 대한 정보를 담고 있습니다.

`const { id } = context.params`: URL에서 동적인 부분을 가져옵니다. 파일 이름이 `[id].js`로 되어 있기 때문에 URL의 해당 부분을 `id`로 받을 수 있습니다.

`const response = await fetch(...)`: API에서 데이터를 가져옵니다. `await`은 이 작업이 완료될 때까지 기다린다는 의미입니다.

`return { props: { product } }`: 가져온 데이터를 `props`라는 이름으로 반환합니다. 이 데이터는 페이지 컴포넌트로 전달됩니다.

`export default function ProductPage({ product })`: 실제 페이지 컴포넌트입니다. 중괄호 안의 `product`는 위에서 전달한 데이터를 받아오는 것입니다. 이를 구조 분해 할당(destructuring)**이라고 합니다.

### 2. 정적 사이트 생성 (SSG - Static Site Generation)

**정적**(Static)이라는 말은 "변하지 않는"이라는 의미입니다. 정적 사이트 생성은 웹사이트를 만들 때(빌드 타임에) 미리 모든 HTML 페이지를 만들어두는 방식입니다.

예를 들어 블로그를 생각해보겠습니다. 블로그 게시글은 한 번 작성하면 자주 바뀌지 않습니다. 이런 경우 매번 서버에서 페이지를 만들 필요 없이, 처음에 한 번만 HTML을 만들어두고 그것을 계속 제공하면 됩니다.

이렇게 하면 다음과 같은 장점이 있습니다.

**빠른 속도**: 이미 만들어진 HTML을 보내기만 하면 되므로 매우 빠릅니다. 서버에서 아무 작업도 할 필요가 없습니다.

**비용 절감**: 서버가 복잡한 작업을 할 필요가 없으므로 서버 비용이 줄어듭니다. CDN(Content Delivery Network)에 파일을 올려두고 전 세계 어디서든 빠르게 제공할 수 있습니다.

**안정성**: 서버가 다운되어도 이미 만들어진 HTML 파일들은 계속 제공될 수 있습니다.

Next.js에서 정적 사이트 생성을 사용하는 예시입니다.

```javascript
// pages/blog/[slug].js 파일

// 빌드 시점에 어떤 페이지들을 생성할지 알려주는 함수
export async function getStaticPaths() {
  // 데이터베이스나 파일 시스템에서 모든 블로그 게시글 목록을 가져옵니다
  const posts = await getAllBlogPosts();
  
  // 각 게시글마다 페이지를 생성하도록 경로 목록을 반환합니다
  const paths = posts.map((post) => ({
    params: { slug: post.slug }, // slug는 URL의 일부입니다. 예: 'my-first-post'
  }));
  
  return {
    paths, // 생성할 페이지들의 목록
    fallback: false, // 목록에 없는 경로는 404 페이지를 보여줍니다
  };
}

// 각 페이지의 데이터를 가져오는 함수 (빌드 시점에 한 번만 실행됩니다)
export async function getStaticProps({ params }) {
  // params.slug를 사용해 해당 게시글의 데이터를 가져옵니다
  const post = await getBlogPost(params.slug);
  
  return {
    props: {
      post, // 이 데이터가 페이지 컴포넌트로 전달됩니다
    },
  };
}

// 실제 블로그 게시글 페이지 컴포넌트
export default function BlogPost({ post }) {
  return (
    <article>
      <h1>{post.title}</h1>
      <p className="date">{post.date}</p>
      <div dangerouslySetInnerHTML={{ __html: post.content }} />
    </article>
  );
}
```

코드 설명을 하나씩 살펴보겠습니다.

`getStaticPaths()`: 이 함수는 Next.js에게 "이런 경로들에 대해 페이지를 미리 만들어줘"라고 알려줍니다. 예를 들어 블로그 게시글이 100개라면, 100개의 HTML 페이지를 빌드 시점에 미리 만듭니다.

`paths`: 생성할 페이지들의 배열입니다. `[{ params: { slug: 'first-post' }}, { params: { slug: 'second-post' }}]` 같은 형태입니다.

`fallback: false`: 이것은 paths 목록에 없는 경로로 접근하면 어떻게 할지 정하는 옵션입니다. `false`로 설정하면 404 페이지를 보여줍니다. `true`나 `'blocking'`으로 설정하면 다른 동작을 할 수 있습니다.

`getStaticProps({ params })`: 각 페이지에 필요한 데이터를 가져옵니다. 이 함수는 빌드할 때 각 경로마다 한 번씩 실행됩니다.

`dangerouslySetInnerHTML`: HTML 문자열을 직접 렌더링하는 React의 기능입니다. 이름에 "dangerous"가 들어간 이유는 XSS(Cross-Site Scripting) 공격에 취약할 수 있기 때문입니다. 신뢰할 수 있는 데이터에만 사용해야 합니다.

### 3. 파일 기반 라우팅 (File-based Routing)

**라우팅**(Routing)은 URL 경로에 따라 어떤 페이지를 보여줄지 결정하는 것입니다. 예를 들어 사용자가 `/about`으로 이동하면 소개 페이지를, `/contact`로 이동하면 연락처 페이지를 보여주는 것입니다.

일반적인 React 앱에서는 react-router 같은 라이브러리를 설치하고 다음처럼 코드로 라우팅을 설정해야 합니다.

```javascript
// 일반적인 React 앱 (Next.js 아님)
import { BrowserRouter, Routes, Route } from 'react-router-dom';

function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<HomePage />} />
        <Route path="/about" element={<AboutPage />} />
        <Route path="/contact" element={<ContactPage />} />
      </Routes>
    </BrowserRouter>
  );
}
```

하지만 Next.js는 **파일 기반 라우팅**을 사용합니다. 폴더와 파일의 구조가 곧 URL 구조가 됩니다. 별도의 라우팅 설정 코드가 필요 없습니다.

다음은 Next.js의 파일 구조와 그에 따른 URL의 예시입니다.

```
pages/
├── index.js          → 루트 경로 /
├── about.js          → /about
├── contact.js        → /contact
├── blog/
│   ├── index.js      → /blog
│   └── [slug].js     → /blog/any-post-name (동적 경로)
└── products/
    ├── index.js      → /products
    └── [id].js       → /products/123 (동적 경로)
```

각 파일과 폴더가 무엇을 의미하는지 설명하겠습니다.

`pages/index.js`: 웹사이트의 메인 페이지입니다. `www.example.com/`에 접속하면 이 파일이 보입니다.

`pages/about.js`: `/about` 페이지입니다. `www.example.com/about`에 접속하면 보입니다.

`pages/blog/index.js`: `/blog` 페이지입니다. 모든 블로그 게시글 목록을 보여주는 페이지로 사용할 수 있습니다.

`pages/blog/[slug].js`: 대괄호 `[]`는 **동적 라우트**(Dynamic Route)를 의미합니다. `slug`라는 이름은 개발자가 정한 것으로, URL의 이 부분에 어떤 값이든 올 수 있다는 뜻입니다. 예를 들어 `/blog/my-first-post`, `/blog/react-tutorial`, `/blog/anything` 모두 이 파일로 처리됩니다.

실제 페이지 파일의 예시를 보겠습니다.

```javascript
// pages/about.js 파일

export default function AboutPage() {
  return (
    <div>
      <h1>회사 소개</h1>
      <p>저희는 2020년에 설립된 기술 회사입니다.</p>
    </div>
  );
}
```

위 코드만 작성하면 끝입니다. 자동으로 `/about` 경로가 생성됩니다. 라우팅 설정 코드가 전혀 필요 없습니다.

동적 라우트의 예시도 보겠습니다.

```javascript
// pages/products/[id].js 파일

import { useRouter } from 'next/router'; // Next.js에서 제공하는 라우터 훅

export default function ProductPage() {
  const router = useRouter(); // 현재 라우터 정보를 가져옵니다
  const { id } = router.query; // URL에서 id 값을 추출합니다
  
  // 사용자가 /products/123 으로 접속하면 id는 '123'입니다
  return (
    <div>
      <h1>상품 번호: {id}</h1>
      <p>이 상품의 상세 정보를 여기에 표시합니다.</p>
    </div>
  );
}
```

`useRouter()`: 이것은 React Hook입니다. 현재 페이지의 라우팅 정보를 가져올 수 있게 해줍니다.

`router.query`: URL의 쿼리 파라미터나 동적 라우트 파라미터를 담고 있는 객체입니다. `[id].js` 파일이므로 `router.query.id`로 URL의 id 부분을 가져올 수 있습니다.

### 4. API 라우트 (API Routes)

**API**(Application Programming Interface)는 프로그램들이 서로 소통하는 방법입니다. 웹 개발에서 API는 보통 프론트엔드(사용자가 보는 화면)가 백엔드(서버)에게 데이터를 요청하거나 보내는 통로를 의미합니다.

일반적으로 웹 애플리케이션을 만들 때는 프론트엔드와 백엔드를 따로 만들어야 합니다. 예를 들어 React로 프론트엔드를 만들고, Node.js + Express로 백엔드 서버를 따로 만드는 식입니다.

하지만 Next.js는 **API 라우트** 기능으로 같은 프로젝트 안에서 백엔드 API도 만들 수 있게 해줍니다. 이를 **풀스택(Full Stack)** 개발이라고 합니다.

API 라우트는 `pages/api/` 폴더 안에 만듭니다. 이 폴더 안의 파일들은 페이지가 아니라 API 엔드포인트가 됩니다.

```
pages/
├── api/
│   ├── hello.js       → /api/hello 엔드포인트
│   ├── users.js       → /api/users 엔드포인트
│   └── posts/
│       └── [id].js    → /api/posts/123 엔드포인트
```

간단한 API 라우트 예시를 보겠습니다.

```javascript
// pages/api/hello.js 파일

// req는 요청(request) 객체, res는 응답(response) 객체입니다
export default function handler(req, res) {
  // 클라이언트에게 JSON 데이터를 응답으로 보냅니다
  res.status(200).json({ 
    message: '안녕하세요!',
    timestamp: new Date().toISOString() 
  });
}
```

코드 설명입니다.

`handler(req, res)`: 모든 API 라우트는 이런 형태의 함수를 export 해야 합니다. 이것을 **핸들러 함수**(Handler Function)라고 합니다.

`req` (request): 클라이언트가 보낸 요청에 대한 정보를 담고 있습니다. 예를 들어 `req.method`는 HTTP 메서드(GET, POST 등)를, `req.body`는 요청 본문을 담고 있습니다.

`res` (response): 클라이언트에게 보낼 응답을 만드는 데 사용하는 객체입니다.

`res.status(200)`: HTTP 상태 코드를 설정합니다. 200은 "성공"을 의미합니다. 다른 코드로는 404(찾을 수 없음), 500(서버 오류) 등이 있습니다.

`res.json({ ... })`: JavaScript 객체를 JSON 형태로 변환해서 클라이언트에게 보냅니다.

조금 더 실용적인 예시를 보겠습니다. 사용자 정보를 가져오는 API입니다.

```javascript
// pages/api/users/[id].js 파일

// 가상의 데이터베이스 (실제로는 진짜 데이터베이스를 사용합니다)
const users = [
  { id: 1, name: '김철수', email: 'kim@example.com' },
  { id: 2, name: '이영희', email: 'lee@example.com' },
  { id: 3, name: '박민수', email: 'park@example.com' },
];

export default function handler(req, res) {
  const { id } = req.query; // URL에서 id를 가져옵니다
  
  // HTTP 메서드에 따라 다르게 처리합니다
  if (req.method === 'GET') {
    // GET 요청: 특정 사용자 정보 조회
    const user = users.find(u => u.id === parseInt(id));
    
    if (user) {
      // 사용자를 찾았으면 200 상태 코드와 함께 데이터를 보냅니다
      res.status(200).json(user);
    } else {
      // 사용자를 못 찾았으면 404 상태 코드와 에러 메시지를 보냅니다
      res.status(404).json({ error: '사용자를 찾을 수 없습니다' });
    }
  } else if (req.method === 'PUT') {
    // PUT 요청: 사용자 정보 수정
    const user = users.find(u => u.id === parseInt(id));
    
    if (user) {
      // req.body에는 클라이언트가 보낸 수정할 데이터가 들어있습니다
      user.name = req.body.name || user.name;
      user.email = req.body.email || user.email;
      
      res.status(200).json({ message: '수정되었습니다', user });
    } else {
      res.status(404).json({ error: '사용자를 찾을 수 없습니다' });
    }
  } else {
    // GET, PUT 외의 메서드는 허용하지 않습니다
    res.status(405).json({ error: '허용되지 않는 메서드입니다' });
  }
}
```

코드를 자세히 살펴보겠습니다.

`req.method`: HTTP 메서드를 확인합니다. GET은 데이터 조회, POST는 새 데이터 생성, PUT은 데이터 수정, DELETE는 데이터 삭제를 의미합니다.

`req.query`: URL의 파라미터를 담고 있습니다. `/api/users/123`으로 요청하면 `req.query.id`는 '123'입니다.

`req.body`: POST나 PUT 요청에서 클라이언트가 보낸 데이터를 담고 있습니다.

`parseInt(id)`: 문자열을 숫자로 변환합니다. URL 파라미터는 항상 문자열이므로 숫자와 비교하려면 변환이 필요합니다.

`users.find(u => u.id === parseInt(id))`: 배열에서 조건에 맞는 첫 번째 요소를 찾습니다. 화살표 함수 `u => u.id === parseInt(id)`는 "각 사용자 u에 대해 u.id가 주어진 id와 같은지 확인하라"는 의미입니다.

프론트엔드에서 이 API를 호출하는 방법은 다음과 같습니다.

```javascript
// 페이지 컴포넌트에서 API 호출하기

export default function UserProfile() {
  const [user, setUser] = useState(null); // 사용자 데이터를 저장할 상태
  const [loading, setLoading] = useState(true); // 로딩 상태
  
  useEffect(() => {
    // 컴포넌트가 마운트되면 API를 호출합니다
    async function fetchUser() {
      const response = await fetch('/api/users/1'); // GET 요청
      const data = await response.json();
      setUser(data); // 받아온 데이터를 상태에 저장
      setLoading(false); // 로딩 완료
    }
    
    fetchUser();
  }, []); // 빈 배열은 이 효과가 처음 한 번만 실행된다는 의미
  
  if (loading) return <p>로딩 중...</p>;
  
  return (
    <div>
      <h1>{user.name}</h1>
      <p>이메일: {user.email}</p>
    </div>
  );
}
```

`useState`: React Hook으로, 컴포넌트에 상태를 추가합니다. `[user, setUser]`는 구조 분해 할당으로, user는 현재 상태 값이고 setUser는 상태를 변경하는 함수입니다.

`useEffect`: React Hook으로, 컴포넌트가 렌더링된 후 실행할 부수 효과(side effect)를 정의합니다. 데이터 가져오기, 구독 설정 등에 사용합니다.

`async/await`: 비동기 작업을 동기적인 코드처럼 작성할 수 있게 해주는 문법입니다. `await`은 Promise가 완료될 때까지 기다립니다.

`fetch()`: 브라우저에 내장된 함수로 HTTP 요청을 보냅니다.

### 5. 자동 코드 분할 (Automatic Code Splitting)

**코드 분할**(Code Splitting)은 전체 JavaScript 코드를 작은 조각들로 나누는 것을 의미합니다.

웹사이트가 커질수록 JavaScript 파일도 커집니다. 만약 사용자가 홈페이지에만 접속했는데 관리자 페이지의 코드까지 모두 다운로드해야 한다면 비효율적입니다. 사용하지도 않을 코드까지 다운로드하느라 시간이 오래 걸리기 때문입니다.

Next.js는 각 페이지마다 필요한 코드만 자동으로 분리해서 로드합니다. 사용자가 홈페이지를 방문하면 홈페이지 코드만, 소개 페이지를 방문하면 소개 페이지 코드만 다운로드됩니다.

또한 사용자가 링크 위에 마우스를 올리면 Next.js는 그 페이지의 코드를 미리 가져옵니다. 이를 **프리페칭**(Prefetching)이라고 합니다. 그래서 실제로 클릭했을 때 페이지가 즉시 나타납니다.

```javascript
// pages/index.js

import Link from 'next/link'; // Next.js의 Link 컴포넌트

export default function HomePage() {
  return (
    <div>
      <h1>홈페이지</h1>
      {/* Link 컴포넌트를 사용하면 자동으로 프리페칭이 됩니다 */}
      <Link href="/about">
        <a>소개 페이지로 이동</a>
      </Link>
    </div>
  );
}
```

`Link` 컴포넌트: Next.js에서 제공하는 특별한 컴포넌트입니다. 일반 HTML `<a>` 태그 대신 이것을 사용하면 페이지 이동 시 전체 페이지를 새로고침하지 않고 필요한 부분만 업데이트합니다. 또한 자동으로 코드 분할과 프리페칭을 처리합니다.

### 6. 이미지 최적화 (Image Optimization)

이미지는 웹페이지에서 가장 큰 용량을 차지하는 요소 중 하나입니다. 최적화하지 않은 이미지를 사용하면 페이지 로딩이 느려지고, 모바일 데이터를 많이 소모하게 됩니다.

Next.js의 `Image` 컴포넌트는 다음과 같은 최적화를 자동으로 해줍니다.

**자동 리사이징**: 사용자의 화면 크기에 맞는 이미지를 제공합니다. 모바일에서는 작은 이미지를, 데스크톱에서는 큰 이미지를 자동으로 제공합니다.

**지연 로딩(Lazy Loading)**: 이미지가 화면에 보일 때만 로드합니다. 페이지 하단에 있는 이미지는 사용자가 스크롤해서 그 위치에 도달할 때 로드됩니다.

**최신 포맷 사용**: WebP 같은 최신 이미지 포맷을 지원하는 브라우저에는 더 작은 용량의 최신 포맷으로 제공합니다.

```javascript
// 일반 HTML img 태그 (Next.js 이미지 최적화 없음)
<img src="/profile.jpg" alt="프로필 사진" width="500" height="500" />

// Next.js Image 컴포넌트 (자동 최적화)
import Image from 'next/image';

<Image
  src="/profile.jpg"           // 이미지 경로
  alt="프로필 사진"              // 대체 텍스트 (접근성을 위해 필수)
  width={500}                  // 원본 이미지의 너비
  height={500}                 // 원본 이미지의 높이
  placeholder="blur"           // 로딩 중 흐릿한 플레이스홀더 표시
  blurDataURL="/blur.jpg"      // 플레이스홀더로 사용할 작은 이미지
  priority                      // 이 이미지를 우선적으로 로드 (중요한 이미지에 사용)
/>
```

각 속성을 설명하겠습니다.

`src`: 이미지 파일의 경로입니다. `/profile.jpg`는 `public/profile.jpg` 파일을 의미합니다.

`alt`: 대체 텍스트로, 이미지가 로드되지 않거나 스크린 리더를 사용하는 시각장애인을 위해 제공하는 설명입니다. 웹 접근성을 위해 반드시 제공해야 합니다.

`width`와 `height`: 이미지의 원래 크기를 지정합니다. Next.js는 이 정보를 사용해 레이아웃이 변경되지 않도록 공간을 미리 확보합니다. 이를 **CLS(Cumulative Layout Shift)** 방지라고 합니다.

`placeholder="blur"`: 이미지가 로딩되는 동안 흐릿한 플레이스홀더를 보여줍니다. 사용자 경험을 개선합니다.

`priority`: 이 속성을 추가하면 Next.js가 이 이미지를 우선적으로 로드합니다. 페이지 상단의 중요한 이미지(히어로 이미지 등)에 사용합니다.

## Next.js를 사용하는 이유 정리

지금까지 설명한 내용을 종합하면 Next.js를 사용하는 이유는 다음과 같습니다.

**개발 경험 향상**: 파일 기반 라우팅으로 복잡한 설정 없이 개발할 수 있고, 코드를 수정하면 즉시 브라우저에 반영되는 Fast Refresh 기능이 있습니다. TypeScript도 기본적으로 지원합니다.

**성능 최적화**: 자동 코드 분할, 이미지 최적화, 폰트 최적화 등 많은 최적화가 자동으로 이루어집니다. 개발자가 직접 설정할 필요가 없습니다.

**SEO 친화적**: 서버 사이드 렌더링과 정적 생성으로 검색 엔진이 페이지 내용을 잘 읽을 수 있습니다. 구글, 네이버 같은 검색엔진에서 사이트가 잘 노출됩니다.

**유연성**: 페이지마다 SSR, SSG, CSR(클라이언트 사이드 렌더링) 중 적합한 방식을 선택할 수 있습니다. 블로그 게시글은 SSG로, 실시간 대시보드는 CSR로, 개인화된 페이지는 SSR로 만들 수 있습니다.

**풀스택 개발**: API 라우트를 사용해 프론트엔드와 백엔드를 한 프로젝트에서 관리할 수 있습니다. 작은 프로젝트나 프로토타입을 빠르게 만들기 좋습니다.

## 첫 Next.js 프로젝트 시작하기

이제 실제로 Next.js 프로젝트를 만들어보겠습니다.

### 준비물

먼저 컴퓨터에 다음 프로그램들이 설치되어 있어야 합니다.

**Node.js**: JavaScript를 브라우저 밖에서도 실행할 수 있게 해주는 런타임 환경입니다. [nodejs.org](https://nodejs.org)에서 다운로드할 수 있습니다. LTS(Long Term Support) 버전을 설치하시면 됩니다.

**npm 또는 yarn**: Node.js와 함께 자동으로 설치되는 패키지 매니저입니다. 다른 사람들이 만든 라이브러리를 쉽게 설치하고 관리할 수 있게 해줍니다.

**코드 에디터**: VS Code를 추천합니다. [code.visualstudio.com](https://code.visualstudio.com)에서 무료로 다운로드할 수 있습니다.

### 프로젝트 생성

터미널(또는 명령 프롬프트)을 열고 다음 명령어를 입력합니다.

```bash
npx create-next-app@latest my-first-nextjs-app
```

각 부분을 설명하겠습니다.

`npx`: npm 패키지를 설치하지 않고 일회성으로 실행하는 명령어입니다.

`create-next-app`: Next.js 팀에서 제공하는 프로젝트 생성 도구입니다.

`@latest`: 최신 버전을 사용하겠다는 의미입니다.

`my-first-nextjs-app`: 만들 프로젝트의 이름입니다. 원하는 이름으로 바꿔도 됩니다.

명령어를 실행하면 몇 가지 질문이 나옵니다.

```
Would you like to use TypeScript? › No / Yes
```
TypeScript를 사용할지 묻습니다. TypeScript는 JavaScript에 타입 시스템을 추가한 언어로, 더 안전한 코드를 작성할 수 있게 해줍니다. 초보자라면 No를 선택해도 좋습니다.

```
Would you like to use ESLint? › No / Yes
```
ESLint는 코드의 문제를 자동으로 찾아주는 도구입니다. Yes를 선택하는 것을 권장합니다.

```
Would you like to use Tailwind CSS? › No / Yes
```
Tailwind CSS는 인기 있는 CSS 프레임워크입니다. 원하시면 Yes를 선택하세요.

```
Would you like to use `src/` directory? › No / Yes
```
src 폴더를 사용할지 묻습니다. 프로젝트 구조를 더 깔끔하게 만들 수 있습니다. 취향에 따라 선택하시면 됩니다.

```
Would you like to use App Router? (recommended) › No / Yes
```
App Router는 Next.js 13부터 도입된 새로운 라우팅 방식입니다. 더 강력한 기능을 제공하지만 초보자에게는 기존의 Pages Router가 더 쉬울 수 있습니다. 이 문서는 Pages Router를 기준으로 설명했으므로 No를 선택하시면 됩니다.

모든 질문에 답하면 프로젝트가 자동으로 생성됩니다.

### 프로젝트 실행

프로젝트 폴더로 이동합니다.

```bash
cd my-first-nextjs-app
```

`cd`는 "change directory"의 약자로 폴더를 이동하는 명령어입니다.

개발 서버를 실행합니다.

```bash
npm run dev
```

`npm run dev`: package.json 파일에 정의된 dev 스크립트를 실행합니다. 개발 모드로 Next.js 서버를 시작합니다.

터미널에 다음과 같은 메시지가 나타나면 성공입니다.

```
ready - started server on 0.0.0.0:3000, url: http://localhost:3000
```

브라우저를 열고 `http://localhost:3000`에 접속하면 Next.js 시작 페이지를 볼 수 있습니다.

**localhost**: 여러분의 컴퓨터를 의미합니다. 외부에서 접속할 수 없고 본인만 볼 수 있습니다.

**3000**: 포트 번호입니다. 한 컴퓨터에서 여러 서버를 동시에 실행할 때 구분하기 위한 번호입니다.

### 첫 페이지 만들기

이제 간단한 페이지를 만들어보겠습니다.

프로젝트 폴더의 `pages` 디렉토리에 `hello.js` 파일을 만들고 다음 코드를 작성합니다.

```javascript
// pages/hello.js

export default function HelloPage() {
  return (
    <div style={{ padding: '50px', textAlign: 'center' }}>
      <h1>안녕하세요!</h1>
      <p>첫 Next.js 페이지입니다.</p>
      <p>현재 시간: {new Date().toLocaleTimeString('ko-KR')}</p>
    </div>
  );
}
```

파일을 저장하고 브라우저에서 `http://localhost:3000/hello`에 접속하면 방금 만든 페이지를 볼 수 있습니다. 별도의 설정 없이 `/hello` 경로가 자동으로 생성되었습니다.

코드를 수정하고 저장하면 브라우저가 자동으로 새로고침되며 변경사항이 즉시 반영됩니다. 이것이 **Hot Module Replacement (HMR)** 또는 **Fast Refresh** 기능입니다.

## 실제 활용 사례

Next.js는 다양한 종류의 웹사이트를 만드는 데 사용됩니다.

**전자상거래 사이트**: 상품 목록 페이지는 SSG로 미리 생성하고, 장바구니는 클라이언트 사이드에서 관리하고, 결제는 API 라우트로 처리할 수 있습니다.

**블로그/뉴스 사이트**: 모든 게시글을 SSG로 미리 생성해 빠른 로딩 속도와 좋은 SEO를 제공합니다.

**대시보드/관리자 페이지**: 실시간 데이터가 필요한 부분은 클라이언트 사이드 렌더링을 사용하고, 인증은 API 라우트로 처리합니다.

**기업 웹사이트**: 마케팅 페이지는 SSG로, 사용자별로 다른 내용을 보여주는 페이지는 SSR로 만듭니다.

**SaaS 애플리케이션**: 랜딩 페이지는 SSG로, 로그인 후 사용자 대시보드는 SSR이나 CSR로, API는 API 라우트로 구현할 수 있습니다.

## 유명 기업들의 사용 사례

실제로 많은 유명 기업들이 Next.js를 사용하고 있습니다.

**Netflix Jobs**: 넷플릭스의 채용 사이트는 Next.js로 만들어졌습니다.

**TikTok**: 틱톡 웹 버전도 Next.js를 사용합니다.

**Twitch**: 트위치의 일부 페이지들이 Next.js로 만들어졌습니다.

**Nike**: 나이키의 일부 웹사이트도 Next.js를 사용합니다.

**Notion**: 노션의 마케팅 사이트는 Next.js로 만들어졌습니다.

## 다음 단계

이제 Next.js가 무엇인지, 어떤 기능들이 있는지 이해하셨을 것입니다. 더 깊이 학습하고 싶으시다면 다음 자료들을 추천드립니다.

**공식 문서**: [nextjs.org/docs](https://nextjs.org/docs)에서 모든 기능을 자세히 설명하고 있습니다.

**공식 튜토리얼**: [nextjs.org/learn](https://nextjs.org/learn)에서 단계별로 Next.js를 배울 수 있는 무료 강의를 제공합니다. 실제로 블로그를 만들어보면서 배울 수 있습니다.

**예제 프로젝트**: [GitHub 저장소](https://github.com/vercel/next.js/tree/canary/examples)에서 다양한 예제 프로젝트를 볼 수 있습니다. 블로그, 전자상거래, 인증 등 여러 주제의 예제가 있습니다.

**커뮤니티**: Next.js Discord 채널이나 한국 개발자 커뮤니티에서 다른 개발자들과 소통하며 배울 수 있습니다.

Next.js와 함께 즐거운 웹 개발 되시길 바랍니다!