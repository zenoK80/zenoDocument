---
title: React 설치하기 (완전 초보자용)
description: 모든 용어와 개념을 처음부터 자세하게 설명합니다
slug: /react-installation
sidebar_position: 1
---

# React 설치하기 - 완전 초보자 가이드

이 문서는 **모든 용어를 처음 듣는 분들**을 위해 작성되었습니다. 천천히 읽어보세요! 📚

:::info 이 문서를 읽기 전에
- ⏰ 예상 소요 시간: 30-40분
- 🎯 모든 용어를 이해하는 것이 목표입니다
- 📝 이해 안 되는 부분은 건너뛰지 말고 다시 읽어보세요
- ☕ 편안하게 앉아서 천천히 읽으세요!
:::

---

## 목차

1. [기본 용어 이해하기](#기본-용어-이해하기)
2. [React를 체험하는 방법](#react를-체험하는-방법)
3. [프레임워크란 무엇인가](#프레임워크란-무엇인가)
4. [각 도구들 자세히 알아보기](#각-도구들-자세히-알아보기)
5. [명령어 이해하기](#명령어-이해하기)

---

## 기본 용어 이해하기

먼저 이 문서에서 나오는 **모든 용어**를 하나씩 설명하겠습니다.

### React가 뭔가요?

**React**는 Facebook(현재는 Meta)에서 만든 **JavaScript 라이브러리**입니다.

```
라이브러리(Library) = 도서관
→ 필요한 책(기능)을 가져다 쓸 수 있는 곳

React = 웹 페이지를 만들 때 필요한 기능들이 모여있는 곳
```

**실생활 비유:**
- 집을 지을 때 벽돌, 시멘트, 목재 등을 사나요? (재료)
- React는 웹사이트를 지을 때 필요한 "재료"입니다

### 설치(Installation)가 뭔가요?

**설치**는 컴퓨터에 프로그램을 준비하는 과정입니다.

```
예시:
- 게임을 하려면 → 게임을 설치해야 함
- React를 쓰려면 → React를 설치해야 함

하지만! React는 설치 없이도 시작할 수 있습니다 (온라인에서)
```

### 프레임워크(Framework)가 뭔가요?

**프레임워크**는 "틀" 또는 "뼈대"라는 뜻입니다.

```
비유:
집을 지을 때

1. 재료만 사기 (React만 쓰기)
   └─ 벽돌, 시멘트, 목재를 사서
   └─ 내가 직접 전부 조립해야 함
   └─ 시간: 6개월, 난이도: 매우 어려움

2. 조립식 주택 키트 사기 (프레임워크 쓰기)
   └─ 설계도와 필요한 재료가 다 들어있음
   └─ 조립만 하면 됨
   └─ 시간: 1개월, 난이도: 보통

프레임워크 = 이미 설계되고 준비된 "키트"
```

**React와 프레임워크의 차이:**

| | React | Next.js (프레임워크) |
|---|---|---|
| 제공하는 것 | UI 만드는 기능만 | UI + 라우팅 + 서버 + 빌드 도구 등 |
| 시작 시간 | 빠름 | 즉시 시작 가능 |
| 설정 필요 | 많음 | 거의 없음 |
| 난이도 | 어려움 | 쉬움 |

---

## 웹 개발 기본 용어들

### npm이 뭔가요?

**npm (Node Package Manager)** = 노드 패키지 관리자

```
비유: 앱스토어

- 핸드폰 앱스토어 → 앱을 다운로드
- npm → JavaScript 라이브러리를 다운로드

예시:
- "카카오톡 앱 설치해줘" → 앱스토어 검색
- "React 라이브러리 설치해줘" → npm 검색
```

**명령어 예시:**
```bash
npm install react
     ↑       ↑
   설치해줘  React를
```

### npx가 뭔가요?

**npx (Node Package eXecute)** = 노드 패키지 실행기

```
npm과 npx의 차이:

npm install = "설치"
└─ 컴퓨터에 저장해서 계속 사용

npx = "잠깐 빌려서 실행"
└─ 설치 안 하고 한 번만 실행
└─ 실행 끝나면 자동 삭제
```

**예시:**
```bash
# npm (설치해서 계속 사용)
npm install create-react-app
create-react-app my-app

# npx (설치 안 하고 바로 실행)
npx create-react-app my-app
    ↑
잠깐 빌려서 실행하고 삭제
```

**언제 뭘 쓰나요?**
- **한 번만 쓸 것** → npx (프로젝트 생성 도구 등)
- **계속 쓸 것** → npm install (React, React-dom 등)

### Node.js가 뭔가요?

**Node.js** = JavaScript를 브라우저 밖에서도 실행할 수 있게 해주는 프로그램

```
원래:
- JavaScript는 브라우저(Chrome, Safari)에서만 실행됨
- HTML 파일을 열어야만 JavaScript가 작동

Node.js 설치 후:
- 컴퓨터 어디서든 JavaScript 실행 가능
- 터미널(명령 프롬프트)에서 JavaScript 실행 가능
```

**왜 필요한가요?**

React 개발을 위해서는:
1. npm을 사용해야 함 (라이브러리 설치)
2. npm은 Node.js가 있어야 작동함
3. 따라서 Node.js를 먼저 설치해야 함

```
Node.js 설치 → npm 사용 가능 → React 설치 가능
```

---

## 코드를 실행하는 방법들

### 브라우저가 뭔가요?

**브라우저 (Browser)** = 웹사이트를 보는 프로그램

```
브라우저 종류:
- Chrome (크롬) ← 가장 많이 사용
- Safari (사파리) ← 맥에서 기본
- Firefox (파이어폭스)
- Edge (엣지) ← 윈도우에서 기본
```

**브라우저가 하는 일:**
1. HTML 파일을 읽음
2. CSS로 예쁘게 꾸밈
3. JavaScript로 움직이게 함
4. 화면에 보여줌

### CDN이 뭔가요?

**CDN (Content Delivery Network)** = 콘텐츠 전달 네트워크

```
비유: 도서관 vs 온라인 도서관

1. 일반 도서관 (npm install)
   - 책을 빌려서 집에 가져옴
   - 내 책장에 보관
   - 언제든지 읽을 수 있음

2. 온라인 도서관 (CDN)
   - 인터넷으로 책 내용을 봄
   - 집에 보관 안 함
   - 인터넷 있어야 읽을 수 있음
```

**React CDN 사용:**

```html
<!-- 이 한 줄로 React를 "빌려서" 사용 -->
<script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
           ↑
      인터넷 주소 (CDN)
```

**CDN 장점:**
- ✅ 설치 필요 없음
- ✅ 간단함
- ✅ 바로 시작 가능

**CDN 단점:**
- ❌ 인터넷 필요
- ❌ 느림 (매번 다운로드)
- ❌ 고급 기능 사용 어려움

---

## React 관련 용어들

### JSX가 뭔가요?

**JSX (JavaScript XML)** = JavaScript 안에 HTML을 쓸 수 있게 해주는 문법

```jsx
// 일반 JavaScript
const element = document.createElement('h1');
element.textContent = 'Hello';
document.body.appendChild(element);

// JSX (훨씬 쉬움!)
const element = <h1>Hello</h1>;
```

**왜 JSX를 쓰나요?**

```jsx
// JSX 없이 (복잡함!)
React.createElement(
  'div',
  { className: 'container' },
  React.createElement('h1', null, 'Hello'),
  React.createElement('p', null, 'World')
)

// JSX 사용 (읽기 쉬움!)
<div className="container">
  <h1>Hello</h1>
  <p>World</p>
</div>
```

**주의:** 브라우저는 JSX를 이해 못 합니다!
```
JSX 코드 작성
    ↓
Babel이 변환 (JSX → 일반 JavaScript)
    ↓
브라우저가 실행
```

### Babel이 뭔가요?

**Babel (바벨)** = JavaScript 코드 번역기

```
비유: 통역사

외국인 ─[영어]→ 통역사 ─[한국어]→ 한국인

개발자 ─[JSX]→ Babel ─[일반 JS]→ 브라우저
```

**Babel이 하는 일:**

```jsx
// 우리가 쓴 코드 (JSX)
const element = <h1>Hello</h1>;

// Babel이 변환한 코드 (일반 JavaScript)
const element = React.createElement('h1', null, 'Hello');
```

**또 다른 역할:**
```javascript
// 최신 JavaScript (브라우저가 모를 수도 있음)
const name = 'John';
const greeting = `Hello, ${name}`;

// Babel이 변환 (구형 브라우저도 이해 가능)
var name = 'John';
var greeting = 'Hello, ' + name;
```

### 컴포넌트가 뭔가요?

**컴포넌트 (Component)** = 재사용 가능한 UI 조각

```
비유: 레고 블록

레고 블록 하나하나 = 컴포넌트
여러 블록을 조합 = 완성된 웹사이트
```

**예시:**
```jsx
// 버튼 컴포넌트
function Button() {
  return <button>클릭하세요</button>;
}

// 이 버튼을 여러 곳에서 재사용
function App() {
  return (
    <div>
      <Button />  {/* 첫 번째 버튼 */}
      <Button />  {/* 두 번째 버튼 */}
      <Button />  {/* 세 번째 버튼 */}
    </div>
  );
}
```

**컴포넌트의 장점:**
- ✅ 한 번 만들면 여러 번 사용
- ✅ 수정이 쉬움 (한 곳만 고치면 모든 곳 변경)
- ✅ 코드 정리가 쉬움

---

## 개발 도구들

### 번들러 (Bundler)가 뭔가요?

**번들러** = 여러 파일을 하나로 합쳐주는 도구

```
비유: 여행 짐싸기

여행 준비:
- 옷, 신발, 세면도구, 충전기, 책...
- 이것들을 여러 가방에 나눠 담으면 불편함
- 하나의 캐리어에 모두 담으면 편함!

웹 개발:
- App.js, Button.js, Header.js, utils.js...
- 이것들을 하나씩 로드하면 느림
- 번들러가 하나의 파일로 합쳐줌 → 빠름!
```

**번들러가 하는 일:**

```
작업 전:
my-app/
├── App.js          (10KB)
├── Header.js       (5KB)
├── Footer.js       (5KB)
├── Button.js       (3KB)
└── utils.js        (2KB)

번들러 실행 후:
dist/
└── bundle.js       (20KB, 하나로 합쳐짐!)
```

**유명한 번들러들:**

1. **Webpack (웹팩)**
   ```
   장점: 가장 많이 사용됨, 기능 많음
   단점: 설정 복잡함, 느림
   ```

2. **Vite (비트)**
   ```
   장점: 엄청 빠름, 설정 간단
   단점: 비교적 새로움
   ```

3. **Parcel (파슬)**
   ```
   장점: 설정 거의 필요 없음
   단점: 커스터마이징 어려움
   ```

### 린터 (Linter)가 뭔가요?

**린터** = 코드 검사 도구 (맞춤법 검사기 같은 것)

```
비유: 글쓰기 맞춤법 검사

글 작성:
"안녕하세요. 졔 이름은 철수입니다."
         ↑
      맞춤법 검사기가 발견!
      "졔" → "제"로 수정 제안

코드 작성:
const name = 'John'
if (name = 'John') { }  ← 버그!
     ↑
린터가 경고: "=는 비교가 아니라 할당입니다. ==를 쓰세요!"
```

**ESLint (가장 많이 사용하는 린터):**

```javascript
// 문제 있는 코드
function hello() {
  var x = 1;  // var는 옛날 방식
  console.log(x)  // 세미콜론 없음
}

// ESLint 경고:
// ⚠️ 'var' 대신 'const'나 'let'을 쓰세요
// ⚠️ 세미콜론이 빠졌습니다
```

**린터를 쓰는 이유:**
- ✅ 버그를 미리 발견
- ✅ 코드 스타일 통일
- ✅ 나쁜 코딩 습관 방지

### 개발 서버가 뭔가요?

**개발 서버** = 코드를 수정하면 자동으로 화면이 업데이트되게 해주는 프로그램

```
개발 서버 없이:
1. 코드 수정
2. 파일 저장
3. 브라우저 열기
4. F5 새로고침
5. 결과 확인
└─ 너무 번거로움!

개발 서버 사용:
1. 코드 수정
2. 파일 저장
3. (자동으로 화면 업데이트!)
4. 결과 확인
└─ 편함!
```

**핫 모듈 교체 (HMR - Hot Module Replacement):**

```
일반 새로고침:
- 페이지 전체가 새로고침
- 작성하던 폼 내용 다 날아감
- 로그인 풀림

HMR:
- 수정한 부분만 교체
- 작성하던 내용 유지
- 로그인 상태 유지
```

**명령어:**
```bash
npm run dev          # 개발 서버 시작 (Vite)
npm start           # 개발 서버 시작 (다른 도구들)

# 서버가 시작되면:
# > Local: http://localhost:3000
#   이 주소를 브라우저에 입력하면 내 앱이 보임
```

---

## 웹 개발 고급 용어들

### 라우팅 (Routing)이 뭔가요?

**라우팅** = 페이지 이동 관리

```
일반 웹사이트:
- home.html      → 홈페이지
- about.html     → 소개 페이지
- contact.html   → 연락처 페이지

React (SPA - Single Page Application):
- index.html 하나만!
- JavaScript가 내용을 바꿔치기
- URL만 바뀌고 페이지는 안 새로고침됨
```

**라우팅 예시:**

```jsx
// React Router 사용 예시
import { BrowserRouter, Routes, Route } from 'react-router-dom';

function App() {
  return (
    <BrowserRouter>
      <Routes>
        {/* URL이 "/" 면 Home 컴포넌트 보여줌 */}
        <Route path="/" element={<Home />} />
        
        {/* URL이 "/about" 면 About 컴포넌트 보여줌 */}
        <Route path="/about" element={<About />} />
        
        {/* URL이 "/contact" 면 Contact 컴포넌트 보여줌 */}
        <Route path="/contact" element={<Contact />} />
      </Routes>
    </BrowserRouter>
  );
}
```

**라우팅의 장점:**
- ✅ 뒤로가기 버튼 작동
- ✅ URL 공유 가능
- ✅ 북마크 가능
- ✅ 페이지 전환이 부드러움

### 데이터 페칭 (Data Fetching)이 뭔가요?

**데이터 페칭** = 서버에서 데이터를 가져오는 것

```
비유: 식당에서 주문

1. 손님이 메뉴 주문 (데이터 요청)
2. 주방에서 요리 (서버 처리)
3. 웨이터가 음식 가져옴 (데이터 받기)
4. 손님이 먹음 (화면에 표시)
```

**실제 예시:**

```jsx
function UserProfile() {
  const [user, setUser] = useState(null);  // 데이터 저장할 곳
  
  useEffect(() => {
    // 서버에서 사용자 정보 가져오기
    fetch('https://api.example.com/user/123')
      .then(response => response.json())  // JSON으로 변환
      .then(data => setUser(data))        // 데이터 저장
  }, []);
  
  if (!user) return <div>로딩 중...</div>;
  
  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
}
```

**단계별 설명:**

```
1. 컴포넌트 시작 → user는 null
2. "로딩 중..." 표시
3. fetch로 서버에 요청
4. 서버가 데이터 보냄: { name: '철수', email: 'chul@email.com' }
5. setUser로 데이터 저장
6. 화면 다시 그림 (리렌더링)
7. 철수의 정보 표시
```

### 빌드 최적화가 뭔가요?

**빌드** = 개발 코드를 배포용 코드로 변환하는 과정

```
비유: 요리

개발 환경 (주방에서 요리):
- 재료가 여기저기 흩어짐
- 시식하면서 조리
- 느리고 지저분해도 괜찮음

배포 환경 (손님에게 제공):
- 깔끔하게 플레이팅
- 먹기 좋게 준비
- 빠르고 예뻐야 함
```

**빌드가 하는 일:**

```javascript
// 개발 중 코드 (읽기 쉬움, 용량 큼)
function calculateTotal(items) {
  let total = 0;
  for (let i = 0; i < items.length; i++) {
    total += items[i].price;
  }
  return total;
}

// 빌드 후 코드 (압축됨, 용량 작음, 빠름)
function calculateTotal(t){let e=0;for(let l=0;l<t.length;l++)e+=t[l].price;return e}
```

**최적화 항목:**

1. **코드 압축 (Minification)**
   ```
   변경 전: 1000줄, 50KB
   변경 후: 100줄, 15KB
   ```

2. **불필요한 코드 제거 (Tree Shaking)**
   ```
   import { sum, multiply } from 'math-utils';
   
   // sum만 쓰고 multiply는 안 쓰면
   // multiply 코드는 최종 번들에서 제거됨
   ```

3. **이미지 최적화**
   ```
   원본 이미지: 5MB
   최적화 후: 500KB (10배 작음!)
   ```

4. **코드 분할 (Code Splitting)**
   ```
   전체 앱을 한 번에 로드하지 않고
   필요한 부분만 나눠서 로드
   → 초기 로딩 속도 향상
   ```

### SEO가 뭔가요?

**SEO (Search Engine Optimization)** = 검색 엔진 최적화

```
비유: 가게 간판

잘 보이는 간판:
- 큰 글씨
- 밝은 조명
- 메인 도로변
→ 손님이 많이 옴

SEO가 좋은 웹사이트:
- 검색 결과 상위에 표시
- 많은 사람이 방문
→ 사업에 도움
```

**SEO가 중요한 이유:**

```
Google 검색: "맛있는 피자"

검색 결과:
1위: 피자천국 (클릭률 30%)
2위: 피자세상 (클릭률 15%)
3위: 피자왕국 (클릭률 10%)
...
10위: 우리 가게 (클릭률 1%)

→ 1위와 10위는 방문자 수가 30배 차이!
```

**React와 SEO 문제:**

```
일반 React 앱 (CSR - Client Side Rendering):

구글 봇이 웹사이트 방문
    ↓
HTML 확인:
<div id="root"></div>  ← 내용이 비어있음!
    ↓
구글: "이 사이트는 내용이 없네요"
    ↓
검색 결과 하위로...

---

Next.js (SSR - Server Side Rendering):

구글 봇이 웹사이트 방문
    ↓
HTML 확인:
<div id="root">
  <h1>맛있는 피자</h1>
  <p>최고의 피자를 만듭니다...</p>
</div>  ← 내용이 이미 있음!
    ↓
구글: "좋은 사이트네요!"
    ↓
검색 결과 상위!
```

### SSR vs SSG vs CSR - 뭐가 다른가요?

이 개념들은 **웹페이지를 "언제" 만드느냐**의 차이입니다.

#### CSR (Client Side Rendering) - 클라이언트에서 렌더링

**"클라이언트"** = 사용자의 브라우저

```
사용자가 웹사이트 방문
    ↓
서버가 빈 HTML 보냄:
<!DOCTYPE html>
<html>
  <body>
    <div id="root"></div>  ← 비어있음!
    <script src="bundle.js"></script>
  </body>
</html>
    ↓
브라우저가 JavaScript 다운로드 (bundle.js)
    ↓
JavaScript 실행
    ↓
React가 화면을 그림
    ↓
사용자가 내용을 봄
```

**특징:**
```
장점:
✅ 페이지 전환이 빠름 (이미 모든 코드가 로드됨)
✅ 서버 부담 적음
✅ 인터랙션이 부드러움

단점:
❌ 초기 로딩 느림 (JavaScript 다운로드 필요)
❌ SEO 나쁨 (구글이 빈 페이지를 봄)
❌ 인터넷 느리면 흰 화면만 보임

언제 사용?
- 관리자 페이지 (SEO 불필요)
- 로그인 필요한 서비스
- 대시보드, 도구
```

#### SSR (Server Side Rendering) - 서버에서 렌더링

```
사용자가 웹사이트 방문
    ↓
서버가 React 실행해서 HTML 생성
    ↓
완성된 HTML을 사용자에게 보냄:
<!DOCTYPE html>
<html>
  <body>
    <div id="root">
      <h1>안녕하세요</h1>  ← 이미 내용이 있음!
      <p>환영합니다</p>
    </div>
    <script src="bundle.js"></script>
  </body>
</html>
    ↓
사용자가 즉시 내용을 봄 (JavaScript 없어도!)
    ↓
JavaScript 로드되면 인터랙티브하게 변함
```

**특징:**
```
장점:
✅ 초기 로딩 빠름 (HTML이 이미 완성)
✅ SEO 좋음 (구글이 내용을 봄)
✅ 느린 인터넷에서도 빠르게 보임

단점:
❌ 서버 부담 큼 (매번 HTML 생성)
❌ 페이지 전환마다 서버 요청
❌ 서버 비용 증가

언제 사용?
- 블로그
- 뉴스 사이트
- 전자상거래 (상품 페이지)
- SEO가 중요한 모든 사이트
```

**Next.js의 SSR 코드:**
```jsx
// 이 함수가 서버에서 실행됨
export async function getServerSideProps() {
  // 서버에서 데이터 가져오기
  const res = await fetch('https://api.example.com/products');
  const products = await res.json();
  
  // 이 데이터로 페이지 생성
  return {
    props: { products }
  };
}

function ProductsPage({ products }) {
  // products는 이미 서버에서 받아온 상태
  return (
    <div>
      {products.map(product => (
        <div key={product.id}>{product.name}</div>
      ))}
    </div>
  );
}
```

#### SSG (Static Site Generation) - 정적 사이트 생성

```
개발자가 npm run build 실행
    ↓
빌드 시점에 모든 페이지를 HTML로 미리 생성
    ↓
서버에 업로드
    ↓
사용자가 방문하면
    ↓
이미 만들어진 HTML 파일을 바로 보냄
```

**비유:**
```
SSR = 주문하면 그때그때 요리 (느림, 신선함)
SSG = 미리 만들어둔 도시락 (빠름, 똑같음)
```

**특징:**
```
장점:
✅ 엄청나게 빠름 (이미 만들어진 HTML)
✅ SEO 완벽 (HTML이 미리 있음)
✅ 서버 비용 거의 없음 (정적 파일 호스팅)
✅ CDN 사용 가능 (전 세계 어디서나 빠름)

단점:
❌ 데이터 업데이트 어려움 (다시 빌드 필요)
❌ 페이지 많으면 빌드 시간 오래 걸림
❌ 실시간 데이터 표시 불가

언제 사용?
- 블로그 (글 수정 드묾)
- 문서 사이트
- 마케팅 페이지
- 포트폴리오
```

**Gatsby의 SSG 예시:**
```jsx
// 빌드 시점에 실행됨 (한 번만!)
export async function getStaticProps() {
  const posts = await fetchBlogPosts();
  
  return {
    props: { posts }
  };
}

function BlogPage({ posts }) {
  // posts는 빌드할 때 이미 가져온 데이터
  return (
    <div>
      {posts.map(post => (
        <article key={post.id}>
          <h2>{post.title}</h2>
          <p>{post.content}</p>
        </article>
      ))}
    </div>
  );
}
```

#### 비교표

| | CSR | SSR | SSG |
|---|---|---|---|
| **렌더링 시점** | 브라우저 (사용자 측) | 서버 (매 요청마다) | 빌드 시 (한 번만) |
| **초기 로딩** | 느림 | 빠름 | 매우 빠름 |
| **SEO** | 나쁨 | 좋음 | 매우 좋음 |
| **서버 비용** | 낮음 | 높음 | 매우 낮음 |
| **실시간 데이터** | 가능 | 가능 | 어려움 |
| **사용 예시** | 대시보드 | 뉴스 사이트 | 블로그 |

---

## 프레임워크 상세 비교

### Next.js란?

**Next.js** = React 기반 풀스택 프레임워크

```
비유: 올인원 주방

일반 React = 가스레인지만
Next.js = 가스레인지 + 오븐 + 냉장고 + 식기세척기
```

**Next.js가 제공하는 것:**

```
1. 라우팅 (파일 기반)
   app/
   ├── page.tsx          → /
   ├── about/
   │   └── page.tsx      → /about
   └── blog/
       └── [id]/
           └── page.tsx  → /blog/1, /blog/2...

2. SSR + SSG (선택 가능)
3. API 라우트 (백엔드 코드)
4. 이미지 최적화
5. 폰트 최적화
6. 빌드 최적화
```

**코드 예시:**

```jsx
// app/page.tsx (홈페이지)
export default function Home() {
  return (
    <div>
      <h1>홈페이지</h1>
      <p>Next.js로 만든 웹사이트</p>
    </div>
  );
}

// app/about/page.tsx (About 페이지)
export default function About() {
  return (
    <div>
      <h1>소개</h1>
      <p>우리는...</p>
    </div>
  );
}

// app/api/hello/route.ts (API 엔드포인트)
export async function GET() {
  return Response.json({ message: 'Hello!' });
}
```

**언제 Next.js를 사용할까요?**

```
✅ 사용하세요:
- 블로그, 뉴스 사이트
- 전자상거래
- 회사 홈페이지
- SEO가 중요한 모든 사이트
- 풀스택 앱 (프론트 + 백엔드)

❌ 피하세요:
- 간단한 학습용 프로젝트 (Vite가 더 쉬움)
- 완전 정적인 사이트 (Gatsby가 더 빠름)
```

### Remix란?

**Remix** = 웹 표준에 충실한 풀스택 프레임워크

```
Remix의 철학:
"웹이 원래 작동하는 방식대로 만들자"

예시:
- HTML <form> 그대로 사용
- HTTP 메서드 (GET, POST, PUT, DELETE) 활용
- 웹 API (FormData, Headers, Request) 사용
```

**Next.js vs Remix:**

```jsx
// Next.js 방식 (JavaScript 중심)
function LoginForm() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  
  async function handleSubmit(e) {
    e.preventDefault();
    await fetch('/api/login', {
      method: 'POST',
      body: JSON.stringify({ email, password })
    });
  }
  
  return (
    <form onSubmit={handleSubmit}>
      <input value={email} onChange={e => setEmail(e.target.value)} />
      <input value={password} onChange={e => setPassword(e.target.value)} />
      <button>로그인</button>
    </form>
  );
}

// Remix 방식 (웹 표준 활용)
export async function action({ request }) {
  // FormData로 바로 받음
  const formData = await request.formData();
  const email = formData.get('email');
  const password = formData.get('password');
  
  return await login(email, password);
}

function LoginForm() {
  // JavaScript 없어도 작동!
  return (
    <form method="post">
      <input name="email" />
      <input name="password" />
      <button>로그인</button>
    </form>
  );
}
```

**Remix의 장점:**
```
✅ JavaScript 꺼져있어도 작동 (Progressive Enhancement)
✅ 에러 처리가 뛰어남 (Error Boundaries)
✅ 중첩 라우팅 (복잡한 레이아웃 쉽게 관리)
✅ 빠른 페이지 전환
```

**언제 Remix를 사용할까요?**
```
✅ 사용하세요:
- 폼이 많은 앱 (설문조사, 관리자 페이지)
- 복잡한 중첩 레이아웃
- 웹 표준을 중시하는 프로젝트
- Progressive Enhancement가 중요한 경우

❌ 피하세요:
- 간단한 블로그 (Next.js나 Gatsby가 더 쉬움)
- 완전 정적 사이트
```

### Gatsby란?

**Gatsby** = 정적 사이트에 특화된 프레임워크

```
Gatsby의 특징:
- 빌드 시 모든 페이지를 HTML로 생성
- GraphQL로 데이터 관리
- 플러그인이 엄청 많음
```

**Gatsby의 동작 방식:**

```
개발 중:
1. 마크다운 파일 작성 (블로그 글)
2. 이미지 추가
3. 데이터 추가

빌드 (npm run build):
1. 마크다운 → HTML 변환
2. 이미지 최적화
3. 모든 페이지를 정적 HTML로 생성
4. public/ 폴더에 결과물 저장

배포:
- public/ 폴더를 서버에 업로드
- 사용자가 방문하면 즉시 HTML 표시 (엄청 빠름!)
```

**Gatsby의 GraphQL:**

```jsx
// 블로그 글 목록 가져오기
export const query = graphql`
  query {
    allMarkdownRemark(sort: { fields: [frontmatter___date], order: DESC }) {
      edges {
        node {
          id
          frontmatter {
            title
            date
          }
          excerpt
        }
      }
    }
  }
`;

function BlogPage({ data }) {
  const posts = data.allMarkdownRemark.edges;
  
  return (
    <div>
      {posts.map(({ node }) => (
        <article key={node.id}>
          <h2>{node.frontmatter.title}</h2>
          <p>{node.frontmatter.date}</p>
          <p>{node.excerpt}</p>
        </article>
      ))}
    </div>
  );
}
```

**Gatsby 플러그인 예시:**

```javascript
// gatsby-config.js
module.exports = {
  plugins: [
    'gatsby-plugin-image',          // 이미지 최적화
    'gatsby-plugin-sitemap',        // sitemap.xml 자동 생성
    'gatsby-plugin-manifest',       // PWA 지원
    'gatsby-transformer-remark',    // 마크다운 변환
    'gatsby-plugin-google-analytics' // 구글 애널리틱스
  ]
};
```

**언제 Gatsby를 사용할까요?**

```
✅ 사용하세요:
- 블로그
- 문서 사이트
- 포트폴리오
- 마케팅 랜딩 페이지
- 마크다운 파일이 많은 사이트

❌ 피하세요:
- 실시간 데이터가 필요한 앱
- 로그인이 필요한 서비스
- 사용자 생성 콘텐츠 (댓글, 포럼 등)
```

### Vite란?

**Vite** = 차세대 빌드 도구 (프레임워크는 아님)

```
발음: "비트" (프랑스어로 "빠르다"는 뜻)
```

**왜 Vite가 빠를까?**

```
Webpack (기존 방식):
앱 시작
    ↓
모든 파일 번들링 (느림... 10초)
    ↓
개발 서버 시작
    ↓
브라우저에서 확인 가능

Vite (새로운 방식):
앱 시작
    ↓
개발 서버 즉시 시작 (빠름! 1초)
    ↓
브라우저에서 요청한 파일만 변환
    ↓
초고속!
```

**Vite의 기술:**

```
ESM (ES Modules) 사용:
- 브라우저가 자체적으로 모듈을 로드
- 번들링 없이 바로 실행
- 수정한 파일만 다시 로드 (HMR 초고속)

esbuild 사용:
- Go 언어로 작성 (JavaScript보다 10-100배 빠름)
- 코드 변환이 번개처럼 빠름
```

**Vite 프로젝트 생성:**

```bash
npm create vite@latest my-app -- --template react

# 이렇게 하면:
my-app/
├── index.html        # 메인 HTML
├── src/
│   ├── main.jsx     # 진입점
│   ├── App.jsx      # 메인 컴포넌트
│   └── App.css
├── package.json
└── vite.config.js   # Vite 설정
```

**vite.config.js 예시:**

```javascript
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],       // React 플러그인
  server: {
    port: 3000,             // 개발 서버 포트
    open: true              // 자동으로 브라우저 열기
  },
  build: {
    outDir: 'dist',         // 빌드 결과물 폴더
    sourcemap: true         // 소스맵 생성
  }
});
```

**언제 Vite를 사용할까요?**

```
✅ 사용하세요:
- 학습용 프로젝트
- 간단한 SPA
- 빠른 프로토타입
- SEO가 필요 없는 앱
- 개발 경험이 중요한 경우

❌ 피하세요:
- SEO가 중요한 사이트 (Next.js 사용)
- 서버 렌더링 필요 (Next.js나 Remix 사용)
```

### 프레임워크/도구 최종 비교

| | Next.js | Remix | Gatsby | Vite |
|---|---|---|---|---|
| **타입** | 풀스택 프레임워크 | 풀스택 프레임워크 | SSG 프레임워크 | 빌드 도구 |
| **렌더링** | SSR, SSG, CSR | SSR | SSG | CSR |
| **난이도** | 중간 | 중상 | 중간 | 쉬움 |
| **빌드 속도** | 보통 | 빠름 | 느림 | 매우 빠름 |
| **개발 속도** | 보통 | 빠름 | 보통 | 매우 빠름 |
| **SEO** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐ |
| **학습 곡선** | 보통 | 가파름 | 보통 | 완만 |
| **커뮤니티** | 매우 큼 | 중간 | 큼 | 큼 |
| **추천 용도** | 대부분의 프로젝트 | 복잡한 폼/중첩 라우팅 | 블로그, 문서 | 학습, SPA |

---

## Vercel이 뭔가요?

**Vercel** = 웹사이트 배포 플랫폼 (무료!)

```
비유: 앱스토어

앱 개발 → 앱스토어 업로드 → 사용자가 다운로드

웹 개발 → Vercel 배포 → 사용자가 접속
```

**Vercel이 하는 일:**

```
1. 코드를 Vercel에 업로드
2. Vercel이 자동으로 빌드
3. 전 세계 서버에 배포
4. URL 생성: your-app.vercel.app
5. 사용자가 접속 가능!
```

**Vercel 배포 과정:**

```bash
# 1. GitHub에 코드 푸시
git push origin main

# 2. Vercel이 자동 감지
"새로운 커밋 발견!"

# 3. 자동 빌드
"npm run build 실행 중..."

# 4. 자동 배포
"배포 완료! https://my-app-abc123.vercel.app"

# 5. 완료!
사용자가 URL로 접속 가능
```

**Vercel의 장점:**

```
✅ 무료 (개인 프로젝트)
✅ 자동 배포 (Git 푸시만 하면 됨)
✅ HTTPS 자동 (보안 인증서)
✅ 빠른 속도 (CDN 전 세계)
✅ Next.js 최적화 (Next.js를 만든 회사)
```

**다른 배포 플랫폼:**

| 플랫폼 | 특징 | 무료 플랜 |
|--------|------|-----------|
| **Vercel** | Next.js 최적화, 매우 쉬움 | ✅ |
| **Netlify** | Gatsby 최적화, 플러그인 많음 | ✅ |
| **GitHub Pages** | 정적 사이트만, 매우 간단 | ✅ |
| **AWS** | 강력하지만 복잡함 | ❌ (저렴) |
| **Heroku** | 백엔드 포함 가능 | ❌ (유료화) |

---

## 실전 예제: 프로젝트 시작하기

### 예제 1: Vite로 학습용 프로젝트

**목표:** React를 처음 배우는 사람이 연습용으로 만들기

```bash
# 1. 프로젝트 생성
npm create vite@latest my-first-react -- --template react
#    ↑       ↑          ↑                    ↑
#  실행   Vite 최신버전  프로젝트 이름      React 템플릿

# 2. 프로젝트 폴더로 이동
cd my-first-react

# 3. 패키지 설치 (node_modules 폴더 생성)
npm install
#   ↑
# package.json에 적힌 모든 라이브러리 설치

# 4. 개발 서버 시작
npm run dev
#       ↑
#   package.json의 "dev" 스크립트 실행
```

**명령어 실행 후:**

```
$ npm run dev

  VITE v5.0.0  ready in 500 ms

  ➜  Local:   http://localhost:5173/
  ➜  Network: use --host to expose
  ➜  press h + enter to show help

→ 브라우저에서 http://localhost:5173/ 접속!
```

**프로젝트 구조:**

```
my-first-react/
├── node_modules/        # 설치된 패키지들 (건들지 말 것!)
├── public/              # 정적 파일 (이미지 등)
├── src/                 # 소스 코드 (여기서 작업!)
│   ├── App.jsx         # 메인 컴포넌트
│   ├── App.css         # 스타일
│   ├── main.jsx        # 진입점
│   └── index.css       # 전역 스타일
├── index.html           # HTML 파일
├── package.json         # 프로젝트 정보
└── vite.config.js       # Vite 설정
```

**첫 수정 해보기:**

```jsx
// src/App.jsx 열기
function App() {
  return (
    <div>
      <h1>안녕하세요!</h1>
      <p>제 첫 React 앱입니다 🎉</p>
    </div>
  );
}

export default App;

// 저장하면 브라우저가 자동으로 업데이트됨!
```

### 예제 2: Next.js로 블로그 만들기

**목표:** SEO가 중요한 블로그 사이트 만들기

```bash
# 1. Next.js 프로젝트 생성
npx create-next-app@latest my-blog
#   ↑                      ↑
# 일회용 실행             프로젝트 이름

# 설치 중 질문들:
? Would you like to use TypeScript? › No
? Would you like to use ESLint? › Yes
? Would you like to use Tailwind CSS? › Yes (스타일링 도구)
? Would you like to use `src/` directory? › Yes
? Would you like to use App Router? › Yes (새로운 방식)
? Would you like to customize the import alias? › No

# 2. 폴더 이동
cd my-blog

# 3. 개발 서버 시작
npm run dev

# 브라우저에서 http://localhost:3000 접속!
```

**Next.js 프로젝트 구조:**

```
my-blog/
├── app/                      # 앱 라우터 (페이지)
│   ├── layout.tsx           # 전체 레이아웃
│   ├── page.tsx             # 홈페이지 (/)
│   ├── about/
│   │   └── page.tsx         # About 페이지 (/about)
│   └── blog/
│       ├── page.tsx         # 블로그 목록 (/blog)
│       └── [id]/
│           └── page.tsx     # 개별 글 (/blog/1, /blog/2...)
├── public/                   # 정적 파일
├── package.json
└── next.config.js            # Next.js 설정
```

**페이지 만들기:**

```jsx
// app/page.tsx (홈페이지)
export default function Home() {
  return (
    <main>
      <h1>내 블로그에 오신 것을 환영합니다! 📝</h1>
      <p>React와 Next.js로 만든 블로그입니다.</p>
    </main>
  );
}

// app/about/page.tsx (About 페이지)
export default function About() {
  return (
    <main>
      <h1>소개</h1>
      <p>안녕하세요! 저는 블로거입니다.</p>
    </main>
  );
}
```

**블로그 글 목록:**

```jsx
// app/blog/page.tsx
async function getPosts() {
  // 실제로는 데이터베이스나 API에서 가져옴
  return [
    { id: 1, title: '첫 번째 글', date: '2024-01-01' },
    { id: 2, title: '두 번째 글', date: '2024-01-02' },
    { id: 3, title: '세 번째 글', date: '2024-01-03' }
  ];
}

export default async function BlogPage() {
  const posts = await getPosts();  // 서버에서 실행됨!
  
  return (
    <main>
      <h1>블로그 글 목록</h1>
      <ul>
        {posts.map(post => (
          <li key={post.id}>
            <a href={`/blog/${post.id}`}>
              {post.title} - {post.date}
            </a>
          </li>
        ))}
      </ul>
    </main>
  );
}
```

---

## 명령어 완전 정복

### package.json이 뭔가요?

**package.json** = 프로젝트 설명서

```json
{
  "name": "my-app",              // 프로젝트 이름
  "version": "1.0.0",            // 버전
  "scripts": {                   // 실행 가능한 명령어들
    "dev": "vite",              // npm run dev
    "build": "vite build",      // npm run build
    "preview": "vite preview"   // npm run preview
  },
  "dependencies": {              // 필요한 라이브러리
    "react": "^18.2.0",         // React 18.2.0 이상
    "react-dom": "^18.2.0"
  },
  "devDependencies": {           // 개발용 라이브러리
    "vite": "^5.0.0",
    "@vitejs/plugin-react": "^4.2.0"
  }
}
```

### npm 명령어 정리

```bash
# 1. 프로젝트 초기화
npm init
# → package.json 파일 생성
# → 프로젝트 정보 입력

npm init -y
# → 모든 질문에 기본값으로 답함 (빠름!)

# 2. 패키지 설치
npm install react
npm i react          # 짧게 쓰기
# → react를 dependencies에 추가
# → node_modules/ 폴더에 다운로드

npm install --save-dev vite
npm i -D vite        # 짧게 쓰기
# → vite를 devDependencies에 추가

npm install
# → package.json의 모든 패키지 설치
# → 보통 프로젝트 다운로드 후 첫 실행

# 3. 패키지 제거
npm uninstall react
npm un react         # 짧게 쓰기

# 4. 스크립트 실행
npm run dev          # "dev" 스크립트 실행
npm run build        # "build" 스크립트 실행
npm start            # "start" 스크립트 실행 (run 생략 가능)

# 5. 전역 설치
npm install -g create-react-app
#            ↑ global (전역)
# → 컴퓨터 어디서든 사용 가능
# → 주의: 요즘은 npx 사용 권장
```

### node_modules가 뭔가요?

**node_modules** = 설치된 패키지들이 저장되는 폴더

```
비유: 책장

package.json = 읽을 책 목록
node_modules = 실제 책들이 꽂혀있는 책장

예시:
npm install react
    ↓
node_modules/
├── react/           ← React 코드
│   ├── index.js
│   └── ...
└── react-dom/       ← React DOM 코드
    ├── index.js
    └── ...
```

**주의사항:**

```
❌ node_modules를 Git에 올리지 마세요!
   - 크기가 매우 큼 (수백 MB)
   - package.json만 공유하면 됨
   - 다른 사람이 npm install로 받을 수 있음

✅ .gitignore에 추가:
node_modules/
```

### ^ (캐럿) 기호가 뭔가요?

**^** = "이 버전 이상, 다음 메이저 버전 미만"

```json
"dependencies": {
  "react": "^18.2.0"
           ↑
}
```

**버전 번호 이해하기:**

```
18.2.0
↑  ↑  ↑
|  |  패치 버전 (버그 수정)
|  마이너 버전 (새 기능 추가, 호환됨)
메이저 버전 (큰 변화, 호환 안 될 수 있음)
```

**^18.2.0의 의미:**

```
✅ 설치 가능:
- 18.2.0
- 18.2.1
- 18.3.0
- 18.9.9

❌ 설치 불가:
- 17.0.0 (메이저 버전 낮음)
- 19.0.0 (메이저 버전 높음)
```

**다른 기호들:**

```
"react": "18.2.0"    - 정확히 18.2.0만
"react": "^18.2.0"   - 18.x.x (18 버전대)
"react": "~18.2.0"   - 18.2.x (18.2 버전만)
"react": "*"         - 아무 버전 (위험!)
"react": ">=18.0.0"  - 18.0.0 이상
```

---

## 자주 묻는 질문 (완전 초보용)

### Q1: JavaScript를 몰라도 React를 배울 수 있나요?

**A: 아니요, JavaScript 기초는 필수입니다!**

```
최소한 알아야 할 것:

1. 변수 (let, const)
   let age = 25;
   const name = 'John';

2. 함수
   function hello() {
     console.log('Hi');
   }
   
   const hello = () => {
     console.log('Hi');
   };

3. 배열
   const numbers = [1, 2, 3];
   numbers.map(n => n * 2);  // [2, 4, 6]

4. 객체
   const user = {
     name: 'John',
     age: 25
   };

5. 구조 분해
   const { name, age } = user;
   const [first, second] = [1, 2];

6. 템플릿 리터럴
   `Hello, ${name}!`

7. 삼항 연산자
   age >= 18 ? '성인' : '미성년자'

8. 화살표 함수
   const add = (a, b) => a + b;
```

**학습 순서:**
```
1주: JavaScript 기초
2주: JavaScript 심화
3주: React 시작
```

### Q2: 컴퓨터가 너무 느려요. React를 배울 수 있나요?

**A: 온라인 에디터를 사용하세요!**

```
저사양 컴퓨터:
- CodeSandbox 사용 (추천!)
- StackBlitz 사용
- 설치 필요 없음
- 브라우저만 있으면 OK

중간 사양 이상:
- Vite 사용 (가볍고 빠름)
- Next.js는 조금 무거움
```

**최소 사양:**
```
운영체제: Windows 10, macOS 10.15, Ubuntu 20.04
램: 4GB (8GB 권장)
저장공간: 10GB 이상
```

### Q3: 맥 vs 윈도우, 뭐가 더 좋나요?

**A: 둘 다 괜찮습니다!**

```
맥/리눅스 장점:
✅ 터미널이 편함
✅ 개발 도구 설치 쉬움
✅ Unix 기반 (서버와 동일)

윈도우 장점:
✅ 게임도 할 수 있음
✅ 가격 저렴
✅ WSL2로 리눅스 환경 가능

결론: 둘 다 OK, 가진 거 쓰세요!
```

### Q4: 영어를 못하는데 괜찮나요?

**A: 기초 단어만 알면 됩니다!**

```
꼭 알아야 할 단어 (30개):

function (함수)
component (컴포넌트)
import (가져오기)
export (내보내기)
const (상수)
let (변수)
return (반환)
props (속성)
state (상태)
render (렌더링)
...

← 이 정도만 외우면 충분!
```

**영어 문서 읽는 팁:**
```
1. Chrome 번역 기능 사용
2. 한글 문서 먼저 읽기
3. 영단어는 구글 이미지 검색
4. 모르는 단어 노트 정리
```

### Q5: 매일 몇 시간씩 공부해야 하나요?

**A: 하루 1-2시간이면 충분합니다!**

```
추천 학습 계획:

1주차 (JavaScript 복습):
- 하루 1시간
- 기초 문법 복습

2-3주차 (React 기초):
- 하루 1-2시간
- 컴포넌트, Props, State

4-5주차 (React 심화):
- 하루 2시간
- Hooks, 라우팅

6주차 이후 (프로젝트):
- 주말에 4-6시간
- 실전 프로젝트

중요: 매일 조금씩 > 주말에 몰아서!
```

### Q6: Create React App이 deprecated라는데 뭔가요?

**A: "더 이상 추천하지 않는다"는 뜻입니다!**

```
deprecated (디프리케이티드):
= 옛날 방식
= 지원 중단 예정
= 새 프로젝트에는 쓰지 마세요

이유:
- 느림 (Webpack 기반)
- 무거움
- 업데이트 안 됨

대신 사용:
✅ Vite (학습용)
✅ Next.js (실전)
```

### Q7: TypeScript도 배워야 하나요?

**A: React 기초 배운 후에 배우세요!**

```
학습 순서:

1단계: JavaScript ✅
2단계: React ✅
3단계: 작은 프로젝트 완성 ✅
4단계: TypeScript 시작 ← 여기서!

TypeScript 장점:
✅ 버그 미리 발견
✅ 자동완성 좋아짐
✅ 큰 프로젝트에 유리

TypeScript 단점:
❌ 학습 곡선
❌ 코드 작성 시간 증가

결론: 나중에 배워도 늦지 않음!
```

### Q8: 에러가 너무 많이 나요!

**A: 정상입니다! 개발자는 늘 에러를 봅니다!**

```
초보자가 자주 겪는 에러:

1. "npm: command not found"
   → Node.js 설치 안 함
   → nodejs.org에서 다운로드

2. "Cannot find module 'react'"
   → npm install 안 함
   → npm install 실행

3. "Port 3000 is already in use"
   → 이미 서버가 실행 중
   → 기존 서버 종료 (Ctrl+C)

4. "Unexpected token <"
   → JSX 문법 오류
   → 태그 닫기 확인

5. "Objects are not valid as a React child"
   → 객체를 직접 렌더링
   → { }안에 문자열이나 숫자만
```

**에러 해결 팁:**
```
1. 에러 메시지 복사
2. 구글에 검색
3. Stack Overflow 확인
4. 천천히 읽어보기
5. 안 되면 처음부터 다시
```

---

## 다음 단계 🚀

축하합니다! 모든 용어를 이해하셨습니다! 🎉

### 추천 학습 경로

```
1주: React 환경 설정 + Quick Start ← 지금 여기!
    ↓
2주: 컴포넌트, Props, State 연습
    ↓
3주: Hooks 배우기 (useState, useEffect)
    ↓
4주: 라우팅 (React Router)
    ↓
5주: 첫 프로젝트 (TODO 앱)
    ↓
6주: 중간 프로젝트 (날씨 앱)
    ↓
8주: 최종 프로젝트 (블로그, 쇼핑몰 등)
```

### 다음에 읽을 문서

1. **[Quick Start 가이드](/react-quick-start)**
   - React 핵심 80% 배우기
   - 예상 시간: 2-3시간

2. **[튜토리얼: 틱택토 게임](https://react.dev/learn/tutorial-tic-tac-toe)**
   - 실전으로 배우기
   - 예상 시간: 3-4시간

3. **[Thinking in React](https://react.dev/learn/thinking-in-react)**
   - React적으로 생각하기
   - 예상 시간: 1-2시간

### 유용한 자료

**한글 자료:**
- [리액트 공식 문서 한글판](https://ko.react.dev)
- [벨로퍼트 React 튜토리얼](https://react.vlpt.us)
- [생활코딩 React](https://opentutorials.org/module/4058)

**영문 자료:**
- [React 공식 문서](https://react.dev)
- [freeCodeCamp](https://www.freecodecamp.org/learn)

**유튜브:**
- 코딩애플 (한글)
- 노마드 코더 (한글)
- Net Ninja (영문)
- Web Dev Simplified (영문)

---

## 마지막 조언

### 공부할 때 기억하세요

```
1. 완벽하게 이해 안 해도 괜찮습니다
   → 일단 따라 해보세요
   → 나중에 이해됩니다

2. 에러는 친구입니다
   → 에러로 배웁니다
   → 에러 두려워하지 마세요

3. 비교하지 마세요
   → 남들은 이미 오래 했을 수 있습니다
   → 어제의 나와 비교하세요

4. 꾸준히가 중요합니다
   → 하루 30분이라도
   → 매일 하는 게 중요합니다

5. 실전이 최고의 공부입니다
   → 튜토리얼만 보지 마세요
   → 직접 만들어보세요
```

### 막혔을 때

```
1. 구글 검색
   "react 에러메시지" 검색

2. ChatGPT / Claude에게 물어보기
   "이 에러가 왜 나요?"

3. 공식 문서 읽기
   react.dev

4. 커뮤니티 질문
   - Stack Overflow
   - Reddit r/react
   - 디스코드 서버들

5. 잠시 쉬기
   - 커피 한 잔
   - 산책
   - 다시 도전!
```

---


화이팅입니다! 💪