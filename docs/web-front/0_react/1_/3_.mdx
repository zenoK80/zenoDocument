---
title: 처음부터 React 앱 만들기
description: React 앱을 처음부터 직접 만드는 방법을 단계별로 배웁니다
slug: /build-react-from-scratch
sidebar_position: 3
---

# 처음부터 React 앱 만들기

React 앱을 **처음부터 직접** 만들고 싶으신가요? 이 문서에서 모든 단계를 자세히 설명합니다!

:::warning 시작하기 전에 꼭 읽으세요!
이 가이드는 **고급 사용자**를 위한 것입니다.

**초보자라면 먼저 프레임워크를 사용하세요:**
- ✅ [Next.js](./2_.mdx) (추천!)
- ✅ [Vite](./2_.mdx) (학습용)

**처음부터 만들기는:**
- ⏰ 시간이 매우 오래 걸림 (수개월)
- 😰 매우 어려움
- 🐛 버그가 많이 발생
- 🔧 유지보수가 힘듦

**이 가이드를 읽어야 하는 사람:**
- 프레임워크가 맞지 않는 특수한 경우
- 자신만의 프레임워크를 만들고 싶은 경우
- React 앱의 기초를 깊이 이해하고 싶은 경우
:::

:::info 이 문서를 읽기 전에
- ⏰ 예상 소요 시간: 60-90분
- 🎯 React 앱을 구성하는 모든 요소를 이해하는 것이 목표
- 📚 각 단계마다 "왜 필요한지" 설명
- ☕ 천천히 읽어주세요!
:::

---

## 목차

1. [왜 처음부터 만드나요?](#왜-처음부터-만드나요)
2. [전체 로드맵](#전체-로드맵)
3. [Step 1: 빌드 도구 설치](#step-1-빌드-도구-설치)
4. [Step 2: 공통 패턴 구축](#step-2-공통-패턴-구축)
5. [성능 최적화](#성능-최적화)
6. [프레임워크 vs 처음부터 만들기](#프레임워크-vs-처음부터-만들기)

---

## 왜 처음부터 만드나요?

### 프레임워크가 안 맞는 경우

```
실제 시나리오:

1. 특수한 제약사항
   예: 레거시 시스템과 통합
   예: 특정 빌드 도구 필수 사용
   예: 회사 보안 정책

2. 자체 프레임워크 제작
   예: 회사 내부용 프레임워크
   예: 특정 산업용 솔루션
   예: 오픈소스 프레임워크 제작

3. 학습 목적
   예: React 내부 동작 이해
   예: 빌드 프로세스 학습
   예: 도구 체인 이해
```

**실생활 비유:**

```
가구 구매 vs 목공:

기성 가구 구매 (프레임워크):
🛋️ IKEA에서 소파 구매
   - 빠름 (1시간)
   - 쉬움
   - 검증된 품질
   - 하지만 규격화됨

직접 제작 (처음부터):
🔨 나무부터 자르기
   - 느림 (수주)
   - 어려움
   - 실수 가능성
   - 하지만 완전 맞춤

대부분의 사람: 기성 가구 ✅
특수한 경우: 직접 제작
```

### 배우게 되는 것들

```
처음부터 만들면서 배우는 것:

1. 빌드 도구가 하는 일
   - 파일 번들링
   - 코드 변환
   - 최적화

2. React가 동작하는 방식
   - 컴포넌트 렌더링
   - 가상 DOM
   - 상태 관리

3. 웹 개발 전반
   - 모듈 시스템
   - 번들러 동작
   - 최적화 기법

4. 문제 해결 능력
   - 디버깅
   - 성능 튜닝
   - 아키텍처 설계
```

---

## 전체 로드맵

처음부터 React 앱을 만드는 **전체 과정**입니다:

```
Step 1: 빌드 도구 선택 및 설치
├─ Vite (추천)
├─ Parcel
└─ Rsbuild

Step 2: 공통 기능 구현
├─ 라우팅 (URL 관리)
├─ 데이터 페칭 (서버 통신)
├─ 코드 스플리팅 (성능 최적화)
└─ 스타일링 (CSS 관리)

Step 3: 렌더링 전략 선택
├─ SPA (Single Page App)
├─ SSR (Server-Side Rendering)
├─ SSG (Static Site Generation)
└─ RSC (React Server Components)

Step 4: 성능 최적화
├─ 번들 크기 최소화
├─ 로딩 속도 개선
├─ 캐싱 전략
└─ 이미지 최적화

예상 소요 시간: 3-6개월 😱
```

:::danger 현실적인 조언
위 모든 것을 혼자 구현하는 것은:
- 3-6개월 소요
- 고급 지식 필요
- 유지보수 부담 큼
- 버그 많음

**대안:** 프레임워크 사용 → 1일이면 시작 가능!
:::

---

## Step 1: 빌드 도구 설치

### 빌드 도구가 뭔가요?

**빌드 도구 (Build Tool)** = 개발 코드를 실행 가능한 코드로 변환하는 프로그램

```
우리가 작성하는 코드:
└─ JSX (React 문법)
└─ 최신 JavaScript
└─ 여러 파일로 나뉘어짐
└─ import/export 사용

브라우저가 이해하는 코드:
└─ 일반 JavaScript
└─ 구형 브라우저도 이해 가능
└─ 하나의 파일로 합쳐짐
└─ 최적화됨

빌드 도구 = 이 변환을 해주는 도구!
```

**빌드 도구가 하는 일:**

```
1. 변환 (Transpiling)
   JSX → JavaScript
   TypeScript → JavaScript
   최신 JS → 구형 JS

2. 번들링 (Bundling)
   App.jsx + Button.jsx + ... → bundle.js

3. 최적화 (Optimization)
   코드 압축 (Minification)
   불필요한 코드 제거 (Tree Shaking)

4. 개발 서버 (Dev Server)
   파일 변경 감지
   자동 새로고침 (Hot Reload)

5. 프로덕션 빌드 (Production Build)
   배포용 파일 생성
   최대한 최적화
```

**실생활 비유:**

```
요리 도구:

재료 (코드):
- 생고기
- 생야채
- 조미료

조리 도구 (빌드 도구):
- 칼 (변환)
- 믹서기 (번들링)
- 오븐 (최적화)
- 가스레인지 (개발 서버)

완성 요리 (빌드 결과):
- 먹을 수 있는 음식
- 맛있게 조리됨
- 보기 좋게 플레이팅
```

### 왜 빌드 도구가 필요한가요?

```
빌드 도구 없이 개발하면:

❌ 문제 1: JSX를 못 씀
   <div>Hello</div> ← 브라우저가 이해 못 함

❌ 문제 2: 파일이 너무 많음
   <script src="App.js"></script>
   <script src="Button.js"></script>
   <script src="Header.js"></script>
   ... (수백 개)
   → 로딩 느림!

❌ 문제 3: 최신 JavaScript 못 씀
   const [state, setState] = useState(0);
   ← 구형 브라우저 에러!

❌ 문제 4: 개발이 불편함
   파일 수정 → 수동 새로고침
   에러 확인 어려움

✅ 빌드 도구 사용하면:
   위 모든 문제 해결!
```

---

## 빌드 도구 비교

### 1. Vite (비트) - 가장 추천! ⭐⭐⭐⭐⭐

**Vite가 뭔가요?**

```
발음: "비트" (프랑스어로 "빠르다")
만든 사람: Evan You (Vue.js 창시자)
출시: 2020년
특징: 엄청나게 빠른 개발 서버
```

**왜 Vite가 빠를까요?**

```
기존 방식 (Webpack 등):

개발 서버 시작
    ↓
모든 파일 번들링 (느림... 10-30초)
    ↓
개발 서버 준비 완료

Vite 방식:

개발 서버 즉시 시작 (빠름! 1초)
    ↓
필요한 파일만 변환
    ↓
브라우저가 요청할 때 처리

결과: 10-100배 빠름!
```

**기술적 설명:**

```
Vite의 비밀:

1. ESM (ES Modules) 사용
   - 브라우저 네이티브 모듈 로드
   - 번들링 없이 바로 실행

2. esbuild 사용
   - Go 언어로 작성 (초고속!)
   - JavaScript보다 10-100배 빠름

3. On-demand 변환
   - 필요할 때만 변환
   - 전체 번들링 불필요

예시:
파일 100개짜리 프로젝트
- Webpack: 10초 대기
- Vite: 1초 대기
```

#### Vite 설치 및 사용

```bash
# Vite + React 프로젝트 생성
npm create vite@latest my-app -- --template react-ts
#                                            ↑
#                                     react-ts = React + TypeScript
#                                     react = React만 (JavaScript)

# 프로젝트 폴더로 이동
cd my-app

# 패키지 설치
npm install

# 개발 서버 시작
npm run dev
```

**명령어 한 줄씩 설명:**

```bash
npm create vite@latest my-app -- --template react-ts
 ↑      ↑      ↑       ↑          ↑         ↑
 |      |      |       |          |         템플릿 선택
 |      |      |       |          --는 뒤 옵션 전달
 |      |      |       프로젝트 이름
 |      |      최신 버전
 |      Vite 생성 도구
 npm 실행
```

**Vite의 기능들:**

```
1. Fast Refresh (빠른 새로고침)
   - 파일 저장 → 즉시 화면 업데이트
   - 페이지 전체 새로고침 없음
   - 상태 유지

2. JSX 지원
   - JSX를 자동으로 변환
   - React.createElement 불필요

3. TypeScript 지원
   - 별도 설정 없이 TS 사용 가능
   - 타입 체크 자동

4. CSS 처리
   - CSS Modules 지원
   - CSS 전처리기 (Sass, Less 등)
   - PostCSS

5. 에셋 처리
   - 이미지 import
   - 폰트 import
   - JSON import

6. 환경 변수
   - .env 파일 지원
   - import.meta.env로 접근

7. 플러그인 생태계
   - React 플러그인
   - SWC 플러그인 (더 빠른 변환)
   - 수백 개의 플러그인
```

**Vite 프로젝트 구조:**

```
my-app/
├── node_modules/          # 설치된 패키지
├── public/                # 정적 파일
│   └── vite.svg          # 변환 없이 복사됨
├── src/                   # 소스 코드
│   ├── App.tsx           # 메인 컴포넌트
│   ├── main.tsx          # 진입점
│   └── index.css         # 전역 스타일
├── index.html             # HTML 템플릿
├── package.json           # 프로젝트 정보
├── tsconfig.json          # TypeScript 설정
└── vite.config.ts         # Vite 설정
```

**vite.config.ts 설명:**

```typescript
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

// Vite 설정
export default defineConfig({
  plugins: [
    react()  // React 플러그인 활성화
  ],
  
  // 개발 서버 설정
  server: {
    port: 3000,          // 포트 번호 (기본: 5173)
    open: true,          // 자동으로 브라우저 열기
    host: true           // 네트워크 접근 허용
  },
  
  // 빌드 설정
  build: {
    outDir: 'dist',      // 빌드 결과물 폴더
    sourcemap: true,     // 소스맵 생성 (디버깅용)
    minify: 'esbuild',   // 압축 도구
    
    // 번들 최적화
    rollupOptions: {
      output: {
        manualChunks: {  // 청크 분리
          vendor: ['react', 'react-dom']
        }
      }
    }
  }
});
```

**코드 설명:**

```
1. plugins: [react()]
   - React를 사용하기 위한 플러그인
   - JSX 변환, Fast Refresh 제공

2. server.port
   - 개발 서버가 실행될 포트
   - localhost:3000으로 접속

3. server.open
   - npm run dev 실행 시
   - 자동으로 브라우저 열림

4. build.outDir
   - npm run build 실행 시
   - 결과물이 저장될 폴더

5. build.sourcemap
   - 디버깅을 위한 소스맵
   - 프로덕션에서는 false 권장

6. manualChunks
   - vendor: React 같은 라이브러리
   - 따로 분리해서 캐싱 효율 높임
```

#### Vite 플러그인 활용

**React SWC 플러그인 (더 빠름!):**

```bash
# SWC 플러그인 설치
npm install --save-dev @vitejs/plugin-react-swc

# vite.config.ts 수정
import react from '@vitejs/plugin-react-swc';  // ← swc 버전

export default defineConfig({
  plugins: [react()]  // 자동으로 SWC 사용
});
```

**SWC가 뭔가요?**

```
SWC (Speedy Web Compiler):
- Rust 언어로 작성
- Babel보다 20-70배 빠름
- TypeScript, JSX 변환
- Minification (압축)

Babel vs SWC:
                변환 속도
Babel:          ████ (1x)
SWC:            ████████████████████ (20x)

대형 프로젝트에서 큰 차이!
```

**기타 유용한 플러그인:**

```bash
# 환경 변수 타입 지원
npm install vite-plugin-env-compatible

# PWA 지원
npm install vite-plugin-pwa

# 이미지 최적화
npm install vite-plugin-imagemin

# 번들 분석
npm install rollup-plugin-visualizer
```

#### Vite 장점 정리

```
✅ 장점:

1. 엄청나게 빠른 개발 서버
   - 시작: 1초 이내
   - 수정: 즉시 반영

2. 간단한 설정
   - 기본 설정만으로 충분
   - 거의 zero-config

3. 최신 기술 사용
   - ESM (ES Modules)
   - esbuild
   - Rollup (프로덕션)

4. 풍부한 플러그인
   - React, Vue, Svelte 등
   - 수백 개의 플러그인

5. 프로덕션 최적화
   - Tree shaking
   - Code splitting
   - Minification

6. 좋은 개발 경험
   - 빠른 피드백
   - 명확한 에러 메시지
   - 좋은 문서

❌ 단점:

1. 비교적 새로움
   - 2020년 출시
   - Webpack보다 생태계 작음

2. 일부 레거시 호환성
   - 아주 오래된 브라우저는 문제
   - 하지만 대부분 괜찮음
```

---

### 2. Parcel (파슬) - Zero Config! ⭐⭐⭐⭐

**Parcel이 뭔가요?**

```
Parcel = 설정 없는 번들러
슬로건: "Zero Configuration"
특징: 그냥 작동함!
```

**Parcel의 철학:**

```
대부분의 빌드 도구:
1. 설정 파일 작성
2. 플러그인 설치
3. 복잡한 설정
4. 드디어 작동

Parcel:
1. 파일 작성
2. 끝!

→ 모든 것을 자동으로 감지하고 처리
```

#### Parcel 설치 및 사용

```bash
# Parcel 설치
npm install --save-dev parcel

# package.json에 스크립트 추가
{
  "scripts": {
    "dev": "parcel src/index.html",
    "build": "parcel build src/index.html"
  }
}

# 개발 서버 시작
npm run dev
```

**Parcel이 자동으로 해주는 것:**

```
1. JSX 변환
   - .jsx 파일 감지 → 자동 변환
   - React import 자동 추가

2. TypeScript
   - .ts, .tsx 감지 → 자동 변환
   - 별도 설정 불필요

3. CSS 처리
   - CSS, SCSS, Less 모두 지원
   - 자동 감지 및 변환

4. 이미지 처리
   - import 하면 자동 최적화
   - 다양한 포맷 지원

5. Hot Module Replacement
   - 자동으로 활성화
   - 빠른 새로고침

모두 설정 없이!
```

#### Parcel 장점과 단점

```
✅ 장점:

1. Zero Config (설정 제로!)
   - 설정 파일 작성 불필요
   - 그냥 작동

2. 빠른 시작
   - 학습 곡선 낮음
   - 초보자 친화적

3. 기본 내장
   - Fast Refresh
   - JSX, TypeScript
   - CSS 전처리기
   - 이미지 최적화

4. 확장 가능
   - 플러그인 지원
   - 필요하면 설정 가능

5. 자동 최적화
   - Tree shaking
   - Code splitting
   - Minification

❌ 단점:

1. 커스터마이징 어려움
   - 세밀한 제어 힘듦
   - 복잡한 설정 불가능

2. 대규모 프로젝트
   - Vite, Webpack만큼 안 빠름
   - 확장성 제한

3. 플러그인 생태계
   - Webpack보다 작음
   - 일부 기능 부족
```

**언제 Parcel을 쓸까요?**

```
✅ Parcel 사용:
- 간단한 프로젝트
- 빠른 프로토타입
- 학습 목적
- 설정에 시간 쓰기 싫음

❌ Parcel 피하기:
- 복잡한 빌드 과정
- 세밀한 최적화 필요
- 대규모 프로젝트
```

---

### 3. Rsbuild - 최신 강자! ⭐⭐⭐⭐

**Rsbuild가 뭔가요?**

```
Rsbuild = Rspack 기반 빌드 도구
Rspack = Webpack의 Rust 버전
특징: Webpack 호환 + 엄청 빠름
```

**Rspack이 뭔가요?**

```
Webpack:
- JavaScript로 작성
- 매우 강력
- 하지만 느림

Rspack:
- Rust로 다시 작성
- Webpack과 호환
- 10배 빠름!

Rsbuild:
- Rspack을 쉽게 사용
- 사전 설정된 옵션
- React에 최적화
```

#### Rsbuild 설치 및 사용

```bash
# Rsbuild + React 프로젝트 생성
npx create-rsbuild --template react

# 프로젝트 시작
cd my-app
npm install
npm run dev
```

**Rsbuild의 특징:**

```
1. 빠른 빌드
   - Rust 언어 사용
   - Webpack보다 10배 빠름

2. Webpack 호환
   - Webpack 플러그인 대부분 사용 가능
   - 마이그레이션 쉬움

3. 최적화된 기본 설정
   - React에 맞춰진 설정
   - 즉시 사용 가능

4. 모던 기능
   - Fast Refresh
   - TypeScript
   - CSS Modules
   - 이미지 최적화
```

#### Rsbuild 장점과 단점

```
✅ 장점:

1. 속도
   - 개발: 빠름
   - 빌드: 매우 빠름

2. Webpack 호환
   - 기존 Webpack 프로젝트 마이그레이션 쉬움
   - 많은 플러그인 사용 가능

3. 좋은 기본 설정
   - 별도 설정 거의 불필요
   - React에 최적화

4. 활발한 개발
   - ByteDance (TikTok 회사) 지원
   - 지속적인 업데이트

❌ 단점:

1. 비교적 새로움
   - 2023년 출시
   - 작은 커뮤니티

2. 문서
   - 영어 문서 제한적
   - 한글 자료 거의 없음

3. 생태계
   - Vite보다 작음
   - 플러그인 제한적
```

---

### 빌드 도구 최종 비교

| | Vite | Parcel | Rsbuild |
|---|---|---|---|
| **속도 (개발)** | ⚡⚡⚡⚡⚡ | ⚡⚡⚡⚡ | ⚡⚡⚡⚡⚡ |
| **속도 (빌드)** | ⚡⚡⚡⚡ | ⚡⚡⚡ | ⚡⚡⚡⚡⚡ |
| **설정 난이도** | 쉬움 | 매우 쉬움 | 쉬움 |
| **커스터마이징** | 좋음 | 제한적 | 좋음 |
| **플러그인** | 매우 많음 | 보통 | 많음 |
| **커뮤니티** | 큼 | 중간 | 작음 |
| **문서** | 훌륭함 | 좋음 | 보통 |
| **학습 곡선** | 낮음 | 매우 낮음 | 낮음 |
| **추천도** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |

**사용 사례별 추천:**

```
학습용, 프로토타입:
  1순위: Parcel (가장 쉬움)
  2순위: Vite

일반 프로젝트:
  1순위: Vite (가장 인기)
  2순위: Rsbuild

대규모 프로젝트:
  1순위: Vite
  2순위: Rsbuild

Webpack에서 마이그레이션:
  1순위: Rsbuild (호환성)
  2순위: Vite
```

---

### React Native는 다릅니다!

:::info React Native 개발
React Native 앱을 처음부터 만든다면 **Metro**를 사용해야 합니다.

**Metro가 뭔가요?**
- React Native 전용 번들러
- iOS, Android 지원
- Facebook(Meta)에서 제작

**특징:**
- 모바일 플랫폼에 특화
- 웹 빌드 도구보다 기능 제한적
- React Native 외에는 사용 안 함

**웹 앱 vs 모바일 앱:**
```
웹 앱 만들기:
└─ Vite, Parcel, Rsbuild 사용

모바일 앱 만들기:
└─ Metro 사용 (React Native)
└─ 또는 Expo 사용 (추천!)
```

**추천:**
React Native 개발이라면 **Expo 사용을 강력 추천**합니다!
- Metro 자동 설정
- 개발 도구 풍부
- 훨씬 쉬움
:::

---

## Step 2: 공통 패턴 구축

빌드 도구를 설치했다면, 이제 **실제 앱 기능**을 만들어야 합니다!

### 빌드 도구만으로는 부족한 이유

```
빌드 도구가 제공하는 것:
✅ JSX 변환
✅ 개발 서버
✅ 파일 번들링
✅ 코드 압축

빌드 도구가 제공하지 않는 것:
❌ 라우팅 (페이지 이동)
❌ 데이터 페칭 (서버 통신)
❌ 상태 관리
❌ 스타일링 시스템
❌ 폼 처리
❌ 인증
❌ 에러 처리
... 등등

→ 이것들을 직접 구현하거나 라이브러리 선택!
```

**비유:**

```
빌드 도구 = 주방 도구
(칼, 도마, 냄비, 가스레인지)

실제 요리 = 앱 기능
(라우팅, 데이터 페칭, 상태 관리...)

도구만 있다고 요리가 완성되지 않음!
레시피와 재료가 필요함!
```

---

## 라우팅 (Routing)

### 라우팅이 뭔가요?

**라우팅** = URL을 페이지/컴포넌트와 연결하는 시스템

```
웹사이트의 URL:
https://mywebsite.com/         ← 홈페이지
https://mywebsite.com/about    ← 소개 페이지
https://mywebsite.com/blog     ← 블로그
https://mywebsite.com/contact  ← 연락처

라우팅 시스템이 하는 일:
"어떤 URL이면 → 어떤 페이지 보여줄까?"
```

**라우팅 없으면?**

```
❌ 문제 1: 모든 내용이 한 페이지
   - 스크롤만 엄청 김
   - 불편함

❌ 문제 2: URL 공유 불가
   - 친구에게 "여기 봐!" 못 함
   - 북마크 불가능

❌ 문제 3: 뒤로가기 버튼 안 됨
   - 브라우저 뒤로가기 작동 안 함

❌ 문제 4: SEO 불가능
   - 구글이 페이지 구분 못 함
```

### 라우팅이 필요한 기능들

```
1. 기본 라우팅
   /home → Home 페이지
   /about → About 페이지

2. 동적 라우팅
   /blog/1 → 1번 글
   /blog/2 → 2번 글
   /user/john → john의 프로필

3. 중첩 라우팅
   /dashboard/profile
   /dashboard/settings
   /dashboard/billing
   → dashboard 레이아웃 안에 서브 페이지

4. 라우트 파라미터
   /product/:id
   /category/:name

5. 쿼리 파라미터
   /search?q=react&sort=newest

6. 프로그래매틱 네비게이션
   버튼 클릭 → 페이지 이동
   로그인 후 → 대시보드로 이동

7. 라우트 가드
   로그인 안 했으면 → 로그인 페이지로
   관리자 아니면 → 접근 거부

8. 404 페이지
   존재하지 않는 URL → 404 페이지
```

### 추천 라우팅 라이브러리

#### 1. React Router (가장 인기!)

**React Router가 뭔가요?**

```
React Router:
- React의 표준 라우팅 라이브러리
- 2014년부터 사용
- 수백만 개 프로젝트
- 가장 많은 사용자
```

**설치:**

```bash
npm install react-router-dom
```

**기본 사용법:**

```jsx
// App.jsx
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import Home from './pages/Home';
import About from './pages/About';
import Blog from './pages/Blog';

function App() {
  return (
    <BrowserRouter>  {/* 1. BrowserRouter로 감싸기 */}
      <Routes>       {/* 2. Routes 안에 Route들 */}
        {/* 3. 각 Route는 path와 element */}
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
        <Route path="/blog" element={<Blog />} />
      </Routes>
    </BrowserRouter>
  );
}
```

**코드 한 줄씩 설명:**

```jsx
<BrowserRouter>
  // 라우팅 기능 활성화
  // 이걸로 감싸야 라우팅 작동

<Routes>
  // 라우트 목록 정의
  // 여러 Route를 감싸는 컨테이너

<Route path="/" element={<Home />} />
  // path: URL 경로
  // element: 보여줄 컴포넌트
  // "/" = 홈페이지 (루트)
```

**동적 라우팅:**

```jsx
<Route path="/blog/:id" element={<BlogPost />} />
//              ↑ 동적 파라미터

// BlogPost 컴포넌트에서 받기
import { useParams } from 'react-router-dom';

function BlogPost() {
  const { id } = useParams();  // URL에서 id 추출
  
  return (
    <div>
      <h1>{id}번 글</h1>
    </div>
  );
}

// /blog/1 접속 → id = "1"
// /blog/2 접속 → id = "2"
```

**링크 만들기:**

```jsx
import { Link } from 'react-router-dom';

function Navigation() {
  return (
    <nav>
      {/* 일반 <a> 태그 대신 <Link> 사용 */}
      <Link to="/">홈</Link>
      <Link to="/about">소개</Link>
      <Link to="/blog">블로그</Link>
    </nav>
  );
}

// Link를 쓰는 이유:
// 1. 페이지 새로고침 없음 (빠름!)
// 2. SPA 경험
// 3. 상태 유지
```

**프로그래매틱 네비게이션:**

```jsx
import { useNavigate } from 'react-router-dom';

function LoginButton() {
  const navigate = useNavigate();  // 네비게이션 함수
  
  function handleLogin() {
    // 로그인 처리...
    
    // 로그인 성공하면 대시보드로 이동
    navigate('/dashboard');
  }
  
  return <button onClick={handleLogin}>로그인</button>;
}
```

#### 2. TanStack Router (최신, 타입 안전)

**TanStack Router가 뭔가요?**

```
TanStack Router:
- TanStack 팀이 제작
- TypeScript에 최적화
- 타입 안전한 라우팅
- 비교적 새로움 (2023)
```

**특징:**

```
✅ 장점:
1. 완벽한 타입 안전성
   - URL 파라미터도 타입 체크
   - 오타 방지

2. 파일 기반 라우팅 가능
   - Next.js처럼 폴더 = URL

3. 데이터 로딩 통합
   - 라우트마다 데이터 로더

4. 검색 파라미터 타입 안전
   - ?q=react 같은 것도 타입 체크

❌ 단점:
1. 새로움
   - 커뮤니티 작음
   - 자료 적음

2. 학습 곡선
   - React Router보다 복잡
   - TypeScript 필수
```

**언제 TanStack Router를 쓸까요?**

```
✅ 사용:
- TypeScript 프로젝트
- 타입 안전성 중시
- 최신 기술 OK

❌ 피하기:
- JavaScript 프로젝트
- 간단한 라우팅만 필요
- 안정성 최우선
```

---

## 데이터 페칭 (Data Fetching)

### 데이터 페칭이 뭔가요?

**데이터 페칭** = 서버에서 데이터를 가져오는 것

```
실생활 비유:

식당에서 주문:
1. 손님: "김치찌개 주세요" (요청)
2. 웨이터: 주방에 전달
3. 주방: 요리 준비
4. 웨이터: 음식 가져옴 (응답)
5. 손님: 먹음 (데이터 사용)

웹에서 데이터 페칭:
1. 브라우저: "사용자 정보 주세요" (요청)
2. 인터넷 통신
3. 서버: 데이터베이스 조회
4. 서버: 데이터 전송 (응답)
5. 브라우저: 화면에 표시 (데이터 사용)
```

### 왜 데이터 페칭이 필요한가요?

```
데이터가 필요한 경우:

1. 사용자 정보
   - 로그인한 사용자 이름, 프로필 사진

2. 콘텐츠
   - 블로그 글 목록
   - 상품 목록
   - 뉴스 기사

3. 실시간 데이터
   - 주식 가격
   - 날씨
   - 채팅 메시지

4. 사용자 생성 콘텐츠
   - 댓글
   - 리뷰
   - 게시글

이 모든 데이터는 서버에 있음!
→ 가져와야 함 (페칭)
```

### 데이터 페칭의 어려운 점

```
❌ 문제들:

1. 로딩 상태 관리
   - "로딩 중..." 표시
   - 스피너 돌리기

2. 에러 처리
   - 네트워크 에러
   - 서버 에러
   - 타임아웃

3. 캐싱
   - 같은 데이터 중복 요청 방지
   - 메모리 관리

4. 재시도
   - 실패하면 다시 시도

5. 폴링
   - 주기적으로 새 데이터 확인

6. 무효화
   - 데이터 변경되면 다시 가져오기

7. 동시성 문제
   - 여러 요청이 동시에 발생

8. 의존성
   - A 데이터를 먼저 받아야 B 데이터 요청 가능

→ 직접 구현하면 매우 복잡!
```

### 직접 fetch 사용 (어려운 방법)

```jsx
import { useState, useEffect } from 'react';

function UserProfile() {
  const [user, setUser] = useState(null);      // 데이터
  const [loading, setLoading] = useState(true); // 로딩 상태
  const [error, setError] = useState(null);     // 에러 상태
  
  useEffect(() => {
    // 컴포넌트 마운트 시 데이터 가져오기
    async function fetchUser() {
      try {
        setLoading(true);  // 로딩 시작
        
        const response = await fetch('https://api.example.com/user/123');
        
        if (!response.ok) {  // 에러 체크
          throw new Error('Failed to fetch');
        }
        
        const data = await response.json();
        setUser(data);      // 데이터 저장
        setError(null);     // 에러 초기화
        
      } catch (err) {
        setError(err.message);  // 에러 저장
        setUser(null);          // 데이터 초기화
        
      } finally {
        setLoading(false);  // 로딩 종료
      }
    }
    
    fetchUser();
  }, []);  // 빈 배열 = 한 번만 실행
  
  // 로딩 중
  if (loading) return <div>로딩 중...</div>;
  
  // 에러 발생
  if (error) return <div>에러: {error}</div>;
  
  // 데이터 표시
  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
}
```

**문제점:**

```
위 코드의 문제:

1. 코드가 너무 김
   - 상태 3개 (user, loading, error)
   - try-catch-finally
   - 조건부 렌더링 3개

2. 재사용 불가능
   - 다른 데이터 가져올 때마다 복사-붙여넣기

3. 캐싱 없음
   - 같은 페이지 다시 방문하면 다시 요청

4. 재시도 없음
   - 실패하면 끝

5. 중복 요청 방지 없음
   - 빠르게 여러 번 클릭하면 여러 번 요청

→ 데이터 페칭 라이브러리 필요!
```

### 추천 데이터 페칭 라이브러리

#### 1. TanStack Query (가장 추천!)

**TanStack Query가 뭔가요?**

```
이전 이름: React Query
새 이름: TanStack Query
역할: 데이터 페칭 + 캐싱 + 상태 관리
```

**설치:**

```bash
npm install @tanstack/react-query
```

**사용 예시:**

```jsx
import { useQuery } from '@tanstack/react-query';

function UserProfile() {
  // useQuery 하나로 모든 것 해결!
  const { data, isLoading, error } = useQuery({
    queryKey: ['user', 123],  // 고유 키
    queryFn: () => fetch('https://api.example.com/user/123').then(res => res.json())
  });
  
  if (isLoading) return <div>로딩 중...</div>;
  if (error) return <div>에러: {error.message}</div>;
  
  return (
    <div>
      <h1>{data.name}</h1>
      <p>{data.email}</p>
    </div>
  );
}
```

**TanStack Query가 자동으로 해주는 것:**

```
✅ 자동 캐싱
   - 같은 데이터 재요청 안 함
   - 메모리에 저장

✅ 백그라운드 갱신
   - 화면 포커스하면 자동 업데이트
   - 오래된 데이터 갱신

✅ 자동 재시도
   - 실패하면 3번 재시도
   - 간격 점점 늘어남

✅ 로딩/에러 상태
   - 자동 관리
   - 조건부 렌더링 쉬움

✅ 무효화
   - 데이터 변경 시 자동 재요청

✅ 폴링
   - 주기적 업데이트
   - refetchInterval 옵션

✅ Optimistic Updates
   - 서버 응답 전 UI 즉시 업데이트

✅ Pagination
   - 페이지네이션 지원

✅ Infinite Scroll
   - 무한 스크롤 지원
```

**변경 요청 (Mutation):**

```jsx
import { useMutation, useQueryClient } from '@tanstack/react-query';

function CreatePostButton() {
  const queryClient = useQueryClient();
  
  // useMutation으로 데이터 생성/수정/삭제
  const mutation = useMutation({
    mutationFn: (newPost) => {
      return fetch('https://api.example.com/posts', {
        method: 'POST',
        body: JSON.stringify(newPost)
      });
    },
    onSuccess: () => {
      // 성공하면 posts 쿼리 무효화 → 자동 재요청
      queryClient.invalidateQueries({ queryKey: ['posts'] });
    }
  });
  
  return (
    <button 
      onClick={() => {
        mutation.mutate({ title: '새 글', content: '내용...' });
      }}
      disabled={mutation.isPending}
    >
      {mutation.isPending ? '저장 중...' : '글 작성'}
    </button>
  );
}
```

#### 2. SWR (Simple, Lightweight)

**SWR이 뭔가요?**

```
SWR = Stale-While-Revalidate
의미: "오래된 데이터를 보여주면서 새 데이터 가져오기"
만든 곳: Vercel (Next.js 회사)
```

**설치:**

```bash
npm install swr
```

**사용 예시:**

```jsx
import useSWR from 'swr';

// fetcher 함수 (한 번만 정의)
const fetcher = (url) => fetch(url).then(res => res.json());

function UserProfile() {
  const { data, error, isLoading } = useSWR(
    'https://api.example.com/user/123',
    fetcher
  );
  
  if (isLoading) return <div>로딩 중...</div>;
  if (error) return <div>에러 발생</div>;
  
  return <div>{data.name}</div>;
}
```

**SWR vs TanStack Query:**

| | TanStack Query | SWR |
|---|---|---|
| **사용 난이도** | 중간 | 쉬움 |
| **기능** | 매우 많음 | 기본적 |
| **번들 크기** | 큼 | 작음 |
| **커뮤니티** | 큼 | 중간 |
| **추천도** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |

**언제 뭘 쓸까요?**

```
TanStack Query:
- 복잡한 데이터 페칭
- Mutation 많음
- 고급 기능 필요

SWR:
- 간단한 데이터 페칭
- GET 요청 위주
- 가벼운 앱
```

#### 3. RTK Query (Redux 사용자)

**RTK Query가 뭔가요?**

```
RTK Query = Redux Toolkit의 데이터 페칭
Redux를 이미 사용 중이라면 고려
```

**장단점:**

```
✅ 장점:
- Redux와 통합
- Redux DevTools
- 타입 안전

❌ 단점:
- Redux 필수
- 학습 곡선 높음
- 보일러플레이트 많음

→ Redux 안 쓴다면 TanStack Query 추천!
```

---

## 데이터 페칭 고급 주제

### 워터폴 문제 (Waterfall Problem)

**워터폴이 뭔가요?**

```
워터폴 = 폭포처럼 순차적으로 떨어지는 것

나쁜 예 (워터폴):
1. 컴포넌트 렌더링
2. useEffect 실행 → 사용자 정보 요청
3. 사용자 정보 받음
4. 사용자의 게시글 목록 요청
5. 게시글 목록 받음
6. 첫 번째 게시글의 댓글 요청
7. 댓글 받음

총 시간 = 요청1 + 요청2 + 요청3
→ 너무 느림!

좋은 예 (병렬 요청):
1. 컴포넌트 렌더링
2. useEffect 실행 → 모든 데이터 동시 요청
3. 모두 받음

총 시간 = max(요청1, 요청2, 요청3)
→ 훨씬 빠름!
```

**해결 방법:**

```jsx
// ❌ 나쁜 예 - 워터폴
function UserDashboard() {
  const { data: user } = useQuery({ queryKey: ['user'] });
  
  // user를 받은 후에야 posts 요청!
  const { data: posts } = useQuery({
    queryKey: ['posts', user?.id],
    enabled: !!user  // user가 있을 때만 실행
  });
  
  // posts를 받은 후에야 comments 요청!
  const { data: comments } = useQuery({
    queryKey: ['comments', posts?.[0]?.id],
    enabled: !!posts
  });
  
  // 총 3번의 순차적 요청!
}

// ✅ 좋은 예 - 병렬 요청
function UserDashboard() {
  // 모두 동시에 요청!
  const { data: user } = useQuery({ queryKey: ['user'] });
  const { data: posts } = useQuery({ queryKey: ['posts'] });
  const { data: comments } = useQuery({ queryKey: ['comments'] });
  
  // 훨씬 빠름!
}
```

### 라우터 로더 (Router Loader)

**라우터 로더가 뭔가요?**

```
컴포넌트가 렌더링되기 전에
데이터를 미리 가져오는 것

장점:
✅ 페이지 전환 시 데이터 준비됨
✅ 워터폴 방지
✅ 더 나은 사용자 경험
```

**React Router 로더 예시:**

```jsx
// loader 정의
async function userLoader() {
  const response = await fetch('https://api.example.com/user');
  return response.json();
}

// 라우트에 loader 연결
<Route 
  path="/user" 
  element={<UserPage />}
  loader={userLoader}  // 페이지 렌더링 전에 실행!
/>

// UserPage에서 데이터 사용
import { useLoaderData } from 'react-router-dom';

function UserPage() {
  const user = useLoaderData();  // loader에서 반환한 데이터
  
  // 이미 데이터가 준비되어 있음!
  return <div>{user.name}</div>;
}
```

---

## 코드 스플리팅 (Code Splitting)

### 코드 스플리팅이 뭔가요?**

**코드 스플리팅** = 앱을 여러 작은 조각으로 나누는 것

```
비유: 책 읽기

전체 다운로드 (코드 스플리팅 없음):
📚 백과사전 전체를 다운로드
   - 5000페이지
   - 다운로드: 10분
   - "ㄱ" 찾으려고 해도 전체 다운로드!

코드 스플리팅:
📖 필요한 권만 다운로드
   - "ㄱ" 권만 다운로드: 30초
   - 나중에 "ㄴ" 필요하면 그때 다운로드
   - 훨씬 빠름!
```

### 왜 코드 스플리팅이 필요한가요?

```
앱이 커질수록:

파일 1: App.js (50KB)
파일 2: HomePage.js (30KB)
파일 3: Dashboard.js (100KB)  ← 관리자만 사용
파일 4: AdminPanel.js (200KB) ← 관리자만 사용
파일 5: Chart.js (300KB)      ← 일부 페이지만 사용

전체 번들: 680KB

문제:
- 일반 사용자도 680KB 다운로드
- Dashboard, AdminPanel은 안 쓰는데!
- Chart도 필요 없는 페이지인데!

해결: 코드 스플리팅
- 홈페이지: 80KB만 다운로드
- 대시보드 방문 시: 추가 100KB
- 차트 페이지: 필요할 때 300KB
```

### React.lazy()로 코드 스플리팅

```jsx
import { lazy, Suspense } from 'react';

// ❌ 일반 import - 즉시 로드
import Dashboard from './Dashboard';

// ✅ lazy import - 필요할 때만 로드
const Dashboard = lazy(() => import('./Dashboard'));

function App() {
  return (
    <Suspense fallback={<div>로딩 중...</div>}>
      {/* Dashboard 사용할 때 다운로드! */}
      <Dashboard />
    </Suspense>
  );
}
```

**코드 설명:**

```jsx
const Dashboard = lazy(() => import('./Dashboard'));
//                ↑           ↑
//              lazy 함수    동적 import

// 이 코드는 Dashboard를 즉시 로드하지 않음
// <Dashboard /> 사용할 때 다운로드 시작!

<Suspense fallback={<div>로딩 중...</div>}>
//        ↑
//     다운로드 중에 보여줄 것

  <Dashboard />
  // 이 순간 Dashboard.js 다운로드 시작
</Suspense>
```

### 라우트별 코드 스플리팅

```jsx
import { lazy, Suspense } from 'react';
import { BrowserRouter, Routes, Route } from 'react-router-dom';

// 각 페이지를 lazy로 로드
const Home = lazy(() => import('./pages/Home'));
const About = lazy(() => import('./pages/About'));
const Dashboard = lazy(() => import('./pages/Dashboard'));
const AdminPanel = lazy(() => import('./pages/AdminPanel'));

function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<div>페이지 로딩 중...</div>}>
        <Routes>
          {/* 각 페이지는 방문할 때만 다운로드! */}
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
          <Route path="/dashboard" element={<Dashboard />} />
          <Route path="/admin" element={<AdminPanel />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}
```

**효과:**

```
사용자가 홈페이지 방문:
└─ Home.js만 다운로드 (30KB)
└─ 빠른 로딩!

사용자가 /about 클릭:
└─ About.js 다운로드 (20KB)
└─ 필요할 때만!

관리자가 /admin 방문:
└─ AdminPanel.js 다운로드 (200KB)
└─ 일반 사용자는 절대 다운로드 안 함!
```

### 빌드 도구별 코드 스플리팅

**Vite:**

```javascript
// vite.config.ts
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          // vendor: React 같은 라이브러리
          vendor: ['react', 'react-dom'],
          
          // 차트 라이브러리 분리
          charts: ['chart.js', 'recharts'],
          
          // UI 라이브러리 분리
          ui: ['@mui/material']
        }
      }
    }
  }
});
```

**Parcel:**

```
Parcel은 자동으로 코드 스플리팅!
- React.lazy() 사용하면 자동 분리
- 별도 설정 불필요
```

**Rsbuild:**

```javascript
// rsbuild.config.ts
export default {
  output: {
    distPath: {
      js: 'static/js',
    },
  },
  performance: {
    chunkSplit: {
      strategy: 'split-by-experience',  // 자동 최적 분리
    },
  },
};
```

---

## 성능 최적화

앱을 만들었다면, 이제 **빠르게** 만들어야 합니다!

### SPA의 한계

**SPA (Single Page Application)** = 한 페이지로 모든 것을 처리

```
SPA의 작동 방식:

1. 사용자가 웹사이트 방문
2. 빈 HTML 다운로드:
   <html>
     <body>
       <div id="root"></div>  ← 비어있음!
       <script src="bundle.js"></script>
     </body>
   </html>
3. JavaScript 다운로드 (bundle.js)
4. JavaScript 실행
5. React가 화면 그림
6. 사용자가 드디어 내용을 봄

총 시간: 2-5초 (느림!)
```

**SPA의 문제점:**

```
❌ 느린 초기 로딩
   - JavaScript 다운로드 + 실행 필요
   - 흰 화면만 보임 (Flash of Unstyled Content)

❌ SEO 나쁨
   - 구글 봇이 빈 HTML만 봄
   - 검색 결과 하위로

❌ 큰 JavaScript 번들
   - 앱이 커질수록 bundle.js 증가
   - 모바일에서 느림
```

### 렌더링 전략들

#### 1. SSR (Server-Side Rendering)

**SSR이 뭔가요?**

```
서버에서 HTML을 완성해서 보내는 것

SSR 작동 방식:

1. 사용자가 웹사이트 방문
2. 서버가 React 실행
3. 서버가 완성된 HTML 생성:
   <html>
     <body>
       <div id="root">
         <h1>안녕하세요</h1>  ← 내용이 있음!
         <p>환영합니다</p>
       </div>
       <script src="bundle.js"></script>
     </body>
   </html>
4. 사용자가 즉시 내용을 봄!
5. JavaScript 로드되면 인터랙티브하게

총 시간: 0.5-1초 (빠름!)
```

**SSR 구현 (Vite):**

```javascript
// server.js
import express from 'express';
import { renderToString } from 'react-dom/server';
import App from './App';

const app = express();

app.get('*', (req, res) => {
  // React를 HTML 문자열로 변환
  const html = renderToString(<App />);
  
  // 완성된 HTML 전송
  res.send(`
    <!DOCTYPE html>
    <html>
      <body>
        <div id="root">${html}</div>
        <script src="/bundle.js"></script>
      </body>
    </html>
  `);
});

app.listen(3000);
```

**SSR 장단점:**

```
✅ 장점:
- 빠른 초기 로딩 (FCP - First Contentful Paint)
- SEO 좋음 (완성된 HTML)
- 느린 네트워크에서 유리

❌ 단점:
- 서버 부담 증가
- 서버 비용 증가
- 복잡한 설정
- 캐싱 어려움

언제 사용?
- SEO 중요
- 빠른 초기 로딩 필요
- 블로그, 뉴스, 전자상거래
```

#### 2. SSG (Static Site Generation)

**SSG가 뭔가요?**

```
빌드 시점에 모든 HTML을 미리 생성

SSG 작동 방식:

빌드 시 (배포 전):
1. npm run build 실행
2. 모든 페이지를 HTML로 생성
3. public/
   ├── index.html       (홈페이지)
   ├── about.html       (소개)
   └── blog/
       ├── post-1.html  (1번 글)
       └── post-2.html  (2번 글)

사용자 방문 시:
1. 이미 만들어진 HTML 전송
2. 초고속! (서버 계산 불필요)
```

**SSG 구현 (Vite):**

```javascript
// build-static.js
import { render ToString } from 'react-dom/server';
import fs from 'fs';
import App from './App';

// 생성할 페이지 목록
const pages = [
  { path: '/', component: <HomePage /> },
  { path: '/about', component: <AboutPage /> },
  { path: '/blog/1', component: <BlogPost id={1} /> },
  { path: '/blog/2', component: <BlogPost id={2} /> },
];

// 각 페이지를 HTML 파일로 생성
pages.forEach(page => {
  const html = renderToString(page.component);
  
  const fullHtml = `
    <!DOCTYPE html>
    <html>
      <body>
        <div id="root">${html}</div>
        <script src="/bundle.js"></script>
      </body>
    </html>
  `;
  
  // 파일로 저장
  fs.writeFileSync(`dist${page.path}.html`, fullHtml);
});
```

**SSG 장단점:**

```
✅ 장점:
- 엄청나게 빠름 (정적 파일)
- SEO 완벽
- 서버 비용 거의 없음 (CDN 호스팅)
- 안정적

❌ 단점:
- 데이터 업데이트 어려움 (다시 빌드 필요)
- 실시간 콘텐츠 불가
- 페이지 많으면 빌드 오래 걸림

언제 사용?
- 블로그
- 문서 사이트
- 마케팅 페이지
- 포트폴리오
```

#### 3. RSC (React Server Components)

**RSC가 뭔가요?**

```
React 컴포넌트를 서버에서 실행

일반 컴포넌트:
- 브라우저에서 실행
- JavaScript 번들에 포함
- 번들 크기 증가

서버 컴포넌트:
- 서버에서만 실행
- JavaScript 번들에 포함 안 됨!
- 번들 크기 감소

혼합 가능:
- 서버 컴포넌트 + 클라이언트 컴포넌트
- 같은 트리에서 사용
```

**RSC 예시:**

```jsx
// 서버 컴포넌트 (기본)
async function BlogPost({ id }) {
  // 서버에서 실행!
  const post = await db.posts.find(id);
  
  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
      
      {/* 클라이언트 컴포넌트 포함 */}
      <LikeButton postId={id} />
    </article>
  );
}

// 클라이언트 컴포넌트
'use client';  // ← 클라이언트 표시!

import { useState } from 'react';

function LikeButton({ postId }) {
  const [liked, setLiked] = useState(false);
  
  // 이것만 JavaScript 번들에 포함됨
  return (
    <button onClick={() => setLiked(!liked)}>
      {liked ? '좋아요 취소' : '좋아요'}
    </button>
  );
}
```

**RSC 장단점:**

```
✅ 장점:
- 번들 크기 극도로 감소
- 서버 데이터 접근 쉬움
- 보안 (민감한 코드 서버에만)

❌ 단점:
- 매우 복잡한 설정
- 고급 지식 필요
- 제한적인 생태계
- 아직 실험적

언제 사용?
- Next.js 13+ (App Router)
- 고급 사용자
- 대규모 앱

초보자는 피하세요!
```

### 성능 지표

**측정해야 할 것들:**

```
1. TTFB (Time to First Byte)
   - 서버 응답 시간
   - 목표: < 600ms

2. FCP (First Contentful Paint)
   - 첫 콘텐츠 표시
   - 목표: < 1.8s

3. LCP (Largest Contentful Paint)
   - 가장 큰 콘텐츠 표시
   - 목표: < 2.5s

4. TTI (Time to Interactive)
   - 인터랙티브 가능 시점
   - 목표: < 3.8s

5. CLS (Cumulative Layout Shift)
   - 레이아웃 이동
   - 목표: < 0.1

6. FID (First Input Delay)
   - 첫 입력 반응 시간
   - 목표: < 100ms
```

**측정 도구:**

```
1. Lighthouse (Chrome DevTools)
   - F12 → Lighthouse 탭
   - 종합 점수 제공

2. Web Vitals
   npm install web-vitals
   
3. Chrome DevTools Performance
   - 녹화 → 분석

4. WebPageTest
   - https://webpagetest.org
   - 실제 네트워크 환경 테스트
```

---

## 기타 고려사항

### 스타일링

```
CSS 관리 방법:

1. 일반 CSS 파일
   - 간단함
   - 전역 스타일 충돌 가능

2. CSS Modules
   - 로컬 스코프
   - 클래스 이름 충돌 방지

3. CSS-in-JS
   - Styled-components
   - Emotion
   - JavaScript로 스타일 작성

4. Utility-first CSS
   - Tailwind CSS
   - 클래스 조합으로 스타일링

5. CSS 전처리기
   - Sass
   - Less
   - 변수, 중첩, 믹스인 등
```

### 테스팅

```
필요한 테스트:

1. 단위 테스트
   - 개별 함수/컴포넌트
   - Jest, Vitest

2. 통합 테스트
   - 여러 컴포넌트 함께
   - Testing Library

3. E2E 테스트
   - 전체 시나리오
   - Playwright, Cypress

4. 시각적 회귀 테스트
   - 화면 스크린샷 비교
   - Chromatic, Percy
```

### 타입 안전성

```
TypeScript:
✅ 타입 체크
✅ 버그 사전 발견
✅ 자동완성
✅ 리팩토링 쉬움

하지만:
❌ 학습 곡선
❌ 코드 작성 시간 증가

PropTypes (대안):
- JavaScript로 타입 체크
- 간단함
- 기능 제한적
```

### 상태 관리

```
전역 상태 관리:

1. Context API (내장)
   - React 기본 기능
   - 간단한 경우

2. Zustand
   - 가볍고 간단
   - 추천!

3. Redux
   - 강력하지만 복잡
   - 대규모 앱

4. Jotai
   - Atomic 상태 관리
   - 모던한 접근

5. Recoil
   - Facebook 제작
   - 실험적
```

---

## 프레임워크 vs 처음부터 만들기 - 최종 비교

### 시간 비교

```
프레임워크 (Next.js):
Day 1: npx create-next-app → 완료!
Day 2-7: 기능 개발
Week 2: 배포

처음부터 만들기:
Week 1-2: 빌드 도구 설정
Week 3-4: 라우팅 구현
Week 5-6: 데이터 페칭 구현
Week 7-8: 코드 스플리팅
Week 9-10: SSR 구현
Week 11-12: 최적화
Week 13-14: 테스팅
Week 15-16: 배포 설정

→ 16배 차이!
```

### 기능 비교

| 기능 | 프레임워크 | 처음부터 | 
|------|----------|---------|
| 라우팅 | ✅ 즉시 | ⏰ 1-2주 |
| 데이터 페칭 | ✅ 즉시 | ⏰ 1-2주 |
| 코드 스플리팅 | ✅ 즉시 | ⏰ 1-2주 |
| SSR | ✅ 즉시 | ⏰ 2-4주 |
| 최적화 | ✅ 자동 | ⏰ 2-4주 |
| SEO | ✅ 자동 | ⏰ 1-2주 |
| 이미지 최적화 | ✅ 자동 | ⏰ 1-2주 |
| 배포 | ✅ 1클릭 | ⏰ 1주 |

### 유지보수 비교

```
프레임워크:
- 업데이트 자동
- 보안 패치 자동
- 커뮤니티 지원
- 버그 수정 빠름

처음부터:
- 모든 것을 직접 관리
- 보안 취약점 직접 패치
- 혼자 해결
- 버그 찾기 어려움
```

---

## 결론

### 언제 처음부터 만들까요?

```
✅ 처음부터 만드는 게 맞는 경우:

1. 특수한 제약사항
   - 레거시 시스템 통합
   - 특정 빌드 도구 필수
   - 보안 정책 제한

2. 프레임워크 제작
   - 오픈소스 프레임워크
   - 회사 내부 프레임워크
   - 특정 산업 솔루션

3. 학습 목적
   - React 깊이 이해
   - 빌드 프로세스 학습
   - 경력 발전

4. 기존 코드 베이스
   - 이미 있는 설정
   - 프레임워크 도입 비용 큼
```

### 대부분의 경우: 프레임워크 사용!

```
❤️ 프레임워크를 사용하세요!

이유:
✅ 시간 절약 (수개월 → 수일)
✅ 검증된 코드
✅ 보안 업데이트
✅ 커뮤니티 지원
✅ 좋은 문서
✅ 쉬운 채용
✅ 유지보수 쉬움

추천:
- Next.js (풀스택, SEO)
- Vite (SPA, 학습)
- Gatsby (정적 사이트)
- Expo (모바일)
```

### 학습 경로

```
1단계: Vite로 시작 (1주)
  - React 기초 학습
  - 간단한 앱 만들기

2단계: 빌드 도구 이해 (1주)
  - Vite 설정 파일 읽기
  - 플러그인 시스템 이해
  - 번들 분석

3단계: Next.js로 전환 (2주)
  - 프레임워크 경험
  - SSR, SSG 이해
  - 실전 프로젝트

4단계: 심화 학습 (선택)
  - 라우팅 라이브러리 깊이 이해
  - 데이터 페칭 고급 기법
  - 성능 최적화

5단계: 처음부터 만들어보기 (선택)
  - 모든 지식 통합
  - 자신만의 도구 체인
  - 하지만 프로덕션에는 프레임워크!
```

---

## 다음 단계

처음부터 만들기를 시도하시겠습니까?

**초보자라면:**
1. [Next.js 시작하기](./2_.mdx)
2. [Vite로 빠른 시작](./2_.mdx)
3. 프레임워크로 여러 프로젝트 경험
4. 나중에 처음부터 도전

**고급 사용자라면:**
1. Vite 설정부터 시작
2. 라우팅 구현 (React Router)
3. 데이터 페칭 (TanStack Query)
4. 성능 최적화
5. 배포

**유용한 리소스:**
- [Vite 가이드](https://vitejs.dev/guide/)
- [React Router 문서](https://reactrouter.com)
- [TanStack Query 문서](https://tanstack.com/query)

---

**기억하세요**: 프레임워크는 당신의 친구입니다! 처음부터 만들기는 학습 목적일 때만 시도하세요! 💪